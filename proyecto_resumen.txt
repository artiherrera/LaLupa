### ESTRUCTURA ###
.
├── .DS_Store
├── .env
├── .gitignore
├── README.md
├── app
│   ├── __init__.py
│   ├── api
│   │   ├── __init__.py
│   │   ├── contracts.py
│   │   ├── search.py
│   │   └── stats.py
│   ├── app.py
│   ├── models
│   │   ├── __init__.py
│   │   └── contrato.py
│   ├── routes.py
│   ├── services
│   │   ├── __init__.py
│   │   ├── aggregation_service.py
│   │   ├── filter_service.py
│   │   └── search_service.py
│   ├── static
│   │   ├── css
│   │   │   └── style.css
│   │   ├── img
│   │   └── js
│   │       ├── app.js
│   │       └── modules
│   ├── templates
│   │   └── index.html
│   └── utils
│       ├── __init__.py
│       ├── activity_tracker.py
│       ├── decorators.py
│       ├── logging_config.py
│       └── metrics.py
├── config
│   ├── __init__.py
│   └── config.py
├── fix_sql.txt
├── logs
│   ├── access.log
│   ├── error.log
│   └── search.log
├── migrations
├── proyecto_completo.txt
├── proyecto_resumen.txt
├── requirements
├── requirements.txt
├── run.py
├── scripts
├── test_connection.py
├── test_connection_do.py
├── test_new_structure.py
├── utils
│   ├── tests
│   │   ├── .gitkeep
│   │   ├── __init__.py
│   │   ├── fixtures
│   │   ├── integration
│   │   │   └── __init__.py
│   │   └── unit
│   │       └── __init__.py
│   └── validators.py
└── view_metrics.py

22 directories, 44 files

### INVENTARIO (.py .json .html .css) ###
path,ext,lines,bytes,modified
./run.py,py,83,2732,2025-09-23 13:03:33
./app/__init__.py,py,268,8387,2025-09-23 13:41:44
./app/utils/metrics.py,py,201,8198,2025-09-23 13:00:17
./app/utils/logging_config.py,py,81,2553,2025-09-23 12:58:44
./app/utils/activity_tracker.py,py,161,5301,2025-09-23 12:59:35
./app/utils/__init__.py,py,0,0,2025-09-23 00:14:00
./app/utils/decorators.py,py,50,1602,2025-09-23 22:38:22
./app/models/contrato.py,py,65,2573,2025-09-23 00:14:00
./app/models/__init__.py,py,4,80,2025-09-23 00:14:00
./app/static/css/style.css,css,733,15020,2025-10-06 17:39:39
./app/app.py,py,557,20886,2025-09-23 22:38:22
./app/api/__init__.py,py,6,169,2025-09-23 00:14:00
./app/api/stats.py,py,19,649,2025-09-23 00:14:00
./app/api/contracts.py,py,59,2045,2025-09-23 00:14:00
./app/api/search.py,py,118,4408,2025-09-23 00:14:00
./app/templates/index.html,html,89,3680,2025-09-19 14:30:07
./app/services/filter_service.py,py,105,3477,2025-09-23 00:14:00
./app/services/__init__.py,py,6,231,2025-09-23 00:14:00
./app/services/search_service.py,py,107,4145,2025-09-23 21:11:28
./app/services/aggregation_service.py,py,119,4440,2025-09-23 00:14:00
./app/routes.py,py,101,3341,2025-09-23 16:09:52
./config/config.py,py,15,367,2025-09-23 22:38:22
./config/__init__.py,py,204,6659,2025-09-23 13:02:05
./view_metrics.py,py,271,9780,2025-09-23 13:26:31
./test_connection.py,py,132,3992,2025-09-19 10:00:47
./utils/validators.py,py,54,1628,2025-09-19 13:00:45
./utils/tests/unit/__init__.py,py,0,0,2025-09-23 00:14:00
./utils/tests/integration/__init__.py,py,0,0,2025-09-23 00:14:00
./utils/tests/__init__.py,py,0,0,2025-09-23 00:14:00
./test_connection_do.py,py,137,4822,2025-09-23 00:14:00
./test_new_structure.py,py,124,4192,2025-09-23 00:14:00
./venv/lib/python3.13/site-packages/flask/logging.py,py,79,2377,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/flask/sansio/blueprints.py,py,632,24637,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/flask/sansio/app.py,py,964,38099,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/flask/sansio/scaffold.py,py,792,30371,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/flask/signals.py,py,17,750,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/flask/sessions.py,py,399,15480,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/flask/config.py,py,367,13219,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/flask/templating.py,py,219,7536,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/flask/globals.py,py,51,1713,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/flask/__init__.py,py,61,2701,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/flask/blueprints.py,py,128,4541,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/flask/json/provider.py,py,215,7672,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/flask/json/__init__.py,py,170,5602,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/flask/json/tag.py,py,327,9281,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/flask/cli.py,py,1135,37184,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/flask/wrappers.py,py,257,9406,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/flask/app.py,py,1536,61744,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/flask/debughelpers.py,py,178,6080,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/flask/ctx.py,py,449,15064,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/flask/typing.py,py,93,3293,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/flask/testing.py,py,298,10117,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/flask/helpers.py,py,641,23517,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/flask/__main__.py,py,3,30,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/flask/views.py,py,191,6962,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/packaging/tags.py,py,656,22745,2025-09-17 14:12:18
./venv/lib/python3.13/site-packages/packaging/_musllinux.py,py,85,2694,2025-09-17 14:12:18
./venv/lib/python3.13/site-packages/packaging/metadata.py,py,862,34739,2025-09-17 14:12:18
./venv/lib/python3.13/site-packages/packaging/version.py,py,582,16676,2025-09-17 14:12:18
./venv/lib/python3.13/site-packages/packaging/licenses/__init__.py,py,145,5715,2025-09-17 14:12:18
./venv/lib/python3.13/site-packages/packaging/licenses/_spdx.py,py,759,48398,2025-09-17 14:12:18
./venv/lib/python3.13/site-packages/packaging/__init__.py,py,15,494,2025-09-17 14:12:18
./venv/lib/python3.13/site-packages/packaging/_parser.py,py,353,10221,2025-09-17 14:12:18
./venv/lib/python3.13/site-packages/packaging/utils.py,py,163,5050,2025-09-17 14:12:18
./venv/lib/python3.13/site-packages/packaging/requirements.py,py,91,2947,2025-09-17 14:12:18
./venv/lib/python3.13/site-packages/packaging/_structures.py,py,61,1431,2025-09-17 14:12:18
./venv/lib/python3.13/site-packages/packaging/markers.py,py,362,12049,2025-09-17 14:12:18
./venv/lib/python3.13/site-packages/packaging/_manylinux.py,py,262,9596,2025-09-17 14:12:18
./venv/lib/python3.13/site-packages/packaging/_tokenizer.py,py,195,5310,2025-09-17 14:12:18
./venv/lib/python3.13/site-packages/packaging/specifiers.py,py,1019,40055,2025-09-17 14:12:18
./venv/lib/python3.13/site-packages/packaging/_elffile.py,py,109,3286,2025-09-17 14:12:18
./venv/lib/python3.13/site-packages/markupsafe/__init__.py,py,395,13214,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/markupsafe/_native.py,py,8,210,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/flask_sqlalchemy/record_queries.py,py,117,3520,2025-09-17 14:12:13
./venv/lib/python3.13/site-packages/flask_sqlalchemy/track_modifications.py,py,88,2755,2025-09-17 14:12:13
./venv/lib/python3.13/site-packages/flask_sqlalchemy/query.py,py,105,3748,2025-09-17 14:12:13
./venv/lib/python3.13/site-packages/flask_sqlalchemy/session.py,py,111,3426,2025-09-17 14:12:13
./venv/lib/python3.13/site-packages/flask_sqlalchemy/__init__.py,py,26,653,2025-09-17 14:12:13
./venv/lib/python3.13/site-packages/flask_sqlalchemy/model.py,py,330,11461,2025-09-17 14:12:13
./venv/lib/python3.13/site-packages/flask_sqlalchemy/cli.py,py,16,484,2025-09-17 14:12:13
./venv/lib/python3.13/site-packages/flask_sqlalchemy/extension.py,py,1008,38261,2025-09-17 14:12:13
./venv/lib/python3.13/site-packages/flask_sqlalchemy/table.py,py,39,859,2025-09-17 14:12:13
./venv/lib/python3.13/site-packages/flask_sqlalchemy/pagination.py,py,364,11119,2025-09-17 14:12:13
./venv/lib/python3.13/site-packages/flask_migrate/__init__.py,py,266,10082,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/flask_migrate/cli.py,py,261,11097,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/flask_migrate/templates/flask/env.py,py,113,3344,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/flask_migrate/templates/aioflask-multidb/env.py,py,202,6573,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/flask_migrate/templates/aioflask/env.py,py,118,3478,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/flask_migrate/templates/flask-multidb/env.py,py,191,6190,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/dotenv/version.py,py,1,22,2025-09-17 14:12:15
./venv/lib/python3.13/site-packages/dotenv/variables.py,py,86,2348,2025-09-17 14:12:15
./venv/lib/python3.13/site-packages/dotenv/__init__.py,py,49,1292,2025-09-17 14:12:15
./venv/lib/python3.13/site-packages/dotenv/parser.py,py,175,5186,2025-09-17 14:12:15
./venv/lib/python3.13/site-packages/dotenv/cli.py,py,205,6197,2025-09-17 14:12:15
./venv/lib/python3.13/site-packages/dotenv/ipython.py,py,39,1303,2025-09-17 14:12:15
./venv/lib/python3.13/site-packages/dotenv/main.py,py,400,12467,2025-09-17 14:12:15
./venv/lib/python3.13/site-packages/dotenv/__main__.py,py,6,129,2025-09-17 14:12:15
./venv/lib/python3.13/site-packages/mako/pyparser.py,py,235,7558,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/mako/cmd.py,py,99,2813,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/mako/compat.py,py,70,1820,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/mako/util.py,py,388,10638,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/mako/_ast_util.py,py,713,20247,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/mako/ext/linguaplugin.py,py,57,1935,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/mako/ext/__init__.py,py,0,0,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/mako/ext/preprocessors.py,py,20,576,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/mako/ext/beaker_cache.py,py,82,2578,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/mako/ext/autohandler.py,py,70,1885,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/mako/ext/babelplugin.py,py,57,2091,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/mako/ext/extract.py,py,129,4659,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/mako/ext/pygmentplugin.py,py,150,4753,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/mako/ext/turbogears.py,py,61,2141,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/mako/lookup.py,py,361,12428,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/mako/cache.py,py,239,7680,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/mako/__init__.py,py,8,243,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/mako/runtime.py,py,968,27804,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/mako/testing/exclusions.py,py,80,1553,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/mako/testing/config.py,py,17,323,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/mako/testing/__init__.py,py,0,0,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/mako/testing/assertions.py,py,166,5161,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/mako/testing/_config.py,py,128,3566,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/mako/testing/helpers.py,py,71,1623,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/mako/testing/fixtures.py,py,119,3044,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/mako/lexer.py,py,481,16321,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/mako/template.py,py,711,23563,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/mako/ast.py,py,202,6642,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/mako/exceptions.py,py,417,12530,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/mako/parsetree.py,py,656,19021,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/mako/codegen.py,py,1319,47736,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/mako/filters.py,py,163,4658,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/mako/pygen.py,py,309,10416,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/jinja2/compiler.py,py,1998,74131,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/jinja2/async_utils.py,py,99,2834,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/jinja2/constants.py,py,20,1433,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/jinja2/loaders.py,py,693,24055,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/jinja2/__init__.py,py,38,1928,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/jinja2/idtracking.py,py,318,10555,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/jinja2/runtime.py,py,1062,34249,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/jinja2/parser.py,py,1049,40383,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/jinja2/sandbox.py,py,436,15009,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/jinja2/visitor.py,py,92,3557,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/jinja2/utils.py,py,766,24129,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/jinja2/debug.py,py,191,6297,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/jinja2/lexer.py,py,868,29786,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/jinja2/environment.py,py,1672,61513,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/jinja2/_identifier.py,py,6,1958,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/jinja2/optimizer.py,py,48,1651,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/jinja2/exceptions.py,py,166,5071,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/jinja2/defaults.py,py,48,1267,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/jinja2/nativetypes.py,py,130,4210,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/jinja2/nodes.py,py,1206,34579,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/jinja2/tests.py,py,256,5926,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/jinja2/bccache.py,py,408,14061,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/jinja2/filters.py,py,1873,55212,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/jinja2/ext.py,py,870,31875,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/jinja2/meta.py,py,112,4397,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/flask_wtf/csrf.py,py,329,10171,2025-09-17 14:12:17
./venv/lib/python3.13/site-packages/flask_wtf/__init__.py,py,16,338,2025-09-17 14:12:17
./venv/lib/python3.13/site-packages/flask_wtf/file.py,py,146,4636,2025-09-17 14:12:17
./venv/lib/python3.13/site-packages/flask_wtf/recaptcha/fields.py,py,17,433,2025-09-17 14:12:17
./venv/lib/python3.13/site-packages/flask_wtf/recaptcha/validators.py,py,75,2434,2025-09-17 14:12:17
./venv/lib/python3.13/site-packages/flask_wtf/recaptcha/__init__.py,py,5,168,2025-09-17 14:12:17
./venv/lib/python3.13/site-packages/flask_wtf/recaptcha/widgets.py,py,43,1512,2025-09-17 14:12:17
./venv/lib/python3.13/site-packages/flask_wtf/form.py,py,127,4049,2025-09-17 14:12:17
./venv/lib/python3.13/site-packages/flask_wtf/i18n.py,py,47,1166,2025-09-17 14:12:17
./venv/lib/python3.13/site-packages/flask_wtf/_compat.py,py,11,248,2025-09-17 14:12:17
./venv/lib/python3.13/site-packages/werkzeug/middleware/dispatcher.py,py,81,2602,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/werkzeug/middleware/proxy_fix.py,py,183,6755,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/werkzeug/middleware/shared_data.py,py,283,9542,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/werkzeug/middleware/http_proxy.py,py,236,7834,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/werkzeug/middleware/__init__.py,py,0,0,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/werkzeug/middleware/profiler.py,py,155,5562,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/werkzeug/middleware/lint.py,py,439,14476,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/werkzeug/wrappers/request.py,py,650,24737,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/werkzeug/wrappers/__init__.py,py,3,138,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/werkzeug/wrappers/response.py,py,831,32459,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/werkzeug/sansio/multipart.py,py,323,11637,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/werkzeug/sansio/request.py,py,534,19832,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/werkzeug/sansio/__init__.py,py,0,0,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/werkzeug/sansio/response.py,py,763,27965,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/werkzeug/sansio/utils.py,py,167,5256,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/werkzeug/sansio/http.py,py,170,5337,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/werkzeug/user_agent.py,py,47,1416,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/werkzeug/_reloader.py,py,471,15429,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/werkzeug/_internal.py,py,211,5545,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/werkzeug/serving.py,py,1125,39857,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/werkzeug/datastructures/auth.py,py,317,10055,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/werkzeug/datastructures/mixins.py,py,317,9027,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/werkzeug/datastructures/range.py,py,214,7020,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/werkzeug/datastructures/__init__.py,py,64,2615,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/werkzeug/datastructures/csp.py,py,100,3816,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/werkzeug/datastructures/etag.py,py,106,3278,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/werkzeug/datastructures/cache_control.py,py,273,9697,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/werkzeug/datastructures/accept.py,py,350,12177,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/werkzeug/datastructures/file_storage.py,py,209,6701,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/werkzeug/datastructures/structures.py,py,1239,41359,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/werkzeug/datastructures/headers.py,py,662,21554,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/werkzeug/local.py,py,653,22492,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/werkzeug/security.py,py,166,5581,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/werkzeug/__init__.py,py,4,165,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/werkzeug/test.py,py,1464,52795,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/werkzeug/formparser.py,py,430,15847,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/werkzeug/utils.py,py,691,24725,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/werkzeug/http.py,py,1405,44880,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/werkzeug/exceptions.py,py,894,26455,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/werkzeug/routing/matcher.py,py,202,7849,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/werkzeug/routing/__init__.py,py,134,4820,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/werkzeug/routing/rules.py,py,928,32510,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/werkzeug/routing/map.py,py,951,36515,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/werkzeug/routing/exceptions.py,py,152,4846,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/werkzeug/routing/converters.py,py,261,7297,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/werkzeug/urls.py,py,203,6430,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/werkzeug/debug/console.py,py,219,6089,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/werkzeug/debug/tbtools.py,py,450,13560,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/werkzeug/debug/__init__.py,py,565,20016,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/werkzeug/debug/shared/style.css,css,150,6078,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/werkzeug/debug/repr.py,py,282,9303,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/werkzeug/wsgi.py,py,595,20894,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/werkzeug/testapp.py,py,194,6332,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/click/_winconsole.py,py,296,8465,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/click/_textwrap.py,py,51,1400,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/click/globals.py,py,67,1923,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/click/__init__.py,py,123,4473,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/click/core.py,py,3135,117343,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/click/types.py,py,1165,38389,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/click/formatting.py,py,301,9726,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/click/parser.py,py,532,18979,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/click/termui.py,py,877,30847,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/click/utils.py,py,627,20245,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/click/exceptions.py,py,308,9891,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/click/shell_completion.py,py,644,19857,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/click/_compat.py,py,622,18693,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/click/_termui_impl.py,py,839,26712,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/click/testing.py,py,565,18702,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/click/decorators.py,py,551,18461,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/gunicorn/pidfile.py,py,85,2327,2025-09-17 14:12:18
./venv/lib/python3.13/site-packages/gunicorn/reloader.py,py,131,3761,2025-09-17 14:12:18
./venv/lib/python3.13/site-packages/gunicorn/config.py,py,2442,70318,2025-09-17 14:12:18
./venv/lib/python3.13/site-packages/gunicorn/app/wsgiapp.py,py,70,1924,2025-09-17 14:12:18
./venv/lib/python3.13/site-packages/gunicorn/app/__init__.py,py,3,105,2025-09-17 14:12:18
./venv/lib/python3.13/site-packages/gunicorn/app/pasterapp.py,py,74,2016,2025-09-17 14:12:18
./venv/lib/python3.13/site-packages/gunicorn/app/base.py,py,235,7370,2025-09-17 14:12:18
./venv/lib/python3.13/site-packages/gunicorn/instrument/__init__.py,py,0,0,2025-09-17 14:12:18
./venv/lib/python3.13/site-packages/gunicorn/instrument/statsd.py,py,134,4750,2025-09-17 14:12:18
./venv/lib/python3.13/site-packages/gunicorn/util.py,py,653,19095,2025-09-17 14:12:18
./venv/lib/python3.13/site-packages/gunicorn/systemd.py,py,75,2498,2025-09-17 14:12:18
./venv/lib/python3.13/site-packages/gunicorn/__init__.py,py,8,257,2025-09-17 14:12:18
./venv/lib/python3.13/site-packages/gunicorn/sock.py,py,231,6834,2025-09-17 14:12:18
./venv/lib/python3.13/site-packages/gunicorn/http/body.py,py,268,7600,2025-09-17 14:12:18
./venv/lib/python3.13/site-packages/gunicorn/http/__init__.py,py,8,255,2025-09-17 14:12:18
./venv/lib/python3.13/site-packages/gunicorn/http/message.py,py,463,17632,2025-09-17 14:12:18
./venv/lib/python3.13/site-packages/gunicorn/http/unreader.py,py,78,1913,2025-09-17 14:12:18
./venv/lib/python3.13/site-packages/gunicorn/http/parser.py,py,51,1334,2025-09-17 14:12:18
./venv/lib/python3.13/site-packages/gunicorn/http/errors.py,py,145,3437,2025-09-17 14:12:18
./venv/lib/python3.13/site-packages/gunicorn/http/wsgi.py,py,401,12811,2025-09-17 14:12:18
./venv/lib/python3.13/site-packages/gunicorn/debug.py,py,68,2263,2025-09-17 14:12:18
./venv/lib/python3.13/site-packages/gunicorn/arbiter.py,py,671,21470,2025-09-17 14:12:18
./venv/lib/python3.13/site-packages/gunicorn/workers/sync.py,py,209,7204,2025-09-17 14:12:18
./venv/lib/python3.13/site-packages/gunicorn/workers/base_async.py,py,147,5627,2025-09-17 14:12:18
./venv/lib/python3.13/site-packages/gunicorn/workers/gtornado.py,py,166,5811,2025-09-17 14:12:18
./venv/lib/python3.13/site-packages/gunicorn/workers/__init__.py,py,14,572,2025-09-17 14:12:18
./venv/lib/python3.13/site-packages/gunicorn/workers/geventlet.py,py,186,6069,2025-09-17 14:12:18
./venv/lib/python3.13/site-packages/gunicorn/workers/workertmp.py,py,53,1604,2025-09-17 14:12:18
./venv/lib/python3.13/site-packages/gunicorn/workers/ggevent.py,py,193,6030,2025-09-17 14:12:18
./venv/lib/python3.13/site-packages/gunicorn/workers/gthread.py,py,372,12500,2025-09-17 14:12:18
./venv/lib/python3.13/site-packages/gunicorn/workers/base.py,py,287,9763,2025-09-17 14:12:18
./venv/lib/python3.13/site-packages/gunicorn/errors.py,py,28,897,2025-09-17 14:12:18
./venv/lib/python3.13/site-packages/gunicorn/glogging.py,py,473,15273,2025-09-17 14:12:18
./venv/lib/python3.13/site-packages/gunicorn/__main__.py,py,10,338,2025-09-17 14:12:18
./venv/lib/python3.13/site-packages/sqlalchemy/connectors/asyncio.py,py,351,10122,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/connectors/__init__.py,py,18,476,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/connectors/aioodbc.py,py,184,5577,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/connectors/pyodbc.py,py,250,8618,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/util/queue.py,py,322,10185,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/util/_concurrency_py3k.py,py,288,9170,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/util/topological.py,py,120,3451,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/util/compat.py,py,303,8848,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/util/preloaded.py,py,150,5904,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/util/concurrency.py,py,108,3304,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/util/_has_cy.py,py,40,1247,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/util/__init__.py,py,160,8314,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/util/deprecations.py,py,401,12012,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/util/_collections.py,py,717,20151,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py,py,2303,68371,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/util/typing.py,py,733,22466,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/util/tool_support.py,py,201,6135,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/util/_py_collections.py,py,541,16650,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/log.py,py,288,8607,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/events.py,py,17,525,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/ext/instrumentation.py,py,450,15707,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/ext/compiler.py,py,600,20889,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/ext/orderinglist.py,py,439,15163,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/ext/hybrid.py,py,1533,52531,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/ext/__init__.py,py,11,322,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/ext/indexable.py,py,346,11066,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/ext/mypy/util.py,py,357,9960,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/ext/mypy/__init__.py,py,6,241,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/ext/mypy/names.py,py,335,10480,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/ext/mypy/plugin.py,py,303,9750,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/ext/mypy/infer.py,py,590,19367,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/ext/mypy/decl_class.py,py,515,17384,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/ext/mypy/apply.py,py,324,10591,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/ext/declarative/__init__.py,py,65,1818,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/ext/declarative/extensions.py,py,564,19531,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/ext/serializer.py,py,185,6169,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/ext/baked.py,py,570,17753,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/ext/automap.py,py,1701,61675,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/ext/asyncio/scoping.py,py,1613,52570,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/ext/asyncio/session.py,py,1961,63743,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/ext/asyncio/__init__.py,py,25,1317,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/ext/asyncio/result.py,py,962,30548,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/ext/asyncio/engine.py,py,1469,48321,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/ext/asyncio/exc.py,py,21,639,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/ext/asyncio/base.py,py,281,9033,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/ext/horizontal_shard.py,py,478,16691,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/ext/mutable.py,py,1096,37603,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/ext/associationproxy.py,py,2027,66442,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/__init__.py,py,283,12659,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/types.py,py,74,3166,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/inspection.py,py,174,5063,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/testing/pickleable.py,py,155,2833,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/testing/exclusions.py,py,435,12473,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/testing/config.py,py,423,12058,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/testing/engines.py,py,474,13414,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/testing/util.py,py,535,14526,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/testing/warnings.py,py,52,1546,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/testing/asyncio.py,py,135,3830,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/testing/plugin/bootstrap.py,py,51,1685,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/testing/plugin/plugin_base.py,py,779,21578,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/testing/plugin/__init__.py,py,6,247,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/testing/plugin/pytestplugin.py,py,867,27624,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/testing/__init__.py,py,96,3160,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/testing/assertions.py,py,991,31564,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/testing/assertsql.py,py,516,16817,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/testing/provision.py,py,502,14702,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/testing/requirements.py,py,1918,55757,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/testing/fixtures/orm.py,py,227,6095,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/testing/fixtures/__init__.py,py,28,1198,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/testing/fixtures/mypy.py,py,332,12755,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/testing/fixtures/sql.py,py,503,15900,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/testing/fixtures/base.py,py,371,12385,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/testing/entities.py,py,117,3354,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/testing/suite/test_sequence.py,py,317,9923,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/testing/suite/test_results.py,py,504,17042,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/testing/suite/test_insert.py,py,630,18824,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/testing/suite/test_select.py,py,2008,62041,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/testing/suite/test_deprecations.py,py,153,5337,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/testing/suite/test_ddl.py,py,389,12031,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/testing/suite/test_dialect.py,py,776,24215,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/testing/suite/__init__.py,py,19,722,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/testing/suite/test_update_delete.py,py,139,3994,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/testing/suite/test_reflection.py,py,3370,114101,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/testing/suite/test_rowcount.py,py,258,7900,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/testing/suite/test_cte.py,py,237,7262,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/testing/suite/test_types.py,py,2145,68013,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/testing/suite/test_unicode_ddl.py,py,189,6141,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/testing/profiling.py,py,324,10148,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/testing/schema.py,py,224,6513,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/cyextension/__init__.py,py,6,244,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/exc.py,py,832,23978,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/dialects/postgresql/pg_catalog.py,py,326,9999,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/dialects/postgresql/_psycopg_common.py,py,189,5783,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py,py,1293,41548,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/dialects/postgresql/psycopg2cffi.py,py,61,1756,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/dialects/postgresql/__init__.py,py,167,3892,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/dialects/postgresql/psycopg.py,py,783,23326,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/dialects/postgresql/types.py,py,313,7629,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/dialects/postgresql/ranges.py,py,1031,32946,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/dialects/postgresql/psycopg2.py,py,892,32032,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/dialects/postgresql/provision.py,py,175,5770,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/dialects/postgresql/pg8000.py,py,669,18743,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/dialects/postgresql/operators.py,py,129,2808,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/dialects/postgresql/array.py,py,509,16956,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/dialects/postgresql/dml.py,py,339,12126,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/dialects/postgresql/json.py,py,367,12842,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/dialects/postgresql/named_types.py,py,524,17812,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/dialects/postgresql/base.py,py,5226,186421,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/dialects/postgresql/ext.py,py,536,17347,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/dialects/postgresql/hstore.py,py,406,11934,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/dialects/_typing.py,py,30,971,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/dialects/oracle/vector.py,py,364,10874,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/dialects/oracle/__init__.py,py,81,1898,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/dialects/oracle/types.py,py,316,9058,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/dialects/oracle/oracledb.py,py,947,33771,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/dialects/oracle/provision.py,py,220,8313,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/dialects/oracle/cx_oracle.py,py,1555,56717,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/dialects/oracle/dictionary.py,py,507,19519,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/dialects/oracle/base.py,py,3802,139156,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/dialects/__init__.py,py,62,1798,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/dialects/sqlite/aiosqlite.py,py,443,14619,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/dialects/sqlite/pysqlcipher.py,py,157,5371,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/dialects/sqlite/__init__.py,py,57,1182,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/dialects/sqlite/provision.py,py,196,5596,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/dialects/sqlite/dml.py,py,263,9138,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/dialects/sqlite/json.py,py,92,2777,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/dialects/sqlite/base.py,py,2953,102859,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/dialects/sqlite/pysqlite.py,py,726,25999,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/dialects/mysql/enumerated.py,py,282,10292,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/dialects/mysql/mysqlconnector.py,py,302,10097,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/dialects/mysql/asyncmy.py,py,225,7093,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/dialects/mysql/aiomysql.py,py,244,7728,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/dialects/mysql/reserved_words.py,py,570,9236,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/dialects/mysql/reflection.py,py,727,24690,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/dialects/mysql/mariadbconnector.py,py,322,10385,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/dialects/mysql/__init__.py,py,104,2206,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/dialects/mysql/types.py,py,835,26459,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/dialects/mysql/mariadb.py,py,73,1886,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/dialects/mysql/provision.py,py,113,3717,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/dialects/mysql/mysqldb.py,py,314,9943,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/dialects/mysql/pymysql.py,py,158,4886,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/dialects/mysql/dml.py,py,225,7768,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/dialects/mysql/expression.py,py,146,4241,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/dialects/mysql/json.py,py,91,2806,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/dialects/mysql/pyodbc.py,py,157,5111,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/dialects/mysql/base.py,py,3923,137763,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/dialects/mysql/cymysql.py,py,106,3215,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/dialects/mssql/__init__.py,py,88,1880,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/dialects/mssql/pymssql.py,py,126,4097,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/dialects/mssql/provision.py,py,162,5593,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/dialects/mssql/aioodbc.py,py,63,2021,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/dialects/mssql/information_schema.py,py,285,8963,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/dialects/mssql/json.py,py,129,4756,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/dialects/mssql/pyodbc.py,py,760,27173,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/dialects/mssql/base.py,py,4084,133927,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/orm/sync.py,py,164,5779,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/orm/interfaces.py,py,1496,49072,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/orm/decl_base.py,py,2192,83486,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/orm/instrumentation.py,py,754,24321,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/orm/loading.py,py,1686,58488,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/orm/persistence.py,py,1788,61812,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/orm/_typing.py,py,179,4973,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/orm/path_registry.py,py,809,25914,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/orm/query.py,py,3453,118724,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/orm/attributes.py,py,2845,93117,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/orm/strategies.py,py,3470,119803,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/orm/strategy_options.py,py,2568,85627,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/orm/properties.py,py,907,30127,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/orm/util.py,py,2403,80889,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/orm/events.py,py,3269,127780,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/orm/mapper.py,py,4435,171834,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/orm/mapped_collection.py,py,557,19682,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/orm/scoping.py,py,2162,78600,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/orm/clsregistry.py,py,571,17952,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/orm/session.py,py,5294,195877,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/orm/__init__.py,py,170,8463,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/orm/writeonly.py,py,674,22225,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/orm/dynamic.py,py,300,9816,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/orm/context.py,py,3334,115082,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/orm/exc.py,py,237,7636,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/orm/collections.py,py,1627,52281,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/orm/_orm_constructors.py,py,2661,105600,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/orm/dependency.py,py,1302,47619,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/orm/descriptor_props.py,py,1092,37795,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/orm/decl_api.py,py,1920,65038,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/orm/bulk_persistence.py,py,2135,72984,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/orm/identity.py,py,302,9249,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/orm/state_changes.py,py,196,6813,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/orm/evaluator.py,py,379,12353,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/orm/unitofwork.py,py,796,27033,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/orm/base.py,py,971,27501,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/orm/relationships.py,py,3508,128763,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/orm/state.py,py,1143,37670,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/engine/interfaces.py,py,3464,115119,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/engine/_py_row.py,py,128,3787,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/engine/characteristics.py,py,155,4765,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/engine/create.py,py,893,33847,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/engine/strategies.py,py,16,439,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/engine/util.py,py,167,5682,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/engine/events.py,py,965,37400,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/engine/reflection.py,py,2102,75565,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/engine/__init__.py,py,62,2818,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/engine/url.py,py,924,31067,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/engine/result.py,py,2387,77805,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/engine/default.py,py,2389,85721,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/engine/_py_processors.py,py,136,3744,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/engine/processors.py,py,61,2379,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/engine/row.py,py,400,12031,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/engine/base.py,py,3374,123090,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/engine/cursor.py,py,2181,76567,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/engine/mock.py,py,134,4156,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/engine/_py_util.py,py,74,2465,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/pool/events.py,py,372,13149,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/pool/__init__.py,py,44,1804,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/pool/impl.py,py,579,18899,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/pool/base.py,py,1516,52383,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/event/legacy.py,py,246,8227,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/event/registry.py,py,390,11144,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/event/__init__.py,py,25,997,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/event/api.py,py,220,8109,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/event/attr.py,py,655,20751,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/event/base.py,py,472,15254,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/future/__init__.py,py,16,512,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/future/engine.py,py,15,495,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/schema.py,py,69,3251,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/sql/functions.py,py,2104,64826,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/sql/annotation.py,py,585,18245,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/sql/ddl.py,py,1444,47993,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/sql/_selectable_constructors.py,py,763,22171,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/sql/compiler.py,py,7999,283319,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/sql/_typing.py,py,468,13029,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/sql/traversals.py,py,1024,33664,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/sql/cache_key.py,py,1057,33653,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/sql/roles.py,py,323,7662,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/sql/naming.py,py,209,6855,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/sql/util.py,py,1485,48110,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/sql/visitors.py,py,1164,36316,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/sql/events.py,py,458,18312,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/sql/default_comparator.py,py,551,16706,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/sql/elements.py,py,5553,178317,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/sql/_dml_constructors.py,py,132,3795,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/sql/__init__.py,py,145,5820,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/sql/_elements_constructors.py,py,1872,63096,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/sql/sqltypes.py,py,3930,132156,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/sql/operators.py,py,2623,76792,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/sql/selectable.py,py,7219,242155,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/sql/dml.py,py,1837,66232,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/sql/coercions.py,py,1403,40705,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/sql/expression.py,py,159,7583,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/sql/base.py,py,2219,75859,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/sql/type_api.py,py,2368,85425,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/sql/crud.py,py,1744,59455,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/sql/lambdas.py,py,1442,49401,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/sql/schema.py,py,6218,230401,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/sql/_orm_types.py,py,20,625,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/sqlalchemy/sql/_py_util.py,py,75,2173,2025-09-17 14:12:10
./venv/lib/python3.13/site-packages/pip/_internal/configuration.py,py,397,14587,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/pyproject.py,py,182,7233,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/network/auth.py,py,564,20681,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/network/xmlrpc.py,py,61,1830,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/network/download.py,py,342,12682,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/network/session.py,py,528,19188,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/network/cache.py,py,133,5302,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/network/__init__.py,py,1,49,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/network/utils.py,py,98,4091,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/network/lazy_wheel.py,py,213,7651,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/cache.py,py,291,10364,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/__init__.py,py,18,511,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/utils/logging.py,py,364,12108,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/utils/misc.py,py,765,23374,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/utils/egg_link.py,py,81,2459,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/utils/compat.py,py,85,2514,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/utils/deprecation.py,py,126,3696,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/utils/subprocess.py,py,248,8983,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/utils/filesystem.py,py,152,4988,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/utils/direct_url_helpers.py,py,87,3200,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/utils/__init__.py,py,0,0,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/utils/_jaraco_text.py,py,109,3350,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/utils/temp_dir.py,py,294,9307,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/utils/retry.py,py,45,1461,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/utils/appdirs.py,py,52,1681,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/utils/setuptools_build.py,py,149,4499,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/utils/packaging.py,py,44,1601,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/utils/entrypoints.py,py,88,3324,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/utils/filetypes.py,py,24,689,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/utils/compatibility_tags.py,py,201,6630,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/utils/datetime.py,py,10,241,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/utils/urls.py,py,55,1601,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/utils/hashes.py,py,150,4998,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/utils/virtualenv.py,py,105,3455,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/utils/_log.py,py,38,1015,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/utils/glibc.py,py,102,3726,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/utils/wheel.py,py,132,4468,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/utils/unpacking.py,py,337,11939,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/models/link.py,py,613,21793,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/models/selection_prefs.py,py,53,2016,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/models/direct_url.py,py,227,6555,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/models/index.py,py,28,1030,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/models/target_python.py,py,122,4243,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/models/pylock.py,py,188,6211,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/models/__init__.py,py,1,62,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/models/search_scope.py,py,126,4507,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/models/candidate.py,py,25,753,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/models/format_control.py,py,78,2471,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/models/installation_report.py,py,57,2839,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/models/scheme.py,py,25,575,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/models/wheel.py,py,141,5526,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/cli/cmdoptions.py,py,1138,32032,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/cli/__init__.py,py,3,131,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/cli/index_command.py,py,175,5717,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/cli/status_codes.py,py,6,116,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/cli/parser.py,py,298,10928,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/cli/command_context.py,py,28,817,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/cli/spinners.py,py,235,7362,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/cli/autocompletion.py,py,184,7193,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/cli/base_command.py,py,244,8716,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/cli/main_parser.py,py,134,4329,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/cli/progress_bars.py,py,151,4668,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/cli/main.py,py,80,2815,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/cli/req_command.py,py,351,13081,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/operations/install/editable_legacy.py,py,48,1311,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/operations/install/__init__.py,py,1,50,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/operations/install/wheel.py,py,746,27956,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/operations/check.py,py,175,5894,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/operations/__init__.py,py,0,0,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/operations/freeze.py,py,259,9854,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/operations/build/wheel_legacy.py,py,119,3616,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/operations/build/metadata.py,py,38,1421,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/operations/build/metadata_editable.py,py,41,1509,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/operations/build/wheel_editable.py,py,47,1422,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/operations/build/__init__.py,py,0,0,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/operations/build/metadata_legacy.py,py,73,2189,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/operations/build/wheel.py,py,38,1080,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/operations/build/build_tracker.py,py,140,4771,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/operations/prepare.py,py,742,28613,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/req/req_install.py,py,937,35718,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/req/req_set.py,py,81,2828,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/req/req_uninstall.py,py,639,24099,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/req/__init__.py,py,105,3122,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/req/req_dependency_group.py,py,75,2618,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/req/req_file.py,py,620,20161,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/req/constructors.py,py,562,18320,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/resolution/legacy/__init__.py,py,0,0,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/resolution/legacy/resolver.py,py,598,24060,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/resolution/__init__.py,py,0,0,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/resolution/base.py,py,20,577,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/resolution/resolvelib/provider.py,py,276,11144,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/resolution/resolvelib/found_candidates.py,py,166,6018,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/resolution/resolvelib/reporter.py,py,85,3270,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/resolution/resolvelib/__init__.py,py,0,0,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/resolution/resolvelib/factory.py,py,814,32577,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/resolution/resolvelib/requirements.py,py,247,8076,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/resolution/resolvelib/resolver.py,py,336,13617,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/resolution/resolvelib/candidates.py,py,582,20208,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/resolution/resolvelib/base.py,py,142,5047,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/vcs/git.py,py,571,19144,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/vcs/__init__.py,py,15,596,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/vcs/mercurial.py,py,186,5575,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/vcs/bazaar.py,py,130,3734,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/vcs/versioncontrol.py,py,693,22502,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/vcs/subversion.py,py,335,11787,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/locations/__init__.py,py,441,14185,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/locations/_sysconfig.py,py,215,7716,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/locations/_distutils.py,py,173,5975,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/locations/base.py,py,82,2550,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/index/collector.py,py,489,16185,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/index/__init__.py,py,1,29,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/index/sources.py,py,287,8639,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/index/package_finder.py,py,1059,38827,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/exceptions.py,py,881,28974,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/commands/configuration.py,py,288,10105,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/commands/show.py,py,231,8066,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/commands/list.py,py,400,13514,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/commands/check.py,py,66,2244,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/commands/index.py,py,159,5243,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/commands/completion.py,py,135,4530,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/commands/download.py,py,145,5249,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/commands/cache.py,py,231,8230,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/commands/__init__.py,py,139,4026,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/commands/hash.py,py,58,1679,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/commands/inspect.py,py,92,3177,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/commands/debug.py,py,203,6805,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/commands/uninstall.py,py,113,3868,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/commands/lock.py,py,170,5917,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/commands/freeze.py,py,107,3099,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/commands/search.py,py,178,5782,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/commands/install.py,py,798,30080,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/commands/help.py,py,40,1108,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/commands/wheel.py,py,181,6322,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/main.py,py,12,338,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/wheel_builder.py,py,334,11225,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/metadata/_json.py,py,87,2711,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/metadata/__init__.py,py,164,5714,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/metadata/pkg_resources.py,py,298,10544,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/metadata/importlib/_dists.py,py,223,8259,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/metadata/importlib/__init__.py,py,6,135,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/metadata/importlib/_compat.py,py,87,2804,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/metadata/importlib/_envs.py,py,143,5333,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/metadata/base.py,py,685,25420,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/distributions/__init__.py,py,21,858,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/distributions/sdist.py,py,165,6952,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/distributions/installed.py,py,33,929,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/distributions/base.py,py,55,1830,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/distributions/wheel.py,py,44,1364,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/self_outdated_check.py,py,254,8326,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_internal/build_env.py,py,349,11566,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/packaging/tags.py,py,656,22745,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/packaging/_musllinux.py,py,85,2694,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/packaging/metadata.py,py,862,34739,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/packaging/version.py,py,582,16688,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/packaging/licenses/__init__.py,py,145,5727,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/packaging/licenses/_spdx.py,py,759,48398,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/packaging/__init__.py,py,15,494,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/packaging/_parser.py,py,353,10221,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/packaging/utils.py,py,163,5050,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/packaging/requirements.py,py,91,2947,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/packaging/_structures.py,py,61,1431,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/packaging/markers.py,py,362,12049,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/packaging/_manylinux.py,py,262,9596,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/packaging/_tokenizer.py,py,195,5310,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/packaging/specifiers.py,py,1019,40079,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/packaging/_elffile.py,py,109,3286,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/truststore/_openssl.py,py,66,2324,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/truststore/_api.py,py,333,11234,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/truststore/_macos.py,py,571,20503,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/truststore/__init__.py,py,36,1320,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/truststore/_ssl_constants.py,py,31,1130,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/truststore/_windows.py,py,567,17993,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/msgpack/__init__.py,py,55,1109,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/msgpack/exceptions.py,py,48,1081,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/msgpack/fallback.py,py,929,32390,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/msgpack/ext.py,py,170,5726,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/dependency_groups/_lint_dependency_groups.py,py,59,1710,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/dependency_groups/__init__.py,py,13,250,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/dependency_groups/_pip_wrapper.py,py,62,1865,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/dependency_groups/_implementation.py,py,209,8041,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/dependency_groups/_toml_compat.py,py,9,285,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/dependency_groups/__main__.py,py,65,1709,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/pygments/filters/__init__.py,py,940,40392,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/pygments/modeline.py,py,43,1005,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/pygments/console.py,py,70,1718,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/pygments/scanner.py,py,104,3092,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/pygments/formatter.py,py,129,4390,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/pygments/lexers/__init__.py,py,362,12115,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/pygments/lexers/python.py,py,1201,53853,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/pygments/lexers/_mapping.py,py,602,77602,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/pygments/token.py,py,214,6226,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/pygments/style.py,py,203,6420,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/pygments/util.py,py,324,10031,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/pygments/sphinxext.py,py,247,7981,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/pygments/__init__.py,py,82,2983,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/pygments/formatters/__init__.py,py,157,5385,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/pygments/formatters/_mapping.py,py,23,4176,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/pygments/styles/__init__.py,py,61,2042,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/pygments/styles/_mapping.py,py,54,3312,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/pygments/unistring.py,py,153,63208,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/pygments/lexer.py,py,963,35349,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/pygments/regexopt.py,py,91,3072,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/pygments/plugin.py,py,72,1891,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/pygments/filter.py,py,70,1910,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/pygments/__main__.py,py,17,353,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/distlib/compat.py,py,1137,41467,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/distlib/util.py,py,1984,66682,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/distlib/__init__.py,py,33,625,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/distlib/resources.py,py,358,10820,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/distlib/scripts.py,py,447,18612,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/distro/__init__.py,py,54,981,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/distro/distro.py,py,1403,49430,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/distro/__main__.py,py,4,64,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/cachecontrol/serialize.py,py,146,5163,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/cachecontrol/wrapper.py,py,43,1417,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/cachecontrol/controller.py,py,511,19101,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/cachecontrol/filewrapper.py,py,119,4291,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/cachecontrol/heuristics.py,py,157,4881,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/cachecontrol/adapter.py,py,168,6599,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/cachecontrol/cache.py,py,75,1953,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/cachecontrol/__init__.py,py,29,677,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/cachecontrol/_cmd.py,py,70,1737,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/cachecontrol/caches/file_cache.py,py,145,4117,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/cachecontrol/caches/__init__.py,py,8,303,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/cachecontrol/caches/redis_cache.py,py,48,1386,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/idna/intranges.py,py,57,1898,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/idna/package_data.py,py,1,21,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/idna/compat.py,py,15,316,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/idna/idnadata.py,py,4243,78306,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/idna/__init__.py,py,45,868,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/idna/core.py,py,437,13239,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/idna/codec.py,py,122,3422,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/idna/uts46data.py,py,8681,239289,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/__init__.py,py,117,4907,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/requests/cookies.py,py,561,18590,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/requests/auth.py,py,314,10186,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/requests/sessions.py,py,831,30495,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/requests/hooks.py,py,33,733,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/requests/compat.py,py,90,1822,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/requests/models.py,py,1039,35575,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/requests/certs.py,py,17,441,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/requests/__init__.py,py,179,5057,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/requests/status_codes.py,py,128,4322,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/requests/packages.py,py,25,1057,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/requests/__version__.py,py,14,435,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/requests/api.py,py,157,6449,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/requests/_internal_utils.py,py,50,1495,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/requests/utils.py,py,1086,33225,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/requests/exceptions.py,py,151,4272,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/requests/structures.py,py,99,2912,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/requests/help.py,py,127,3813,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/requests/adapters.py,py,719,27607,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/tomli/_types.py,py,10,254,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/tomli/__init__.py,py,8,314,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/tomli/_parser.py,py,770,25591,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/tomli/_re.py,py,112,3171,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/certifi/__init__.py,py,4,94,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/certifi/core.py,py,83,3442,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/certifi/__main__.py,py,12,255,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/pyproject_hooks/_impl.py,py,410,14936,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/pyproject_hooks/__init__.py,py,31,691,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/pyproject_hooks/_in_process/_in_process.py,py,389,12216,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/pyproject_hooks/_in_process/__init__.py,py,21,557,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/rich/themes.py,py,5,102,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/rich/screen.py,py,54,1591,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/rich/logging.py,py,297,12468,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/rich/measure.py,py,151,5305,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/rich/tree.py,py,257,9451,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/rich/console.py,py,2680,100849,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/rich/live_render.py,py,106,3521,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/rich/_emoji_codes.py,py,3610,140235,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/rich/box.py,py,474,10686,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/rich/color.py,py,621,18211,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/rich/_timer.py,py,19,417,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/rich/_fileno.py,py,24,799,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/rich/align.py,py,306,10324,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/rich/theme.py,py,115,3771,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/rich/style.py,py,796,27059,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/rich/default_styles.py,py,193,8257,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/rich/_wrap.py,py,93,3404,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/rich/_log_render.py,py,94,3225,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/rich/emoji.py,py,91,2367,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/rich/layout.py,py,442,14004,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/rich/containers.py,py,167,5502,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/rich/_emoji_replace.py,py,32,1064,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/rich/traceback.py,py,899,35861,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/rich/region.py,py,10,166,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/rich/protocol.py,py,42,1391,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/rich/_loop.py,py,43,1236,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/rich/control.py,py,219,6487,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/rich/filesize.py,py,88,2484,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/rich/_null_file.py,py,69,1394,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/rich/_palettes.py,py,309,7063,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/rich/__init__.py,py,177,6090,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/rich/_pick.py,py,17,423,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/rich/file_proxy.py,py,57,1683,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/rich/palette.py,py,100,3396,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/rich/markup.py,py,251,8451,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/rich/_ratio.py,py,153,5325,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/rich/repr.py,py,149,4431,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/rich/constrain.py,py,37,1288,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/rich/pretty.py,py,1016,36391,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/rich/diagnose.py,py,39,1025,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/rich/columns.py,py,187,7131,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/rich/rule.py,py,130,4602,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/rich/_inspect.py,py,268,9656,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/rich/pager.py,py,34,828,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/rich/text.py,py,1361,47552,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/rich/highlighter.py,py,232,9586,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/rich/_spinners.py,py,482,19919,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/rich/terminal_theme.py,py,153,3370,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/rich/bar.py,py,93,3263,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/rich/live.py,py,400,15180,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/rich/syntax.py,py,985,36371,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/rich/table.py,py,1006,40049,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/rich/_export_format.py,py,76,2128,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/rich/progress_bar.py,py,223,8162,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/rich/errors.py,py,34,642,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/rich/prompt.py,py,400,12447,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/rich/segment.py,py,752,24743,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/rich/ansi.py,py,241,6921,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/rich/progress.py,py,1715,60408,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/rich/_stack.py,py,16,351,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/rich/_windows.py,py,71,1925,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/rich/_cell_widths.py,py,454,10209,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/rich/cells.py,py,174,5130,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/rich/_win32_console.py,py,661,22755,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/rich/panel.py,py,317,11157,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/rich/styled.py,py,42,1258,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/rich/spinner.py,py,132,4214,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/rich/_windows_renderer.py,py,56,2783,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/rich/json.py,py,139,5031,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/rich/padding.py,py,141,4908,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/rich/__main__.py,py,245,7896,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/rich/scope.py,py,86,2843,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/rich/_extension.py,py,10,265,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/rich/status.py,py,131,4424,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/rich/abc.py,py,33,890,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/rich/jupyter.py,py,101,3252,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/rich/color_triplet.py,py,38,1054,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/tomli_w/_writer.py,py,229,6961,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/tomli_w/__init__.py,py,4,169,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/urllib3/filepost.py,py,98,2440,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/urllib3/fields.py,py,274,8579,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/urllib3/util/queue.py,py,22,498,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/urllib3/util/ssltransport.py,py,221,6895,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/urllib3/util/proxy.py,py,57,1605,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/urllib3/util/wait.py,py,152,5403,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/urllib3/util/request.py,py,137,3997,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/urllib3/util/timeout.py,py,271,10168,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/urllib3/util/__init__.py,py,49,1155,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/urllib3/util/response.py,py,107,3510,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/urllib3/util/ssl_.py,py,504,17460,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/urllib3/util/retry.py,py,622,22050,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/urllib3/util/url.py,py,435,14296,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/urllib3/util/connection.py,py,149,4901,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/urllib3/util/ssl_match_hostname.py,py,159,5758,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/urllib3/_version.py,py,2,64,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/urllib3/request.py,py,191,6691,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/urllib3/__init__.py,py,102,3333,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/urllib3/poolmanager.py,py,540,19990,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/urllib3/response.py,py,879,30641,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/urllib3/contrib/securetransport.py,py,920,34446,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/urllib3/contrib/__init__.py,py,0,0,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/urllib3/contrib/socks.py,py,216,7097,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/urllib3/contrib/_appengine_environ.py,py,36,957,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/urllib3/contrib/pyopenssl.py,py,518,17081,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/urllib3/contrib/appengine.py,py,314,11036,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/urllib3/contrib/_securetransport/__init__.py,py,0,0,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/urllib3/contrib/_securetransport/low_level.py,py,397,13922,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/urllib3/contrib/_securetransport/bindings.py,py,519,17632,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/urllib3/contrib/ntlmpool.py,py,130,4528,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/urllib3/connection.py,py,572,20314,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/urllib3/_collections.py,py,355,11372,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/urllib3/packages/__init__.py,py,0,0,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/urllib3/packages/backports/__init__.py,py,0,0,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/urllib3/packages/backports/makefile.py,py,51,1417,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/urllib3/packages/backports/weakref_finalize.py,py,155,5343,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/urllib3/packages/six.py,py,1076,34665,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/urllib3/exceptions.py,py,323,8217,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/urllib3/connectionpool.py,py,1140,40408,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/pkg_resources/__init__.py,py,3676,124451,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/resolvelib/__init__.py,py,27,541,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/resolvelib/resolvers/abstract.py,py,47,1558,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/resolvelib/resolvers/__init__.py,py,27,640,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/resolvelib/resolvers/exceptions.py,py,57,1768,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/resolvelib/resolvers/criterion.py,py,48,1768,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/resolvelib/resolvers/resolution.py,py,622,23994,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/resolvelib/providers.py,py,196,8914,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/resolvelib/structs.py,py,209,6420,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/resolvelib/reporters.py,py,55,2037,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/platformdirs/macos.py,py,144,6154,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/platformdirs/unix.py,py,272,10458,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/platformdirs/version.py,py,21,511,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/platformdirs/__init__.py,py,631,22344,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/platformdirs/api.py,py,299,9277,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/platformdirs/android.py,py,249,9013,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/platformdirs/windows.py,py,272,10125,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/_vendor/platformdirs/__main__.py,py,55,1505,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/__init__.py,py,13,353,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/__pip-runner__.py,py,50,1450,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/pip/__main__.py,py,24,854,2025-09-17 14:12:05
./venv/lib/python3.13/site-packages/alembic/command.py,py,835,24855,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/alembic/config.py,py,1026,34237,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/alembic/util/compat.py,py,146,4248,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/alembic/util/pyfiles.py,py,153,4730,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/alembic/util/__init__.py,py,29,1519,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/alembic/util/exc.py,py,25,564,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/alembic/util/langhelpers.py,py,332,10026,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/alembic/util/editor.py,py,81,2546,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/alembic/util/sqla_compat.py,py,495,14790,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/alembic/util/messaging.py,py,122,3294,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/alembic/ddl/postgresql.py,py,854,29950,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/alembic/ddl/mssql.py,py,421,14216,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/alembic/ddl/__init__.py,py,6,152,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/alembic/ddl/_autogen.py,py,329,9275,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/alembic/ddl/sqlite.py,py,237,8006,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/alembic/ddl/impl.py,py,902,30439,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/alembic/ddl/oracle.py,py,202,6243,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/alembic/ddl/base.py,py,364,10478,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/alembic/ddl/mysql.py,py,524,18383,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/alembic/runtime/__init__.py,py,0,0,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/alembic/runtime/environment.py,py,1051,41479,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/alembic/runtime/migration.py,py,1395,49997,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/alembic/__init__.py,py,4,63,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/alembic/operations/schemaobj.py,py,290,9468,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/alembic/operations/batch.py,py,718,26923,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/alembic/operations/__init__.py,py,15,318,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/alembic/operations/ops.py,py,2842,96276,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/alembic/operations/toimpl.py,py,242,7503,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/alembic/operations/base.py,py,1923,75157,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/alembic/script/__init__.py,py,4,100,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/alembic/script/write_hooks.py,py,176,5092,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/alembic/script/revision.py,py,1728,62307,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/alembic/script/base.py,py,1055,36896,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/alembic/op.py,py,5,167,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/alembic/testing/env.py,py,557,11551,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/alembic/testing/util.py,py,126,3350,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/alembic/testing/schemacompare.py,py,169,4838,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/alembic/testing/warnings.py,py,31,831,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/alembic/testing/plugin/bootstrap.py,py,4,50,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/alembic/testing/plugin/__init__.py,py,0,0,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/alembic/testing/__init__.py,py,32,1297,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/alembic/testing/assertions.py,py,179,5302,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/alembic/testing/requirements.py,py,176,4180,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/alembic/testing/suite/test_autogen_fks.py,py,1190,32927,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/alembic/testing/suite/_autogen_fixtures.py,py,448,13480,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/alembic/testing/suite/test_autogen_computed.py,py,144,4126,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/alembic/testing/suite/test_autogen_diffs.py,py,273,8394,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/alembic/testing/suite/__init__.py,py,7,288,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/alembic/testing/suite/test_autogen_identity.py,py,226,5824,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/alembic/testing/suite/test_autogen_comments.py,py,242,6283,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/alembic/testing/suite/test_op.py,py,42,1343,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/alembic/testing/suite/test_environment.py,py,364,11877,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/alembic/testing/fixtures.py,py,333,9920,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/alembic/context.py,py,5,195,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/alembic/autogenerate/render.py,py,1172,37270,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/alembic/autogenerate/rewriter.py,py,240,7814,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/alembic/autogenerate/__init__.py,py,10,543,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/alembic/autogenerate/api.py,py,650,22219,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/alembic/autogenerate/compare.py,py,1370,45979,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/alembic/environment.py,py,1,43,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/alembic/templates/pyproject_async/env.py,py,89,2389,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/alembic/templates/async/env.py,py,89,2389,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/alembic/templates/multidb/env.py,py,140,4230,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/alembic/templates/pyproject/env.py,py,78,2103,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/alembic/templates/generic/env.py,py,78,2103,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/alembic/migration.py,py,1,41,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/alembic/__main__.py,py,4,78,2025-09-17 14:12:16
./venv/lib/python3.13/site-packages/blinker/__init__.py,py,17,317,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/blinker/_utilities.py,py,64,1675,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/blinker/base.py,py,512,19132,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/wtforms/validators.py,py,734,21927,2025-09-17 14:12:17
./venv/lib/python3.13/site-packages/wtforms/__init__.py,py,79,2408,2025-09-17 14:12:17
./venv/lib/python3.13/site-packages/wtforms/csrf/session.py,py,93,3092,2025-09-17 14:12:17
./venv/lib/python3.13/site-packages/wtforms/csrf/__init__.py,py,0,0,2025-09-17 14:12:17
./venv/lib/python3.13/site-packages/wtforms/csrf/core.py,py,96,3097,2025-09-17 14:12:17
./venv/lib/python3.13/site-packages/wtforms/form.py,py,330,12619,2025-09-17 14:12:17
./venv/lib/python3.13/site-packages/wtforms/utils.py,py,91,2399,2025-09-17 14:12:17
./venv/lib/python3.13/site-packages/wtforms/i18n.py,py,72,1958,2025-09-17 14:12:17
./venv/lib/python3.13/site-packages/wtforms/fields/list.py,py,202,6471,2025-09-17 14:12:17
./venv/lib/python3.13/site-packages/wtforms/fields/__init__.py,py,71,2255,2025-09-17 14:12:17
./venv/lib/python3.13/site-packages/wtforms/fields/core.py,py,448,14385,2025-09-17 14:12:17
./venv/lib/python3.13/site-packages/wtforms/fields/form.py,py,98,2897,2025-09-17 14:12:17
./venv/lib/python3.13/site-packages/wtforms/fields/numeric.py,py,213,6157,2025-09-17 14:12:17
./venv/lib/python3.13/site-packages/wtforms/fields/choices.py,py,229,6882,2025-09-17 14:12:17
./venv/lib/python3.13/site-packages/wtforms/fields/datetime.py,py,170,5034,2025-09-17 14:12:17
./venv/lib/python3.13/site-packages/wtforms/fields/simple.py,py,173,4075,2025-09-17 14:12:17
./venv/lib/python3.13/site-packages/wtforms/widgets/__init__.py,py,57,1687,2025-09-17 14:12:17
./venv/lib/python3.13/site-packages/wtforms/widgets/core.py,py,569,15509,2025-09-17 14:12:17
./venv/lib/python3.13/site-packages/wtforms/meta.py,py,132,4097,2025-09-17 14:12:17
./venv/lib/python3.13/site-packages/psycopg2/_json.py,py,199,7153,2025-09-17 14:12:14
./venv/lib/python3.13/site-packages/psycopg2/extras.py,py,1340,44215,2025-09-17 14:12:14
./venv/lib/python3.13/site-packages/psycopg2/errorcodes.py,py,450,14392,2025-09-17 14:12:14
./venv/lib/python3.13/site-packages/psycopg2/tz.py,py,158,4870,2025-09-17 14:12:14
./venv/lib/python3.13/site-packages/psycopg2/_range.py,py,554,18494,2025-09-17 14:12:14
./venv/lib/python3.13/site-packages/psycopg2/_ipaddress.py,py,90,2922,2025-09-17 14:12:14
./venv/lib/python3.13/site-packages/psycopg2/__init__.py,py,126,4768,2025-09-17 14:12:14
./venv/lib/python3.13/site-packages/psycopg2/extensions.py,py,213,6797,2025-09-17 14:12:14
./venv/lib/python3.13/site-packages/psycopg2/errors.py,py,38,1425,2025-09-17 14:12:14
./venv/lib/python3.13/site-packages/psycopg2/sql.py,py,455,14779,2025-09-17 14:12:14
./venv/lib/python3.13/site-packages/psycopg2/pool.py,py,187,6316,2025-09-17 14:12:14
./venv/lib/python3.13/site-packages/itsdangerous/_json.py,py,18,473,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/itsdangerous/timed.py,py,228,8083,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/itsdangerous/encoding.py,py,54,1409,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/itsdangerous/__init__.py,py,38,1427,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/itsdangerous/url_safe.py,py,83,2505,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/itsdangerous/exc.py,py,106,3201,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/itsdangerous/serializer.py,py,406,15601,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/itsdangerous/signer.py,py,266,9647,2025-09-17 14:12:09
./venv/lib/python3.13/site-packages/typing_extensions.py,py,4317,160429,2025-09-17 14:12:10

### SNIPPETS (máx 40 líneas por archivo; .py sin comentarios) ###

===== ./run.py =====
import os
from dotenv import load_dotenv
load_dotenv()
from app import create_app, db
from app.models import Contrato
from sqlalchemy import text, func
config_name = os.environ.get('FLASK_ENV', 'development')
app = create_app(config_name)
def create_indexes():
    """Crea los índices necesarios para optimizar las búsquedas"""
    indices_sql = """
    -- Índices para mejorar performance
    CREATE INDEX IF NOT EXISTS idx_contratos_importe 
        ON contratos.contratos(importe DESC NULLS LAST);
    
    CREATE INDEX IF NOT EXISTS idx_contratos_proveedor 
        ON contratos.contratos(proveedor_contratista);
    
    CREATE INDEX IF NOT EXISTS idx_contratos_rfc 
        ON contratos.contratos(rfc);
    
    CREATE INDEX IF NOT EXISTS idx_contratos_siglas_inst 
        ON contratos.contratos(siglas_institucion);
    
    CREATE INDEX IF NOT EXISTS idx_contratos_anio 
        ON contratos.contratos(anio_fuente);
    
    CREATE INDEX IF NOT EXISTS idx_contratos_tipo_contratacion
        ON contratos.contratos(tipo_contratacion);
    
    CREATE INDEX IF NOT EXISTS idx_contratos_tipo_procedimiento
        ON contratos.contratos(tipo_procedimiento);
    
    -- Índices para búsqueda de texto
    CREATE INDEX IF NOT EXISTS idx_contratos_titulo_gin
        ON contratos.contratos USING gin(to_tsvector('spanish', titulo_contrato));
    
    CREATE INDEX IF NOT EXISTS idx_contratos_descripcion_gin
        ON contratos.contratos USING gin(to_tsvector('spanish', descripcion_contrato));
    """
...(truncado)

===== ./app/__init__.py =====
import os
import logging
from pathlib import Path
from flask import Flask, g, request
from flask_sqlalchemy import SQLAlchemy
from flask_migrate import Migrate
from config import config
import time
import json
from datetime import datetime
import hashlib
db = SQLAlchemy()
migrate = Migrate()
def setup_logging(app):
    """Configurar el sistema de logging"""
    
    # Crear directorio de logs si no existe
    log_dir = Path('logs')
    log_dir.mkdir(exist_ok=True)
    
    # Configuración del formato de logs
    class JSONFormatter(logging.Formatter):
        def format(self, record):
            log_obj = {
                'timestamp': datetime.utcnow().isoformat(),
                'level': record.levelname,
                'message': record.getMessage(),
                'module': record.module,
                'function': record.funcName
            }
            if hasattr(record, 'extra_fields'):
                log_obj.update(record.extra_fields)
            return json.dumps(log_obj)
    
    # Configurar handlers para diferentes tipos de logs
    from logging.handlers import RotatingFileHandler
    
    # Handler para logs generales
    if not app.debug:
        file_handler = RotatingFileHandler(
...(truncado)

===== ./app/utils/metrics.py =====
from datetime import datetime, timedelta
from collections import Counter, defaultdict
import json
from pathlib import Path
import pandas as pd
class PlatformMetrics:
    """Analiza métricas de uso de la plataforma"""
    
    @staticmethod
    def parse_logs(log_file, start_date=None, end_date=None):
        """Parsea archivo de logs y filtra por fecha"""
        logs = []
        
        with open(log_file, 'r') as f:
            for line in f:
                try:
                    log_entry = json.loads(line)
                    log_time = datetime.fromisoformat(log_entry['timestamp'])
                    
                    if start_date and log_time < start_date:
                        continue
                    if end_date and log_time > end_date:
                        continue
                        
                    logs.append(log_entry)
                except:
                    continue
                    
        return logs
    
    @staticmethod
    def get_usage_metrics(days=7):
        """Obtiene métricas de uso de los últimos N días"""
        end_date = datetime.utcnow()
        start_date = end_date - timedelta(days=days)
        
        # Parsear logs de acceso
        access_logs = PlatformMetrics.parse_logs(
            'logs/access.log',
            start_date,
...(truncado)

===== ./app/utils/logging_config.py =====
import logging
import logging.handlers
import json
from datetime import datetime
from flask import request, g
from functools import wraps
import os
from pathlib import Path
class StructuredFormatter(logging.Formatter):
    """Formateador para logs estructurados en JSON"""
    def format(self, record):
        log_obj = {
            'timestamp': datetime.utcnow().isoformat(),
            'level': record.levelname,
            'logger': record.name,
            'message': record.getMessage(),
            'module': record.module,
            'function': record.funcName,
            'line': record.lineno
        }
        
        # Agregar campos extra si existen
        if hasattr(record, 'extra_fields'):
            log_obj.update(record.extra_fields)
            
        return json.dumps(log_obj, ensure_ascii=False)
def setup_logging(app):
    """Configurar el sistema de logging para la aplicación"""
    
    # Crear directorio de logs si no existe
    log_dir = Path('logs')
    log_dir.mkdir(exist_ok=True)
    
    # Configurar logger principal
    app.logger.setLevel(logging.INFO)
    
    # Handler para archivo de logs general
    file_handler = logging.handlers.RotatingFileHandler(
        'logs/app.log',
        maxBytes=10485760,  # 10MB
...(truncado)

===== ./app/utils/activity_tracker.py =====
from flask import request, g, session
from datetime import datetime
import logging
import hashlib
from user_agents import parse
from functools import wraps
import time
access_logger = logging.getLogger('access')
search_logger = logging.getLogger('search')
class ActivityTracker:
    """Rastrea actividad de usuarios en la plataforma"""
    
    @staticmethod
    def get_user_fingerprint():
        """Genera un fingerprint único para el usuario (anónimo)"""
        user_agent = request.headers.get('User-Agent', '')
        ip = request.remote_addr
        # Hash para anonimizar
        fingerprint = hashlib.md5(f"{ip}{user_agent}".encode()).hexdigest()
        return fingerprint
    
    @staticmethod
    def get_request_context():
        """Obtiene contexto de la petición actual"""
        user_agent = parse(request.headers.get('User-Agent', ''))
        
        return {
            'ip_hash': hashlib.md5(request.remote_addr.encode()).hexdigest()[:8],
            'method': request.method,
            'path': request.path,
            'endpoint': request.endpoint,
            'referrer': request.referrer,
            'browser': user_agent.browser.family,
            'browser_version': user_agent.browser.version_string,
            'os': user_agent.os.family,
            'device': user_agent.device.family,
            'is_mobile': user_agent.is_mobile,
            'is_bot': user_agent.is_bot,
            'session_id': session.get('session_id'),
            'user_fingerprint': ActivityTracker.get_user_fingerprint()
...(truncado)

===== ./app/utils/__init__.py =====
...(truncado)

===== ./app/utils/decorators.py =====
from functools import wraps
from flask import g
import time
from app.utils.activity_tracker import ActivityTracker
def track_activity(func):
    """Decorador para rastrear actividad en endpoints específicos"""
    @wraps(func)
    def decorated_function(*args, **kwargs):
        g.start_time = time.time()
        
        try:
            result = func(*args, **kwargs)
            
            # Log específico según el endpoint
            if 'contract' in func.__name__:
                contract_id = kwargs.get('id')
                if contract_id:
                    ActivityTracker.log_contract_view(contract_id)
                    
            return result
            
        except Exception as e:
            ActivityTracker.log_error(e, error_type='endpoint_error')
            raise
            
    return decorated_function
def track_search(func):
    """Decorador específico para rastrear búsquedas"""
    @wraps(func)
    def decorated_function(*args, **kwargs):
        start_time = time.time()
        
        result = func(*args, **kwargs)
        
        execution_time = time.time() - start_time
        
        # Extraer parámetros de búsqueda del request
        from flask import request
        search_params = dict(request.args)
        
...(truncado)

===== ./app/models/contrato.py =====
from app import db
from datetime import datetime
class Contrato(db.Model):
    """Modelo de Contrato"""
    __tablename__ = 'contratos'
    __table_args__ = {'schema': 'contratos'}
    
    codigo_contrato = db.Column(db.String, primary_key=True)
    codigo_expediente = db.Column(db.String)
    titulo_contrato = db.Column(db.Text)
    titulo_expediente = db.Column(db.Text)
    descripcion_contrato = db.Column(db.Text)
    tipo_contratacion = db.Column(db.String)
    tipo_procedimiento = db.Column(db.String)
    proveedor_contratista = db.Column(db.String)
    rfc = db.Column(db.String)
    institucion = db.Column(db.String)
    siglas_institucion = db.Column(db.String)
    importe = db.Column(db.Numeric)
    importe_contrato = db.Column(db.String)
    moneda = db.Column(db.String)
    fecha_inicio_contrato = db.Column(db.Date)
    fecha_fin_contrato = db.Column(db.Date)
    estatus_contrato = db.Column(db.String)
    direccion_anuncio = db.Column(db.Text)
    anio_fuente = db.Column(db.Integer)
    
    def get_importe_numerico(self):
        """Obtiene el importe como número flotante"""
        if self.importe:
            return float(self.importe)
        elif self.importe_contrato:
            try:
                importe_str = str(self.importe_contrato).replace(',', '').strip()
                return float(importe_str)
            except:
                return 0.0
        return 0.0
    
    def to_dict(self):
...(truncado)

===== ./app/models/__init__.py =====
from .contrato import Contrato
__all__ = ['Contrato']...(truncado)

===== ./app/static/css/style.css =====
/* Minimal Liquid Glass Design - Elegant & Functional */

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

:root {
    /* Primary Colors */
    --primary: #007AFF;
    --primary-dark: #0051D5;
    --success: #34C759;
    --danger: #FF3B30;
    --warning: #FF9500;
    
    /* Neutral Palette */
    --bg-primary: #000000;
    --bg-secondary: #1C1C1E;
    --bg-tertiary: #2C2C2E;
    --surface: #1C1C1E;
    --surface-elevated: #2C2C2E;
    
    /* Text Colors */
    --text-primary: rgba(255, 255, 255, 1);
    --text-secondary: rgba(255, 255, 255, 0.85);
    --text-tertiary: rgba(255, 255, 255, 0.6);
    --text-quaternary: rgba(255, 255, 255, 0.4);
    
    /* Glass Effects - Subtle */
    --glass: rgba(255, 255, 255, 0.05);
    --glass-hover: rgba(255, 255, 255, 0.08);
    --glass-border: rgba(255, 255, 255, 0.1);
    
    /* Shadows */
    --shadow-sm: 0 2px 8px rgba(0, 0, 0, 0.2);
    --shadow-md: 0 4px 20px rgba(0, 0, 0, 0.25);
    --shadow-lg: 0 8px 40px rgba(0, 0, 0, 0.3);
    
    /* Animation */
...(truncado)

===== ./app/app.py =====
import os
import re
from datetime import datetime
from flask import Flask, render_template, request, jsonify
from flask_sqlalchemy import SQLAlchemy
from sqlalchemy import func, or_, text, and_
from sqlalchemy.orm import Query
import logging
app = Flask(__name__)
DB_USER = os.getenv('DB_USER', 'postgres')
DB_PASSWORD = os.getenv('DB_PASSWORD', 'password')
DB_HOST = os.getenv('DB_HOST', 'localhost')
DB_PORT = os.getenv('DB_PORT', '5432')
DB_NAME = os.getenv('DB_NAME', 'contratos_db')
app.config['SQLALCHEMY_DATABASE_URI'] = f'postgresql://{DB_USER}:{DB_PASSWORD}@{DB_HOST}:{DB_PORT}/{DB_NAME}'
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
app.config['JSON_AS_ASCII'] = False
db = SQLAlchemy(app)
logging.basicConfig(level=logging.INFO)
class Contrato(db.Model):
    __tablename__ = 'contratos'
    __table_args__ = {'schema': 'contratos'}
    
    codigo_contrato = db.Column(db.String, primary_key=True)
    codigo_expediente = db.Column(db.String)
    titulo_contrato = db.Column(db.Text)
    titulo_expediente = db.Column(db.Text)
    descripcion_contrato = db.Column(db.Text)
    tipo_contratacion = db.Column(db.String)
    tipo_procedimiento = db.Column(db.String)
    proveedor_contratista = db.Column(db.String)
    rfc = db.Column(db.String)
    institucion = db.Column(db.String)
    siglas_institucion = db.Column(db.String)
    importe = db.Column(db.Numeric)
    importe_contrato = db.Column(db.String)
    moneda = db.Column(db.String)
    fecha_inicio_contrato = db.Column(db.Date)
    fecha_fin_contrato = db.Column(db.Date)
    estatus_contrato = db.Column(db.String)
...(truncado)

===== ./app/api/__init__.py =====
from .search import search_bp
from .contracts import contracts_bp
from .stats import stats_bp
__all__ = ['search_bp', 'contracts_bp', 'stats_bp']...(truncado)

===== ./app/api/stats.py =====
from flask import Blueprint, jsonify
from app.services.aggregation_service import AggregationService
import logging
stats_bp = Blueprint('stats', __name__)
logger = logging.getLogger(__name__)
@stats_bp.route('/stats', methods=['GET'])
def get_stats():
    """Obtiene estadísticas generales de la base de datos"""
    try:
        aggregation_service = AggregationService()
        stats = aggregation_service.get_stats()
        return jsonify(stats)
        
    except Exception as e:
        logger.error(f"Error obteniendo estadísticas: {str(e)}")
        return jsonify({'error': 'Error al obtener estadísticas'}), 500...(truncado)

===== ./app/api/contracts.py =====
from flask import Blueprint, request, jsonify
from app.models import Contrato
from app.services.search_service import SearchService
import logging
contracts_bp = Blueprint('contracts', __name__)
logger = logging.getLogger(__name__)
@contracts_bp.route('/contracts/page', methods=['POST'])
def get_contracts_page():
    """Obtiene una página específica de contratos (para scroll infinito)"""
    try:
        data = request.get_json()
        
        query_text = data.get('query', '').strip()
        search_type = data.get('search_type', 'todo')
        filters = data.get('filters', {})
        page = data.get('page', 1)
        per_page = min(data.get('per_page', 50), 100)  # Máximo 100 por página
        
        # Validación básica
        if not query_text:
            return jsonify({'error': 'Query requerido'}), 400
        
        if page < 1:
            page = 1
        
        # Usar el servicio para construir la consulta
        search_service = SearchService()
        query = search_service.build_search_query(query_text, search_type)
        
        # Aplicar filtros
        if filters:
            query = search_service.apply_filters(query, filters)
        
        # Calcular offset
        offset = (page - 1) * per_page
        
        # Obtener contratos paginados ordenados por importe
        contratos = query.order_by(
            Contrato.importe.desc().nullslast()
        ).offset(offset).limit(per_page).all()
...(truncado)

===== ./app/api/search.py =====
from flask import Blueprint, request, jsonify
from app.models import Contrato
from app.services.search_service import SearchService
from app.services.aggregation_service import AggregationService
from app.services.filter_service import FilterService
from app import db
from sqlalchemy import func
import logging
import time
search_bp = Blueprint('search', __name__)
logger = logging.getLogger(__name__)
@search_bp.route('/search', methods=['POST'])
def search():
    """Búsqueda inicial - retorna agregados COMPLETOS y primeros 50 contratos"""
    try:
        start_time = time.time()
        data = request.get_json()
        
        # Validar entrada
        search_service = SearchService()
        query_text, search_type = search_service.validate_search_input(
            data.get('query', ''),
            data.get('search_type', 'todo')
        )
        
        filters = data.get('filters', {})
        
        if not query_text:
            return jsonify({'error': 'Por favor ingresa un término de búsqueda'}), 400
        
        # Construir la consulta base
        base_query = search_service.build_search_query(query_text, search_type)
        
        # Aplicar filtros
        if filters:
            base_query = search_service.apply_filters(base_query, filters)
        
        logger.info(f"Búsqueda: {query_text}, tipo: {search_type}, filtros: {filters}")
        
        # 1. Obtener agregados COMPLETOS de TODOS los resultados
...(truncado)

===== ./app/templates/index.html =====
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LaLupa 🔍 - Buscador de Contratos Gubernamentales</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
</head>
<body>
    <div class="container">
        <!-- Header -->
        <header>
            <h1>LaLupa 🔍</h1>
            <p class="subtitle">Buscador de Contratos Gubernamentales de México</p>
        </header>

        <!-- Barra de búsqueda -->
        <div class="search-container">
            <div class="search-box">
                <input type="text" id="searchInput" placeholder="Buscar contratos..." autofocus>
                <button id="searchBtn" type="button" onclick="buscar()">Buscar</button>
            </div>
            <div class="search-options">
                <label><input type="radio" name="searchType" value="descripcion" checked> Descripción</label>
                <label><input type="radio" name="searchType" value="titulo"> Título</label>
                <label><input type="radio" name="searchType" value="empresa"> Proveedor</label>
                <label><input type="radio" name="searchType" value="rfc"> RFC</label>
                <label><input type="radio" name="searchType" value="institucion"> Institución</label>
                <label><input type="radio" name="searchType" value="todo"> Todo</label>
            </div>
        </div>

        <!-- Loading global -->
        <div id="loading" class="loading hidden">
            <div class="spinner"></div>
            <p>Buscando contratos...</p>
        </div>

        <!-- Área de resultados -->
        <div id="resultsArea" class="hidden">
...(truncado)

===== ./app/services/filter_service.py =====
"""Servicio de filtros"""
from sqlalchemy import func
from app import db
import logging
logger = logging.getLogger(__name__)
class FilterService:
    """Servicio para manejar filtros"""
    
    def obtener_filtros_disponibles(self, base_query):
        """Obtiene los valores únicos para filtros usando consultas optimizadas"""
        try:
            from app.models import Contrato
            filtros = {}
            
            # Crear alias para la subquery
            subquery = base_query.subquery()
            
            # Top 10 instituciones más frecuentes
            inst_query = db.session.query(
                subquery.c.siglas_institucion,
                func.count('*').label('count')
            ).group_by(
                subquery.c.siglas_institucion
            ).filter(
                subquery.c.siglas_institucion.isnot(None)
            ).order_by(
                func.count('*').desc()
            ).limit(10)
            
            filtros['instituciones'] = {
                i.siglas_institucion: i.count for i in inst_query
            }
            
            # Top 10 tipos de contratación
            tipos_query = db.session.query(
                subquery.c.tipo_contratacion,
                func.count('*').label('count')
            ).group_by(
                subquery.c.tipo_contratacion
            ).filter(
...(truncado)

===== ./app/services/__init__.py =====
from .search_service import SearchService
from .aggregation_service import AggregationService
from .filter_service import FilterService
__all__ = ['SearchService', 'AggregationService', 'FilterService']...(truncado)

===== ./app/services/search_service.py =====
"""Servicio de búsqueda de contratos"""
import re
from sqlalchemy import or_
class SearchService:
    """Servicio para búsquedas de contratos"""
    
    def validate_search_input(self, query_text, search_type):
        """Valida y sanitiza la entrada de búsqueda"""
        query_text = query_text.strip()
        
        if len(query_text) > 200:
            raise ValueError('Término de búsqueda demasiado largo')
        
        # Remover caracteres peligrosos pero mantener acentos
        query_text = re.sub(r'[^\w\s\-.,áéíóúñÁÉÍÓÚÑ]', '', query_text)
        
        # Validar tipo de búsqueda
        valid_types = ['descripcion', 'titulo', 'empresa', 'rfc', 'institucion', 'todo']
        if search_type not in valid_types:
            search_type = 'todo'
        
        # Validación especial para RFC
        if search_type == 'rfc':
            rfc_pattern = r'^[A-ZÑ&]{3,4}\d{6}[A-Z0-9]{3}$'
            if not re.match(rfc_pattern, query_text.upper()):
                raise ValueError('Formato de RFC inválido')
        
        return query_text, search_type
    
    def build_search_query(self, query_text, search_type):
        """Construye la consulta según el tipo de búsqueda"""
        # Importar aquí para evitar import circular
        from app.models import Contrato
        
        query = Contrato.query
        
        if search_type == 'descripcion':
            query = query.filter(
                Contrato.descripcion_contrato.ilike(f'%{query_text}%')
            )
...(truncado)

===== ./app/services/aggregation_service.py =====
"""Servicio de agregación de datos"""
from sqlalchemy import func
from app import db
import logging
logger = logging.getLogger(__name__)
class AggregationService:
    """Servicio para agregaciones y estadísticas"""
    
    def obtener_agregados_optimizado(self, base_query):
        """Obtiene agregados usando consultas SQL optimizadas"""
        try:
            from app.models import Contrato
            
            # Total de contratos y monto total
            subquery = base_query.subquery()
            totales = db.session.query(
                func.count('*').label('total'),
                func.sum(subquery.c.importe).label('monto_total')
            ).select_from(subquery).first()
            
            total_contratos = totales.total or 0
            monto_total = float(totales.monto_total or 0)
            
            # Top 20 proveedores
            proveedores_query = db.session.query(
                subquery.c.proveedor_contratista.label('nombre'),
                subquery.c.rfc.label('rfc'),
                func.count('*').label('num_contratos'),
                func.sum(subquery.c.importe).label('monto_total')
            ).filter(
                subquery.c.proveedor_contratista.isnot(None)
            ).group_by(
                subquery.c.proveedor_contratista,
                subquery.c.rfc
            ).order_by(
                func.sum(subquery.c.importe).desc().nullslast()
            ).limit(20)
            
            proveedores = []
            for p in proveedores_query:
...(truncado)

===== ./app/routes.py =====
from flask import Blueprint, render_template, request, jsonify
from app import db
from sqlalchemy import func, text
main_bp = Blueprint('main', __name__)
@main_bp.route('/')
def index():
    """Página principal"""
    return render_template('index.html')
@main_bp.route('/api/filters', methods=['GET'])
def get_filters():
    """
    Obtener opciones disponibles para filtros
    """
    try:
        from app.models.contrato import Contrato
        
        # Obtener instituciones únicas con conteo
        instituciones = db.session.query(
            Contrato.siglas_institucion,
            Contrato.institucion,
            func.count(Contrato.codigo_contrato).label('total')
        ).filter(
            Contrato.siglas_institucion != None
        ).group_by(
            Contrato.siglas_institucion,
            Contrato.institucion
        ).having(
            func.count(Contrato.codigo_contrato) > 10
        ).order_by(
            text('total DESC')
        ).limit(100).all()
        
        # Años disponibles
        anios = db.session.query(
            Contrato.anio_fuente
        ).distinct().filter(
            Contrato.anio_fuente != None
        ).order_by(
            Contrato.anio_fuente.desc()
        ).all()
...(truncado)

===== ./config/config.py =====
import os
from dotenv import load_dotenv
load_dotenv()
class Config:
    SECRET_KEY = os.environ.get('SECRET_KEY') or 'dev-secret-key'
    SQLALCHEMY_DATABASE_URI = os.environ.get('DATABASE_URL')
    SQLALCHEMY_TRACK_MODIFICATIONS = False
    SQLALCHEMY_ENGINE_OPTIONS = {
        'pool_size': 10,
        'pool_recycle': 3600,
        'pool_pre_ping': True
    }
...(truncado)

===== ./config/__init__.py =====
import os
from datetime import timedelta
class Config:
    """Configuración base"""
    SECRET_KEY = os.environ.get('SECRET_KEY') or 'dev-secret-key-change-in-production'
    
    # Database
    SQLALCHEMY_TRACK_MODIFICATIONS = False
    SQLALCHEMY_RECORD_QUERIES = True
    
    # JSON
    JSON_AS_ASCII = False
    JSON_SORT_KEYS = False
    
    # Pagination
    CONTRACTS_PER_PAGE = 50
    MAX_CONTRACTS_PER_PAGE = 100
    
    # Cache
    CACHE_TYPE = 'simple'
    CACHE_DEFAULT_TIMEOUT = 300
    
    # ===== CONFIGURACIÓN DE LOGGING =====
    # Directorio de logs
    LOG_DIR = 'logs'
    LOG_TO_STDOUT = os.environ.get('LOG_TO_STDOUT', 'false').lower() == 'true'
    
    # Niveles de logging
    LOG_LEVEL = os.environ.get('LOG_LEVEL', 'INFO')
    
    # Configuración de archivos de log
    LOG_FILE_MAX_BYTES = 10485760  # 10MB
    LOG_FILE_BACKUP_COUNT = 10
    
    # Tipos de logs a mantener
    LOG_TYPES = {
        'app': {
            'filename': 'app.log',
            'level': 'INFO',
            'backup_count': 10
...(truncado)

===== ./view_metrics.py =====
import json
import os
from datetime import datetime, timedelta
from collections import Counter
from pathlib import Path
def parse_json_logs(log_file):
    """Parse JSON logs from file"""
    logs = []
    if not os.path.exists(log_file):
        return logs
        
    with open(log_file, 'r') as f:
        for line in f:
            try:
                logs.append(json.loads(line.strip()))
            except:
                continue
    return logs
def show_recent_activity():
    """Muestra actividad reciente"""
    print("\n" + "="*60)
    print("📊 ACTIVIDAD RECIENTE (Últimos 30 minutos)")
    print("="*60)
    
    # Leer logs de acceso
    access_logs = parse_json_logs('logs/access.log')
    
    # Filtrar últimos 30 minutos
    thirty_min_ago = datetime.utcnow() - timedelta(minutes=30)
    recent_logs = [
        log for log in access_logs 
        if datetime.fromisoformat(log.get('timestamp', '')) > thirty_min_ago
    ]
    
    if recent_logs:
        print(f"\n✅ Total de requests: {len(recent_logs)}")
        
        # Endpoints más visitados
        endpoints = Counter(log.get('endpoint') for log in recent_logs if log.get('endpoint'))
        print("\n🎯 Top Endpoints visitados:")
...(truncado)

===== ./test_connection.py =====
import os
from dotenv import load_dotenv
import psycopg2
from urllib.parse import urlparse
load_dotenv()
print("🔍 PRUEBA DE CONEXIÓN DESDE .env")
print("=" * 60)
DATABASE_URL = os.getenv('DATABASE_URL')
if not DATABASE_URL:
    print("❌ Error: No se encontró DATABASE_URL en el archivo .env")
    print("Verifica que el archivo .env existe y contiene DATABASE_URL")
    exit(1)
print("✅ DATABASE_URL encontrada en .env")
print(f"📝 URL: {DATABASE_URL[:50]}...")  # Mostrar solo el inicio por seguridad
print()
result = urlparse(DATABASE_URL)
print("📋 Configuración parseada:")
print(f"   Host: {result.hostname}")
print(f"   Puerto: {result.port}")
print(f"   Base de datos: {result.path[1:]}")
print(f"   Usuario: {result.username}")
print(f"   SSL: sslmode=require")
print()
print("🔌 Intentando conectar...")
print("-" * 60)
try:
    # Conectar usando psycopg2 directamente
    conn = psycopg2.connect(DATABASE_URL)
    
    print("✅ ¡CONEXIÓN EXITOSA!")
    print()
    
    cur = conn.cursor()
    
    # Prueba 1: Contar registros
    cur.execute("SELECT COUNT(*) FROM contratos.contratos")
    count = cur.fetchone()[0]
    print(f"📊 Total de contratos en la BD: {count:,}")
    
    # Prueba 2: Obtener muestra de datos
...(truncado)

===== ./utils/validators.py =====
import re
from typing import Optional
def sanitize_search_input(text: str, max_length: int = 200) -> Optional[str]:
    """
    Sanitiza la entrada de búsqueda
    """
    if not text:
        return None
    
    # Eliminar espacios al inicio y final
    text = text.strip()
    
    # Limitar longitud
    if len(text) > max_length:
        text = text[:max_length]
    
    # Remover caracteres peligrosos pero permitir búsquedas normales
    # Permitimos letras, números, espacios, guiones, puntos, comas, acentos
    text = re.sub(r'[^\w\s\-.,áéíóúñÁÉÍÓÚÑ]', '', text)
    
    # Evitar múltiples espacios
    text = ' '.join(text.split())
    
    return text if text else None
def validate_rfc(rfc: str) -> bool:
    """
    Valida formato de RFC mexicano
    """
    # RFC persona moral: 3 letras, 6 números, 3 caracteres
    # RFC persona física: 4 letras, 6 números, 3 caracteres
    pattern = r'^[A-ZÑ&]{3,4}\d{6}[A-Z0-9]{3}$'
    return bool(re.match(pattern, rfc.upper()))
def validate_year(year: str) -> Optional[int]:
    """
    Valida que el año esté en un rango razonable
    """
    try:
        year_int = int(year)
        # Rango razonable de años para contratos
        if 2000 <= year_int <= 2030:
...(truncado)

===== ./utils/tests/unit/__init__.py =====
...(truncado)

===== ./utils/tests/integration/__init__.py =====
...(truncado)

===== ./utils/tests/__init__.py =====
...(truncado)

===== ./test_connection_do.py =====
"""Script para probar que la nueva estructura funciona correctamente"""
import os
import sys
from dotenv import load_dotenv
load_dotenv()
os.environ['FLASK_ENV'] = 'development'
from app import create_app, db
from app.models import Contrato
from app.services import SearchService, AggregationService, FilterService
from sqlalchemy import func
def test_database_connection():
    """Prueba la conexión a la base de datos"""
    print("\n1. Probando conexión a la base de datos...")
    try:
        app = create_app('development')
        with app.app_context():
            # Test básico de conexión
            result = db.session.execute(db.text('SELECT 1')).scalar()
            assert result == 1
            
            # Contar contratos
            count = db.session.query(func.count(Contrato.codigo_contrato)).scalar()
            print(f"   ✅ Conexión exitosa. Contratos en BD: {count:,}")
            return True
    except Exception as e:
        print(f"   ❌ Error: {e}")
        return False
def test_services():
    """Prueba los servicios"""
    print("\n2. Probando servicios...")
    try:
        app = create_app('development')
        with app.app_context():
            # Probar SearchService
            search_service = SearchService()
            query_text, search_type = search_service.validate_search_input(
                "construcción", "todo"
            )
            print(f"   ✅ SearchService funciona")
            
...(truncado)

===== ./test_new_structure.py =====
"""Script para probar que la nueva estructura funciona correctamente"""
import os
import sys
from dotenv import load_dotenv
load_dotenv()
os.environ['FLASK_ENV'] = 'development'
from app import create_app, db
from app.models import Contrato
from app.services import SearchService, AggregationService, FilterService
from sqlalchemy import func
def test_database_connection():
    """Prueba la conexión a la base de datos"""
    print("\n1. Probando conexión a la base de datos...")
    try:
        app = create_app('development')
        with app.app_context():
            # Test básico de conexión
            result = db.session.execute(db.text('SELECT 1')).scalar()
            assert result == 1
            
            # Contar contratos
            count = db.session.query(func.count(Contrato.codigo_contrato)).scalar()
            print(f"   ✅ Conexión exitosa. Contratos en BD: {count:,}")
            return True
    except Exception as e:
        print(f"   ❌ Error: {e}")
        return False
def test_services():
    """Prueba los servicios"""
    print("\n2. Probando servicios...")
    try:
        app = create_app('development')
        with app.app_context():
            # Probar SearchService
            search_service = SearchService()
            query_text, search_type = search_service.validate_search_input(
                "construcción", "todo"
            )
            print(f"   ✅ SearchService funciona")
            
...(truncado)

===== ./venv/lib/python3.13/site-packages/flask/logging.py =====
from __future__ import annotations
import logging
import sys
import typing as t
from werkzeug.local import LocalProxy
from .globals import request
if t.TYPE_CHECKING:  # pragma: no cover
    from .sansio.app import App
@LocalProxy
def wsgi_errors_stream() -> t.TextIO:
    """Find the most appropriate error stream for the application. If a request
    is active, log to ``wsgi.errors``, otherwise use ``sys.stderr``.
    If you configure your own :class:`logging.StreamHandler`, you may want to
    use this for the stream. If you are using file or dict configuration and
    can't import this directly, you can refer to it as
    ``ext://flask.logging.wsgi_errors_stream``.
    """
    if request:
        return request.environ["wsgi.errors"]  # type: ignore[no-any-return]
    return sys.stderr
def has_level_handler(logger: logging.Logger) -> bool:
    """Check if there is a handler in the logging chain that will handle the
    given logger's :meth:`effective level <~logging.Logger.getEffectiveLevel>`.
    """
    level = logger.getEffectiveLevel()
    current = logger
    while current:
        if any(handler.level <= level for handler in current.handlers):
            return True
        if not current.propagate:
            break
        current = current.parent  # type: ignore
    return False
default_handler = logging.StreamHandler(wsgi_errors_stream)  # type: ignore
default_handler.setFormatter(
    logging.Formatter("[%(asctime)s] %(levelname)s in %(module)s: %(message)s")
)
def create_logger(app: App) -> logging.Logger:
    """Get the Flask app's logger and configure it if needed.
    The logger name will be the same as
...(truncado)

===== ./venv/lib/python3.13/site-packages/flask/sansio/blueprints.py =====
from __future__ import annotations
import os
import typing as t
from collections import defaultdict
from functools import update_wrapper
from .. import typing as ft
from .scaffold import _endpoint_from_view_func
from .scaffold import _sentinel
from .scaffold import Scaffold
from .scaffold import setupmethod
if t.TYPE_CHECKING:  # pragma: no cover
    from .app import App
DeferredSetupFunction = t.Callable[["BlueprintSetupState"], None]
T_after_request = t.TypeVar("T_after_request", bound=ft.AfterRequestCallable[t.Any])
T_before_request = t.TypeVar("T_before_request", bound=ft.BeforeRequestCallable)
T_error_handler = t.TypeVar("T_error_handler", bound=ft.ErrorHandlerCallable)
T_teardown = t.TypeVar("T_teardown", bound=ft.TeardownCallable)
T_template_context_processor = t.TypeVar(
    "T_template_context_processor", bound=ft.TemplateContextProcessorCallable
)
T_template_filter = t.TypeVar("T_template_filter", bound=ft.TemplateFilterCallable)
T_template_global = t.TypeVar("T_template_global", bound=ft.TemplateGlobalCallable)
T_template_test = t.TypeVar("T_template_test", bound=ft.TemplateTestCallable)
T_url_defaults = t.TypeVar("T_url_defaults", bound=ft.URLDefaultCallable)
T_url_value_preprocessor = t.TypeVar(
    "T_url_value_preprocessor", bound=ft.URLValuePreprocessorCallable
)
class BlueprintSetupState:
    """Temporary holder object for registering a blueprint with the
    application.  An instance of this class is created by the
    :meth:`~flask.Blueprint.make_setup_state` method and later passed
    to all register callback functions.
    """
    def __init__(
        self,
        blueprint: Blueprint,
        app: App,
        options: t.Any,
        first_registration: bool,
    ) -> None:
...(truncado)

===== ./venv/lib/python3.13/site-packages/flask/sansio/app.py =====
from __future__ import annotations
import logging
import os
import sys
import typing as t
from datetime import timedelta
from itertools import chain
from werkzeug.exceptions import Aborter
from werkzeug.exceptions import BadRequest
from werkzeug.exceptions import BadRequestKeyError
from werkzeug.routing import BuildError
from werkzeug.routing import Map
from werkzeug.routing import Rule
from werkzeug.sansio.response import Response
from werkzeug.utils import cached_property
from werkzeug.utils import redirect as _wz_redirect
from .. import typing as ft
from ..config import Config
from ..config import ConfigAttribute
from ..ctx import _AppCtxGlobals
from ..helpers import _split_blueprint_path
from ..helpers import get_debug_flag
from ..json.provider import DefaultJSONProvider
from ..json.provider import JSONProvider
from ..logging import create_logger
from ..templating import DispatchingJinjaLoader
from ..templating import Environment
from .scaffold import _endpoint_from_view_func
from .scaffold import find_package
from .scaffold import Scaffold
from .scaffold import setupmethod
if t.TYPE_CHECKING:  # pragma: no cover
    from werkzeug.wrappers import Response as BaseResponse
    from ..testing import FlaskClient
    from ..testing import FlaskCliRunner
    from .blueprints import Blueprint
T_shell_context_processor = t.TypeVar(
    "T_shell_context_processor", bound=ft.ShellContextProcessorCallable
)
T_teardown = t.TypeVar("T_teardown", bound=ft.TeardownCallable)
...(truncado)

===== ./venv/lib/python3.13/site-packages/flask/sansio/scaffold.py =====
from __future__ import annotations
import importlib.util
import os
import pathlib
import sys
import typing as t
from collections import defaultdict
from functools import update_wrapper
from jinja2 import BaseLoader
from jinja2 import FileSystemLoader
from werkzeug.exceptions import default_exceptions
from werkzeug.exceptions import HTTPException
from werkzeug.utils import cached_property
from .. import typing as ft
from ..helpers import get_root_path
from ..templating import _default_template_ctx_processor
if t.TYPE_CHECKING:  # pragma: no cover
    from click import Group
_sentinel = object()
F = t.TypeVar("F", bound=t.Callable[..., t.Any])
T_after_request = t.TypeVar("T_after_request", bound=ft.AfterRequestCallable[t.Any])
T_before_request = t.TypeVar("T_before_request", bound=ft.BeforeRequestCallable)
T_error_handler = t.TypeVar("T_error_handler", bound=ft.ErrorHandlerCallable)
T_teardown = t.TypeVar("T_teardown", bound=ft.TeardownCallable)
T_template_context_processor = t.TypeVar(
    "T_template_context_processor", bound=ft.TemplateContextProcessorCallable
)
T_url_defaults = t.TypeVar("T_url_defaults", bound=ft.URLDefaultCallable)
T_url_value_preprocessor = t.TypeVar(
    "T_url_value_preprocessor", bound=ft.URLValuePreprocessorCallable
)
T_route = t.TypeVar("T_route", bound=ft.RouteCallable)
def setupmethod(f: F) -> F:
    f_name = f.__name__
    def wrapper_func(self: Scaffold, *args: t.Any, **kwargs: t.Any) -> t.Any:
        self._check_setup_finished(f_name)
        return f(self, *args, **kwargs)
    return t.cast(F, update_wrapper(wrapper_func, f))
class Scaffold:
    """Common behavior shared between :class:`~flask.Flask` and
...(truncado)

===== ./venv/lib/python3.13/site-packages/flask/signals.py =====
from __future__ import annotations
from blinker import Namespace
_signals = Namespace()
template_rendered = _signals.signal("template-rendered")
before_render_template = _signals.signal("before-render-template")
request_started = _signals.signal("request-started")
request_finished = _signals.signal("request-finished")
request_tearing_down = _signals.signal("request-tearing-down")
got_request_exception = _signals.signal("got-request-exception")
appcontext_tearing_down = _signals.signal("appcontext-tearing-down")
appcontext_pushed = _signals.signal("appcontext-pushed")
appcontext_popped = _signals.signal("appcontext-popped")
message_flashed = _signals.signal("message-flashed")
...(truncado)

===== ./venv/lib/python3.13/site-packages/flask/sessions.py =====
from __future__ import annotations
import collections.abc as c
import hashlib
import typing as t
from collections.abc import MutableMapping
from datetime import datetime
from datetime import timezone
from itsdangerous import BadSignature
from itsdangerous import URLSafeTimedSerializer
from werkzeug.datastructures import CallbackDict
from .json.tag import TaggedJSONSerializer
if t.TYPE_CHECKING:  # pragma: no cover
    import typing_extensions as te
    from .app import Flask
    from .wrappers import Request
    from .wrappers import Response
class SessionMixin(MutableMapping[str, t.Any]):
    """Expands a basic dictionary with session attributes."""
    @property
    def permanent(self) -> bool:
        """This reflects the ``'_permanent'`` key in the dict."""
        return self.get("_permanent", False)
    @permanent.setter
    def permanent(self, value: bool) -> None:
        self["_permanent"] = bool(value)
    #: Some implementations can detect whether a session is newly
    #: created, but that is not guaranteed. Use with caution. The mixin
    # default is hard-coded ``False``.
    new = False
    #: Some implementations can detect changes to the session and set
    #: this when that happens. The mixin default is hard coded to
    #: ``True``.
    modified = True
    #: Some implementations can detect when session data is read or
    #: written and set this when that happens. The mixin default is hard
    #: coded to ``True``.
    accessed = True
class SecureCookieSession(CallbackDict[str, t.Any], SessionMixin):
    """Base class for sessions based on signed cookies.
    This session backend will set the :attr:`modified` and
...(truncado)

===== ./venv/lib/python3.13/site-packages/flask/config.py =====
from __future__ import annotations
import errno
import json
import os
import types
import typing as t
from werkzeug.utils import import_string
if t.TYPE_CHECKING:
    import typing_extensions as te
    from .sansio.app import App
T = t.TypeVar("T")
class ConfigAttribute(t.Generic[T]):
    """Makes an attribute forward to the config"""
    def __init__(
        self, name: str, get_converter: t.Callable[[t.Any], T] | None = None
    ) -> None:
        self.__name__ = name
        self.get_converter = get_converter
    @t.overload
    def __get__(self, obj: None, owner: None) -> te.Self: ...
    @t.overload
    def __get__(self, obj: App, owner: type[App]) -> T: ...
    def __get__(self, obj: App | None, owner: type[App] | None = None) -> T | te.Self:
        if obj is None:
            return self
        rv = obj.config[self.__name__]
        if self.get_converter is not None:
            rv = self.get_converter(rv)
        return rv  # type: ignore[no-any-return]
    def __set__(self, obj: App, value: t.Any) -> None:
        obj.config[self.__name__] = value
class Config(dict):  # type: ignore[type-arg]
    """Works exactly like a dict but provides ways to fill it from files
    or special dictionaries.  There are two common patterns to populate the
    config.
    Either you can fill the config from a config file::
        app.config.from_pyfile('yourconfig.cfg')
    Or alternatively you can define the configuration options in the
    module that calls :meth:`from_object` or provide an import path to
    a module that should be loaded.  It is also possible to tell it to
...(truncado)

===== ./venv/lib/python3.13/site-packages/flask/templating.py =====
from __future__ import annotations
import typing as t
from jinja2 import BaseLoader
from jinja2 import Environment as BaseEnvironment
from jinja2 import Template
from jinja2 import TemplateNotFound
from .globals import _cv_app
from .globals import _cv_request
from .globals import current_app
from .globals import request
from .helpers import stream_with_context
from .signals import before_render_template
from .signals import template_rendered
if t.TYPE_CHECKING:  # pragma: no cover
    from .app import Flask
    from .sansio.app import App
    from .sansio.scaffold import Scaffold
def _default_template_ctx_processor() -> dict[str, t.Any]:
    """Default template context processor.  Injects `request`,
    `session` and `g`.
    """
    appctx = _cv_app.get(None)
    reqctx = _cv_request.get(None)
    rv: dict[str, t.Any] = {}
    if appctx is not None:
        rv["g"] = appctx.g
    if reqctx is not None:
        rv["request"] = reqctx.request
        rv["session"] = reqctx.session
    return rv
class Environment(BaseEnvironment):
    """Works like a regular Jinja environment but has some additional
    knowledge of how Flask's blueprint works so that it can prepend the
    name of the blueprint to referenced templates if necessary.
    """
    def __init__(self, app: App, **options: t.Any) -> None:
        if "loader" not in options:
            options["loader"] = app.create_global_jinja_loader()
        BaseEnvironment.__init__(self, **options)
        self.app = app
...(truncado)

===== ./venv/lib/python3.13/site-packages/flask/globals.py =====
from __future__ import annotations
import typing as t
from contextvars import ContextVar
from werkzeug.local import LocalProxy
if t.TYPE_CHECKING:  # pragma: no cover
    from .app import Flask
    from .ctx import _AppCtxGlobals
    from .ctx import AppContext
    from .ctx import RequestContext
    from .sessions import SessionMixin
    from .wrappers import Request
_no_app_msg = """\
Working outside of application context.
This typically means that you attempted to use functionality that needed
the current application. To solve this, set up an application context
with app.app_context(). See the documentation for more information.\
"""
_cv_app: ContextVar[AppContext] = ContextVar("flask.app_ctx")
app_ctx: AppContext = LocalProxy(  # type: ignore[assignment]
    _cv_app, unbound_message=_no_app_msg
)
current_app: Flask = LocalProxy(  # type: ignore[assignment]
    _cv_app, "app", unbound_message=_no_app_msg
)
g: _AppCtxGlobals = LocalProxy(  # type: ignore[assignment]
    _cv_app, "g", unbound_message=_no_app_msg
)
_no_req_msg = """\
Working outside of request context.
This typically means that you attempted to use functionality that needed
an active HTTP request. Consult the documentation on testing for
information about how to avoid this problem.\
"""
_cv_request: ContextVar[RequestContext] = ContextVar("flask.request_ctx")
request_ctx: RequestContext = LocalProxy(  # type: ignore[assignment]
    _cv_request, unbound_message=_no_req_msg
)
request: Request = LocalProxy(  # type: ignore[assignment]
    _cv_request, "request", unbound_message=_no_req_msg
)
...(truncado)

===== ./venv/lib/python3.13/site-packages/flask/__init__.py =====
from __future__ import annotations
import typing as t
from . import json as json
from .app import Flask as Flask
from .blueprints import Blueprint as Blueprint
from .config import Config as Config
from .ctx import after_this_request as after_this_request
from .ctx import copy_current_request_context as copy_current_request_context
from .ctx import has_app_context as has_app_context
from .ctx import has_request_context as has_request_context
from .globals import current_app as current_app
from .globals import g as g
from .globals import request as request
from .globals import session as session
from .helpers import abort as abort
from .helpers import flash as flash
from .helpers import get_flashed_messages as get_flashed_messages
from .helpers import get_template_attribute as get_template_attribute
from .helpers import make_response as make_response
from .helpers import redirect as redirect
from .helpers import send_file as send_file
from .helpers import send_from_directory as send_from_directory
from .helpers import stream_with_context as stream_with_context
from .helpers import url_for as url_for
from .json import jsonify as jsonify
from .signals import appcontext_popped as appcontext_popped
from .signals import appcontext_pushed as appcontext_pushed
from .signals import appcontext_tearing_down as appcontext_tearing_down
from .signals import before_render_template as before_render_template
from .signals import got_request_exception as got_request_exception
from .signals import message_flashed as message_flashed
from .signals import request_finished as request_finished
from .signals import request_started as request_started
from .signals import request_tearing_down as request_tearing_down
from .signals import template_rendered as template_rendered
from .templating import render_template as render_template
from .templating import render_template_string as render_template_string
from .templating import stream_template as stream_template
from .templating import stream_template_string as stream_template_string
from .wrappers import Request as Request
...(truncado)

===== ./venv/lib/python3.13/site-packages/flask/blueprints.py =====
from __future__ import annotations
import os
import typing as t
from datetime import timedelta
from .cli import AppGroup
from .globals import current_app
from .helpers import send_from_directory
from .sansio.blueprints import Blueprint as SansioBlueprint
from .sansio.blueprints import BlueprintSetupState as BlueprintSetupState  # noqa
from .sansio.scaffold import _sentinel
if t.TYPE_CHECKING:  # pragma: no cover
    from .wrappers import Response
class Blueprint(SansioBlueprint):
    def __init__(
        self,
        name: str,
        import_name: str,
        static_folder: str | os.PathLike[str] | None = None,
        static_url_path: str | None = None,
        template_folder: str | os.PathLike[str] | None = None,
        url_prefix: str | None = None,
        subdomain: str | None = None,
        url_defaults: dict[str, t.Any] | None = None,
        root_path: str | None = None,
        cli_group: str | None = _sentinel,  # type: ignore
    ) -> None:
        super().__init__(
            name,
            import_name,
            static_folder,
            static_url_path,
            template_folder,
            url_prefix,
            subdomain,
            url_defaults,
            root_path,
            cli_group,
        )
        #: The Click command group for registering CLI commands for this
        #: object. The commands are available from the ``flask`` command
...(truncado)

===== ./venv/lib/python3.13/site-packages/flask/json/provider.py =====
from __future__ import annotations
import dataclasses
import decimal
import json
import typing as t
import uuid
import weakref
from datetime import date
from werkzeug.http import http_date
if t.TYPE_CHECKING:  # pragma: no cover
    from werkzeug.sansio.response import Response
    from ..sansio.app import App
class JSONProvider:
    """A standard set of JSON operations for an application. Subclasses
    of this can be used to customize JSON behavior or use different
    JSON libraries.
    To implement a provider for a specific library, subclass this base
    class and implement at least :meth:`dumps` and :meth:`loads`. All
    other methods have default implementations.
    To use a different provider, either subclass ``Flask`` and set
    :attr:`~flask.Flask.json_provider_class` to a provider class, or set
    :attr:`app.json <flask.Flask.json>` to an instance of the class.
    :param app: An application instance. This will be stored as a
        :class:`weakref.proxy` on the :attr:`_app` attribute.
    .. versionadded:: 2.2
    """
    def __init__(self, app: App) -> None:
        self._app: App = weakref.proxy(app)
    def dumps(self, obj: t.Any, **kwargs: t.Any) -> str:
        """Serialize data as JSON.
        :param obj: The data to serialize.
        :param kwargs: May be passed to the underlying JSON library.
        """
        raise NotImplementedError
    def dump(self, obj: t.Any, fp: t.IO[str], **kwargs: t.Any) -> None:
        """Serialize data as JSON and write to a file.
        :param obj: The data to serialize.
        :param fp: A file opened for writing text. Should use the UTF-8
            encoding to be valid JSON.
        :param kwargs: May be passed to the underlying JSON library.
...(truncado)

===== ./venv/lib/python3.13/site-packages/flask/json/__init__.py =====
from __future__ import annotations
import json as _json
import typing as t
from ..globals import current_app
from .provider import _default
if t.TYPE_CHECKING:  # pragma: no cover
    from ..wrappers import Response
def dumps(obj: t.Any, **kwargs: t.Any) -> str:
    """Serialize data as JSON.
    If :data:`~flask.current_app` is available, it will use its
    :meth:`app.json.dumps() <flask.json.provider.JSONProvider.dumps>`
    method, otherwise it will use :func:`json.dumps`.
    :param obj: The data to serialize.
    :param kwargs: Arguments passed to the ``dumps`` implementation.
    .. versionchanged:: 2.3
        The ``app`` parameter was removed.
    .. versionchanged:: 2.2
        Calls ``current_app.json.dumps``, allowing an app to override
        the behavior.
    .. versionchanged:: 2.0.2
        :class:`decimal.Decimal` is supported by converting to a string.
    .. versionchanged:: 2.0
        ``encoding`` will be removed in Flask 2.1.
    .. versionchanged:: 1.0.3
        ``app`` can be passed directly, rather than requiring an app
        context for configuration.
    """
    if current_app:
        return current_app.json.dumps(obj, **kwargs)
    kwargs.setdefault("default", _default)
    return _json.dumps(obj, **kwargs)
def dump(obj: t.Any, fp: t.IO[str], **kwargs: t.Any) -> None:
    """Serialize data as JSON and write to a file.
    If :data:`~flask.current_app` is available, it will use its
    :meth:`app.json.dump() <flask.json.provider.JSONProvider.dump>`
    method, otherwise it will use :func:`json.dump`.
    :param obj: The data to serialize.
    :param fp: A file opened for writing text. Should use the UTF-8
        encoding to be valid JSON.
    :param kwargs: Arguments passed to the ``dump`` implementation.
...(truncado)

===== ./venv/lib/python3.13/site-packages/flask/json/tag.py =====
"""
Tagged JSON
~~~~~~~~~~~
A compact representation for lossless serialization of non-standard JSON
types. :class:`~flask.sessions.SecureCookieSessionInterface` uses this
to serialize the session data, but it may be useful in other places. It
can be extended to support other types.
.. autoclass:: TaggedJSONSerializer
    :members:
.. autoclass:: JSONTag
    :members:
Let's see an example that adds support for
:class:`~collections.OrderedDict`. Dicts don't have an order in JSON, so
to handle this we will dump the items as a list of ``[key, value]``
pairs. Subclass :class:`JSONTag` and give it the new key ``' od'`` to
identify the type. The session serializer processes dicts first, so
insert the new tag at the front of the order since ``OrderedDict`` must
be processed before ``dict``.
.. code-block:: python
    from flask.json.tag import JSONTag
    class TagOrderedDict(JSONTag):
        __slots__ = ('serializer',)
        key = ' od'
        def check(self, value):
            return isinstance(value, OrderedDict)
        def to_json(self, value):
            return [[k, self.serializer.tag(v)] for k, v in iteritems(value)]
        def to_python(self, value):
            return OrderedDict(value)
    app.session_interface.serializer.register(TagOrderedDict, index=0)
"""
from __future__ import annotations
import typing as t
from base64 import b64decode
from base64 import b64encode
from datetime import datetime
from uuid import UUID
from markupsafe import Markup
from werkzeug.http import http_date
from werkzeug.http import parse_date
...(truncado)

===== ./venv/lib/python3.13/site-packages/flask/cli.py =====
from __future__ import annotations
import ast
import collections.abc as cabc
import importlib.metadata
import inspect
import os
import platform
import re
import sys
import traceback
import typing as t
from functools import update_wrapper
from operator import itemgetter
from types import ModuleType
import click
from click.core import ParameterSource
from werkzeug import run_simple
from werkzeug.serving import is_running_from_reloader
from werkzeug.utils import import_string
from .globals import current_app
from .helpers import get_debug_flag
from .helpers import get_load_dotenv
if t.TYPE_CHECKING:
    import ssl
    from _typeshed.wsgi import StartResponse
    from _typeshed.wsgi import WSGIApplication
    from _typeshed.wsgi import WSGIEnvironment
    from .app import Flask
class NoAppException(click.UsageError):
    """Raised if an application cannot be found or loaded."""
def find_best_app(module: ModuleType) -> Flask:
    """Given a module instance this tries to find the best possible
    application in the module or raises an exception.
    """
    from . import Flask
    # Search for the most common names first.
    for attr_name in ("app", "application"):
        app = getattr(module, attr_name, None)
        if isinstance(app, Flask):
            return app
...(truncado)

===== ./venv/lib/python3.13/site-packages/flask/wrappers.py =====
from __future__ import annotations
import typing as t
from werkzeug.exceptions import BadRequest
from werkzeug.exceptions import HTTPException
from werkzeug.wrappers import Request as RequestBase
from werkzeug.wrappers import Response as ResponseBase
from . import json
from .globals import current_app
from .helpers import _split_blueprint_path
if t.TYPE_CHECKING:  # pragma: no cover
    from werkzeug.routing import Rule
class Request(RequestBase):
    """The request object used by default in Flask.  Remembers the
    matched endpoint and view arguments.
    It is what ends up as :class:`~flask.request`.  If you want to replace
    the request object used you can subclass this and set
    :attr:`~flask.Flask.request_class` to your subclass.
    The request object is a :class:`~werkzeug.wrappers.Request` subclass and
    provides all of the attributes Werkzeug defines plus a few Flask
    specific ones.
    """
    json_module: t.Any = json
    #: The internal URL rule that matched the request.  This can be
    #: useful to inspect which methods are allowed for the URL from
    #: a before/after handler (``request.url_rule.methods``) etc.
    #: Though if the request's method was invalid for the URL rule,
    #: the valid list is available in ``routing_exception.valid_methods``
    #: instead (an attribute of the Werkzeug exception
    #: :exc:`~werkzeug.exceptions.MethodNotAllowed`)
    #: because the request was never internally bound.
    #:
    #: .. versionadded:: 0.6
    url_rule: Rule | None = None
    #: A dict of view arguments that matched the request.  If an exception
    #: happened when matching, this will be ``None``.
    view_args: dict[str, t.Any] | None = None
    #: If matching the URL failed, this is the exception that will be
    #: raised / was raised as part of the request handling.  This is
    #: usually a :exc:`~werkzeug.exceptions.NotFound` exception or
    #: something similar.
...(truncado)

===== ./venv/lib/python3.13/site-packages/flask/app.py =====
from __future__ import annotations
import collections.abc as cabc
import os
import sys
import typing as t
import weakref
from datetime import timedelta
from inspect import iscoroutinefunction
from itertools import chain
from types import TracebackType
from urllib.parse import quote as _url_quote
import click
from werkzeug.datastructures import Headers
from werkzeug.datastructures import ImmutableDict
from werkzeug.exceptions import BadRequestKeyError
from werkzeug.exceptions import HTTPException
from werkzeug.exceptions import InternalServerError
from werkzeug.routing import BuildError
from werkzeug.routing import MapAdapter
from werkzeug.routing import RequestRedirect
from werkzeug.routing import RoutingException
from werkzeug.routing import Rule
from werkzeug.serving import is_running_from_reloader
from werkzeug.wrappers import Response as BaseResponse
from werkzeug.wsgi import get_host
from . import cli
from . import typing as ft
from .ctx import AppContext
from .ctx import RequestContext
from .globals import _cv_app
from .globals import _cv_request
from .globals import current_app
from .globals import g
from .globals import request
from .globals import request_ctx
from .globals import session
from .helpers import get_debug_flag
from .helpers import get_flashed_messages
from .helpers import get_load_dotenv
from .helpers import send_from_directory
...(truncado)

===== ./venv/lib/python3.13/site-packages/flask/debughelpers.py =====
from __future__ import annotations
import typing as t
from jinja2.loaders import BaseLoader
from werkzeug.routing import RequestRedirect
from .blueprints import Blueprint
from .globals import request_ctx
from .sansio.app import App
if t.TYPE_CHECKING:
    from .sansio.scaffold import Scaffold
    from .wrappers import Request
class UnexpectedUnicodeError(AssertionError, UnicodeError):
    """Raised in places where we want some better error reporting for
    unexpected unicode or binary data.
    """
class DebugFilesKeyError(KeyError, AssertionError):
    """Raised from request.files during debugging.  The idea is that it can
    provide a better error message than just a generic KeyError/BadRequest.
    """
    def __init__(self, request: Request, key: str) -> None:
        form_matches = request.form.getlist(key)
        buf = [
            f"You tried to access the file {key!r} in the request.files"
            " dictionary but it does not exist. The mimetype for the"
            f" request is {request.mimetype!r} instead of"
            " 'multipart/form-data' which means that no file contents"
            " were transmitted. To fix this error you should provide"
            ' enctype="multipart/form-data" in your form.'
        ]
        if form_matches:
            names = ", ".join(repr(x) for x in form_matches)
            buf.append(
                "\n\nThe browser instead transmitted some file names. "
                f"This was submitted: {names}"
            )
        self.msg = "".join(buf)
    def __str__(self) -> str:
        return self.msg
class FormDataRoutingRedirect(AssertionError):
    """This exception is raised in debug mode if a routing redirect
    would cause the browser to drop the method or body. This happens
...(truncado)

===== ./venv/lib/python3.13/site-packages/flask/ctx.py =====
from __future__ import annotations
import contextvars
import sys
import typing as t
from functools import update_wrapper
from types import TracebackType
from werkzeug.exceptions import HTTPException
from . import typing as ft
from .globals import _cv_app
from .globals import _cv_request
from .signals import appcontext_popped
from .signals import appcontext_pushed
if t.TYPE_CHECKING:  # pragma: no cover
    from _typeshed.wsgi import WSGIEnvironment
    from .app import Flask
    from .sessions import SessionMixin
    from .wrappers import Request
_sentinel = object()
class _AppCtxGlobals:
    """A plain object. Used as a namespace for storing data during an
    application context.
    Creating an app context automatically creates this object, which is
    made available as the :data:`g` proxy.
    .. describe:: 'key' in g
        Check whether an attribute is present.
        .. versionadded:: 0.10
    .. describe:: iter(g)
        Return an iterator over the attribute names.
        .. versionadded:: 0.10
    """
    # Define attr methods to let mypy know this is a namespace object
    # that has arbitrary attributes.
    def __getattr__(self, name: str) -> t.Any:
        try:
            return self.__dict__[name]
        except KeyError:
            raise AttributeError(name) from None
    def __setattr__(self, name: str, value: t.Any) -> None:
        self.__dict__[name] = value
    def __delattr__(self, name: str) -> None:
...(truncado)

===== ./venv/lib/python3.13/site-packages/flask/typing.py =====
from __future__ import annotations
import collections.abc as cabc
import typing as t
if t.TYPE_CHECKING:  # pragma: no cover
    from _typeshed.wsgi import WSGIApplication  # noqa: F401
    from werkzeug.datastructures import Headers  # noqa: F401
    from werkzeug.sansio.response import Response  # noqa: F401
ResponseValue = t.Union[
    "Response",
    str,
    bytes,
    list[t.Any],
    # Only dict is actually accepted, but Mapping allows for TypedDict.
    t.Mapping[str, t.Any],
    t.Iterator[str],
    t.Iterator[bytes],
    cabc.AsyncIterable[str],  # for Quart, until App is generic.
    cabc.AsyncIterable[bytes],
]
HeaderValue = t.Union[str, list[str], tuple[str, ...]]
HeadersValue = t.Union[
    "Headers",
    t.Mapping[str, HeaderValue],
    t.Sequence[tuple[str, HeaderValue]],
]
ResponseReturnValue = t.Union[
    ResponseValue,
    tuple[ResponseValue, HeadersValue],
    tuple[ResponseValue, int],
    tuple[ResponseValue, int, HeadersValue],
    "WSGIApplication",
]
ResponseClass = t.TypeVar("ResponseClass", bound="Response")
AppOrBlueprintKey = t.Optional[str]  # The App key is None, whereas blueprints are named
AfterRequestCallable = t.Union[
    t.Callable[[ResponseClass], ResponseClass],
    t.Callable[[ResponseClass], t.Awaitable[ResponseClass]],
]
BeforeFirstRequestCallable = t.Union[
    t.Callable[[], None], t.Callable[[], t.Awaitable[None]]
...(truncado)

===== ./venv/lib/python3.13/site-packages/flask/testing.py =====
from __future__ import annotations
import importlib.metadata
import typing as t
from contextlib import contextmanager
from contextlib import ExitStack
from copy import copy
from types import TracebackType
from urllib.parse import urlsplit
import werkzeug.test
from click.testing import CliRunner
from click.testing import Result
from werkzeug.test import Client
from werkzeug.wrappers import Request as BaseRequest
from .cli import ScriptInfo
from .sessions import SessionMixin
if t.TYPE_CHECKING:  # pragma: no cover
    from _typeshed.wsgi import WSGIEnvironment
    from werkzeug.test import TestResponse
    from .app import Flask
class EnvironBuilder(werkzeug.test.EnvironBuilder):
    """An :class:`~werkzeug.test.EnvironBuilder`, that takes defaults from the
    application.
    :param app: The Flask application to configure the environment from.
    :param path: URL path being requested.
    :param base_url: Base URL where the app is being served, which
        ``path`` is relative to. If not given, built from
        :data:`PREFERRED_URL_SCHEME`, ``subdomain``,
        :data:`SERVER_NAME`, and :data:`APPLICATION_ROOT`.
    :param subdomain: Subdomain name to append to :data:`SERVER_NAME`.
    :param url_scheme: Scheme to use instead of
        :data:`PREFERRED_URL_SCHEME`.
    :param json: If given, this is serialized as JSON and passed as
        ``data``. Also defaults ``content_type`` to
        ``application/json``.
    :param args: other positional arguments passed to
        :class:`~werkzeug.test.EnvironBuilder`.
    :param kwargs: other keyword arguments passed to
        :class:`~werkzeug.test.EnvironBuilder`.
    """
    def __init__(
...(truncado)

===== ./venv/lib/python3.13/site-packages/flask/helpers.py =====
from __future__ import annotations
import importlib.util
import os
import sys
import typing as t
from datetime import datetime
from functools import cache
from functools import update_wrapper
import werkzeug.utils
from werkzeug.exceptions import abort as _wz_abort
from werkzeug.utils import redirect as _wz_redirect
from werkzeug.wrappers import Response as BaseResponse
from .globals import _cv_app
from .globals import _cv_request
from .globals import current_app
from .globals import request
from .globals import request_ctx
from .globals import session
from .signals import message_flashed
if t.TYPE_CHECKING:  # pragma: no cover
    from .wrappers import Response
def get_debug_flag() -> bool:
    """Get whether debug mode should be enabled for the app, indicated by the
    :envvar:`FLASK_DEBUG` environment variable. The default is ``False``.
    """
    val = os.environ.get("FLASK_DEBUG")
    return bool(val and val.lower() not in {"0", "false", "no"})
def get_load_dotenv(default: bool = True) -> bool:
    """Get whether the user has disabled loading default dotenv files by
    setting :envvar:`FLASK_SKIP_DOTENV`. The default is ``True``, load
    the files.
    :param default: What to return if the env var isn't set.
    """
    val = os.environ.get("FLASK_SKIP_DOTENV")
    if not val:
        return default
    return val.lower() in ("0", "false", "no")
@t.overload
def stream_with_context(
    generator_or_function: t.Iterator[t.AnyStr],
...(truncado)

===== ./venv/lib/python3.13/site-packages/flask/__main__.py =====
from .cli import main
main()
...(truncado)

===== ./venv/lib/python3.13/site-packages/flask/views.py =====
from __future__ import annotations
import typing as t
from . import typing as ft
from .globals import current_app
from .globals import request
F = t.TypeVar("F", bound=t.Callable[..., t.Any])
http_method_funcs = frozenset(
    ["get", "post", "head", "options", "delete", "put", "trace", "patch"]
)
class View:
    """Subclass this class and override :meth:`dispatch_request` to
    create a generic class-based view. Call :meth:`as_view` to create a
    view function that creates an instance of the class with the given
    arguments and calls its ``dispatch_request`` method with any URL
    variables.
    See :doc:`views` for a detailed guide.
    .. code-block:: python
        class Hello(View):
            init_every_request = False
            def dispatch_request(self, name):
                return f"Hello, {name}!"
        app.add_url_rule(
            "/hello/<name>", view_func=Hello.as_view("hello")
        )
    Set :attr:`methods` on the class to change what methods the view
    accepts.
    Set :attr:`decorators` on the class to apply a list of decorators to
    the generated view function. Decorators applied to the class itself
    will not be applied to the generated view function!
    Set :attr:`init_every_request` to ``False`` for efficiency, unless
    you need to store request-global data on ``self``.
    """
    #: The methods this view is registered for. Uses the same default
    #: (``["GET", "HEAD", "OPTIONS"]``) as ``route`` and
    #: ``add_url_rule`` by default.
    methods: t.ClassVar[t.Collection[str] | None] = None
    #: Control whether the ``OPTIONS`` method is handled automatically.
    #: Uses the same default (``True``) as ``route`` and
    #: ``add_url_rule`` by default.
    provide_automatic_options: t.ClassVar[bool | None] = None
...(truncado)

===== ./venv/lib/python3.13/site-packages/packaging/tags.py =====
from __future__ import annotations
import logging
import platform
import re
import struct
import subprocess
import sys
import sysconfig
from importlib.machinery import EXTENSION_SUFFIXES
from typing import (
    Iterable,
    Iterator,
    Sequence,
    Tuple,
    cast,
)
from . import _manylinux, _musllinux
logger = logging.getLogger(__name__)
PythonVersion = Sequence[int]
AppleVersion = Tuple[int, int]
INTERPRETER_SHORT_NAMES: dict[str, str] = {
    "python": "py",  # Generic.
    "cpython": "cp",
    "pypy": "pp",
    "ironpython": "ip",
    "jython": "jy",
}
_32_BIT_INTERPRETER = struct.calcsize("P") == 4
class Tag:
    """
    A representation of the tag triple for a wheel.
    Instances are considered immutable and thus are hashable. Equality checking
    is also supported.
    """
    __slots__ = ["_abi", "_hash", "_interpreter", "_platform"]
    def __init__(self, interpreter: str, abi: str, platform: str) -> None:
        self._interpreter = interpreter.lower()
        self._abi = abi.lower()
        self._platform = platform.lower()
        # The __hash__ of every single element in a Set[Tag] will be evaluated each time
...(truncado)

===== ./venv/lib/python3.13/site-packages/packaging/_musllinux.py =====
"""PEP 656 support.
This module implements logic to detect if the currently running Python is
linked against musl, and what musl version is used.
"""
from __future__ import annotations
import functools
import re
import subprocess
import sys
from typing import Iterator, NamedTuple, Sequence
from ._elffile import ELFFile
class _MuslVersion(NamedTuple):
    major: int
    minor: int
def _parse_musl_version(output: str) -> _MuslVersion | None:
    lines = [n for n in (n.strip() for n in output.splitlines()) if n]
    if len(lines) < 2 or lines[0][:4] != "musl":
        return None
    m = re.match(r"Version (\d+)\.(\d+)", lines[1])
    if not m:
        return None
    return _MuslVersion(major=int(m.group(1)), minor=int(m.group(2)))
@functools.lru_cache
def _get_musl_version(executable: str) -> _MuslVersion | None:
    """Detect currently-running musl runtime version.
    This is done by checking the specified executable's dynamic linking
    information, and invoking the loader to parse its output for a version
    string. If the loader is musl, the output would be something like::
        musl libc (x86_64)
        Version 1.2.2
        Dynamic Program Loader
    """
    try:
        with open(executable, "rb") as f:
            ld = ELFFile(f).interpreter
    except (OSError, TypeError, ValueError):
        return None
    if ld is None or "musl" not in ld:
        return None
    proc = subprocess.run([ld], stderr=subprocess.PIPE, text=True)
...(truncado)

===== ./venv/lib/python3.13/site-packages/packaging/metadata.py =====
from __future__ import annotations
import email.feedparser
import email.header
import email.message
import email.parser
import email.policy
import pathlib
import sys
import typing
from typing import (
    Any,
    Callable,
    Generic,
    Literal,
    TypedDict,
    cast,
)
from . import licenses, requirements, specifiers, utils
from . import version as version_module
from .licenses import NormalizedLicenseExpression
T = typing.TypeVar("T")
if sys.version_info >= (3, 11):  # pragma: no cover
    ExceptionGroup = ExceptionGroup
else:  # pragma: no cover
    class ExceptionGroup(Exception):
        """A minimal implementation of :external:exc:`ExceptionGroup` from Python 3.11.
        If :external:exc:`ExceptionGroup` is already defined by Python itself,
        that version is used instead.
        """
        message: str
        exceptions: list[Exception]
        def __init__(self, message: str, exceptions: list[Exception]) -> None:
            self.message = message
            self.exceptions = exceptions
        def __repr__(self) -> str:
            return f"{self.__class__.__name__}({self.message!r}, {self.exceptions!r})"
class InvalidMetadata(ValueError):
    """A metadata field contains invalid data."""
    field: str
    """The name of the field that contains invalid data."""
...(truncado)

===== ./venv/lib/python3.13/site-packages/packaging/version.py =====
"""
.. testsetup::
    from packaging.version import parse, Version
"""
from __future__ import annotations
import itertools
import re
from typing import Any, Callable, NamedTuple, SupportsInt, Tuple, Union
from ._structures import Infinity, InfinityType, NegativeInfinity, NegativeInfinityType
__all__ = ["VERSION_PATTERN", "InvalidVersion", "Version", "parse"]
LocalType = Tuple[Union[int, str], ...]
CmpPrePostDevType = Union[InfinityType, NegativeInfinityType, Tuple[str, int]]
CmpLocalType = Union[
    NegativeInfinityType,
    Tuple[Union[Tuple[int, str], Tuple[NegativeInfinityType, Union[int, str]]], ...],
]
CmpKey = Tuple[
    int,
    Tuple[int, ...],
    CmpPrePostDevType,
    CmpPrePostDevType,
    CmpPrePostDevType,
    CmpLocalType,
]
VersionComparisonMethod = Callable[[CmpKey, CmpKey], bool]
class _Version(NamedTuple):
    epoch: int
    release: tuple[int, ...]
    dev: tuple[str, int] | None
    pre: tuple[str, int] | None
    post: tuple[str, int] | None
    local: LocalType | None
def parse(version: str) -> Version:
    """Parse the given version string.
    >>> parse('1.0.dev1')
    <Version('1.0.dev1')>
    :param version: The version string to parse.
    :raises InvalidVersion: When the version string is not a valid version.
    """
    return Version(version)
...(truncado)

===== ./venv/lib/python3.13/site-packages/packaging/licenses/__init__.py =====
from __future__ import annotations
import re
from typing import NewType, cast
from packaging.licenses._spdx import EXCEPTIONS, LICENSES
__all__ = [
    "InvalidLicenseExpression",
    "NormalizedLicenseExpression",
    "canonicalize_license_expression",
]
license_ref_allowed = re.compile("^[A-Za-z0-9.-]*$")
NormalizedLicenseExpression = NewType("NormalizedLicenseExpression", str)
class InvalidLicenseExpression(ValueError):
    """Raised when a license-expression string is invalid
    >>> canonicalize_license_expression("invalid")
    Traceback (most recent call last):
        ...
    packaging.licenses.InvalidLicenseExpression: Invalid license expression: 'invalid'
    """
def canonicalize_license_expression(
    raw_license_expression: str,
) -> NormalizedLicenseExpression:
    if not raw_license_expression:
        message = f"Invalid license expression: {raw_license_expression!r}"
        raise InvalidLicenseExpression(message)
    # Pad any parentheses so tokenization can be achieved by merely splitting on
    # whitespace.
    license_expression = raw_license_expression.replace("(", " ( ").replace(")", " ) ")
    licenseref_prefix = "LicenseRef-"
    license_refs = {
        ref.lower(): "LicenseRef-" + ref[len(licenseref_prefix) :]
        for ref in license_expression.split()
        if ref.lower().startswith(licenseref_prefix.lower())
    }
    # Normalize to lower case so we can look up licenses/exceptions
    # and so boolean operators are Python-compatible.
    license_expression = license_expression.lower()
    tokens = license_expression.split()
    # Rather than implementing boolean logic, we create an expression that Python can
    # parse. Everything that is not involved with the grammar itself is treated as
    # `False` and the expression should evaluate as such.
...(truncado)

===== ./venv/lib/python3.13/site-packages/packaging/licenses/_spdx.py =====
from __future__ import annotations
from typing import TypedDict
class SPDXLicense(TypedDict):
    id: str
    deprecated: bool
class SPDXException(TypedDict):
    id: str
    deprecated: bool
VERSION = '3.25.0'
LICENSES: dict[str, SPDXLicense] = {
    '0bsd': {'id': '0BSD', 'deprecated': False},
    '3d-slicer-1.0': {'id': '3D-Slicer-1.0', 'deprecated': False},
    'aal': {'id': 'AAL', 'deprecated': False},
    'abstyles': {'id': 'Abstyles', 'deprecated': False},
    'adacore-doc': {'id': 'AdaCore-doc', 'deprecated': False},
    'adobe-2006': {'id': 'Adobe-2006', 'deprecated': False},
    'adobe-display-postscript': {'id': 'Adobe-Display-PostScript', 'deprecated': False},
    'adobe-glyph': {'id': 'Adobe-Glyph', 'deprecated': False},
    'adobe-utopia': {'id': 'Adobe-Utopia', 'deprecated': False},
    'adsl': {'id': 'ADSL', 'deprecated': False},
    'afl-1.1': {'id': 'AFL-1.1', 'deprecated': False},
    'afl-1.2': {'id': 'AFL-1.2', 'deprecated': False},
    'afl-2.0': {'id': 'AFL-2.0', 'deprecated': False},
    'afl-2.1': {'id': 'AFL-2.1', 'deprecated': False},
    'afl-3.0': {'id': 'AFL-3.0', 'deprecated': False},
    'afmparse': {'id': 'Afmparse', 'deprecated': False},
    'agpl-1.0': {'id': 'AGPL-1.0', 'deprecated': True},
    'agpl-1.0-only': {'id': 'AGPL-1.0-only', 'deprecated': False},
    'agpl-1.0-or-later': {'id': 'AGPL-1.0-or-later', 'deprecated': False},
    'agpl-3.0': {'id': 'AGPL-3.0', 'deprecated': True},
    'agpl-3.0-only': {'id': 'AGPL-3.0-only', 'deprecated': False},
    'agpl-3.0-or-later': {'id': 'AGPL-3.0-or-later', 'deprecated': False},
    'aladdin': {'id': 'Aladdin', 'deprecated': False},
    'amd-newlib': {'id': 'AMD-newlib', 'deprecated': False},
    'amdplpa': {'id': 'AMDPLPA', 'deprecated': False},
    'aml': {'id': 'AML', 'deprecated': False},
    'aml-glslang': {'id': 'AML-glslang', 'deprecated': False},
    'ampas': {'id': 'AMPAS', 'deprecated': False},
    'antlr-pd': {'id': 'ANTLR-PD', 'deprecated': False},
    'antlr-pd-fallback': {'id': 'ANTLR-PD-fallback', 'deprecated': False},
...(truncado)

===== ./venv/lib/python3.13/site-packages/packaging/__init__.py =====
__title__ = "packaging"
__summary__ = "Core utilities for Python packages"
__uri__ = "https://github.com/pypa/packaging"
__version__ = "25.0"
__author__ = "Donald Stufft and individual contributors"
__email__ = "donald@stufft.io"
__license__ = "BSD-2-Clause or Apache-2.0"
__copyright__ = f"2014 {__author__}"
...(truncado)

===== ./venv/lib/python3.13/site-packages/packaging/_parser.py =====
"""Handwritten parser of dependency specifiers.
The docstring for each __parse_* function contains EBNF-inspired grammar representing
the implementation.
"""
from __future__ import annotations
import ast
from typing import NamedTuple, Sequence, Tuple, Union
from ._tokenizer import DEFAULT_RULES, Tokenizer
class Node:
    def __init__(self, value: str) -> None:
        self.value = value
    def __str__(self) -> str:
        return self.value
    def __repr__(self) -> str:
        return f"<{self.__class__.__name__}('{self}')>"
    def serialize(self) -> str:
        raise NotImplementedError
class Variable(Node):
    def serialize(self) -> str:
        return str(self)
class Value(Node):
    def serialize(self) -> str:
        return f'"{self}"'
class Op(Node):
    def serialize(self) -> str:
        return str(self)
MarkerVar = Union[Variable, Value]
MarkerItem = Tuple[MarkerVar, Op, MarkerVar]
MarkerAtom = Union[MarkerItem, Sequence["MarkerAtom"]]
MarkerList = Sequence[Union["MarkerList", MarkerAtom, str]]
class ParsedRequirement(NamedTuple):
    name: str
    url: str
    extras: list[str]
    specifier: str
    marker: MarkerList | None
def parse_requirement(source: str) -> ParsedRequirement:
    return _parse_requirement(Tokenizer(source, rules=DEFAULT_RULES))
def _parse_requirement(tokenizer: Tokenizer) -> ParsedRequirement:
    """
...(truncado)

===== ./venv/lib/python3.13/site-packages/packaging/utils.py =====
from __future__ import annotations
import functools
import re
from typing import NewType, Tuple, Union, cast
from .tags import Tag, parse_tag
from .version import InvalidVersion, Version, _TrimmedRelease
BuildTag = Union[Tuple[()], Tuple[int, str]]
NormalizedName = NewType("NormalizedName", str)
class InvalidName(ValueError):
    """
    An invalid distribution name; users should refer to the packaging user guide.
    """
class InvalidWheelFilename(ValueError):
    """
    An invalid wheel filename was found, users should refer to PEP 427.
    """
class InvalidSdistFilename(ValueError):
    """
    An invalid sdist filename was found, users should refer to the packaging user guide.
    """
_validate_regex = re.compile(
    r"^([A-Z0-9]|[A-Z0-9][A-Z0-9._-]*[A-Z0-9])$", re.IGNORECASE
)
_canonicalize_regex = re.compile(r"[-_.]+")
_normalized_regex = re.compile(r"^([a-z0-9]|[a-z0-9]([a-z0-9-](?!--))*[a-z0-9])$")
_build_tag_regex = re.compile(r"(\d+)(.*)")
def canonicalize_name(name: str, *, validate: bool = False) -> NormalizedName:
    if validate and not _validate_regex.match(name):
        raise InvalidName(f"name is invalid: {name!r}")
    # This is taken from PEP 503.
    value = _canonicalize_regex.sub("-", name).lower()
    return cast(NormalizedName, value)
def is_normalized_name(name: str) -> bool:
    return _normalized_regex.match(name) is not None
@functools.singledispatch
def canonicalize_version(
    version: Version | str, *, strip_trailing_zero: bool = True
) -> str:
    """
    Return a canonical form of a version as a string.
...(truncado)

===== ./venv/lib/python3.13/site-packages/packaging/requirements.py =====
from __future__ import annotations
from typing import Any, Iterator
from ._parser import parse_requirement as _parse_requirement
from ._tokenizer import ParserSyntaxError
from .markers import Marker, _normalize_extra_values
from .specifiers import SpecifierSet
from .utils import canonicalize_name
class InvalidRequirement(ValueError):
    """
    An invalid requirement was found, users should refer to PEP 508.
    """
class Requirement:
    """Parse a requirement.
    Parse a given requirement string into its parts, such as name, specifier,
    URL, and extras. Raises InvalidRequirement on a badly-formed requirement
    string.
    """
    # TODO: Can we test whether something is contained within a requirement?
    #       If so how do we do that? Do we need to test against the _name_ of
    #       the thing as well as the version? What about the markers?
    # TODO: Can we normalize the name and extra name?
    def __init__(self, requirement_string: str) -> None:
        try:
            parsed = _parse_requirement(requirement_string)
        except ParserSyntaxError as e:
            raise InvalidRequirement(str(e)) from e
        self.name: str = parsed.name
        self.url: str | None = parsed.url or None
        self.extras: set[str] = set(parsed.extras or [])
        self.specifier: SpecifierSet = SpecifierSet(parsed.specifier)
        self.marker: Marker | None = None
        if parsed.marker is not None:
            self.marker = Marker.__new__(Marker)
            self.marker._markers = _normalize_extra_values(parsed.marker)
    def _iter_parts(self, name: str) -> Iterator[str]:
        yield name
        if self.extras:
            formatted_extras = ",".join(sorted(self.extras))
            yield f"[{formatted_extras}]"
        if self.specifier:
...(truncado)

===== ./venv/lib/python3.13/site-packages/packaging/_structures.py =====
class InfinityType:
    def __repr__(self) -> str:
        return "Infinity"
    def __hash__(self) -> int:
        return hash(repr(self))
    def __lt__(self, other: object) -> bool:
        return False
    def __le__(self, other: object) -> bool:
        return False
    def __eq__(self, other: object) -> bool:
        return isinstance(other, self.__class__)
    def __gt__(self, other: object) -> bool:
        return True
    def __ge__(self, other: object) -> bool:
        return True
    def __neg__(self: object) -> "NegativeInfinityType":
        return NegativeInfinity
Infinity = InfinityType()
class NegativeInfinityType:
    def __repr__(self) -> str:
        return "-Infinity"
    def __hash__(self) -> int:
        return hash(repr(self))
    def __lt__(self, other: object) -> bool:
        return True
    def __le__(self, other: object) -> bool:
        return True
    def __eq__(self, other: object) -> bool:
        return isinstance(other, self.__class__)
    def __gt__(self, other: object) -> bool:
        return False
    def __ge__(self, other: object) -> bool:
        return False
    def __neg__(self: object) -> InfinityType:
        return Infinity
NegativeInfinity = NegativeInfinityType()
...(truncado)

===== ./venv/lib/python3.13/site-packages/packaging/markers.py =====
from __future__ import annotations
import operator
import os
import platform
import sys
from typing import AbstractSet, Any, Callable, Literal, TypedDict, Union, cast
from ._parser import MarkerAtom, MarkerList, Op, Value, Variable
from ._parser import parse_marker as _parse_marker
from ._tokenizer import ParserSyntaxError
from .specifiers import InvalidSpecifier, Specifier
from .utils import canonicalize_name
__all__ = [
    "EvaluateContext",
    "InvalidMarker",
    "Marker",
    "UndefinedComparison",
    "UndefinedEnvironmentName",
    "default_environment",
]
Operator = Callable[[str, Union[str, AbstractSet[str]]], bool]
EvaluateContext = Literal["metadata", "lock_file", "requirement"]
MARKERS_ALLOWING_SET = {"extras", "dependency_groups"}
class InvalidMarker(ValueError):
    """
    An invalid marker was found, users should refer to PEP 508.
    """
class UndefinedComparison(ValueError):
    """
    An invalid operation was attempted on a value that doesn't support it.
    """
class UndefinedEnvironmentName(ValueError):
    """
    A name was attempted to be used that does not exist inside of the
    environment.
    """
class Environment(TypedDict):
    implementation_name: str
    """The implementation's identifier, e.g. ``'cpython'``."""
    implementation_version: str
    """
...(truncado)

===== ./venv/lib/python3.13/site-packages/packaging/_manylinux.py =====
from __future__ import annotations
import collections
import contextlib
import functools
import os
import re
import sys
import warnings
from typing import Generator, Iterator, NamedTuple, Sequence
from ._elffile import EIClass, EIData, ELFFile, EMachine
EF_ARM_ABIMASK = 0xFF000000
EF_ARM_ABI_VER5 = 0x05000000
EF_ARM_ABI_FLOAT_HARD = 0x00000400
@contextlib.contextmanager
def _parse_elf(path: str) -> Generator[ELFFile | None, None, None]:
    try:
        with open(path, "rb") as f:
            yield ELFFile(f)
    except (OSError, TypeError, ValueError):
        yield None
def _is_linux_armhf(executable: str) -> bool:
    # hard-float ABI can be detected from the ELF header of the running
    # process
    # https://static.docs.arm.com/ihi0044/g/aaelf32.pdf
    with _parse_elf(executable) as f:
        return (
            f is not None
            and f.capacity == EIClass.C32
            and f.encoding == EIData.Lsb
            and f.machine == EMachine.Arm
            and f.flags & EF_ARM_ABIMASK == EF_ARM_ABI_VER5
            and f.flags & EF_ARM_ABI_FLOAT_HARD == EF_ARM_ABI_FLOAT_HARD
        )
def _is_linux_i686(executable: str) -> bool:
    with _parse_elf(executable) as f:
        return (
            f is not None
            and f.capacity == EIClass.C32
            and f.encoding == EIData.Lsb
            and f.machine == EMachine.I386
...(truncado)

===== ./venv/lib/python3.13/site-packages/packaging/_tokenizer.py =====
from __future__ import annotations
import contextlib
import re
from dataclasses import dataclass
from typing import Iterator, NoReturn
from .specifiers import Specifier
@dataclass
class Token:
    name: str
    text: str
    position: int
class ParserSyntaxError(Exception):
    """The provided source text could not be parsed correctly."""
    def __init__(
        self,
        message: str,
        *,
        source: str,
        span: tuple[int, int],
    ) -> None:
        self.span = span
        self.message = message
        self.source = source
        super().__init__()
    def __str__(self) -> str:
        marker = " " * self.span[0] + "~" * (self.span[1] - self.span[0]) + "^"
        return "\n    ".join([self.message, self.source, marker])
DEFAULT_RULES: dict[str, str | re.Pattern[str]] = {
    "LEFT_PARENTHESIS": r"\(",
    "RIGHT_PARENTHESIS": r"\)",
    "LEFT_BRACKET": r"\[",
    "RIGHT_BRACKET": r"\]",
    "SEMICOLON": r";",
    "COMMA": r",",
    "QUOTED_STRING": re.compile(
        r"""
            (
                ('[^']*')
                |
                ("[^"]*")
...(truncado)

===== ./venv/lib/python3.13/site-packages/packaging/specifiers.py =====
"""
.. testsetup::
    from packaging.specifiers import Specifier, SpecifierSet, InvalidSpecifier
    from packaging.version import Version
"""
from __future__ import annotations
import abc
import itertools
import re
from typing import Callable, Iterable, Iterator, TypeVar, Union
from .utils import canonicalize_version
from .version import Version
UnparsedVersion = Union[Version, str]
UnparsedVersionVar = TypeVar("UnparsedVersionVar", bound=UnparsedVersion)
CallableOperator = Callable[[Version, str], bool]
def _coerce_version(version: UnparsedVersion) -> Version:
    if not isinstance(version, Version):
        version = Version(version)
    return version
class InvalidSpecifier(ValueError):
    """
    Raised when attempting to create a :class:`Specifier` with a specifier
    string that is invalid.
    >>> Specifier("lolwat")
    Traceback (most recent call last):
        ...
    packaging.specifiers.InvalidSpecifier: Invalid specifier: 'lolwat'
    """
class BaseSpecifier(metaclass=abc.ABCMeta):
    @abc.abstractmethod
    def __str__(self) -> str:
        """
        Returns the str representation of this Specifier-like object. This
        should be representative of the Specifier itself.
        """
    @abc.abstractmethod
    def __hash__(self) -> int:
        """
        Returns a hash value for this Specifier-like object.
        """
...(truncado)

===== ./venv/lib/python3.13/site-packages/packaging/_elffile.py =====
"""
ELF file parser.
This provides a class ``ELFFile`` that parses an ELF executable in a similar
interface to ``ZipFile``. Only the read interface is implemented.
Based on: https://gist.github.com/lyssdod/f51579ae8d93c8657a5564aefc2ffbca
ELF header: https://refspecs.linuxfoundation.org/elf/gabi4+/ch4.eheader.html
"""
from __future__ import annotations
import enum
import os
import struct
from typing import IO
class ELFInvalid(ValueError):
    pass
class EIClass(enum.IntEnum):
    C32 = 1
    C64 = 2
class EIData(enum.IntEnum):
    Lsb = 1
    Msb = 2
class EMachine(enum.IntEnum):
    I386 = 3
    S390 = 22
    Arm = 40
    X8664 = 62
    AArc64 = 183
class ELFFile:
    """
    Representation of an ELF executable.
    """
    def __init__(self, f: IO[bytes]) -> None:
        self._f = f
        try:
            ident = self._read("16B")
        except struct.error as e:
            raise ELFInvalid("unable to parse identification") from e
        magic = bytes(ident[:4])
        if magic != b"\x7fELF":
            raise ELFInvalid(f"invalid magic: {magic!r}")
        self.capacity = ident[4]  # Format for program header (bitness).
...(truncado)

===== ./venv/lib/python3.13/site-packages/markupsafe/__init__.py =====
from __future__ import annotations
import collections.abc as cabc
import string
import typing as t
try:
    from ._speedups import _escape_inner
except ImportError:
    from ._native import _escape_inner
if t.TYPE_CHECKING:
    import typing_extensions as te
class _HasHTML(t.Protocol):
    def __html__(self, /) -> str: ...
class _TPEscape(t.Protocol):
    def __call__(self, s: t.Any, /) -> Markup: ...
def escape(s: t.Any, /) -> Markup:
    """Replace the characters ``&``, ``<``, ``>``, ``'``, and ``"`` in
    the string with HTML-safe sequences. Use this if you need to display
    text that might contain such characters in HTML.
    If the object has an ``__html__`` method, it is called and the
    return value is assumed to already be safe for HTML.
    :param s: An object to be converted to a string and escaped.
    :return: A :class:`Markup` string with the escaped text.
    """
    # If the object is already a plain string, skip __html__ check and string
    # conversion. This is the most common use case.
    # Use type(s) instead of s.__class__ because a proxy object may be reporting
    # the __class__ of the proxied value.
    if type(s) is str:
        return Markup(_escape_inner(s))
    if hasattr(s, "__html__"):
        return Markup(s.__html__())
    return Markup(_escape_inner(str(s)))
def escape_silent(s: t.Any | None, /) -> Markup:
    """Like :func:`escape` but treats ``None`` as the empty string.
    Useful with optional values, as otherwise you get the string
    ``'None'`` when the value is ``None``.
    >>> escape(None)
    Markup('None')
    >>> escape_silent(None)
    Markup('')
...(truncado)

===== ./venv/lib/python3.13/site-packages/markupsafe/_native.py =====
def _escape_inner(s: str, /) -> str:
    return (
        s.replace("&", "&amp;")
        .replace(">", "&gt;")
        .replace("<", "&lt;")
        .replace("'", "&#39;")
        .replace('"', "&#34;")
    )
...(truncado)

===== ./venv/lib/python3.13/site-packages/flask_sqlalchemy/record_queries.py =====
from __future__ import annotations
import dataclasses
import inspect
import typing as t
from time import perf_counter
import sqlalchemy as sa
import sqlalchemy.event as sa_event
from flask import current_app
from flask import g
from flask import has_app_context
def get_recorded_queries() -> list[_QueryInfo]:
    """Get the list of recorded query information for the current session. Queries are
    recorded if the config :data:`.SQLALCHEMY_RECORD_QUERIES` is enabled.
    Each query info object has the following attributes:
    ``statement``
        The string of SQL generated by SQLAlchemy with parameter placeholders.
    ``parameters``
        The parameters sent with the SQL statement.
    ``start_time`` / ``end_time``
        Timing info about when the query started execution and when the results where
        returned. Accuracy and value depends on the operating system.
    ``duration``
        The time the query took in seconds.
    ``location``
        A string description of where in your application code the query was executed.
        This may not be possible to calculate, and the format is not stable.
    .. versionchanged:: 3.0
        Renamed from ``get_debug_queries``.
    .. versionchanged:: 3.0
        The info object is a dataclass instead of a tuple.
    .. versionchanged:: 3.0
        The info object attribute ``context`` is renamed to ``location``.
    .. versionchanged:: 3.0
        Not enabled automatically in debug or testing mode.
    """
    return g.get("_sqlalchemy_queries", [])  # type: ignore[no-any-return]
@dataclasses.dataclass
class _QueryInfo:
    """Information about an executed query. Returned by :func:`get_recorded_queries`.
    .. versionchanged:: 3.0
...(truncado)

===== ./venv/lib/python3.13/site-packages/flask_sqlalchemy/track_modifications.py =====
from __future__ import annotations
import typing as t
import sqlalchemy as sa
import sqlalchemy.event as sa_event
import sqlalchemy.orm as sa_orm
from flask import current_app
from flask import has_app_context
from flask.signals import Namespace  # type: ignore[attr-defined]
if t.TYPE_CHECKING:
    from .session import Session
_signals = Namespace()
models_committed = _signals.signal("models-committed")
"""This Blinker signal is sent after the session is committed if there were changed
models in the session.
The sender is the application that emitted the changes. The receiver is passed the
``changes`` argument with a list of tuples in the form ``(instance, operation)``.
The operations are ``"insert"``, ``"update"``, and ``"delete"``.
"""
before_models_committed = _signals.signal("before-models-committed")
"""This signal works exactly like :data:`models_committed` but is emitted before the
commit takes place.
"""
def _listen(session: sa_orm.scoped_session[Session]) -> None:
    sa_event.listen(session, "before_flush", _record_ops, named=True)
    sa_event.listen(session, "before_commit", _record_ops, named=True)
    sa_event.listen(session, "before_commit", _before_commit)
    sa_event.listen(session, "after_commit", _after_commit)
    sa_event.listen(session, "after_rollback", _after_rollback)
def _record_ops(session: Session, **kwargs: t.Any) -> None:
    if not has_app_context():
        return
    if not current_app.config["SQLALCHEMY_TRACK_MODIFICATIONS"]:
        return
    for targets, operation in (
        (session.new, "insert"),
        (session.dirty, "update"),
        (session.deleted, "delete"),
    ):
        for target in targets:
            state = sa.inspect(target)
...(truncado)

===== ./venv/lib/python3.13/site-packages/flask_sqlalchemy/query.py =====
from __future__ import annotations
import typing as t
import sqlalchemy.exc as sa_exc
import sqlalchemy.orm as sa_orm
from flask import abort
from .pagination import Pagination
from .pagination import QueryPagination
class Query(sa_orm.Query):  # type: ignore[type-arg]
    """SQLAlchemy :class:`~sqlalchemy.orm.query.Query` subclass with some extra methods
    useful for querying in a web application.
    This is the default query class for :attr:`.Model.query`.
    .. versionchanged:: 3.0
        Renamed to ``Query`` from ``BaseQuery``.
    """
    def get_or_404(self, ident: t.Any, description: str | None = None) -> t.Any:
        """Like :meth:`~sqlalchemy.orm.Query.get` but aborts with a ``404 Not Found``
        error instead of returning ``None``.
        :param ident: The primary key to query.
        :param description: A custom message to show on the error page.
        """
        rv = self.get(ident)
        if rv is None:
            abort(404, description=description)
        return rv
    def first_or_404(self, description: str | None = None) -> t.Any:
        """Like :meth:`~sqlalchemy.orm.Query.first` but aborts with a ``404 Not Found``
        error instead of returning ``None``.
        :param description: A custom message to show on the error page.
        """
        rv = self.first()
        if rv is None:
            abort(404, description=description)
        return rv
    def one_or_404(self, description: str | None = None) -> t.Any:
        """Like :meth:`~sqlalchemy.orm.Query.one` but aborts with a ``404 Not Found``
        error instead of raising ``NoResultFound`` or ``MultipleResultsFound``.
        :param description: A custom message to show on the error page.
        .. versionadded:: 3.0
        """
        try:
...(truncado)

===== ./venv/lib/python3.13/site-packages/flask_sqlalchemy/session.py =====
from __future__ import annotations
import typing as t
import sqlalchemy as sa
import sqlalchemy.exc as sa_exc
import sqlalchemy.orm as sa_orm
from flask.globals import app_ctx
if t.TYPE_CHECKING:
    from .extension import SQLAlchemy
class Session(sa_orm.Session):
    """A SQLAlchemy :class:`~sqlalchemy.orm.Session` class that chooses what engine to
    use based on the bind key associated with the metadata associated with the thing
    being queried.
    To customize ``db.session``, subclass this and pass it as the ``class_`` key in the
    ``session_options`` to :class:`.SQLAlchemy`.
    .. versionchanged:: 3.0
        Renamed from ``SignallingSession``.
    """
    def __init__(self, db: SQLAlchemy, **kwargs: t.Any) -> None:
        super().__init__(**kwargs)
        self._db = db
        self._model_changes: dict[object, tuple[t.Any, str]] = {}
    def get_bind(
        self,
        mapper: t.Any | None = None,
        clause: t.Any | None = None,
        bind: sa.engine.Engine | sa.engine.Connection | None = None,
        **kwargs: t.Any,
    ) -> sa.engine.Engine | sa.engine.Connection:
        """Select an engine based on the ``bind_key`` of the metadata associated with
        the model or table being queried. If no bind key is set, uses the default bind.
        .. versionchanged:: 3.0.3
            Fix finding the bind for a joined inheritance model.
        .. versionchanged:: 3.0
            The implementation more closely matches the base SQLAlchemy implementation.
        .. versionchanged:: 2.1
            Support joining an external transaction.
        """
        if bind is not None:
            return bind
        engines = self._db.engines
...(truncado)

===== ./venv/lib/python3.13/site-packages/flask_sqlalchemy/__init__.py =====
from __future__ import annotations
import typing as t
from .extension import SQLAlchemy
__all__ = [
    "SQLAlchemy",
]
def __getattr__(name: str) -> t.Any:
    if name == "__version__":
        import importlib.metadata
        import warnings
        warnings.warn(
            "The '__version__' attribute is deprecated and will be removed in"
            " Flask-SQLAlchemy 3.2. Use feature detection or"
            " 'importlib.metadata.version(\"flask-sqlalchemy\")' instead.",
            DeprecationWarning,
            stacklevel=2,
        )
        return importlib.metadata.version("flask-sqlalchemy")
    raise AttributeError(name)
...(truncado)

===== ./venv/lib/python3.13/site-packages/flask_sqlalchemy/model.py =====
from __future__ import annotations
import re
import typing as t
import sqlalchemy as sa
import sqlalchemy.orm as sa_orm
from .query import Query
if t.TYPE_CHECKING:
    from .extension import SQLAlchemy
class _QueryProperty:
    """A class property that creates a query object for a model.
    :meta private:
    """
    def __get__(self, obj: Model | None, cls: type[Model]) -> Query:
        return cls.query_class(
            cls, session=cls.__fsa__.session()  # type: ignore[arg-type]
        )
class Model:
    """The base class of the :attr:`.SQLAlchemy.Model` declarative model class.
    To define models, subclass :attr:`db.Model <.SQLAlchemy.Model>`, not this. To
    customize ``db.Model``, subclass this and pass it as ``model_class`` to
    :class:`.SQLAlchemy`. To customize ``db.Model`` at the metaclass level, pass an
    already created declarative model class as ``model_class``.
    """
    __fsa__: t.ClassVar[SQLAlchemy]
    """Internal reference to the extension object.
    :meta private:
    """
    query_class: t.ClassVar[type[Query]] = Query
    """Query class used by :attr:`query`. Defaults to :attr:`.SQLAlchemy.Query`, which
    defaults to :class:`.Query`.
    """
    query: t.ClassVar[Query] = _QueryProperty()  # type: ignore[assignment]
    """A SQLAlchemy query for a model. Equivalent to ``db.session.query(Model)``. Can be
    customized per-model by overriding :attr:`query_class`.
    .. warning::
        The query interface is considered legacy in SQLAlchemy. Prefer using
        ``session.execute(select())`` instead.
    """
    def __repr__(self) -> str:
        state = sa.inspect(self)
...(truncado)

===== ./venv/lib/python3.13/site-packages/flask_sqlalchemy/cli.py =====
from __future__ import annotations
import typing as t
from flask import current_app
def add_models_to_shell() -> dict[str, t.Any]:
    """Registered with :meth:`~flask.Flask.shell_context_processor` if
    ``add_models_to_shell`` is enabled. Adds the ``db`` instance and all model classes
    to ``flask shell``.
    """
    db = current_app.extensions["sqlalchemy"]
    out = {m.class_.__name__: m.class_ for m in db.Model._sa_registry.mappers}
    out["db"] = db
    return out
...(truncado)

===== ./venv/lib/python3.13/site-packages/flask_sqlalchemy/extension.py =====
from __future__ import annotations
import os
import types
import typing as t
import warnings
from weakref import WeakKeyDictionary
import sqlalchemy as sa
import sqlalchemy.event as sa_event
import sqlalchemy.exc as sa_exc
import sqlalchemy.orm as sa_orm
from flask import abort
from flask import current_app
from flask import Flask
from flask import has_app_context
from .model import _QueryProperty
from .model import BindMixin
from .model import DefaultMeta
from .model import DefaultMetaNoName
from .model import Model
from .model import NameMixin
from .pagination import Pagination
from .pagination import SelectPagination
from .query import Query
from .session import _app_ctx_id
from .session import Session
from .table import _Table
_O = t.TypeVar("_O", bound=object)  # Based on sqlalchemy.orm._typing.py
_FSA_MCT = t.TypeVar(
    "_FSA_MCT",
    bound=t.Union[
        t.Type[Model],
        sa_orm.DeclarativeMeta,
        t.Type[sa_orm.DeclarativeBase],
        t.Type[sa_orm.DeclarativeBaseNoMeta],
    ],
)
class _FSAModel(Model):
    metadata: sa.MetaData
def _get_2x_declarative_bases(
    model_class: _FSA_MCT,
...(truncado)

===== ./venv/lib/python3.13/site-packages/flask_sqlalchemy/table.py =====
from __future__ import annotations
import typing as t
import sqlalchemy as sa
import sqlalchemy.sql.schema as sa_sql_schema
class _Table(sa.Table):
    @t.overload
    def __init__(
        self,
        name: str,
        *args: sa_sql_schema.SchemaItem,
        bind_key: str | None = None,
        **kwargs: t.Any,
    ) -> None:
        ...
    @t.overload
    def __init__(
        self,
        name: str,
        metadata: sa.MetaData,
        *args: sa_sql_schema.SchemaItem,
        **kwargs: t.Any,
    ) -> None:
        ...
    @t.overload
    def __init__(
        self, name: str, *args: sa_sql_schema.SchemaItem, **kwargs: t.Any
    ) -> None:
        ...
    def __init__(
        self, name: str, *args: sa_sql_schema.SchemaItem, **kwargs: t.Any
    ) -> None:
        super().__init__(name, *args, **kwargs)  # type: ignore[arg-type]
...(truncado)

===== ./venv/lib/python3.13/site-packages/flask_sqlalchemy/pagination.py =====
from __future__ import annotations
import typing as t
from math import ceil
import sqlalchemy as sa
import sqlalchemy.orm as sa_orm
from flask import abort
from flask import request
class Pagination:
    """Apply an offset and limit to the query based on the current page and number of
    items per page.
    Don't create pagination objects manually. They are created by
    :meth:`.SQLAlchemy.paginate` and :meth:`.Query.paginate`.
    This is a base class, a subclass must implement :meth:`_query_items` and
    :meth:`_query_count`. Those methods will use arguments passed as ``kwargs`` to
    perform the queries.
    :param page: The current page, used to calculate the offset. Defaults to the
        ``page`` query arg during a request, or 1 otherwise.
    :param per_page: The maximum number of items on a page, used to calculate the
        offset and limit. Defaults to the ``per_page`` query arg during a request,
        or 20 otherwise.
    :param max_per_page: The maximum allowed value for ``per_page``, to limit a
        user-provided value. Use ``None`` for no limit. Defaults to 100.
    :param error_out: Abort with a ``404 Not Found`` error if no items are returned
        and ``page`` is not 1, or if ``page`` or ``per_page`` is less than 1, or if
        either are not ints.
    :param count: Calculate the total number of values by issuing an extra count
        query. For very complex queries this may be inaccurate or slow, so it can be
        disabled and set manually if necessary.
    :param kwargs: Information about the query to paginate. Different subclasses will
        require different arguments.
    .. versionchanged:: 3.0
        Iterating over a pagination object iterates over its items.
    .. versionchanged:: 3.0
        Creating instances manually is not a public API.
    """
    def __init__(
        self,
        page: int | None = None,
        per_page: int | None = None,
        max_per_page: int | None = 100,
...(truncado)

===== ./venv/lib/python3.13/site-packages/flask_migrate/__init__.py =====
import argparse
from functools import wraps
import logging
import os
import sys
from flask import current_app, g
from alembic import __version__ as __alembic_version__
from alembic.config import Config as AlembicConfig
from alembic import command
from alembic.util import CommandError
alembic_version = tuple([int(v) for v in __alembic_version__.split('.')[0:3]])
log = logging.getLogger(__name__)
class _MigrateConfig(object):
    def __init__(self, migrate, db, **kwargs):
        self.migrate = migrate
        self.db = db
        self.directory = migrate.directory
        self.configure_args = kwargs
    @property
    def metadata(self):
        """
        Backwards compatibility, in old releases app.extensions['migrate']
        was set to db, and env.py accessed app.extensions['migrate'].metadata
        """
        return self.db.metadata
class Config(AlembicConfig):
    def __init__(self, *args, **kwargs):
        self.template_directory = kwargs.pop('template_directory', None)
        super().__init__(*args, **kwargs)
    def get_template_directory(self):
        if self.template_directory:
            return self.template_directory
        package_dir = os.path.abspath(os.path.dirname(__file__))
        return os.path.join(package_dir, 'templates')
class Migrate(object):
    def __init__(self, app=None, db=None, directory='migrations', command='db',
                 compare_type=True, render_as_batch=True, **kwargs):
        self.configure_callbacks = []
        self.db = db
        self.command = command
...(truncado)

===== ./venv/lib/python3.13/site-packages/flask_migrate/cli.py =====
import click
from flask import g
from flask.cli import with_appcontext
from flask_migrate import list_templates as _list_templates
from flask_migrate import init as _init
from flask_migrate import revision as _revision
from flask_migrate import migrate as _migrate
from flask_migrate import edit as _edit
from flask_migrate import merge as _merge
from flask_migrate import upgrade as _upgrade
from flask_migrate import downgrade as _downgrade
from flask_migrate import show as _show
from flask_migrate import history as _history
from flask_migrate import heads as _heads
from flask_migrate import branches as _branches
from flask_migrate import current as _current
from flask_migrate import stamp as _stamp
from flask_migrate import check as _check
@click.group()
@click.option('-d', '--directory', default=None,
              help=('Migration script directory (default is "migrations")'))
@click.option('-x', '--x-arg', multiple=True,
              help='Additional arguments consumed by custom env.py scripts')
@with_appcontext
def db(directory, x_arg):
    """Perform database migrations."""
    g.directory = directory
    g.x_arg = x_arg  # these will be picked up by Migrate.get_config()
@db.command()
@with_appcontext
def list_templates():
    """List available templates."""
    _list_templates()
@db.command()
@click.option('-d', '--directory', default=None,
              help=('Migration script directory (default is "migrations")'))
@click.option('--multidb', is_flag=True,
              help=('Support multiple databases'))
@click.option('-t', '--template', default=None,
              help=('Repository template to use (default is "flask")'))
...(truncado)

===== ./venv/lib/python3.13/site-packages/flask_migrate/templates/flask/env.py =====
import logging
from logging.config import fileConfig
from flask import current_app
from alembic import context
config = context.config
fileConfig(config.config_file_name)
logger = logging.getLogger('alembic.env')
def get_engine():
    try:
        # this works with Flask-SQLAlchemy<3 and Alchemical
        return current_app.extensions['migrate'].db.get_engine()
    except (TypeError, AttributeError):
        # this works with Flask-SQLAlchemy>=3
        return current_app.extensions['migrate'].db.engine
def get_engine_url():
    try:
        return get_engine().url.render_as_string(hide_password=False).replace(
            '%', '%%')
    except AttributeError:
        return str(get_engine().url).replace('%', '%%')
config.set_main_option('sqlalchemy.url', get_engine_url())
target_db = current_app.extensions['migrate'].db
def get_metadata():
    if hasattr(target_db, 'metadatas'):
        return target_db.metadatas[None]
    return target_db.metadata
def run_migrations_offline():
    """Run migrations in 'offline' mode.
    This configures the context with just a URL
    and not an Engine, though an Engine is acceptable
    here as well.  By skipping the Engine creation
    we don't even need a DBAPI to be available.
    Calls to context.execute() here emit the given string to the
    script output.
    """
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url, target_metadata=get_metadata(), literal_binds=True
    )
    with context.begin_transaction():
...(truncado)

===== ./venv/lib/python3.13/site-packages/flask_migrate/templates/aioflask-multidb/env.py =====
import asyncio
import logging
from logging.config import fileConfig
from sqlalchemy import MetaData
from flask import current_app
from alembic import context
USE_TWOPHASE = False
config = context.config
fileConfig(config.config_file_name)
logger = logging.getLogger('alembic.env')
def get_engine(bind_key=None):
    try:
        # this works with Flask-SQLAlchemy<3 and Alchemical
        return current_app.extensions['migrate'].db.get_engine(bind=bind_key)
    except (TypeError, AttributeError):
        # this works with Flask-SQLAlchemy>=3
        return current_app.extensions['migrate'].db.engines.get(bind_key)
def get_engine_url(bind_key=None):
    try:
        return get_engine(bind_key).url.render_as_string(
            hide_password=False).replace('%', '%%')
    except AttributeError:
        return str(get_engine(bind_key).url).replace('%', '%%')
config.set_main_option('sqlalchemy.url', get_engine_url())
bind_names = []
if current_app.config.get('SQLALCHEMY_BINDS') is not None:
    bind_names = list(current_app.config['SQLALCHEMY_BINDS'].keys())
else:
    get_bind_names = getattr(current_app.extensions['migrate'].db,
                             'bind_names', None)
    if get_bind_names:
        bind_names = get_bind_names()
for bind in bind_names:
    context.config.set_section_option(
        bind, "sqlalchemy.url", get_engine_url(bind_key=bind))
target_db = current_app.extensions['migrate'].db
def get_metadata(bind):
    """Return the metadata for a bind."""
    if bind == '':
        bind = None
...(truncado)

===== ./venv/lib/python3.13/site-packages/flask_migrate/templates/aioflask/env.py =====
import asyncio
import logging
from logging.config import fileConfig
from flask import current_app
from alembic import context
config = context.config
fileConfig(config.config_file_name)
logger = logging.getLogger('alembic.env')
def get_engine():
    try:
        # this works with Flask-SQLAlchemy<3 and Alchemical
        return current_app.extensions['migrate'].db.get_engine()
    except (TypeError, AttributeError):
        # this works with Flask-SQLAlchemy>=3
        return current_app.extensions['migrate'].db.engine
def get_engine_url():
    try:
        return get_engine().url.render_as_string(hide_password=False).replace(
            '%', '%%')
    except AttributeError:
        return str(get_engine().url).replace('%', '%%')
config.set_main_option('sqlalchemy.url', get_engine_url())
target_db = current_app.extensions['migrate'].db
def get_metadata():
    if hasattr(target_db, 'metadatas'):
        return target_db.metadatas[None]
    return target_db.metadata
def run_migrations_offline():
    """Run migrations in 'offline' mode.
    This configures the context with just a URL
    and not an Engine, though an Engine is acceptable
    here as well.  By skipping the Engine creation
    we don't even need a DBAPI to be available.
    Calls to context.execute() here emit the given string to the
    script output.
    """
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url, target_metadata=get_metadata(), literal_binds=True
    )
...(truncado)

===== ./venv/lib/python3.13/site-packages/flask_migrate/templates/flask-multidb/env.py =====
import logging
from logging.config import fileConfig
from sqlalchemy import MetaData
from flask import current_app
from alembic import context
USE_TWOPHASE = False
config = context.config
fileConfig(config.config_file_name)
logger = logging.getLogger('alembic.env')
def get_engine(bind_key=None):
    try:
        # this works with Flask-SQLAlchemy<3 and Alchemical
        return current_app.extensions['migrate'].db.get_engine(bind=bind_key)
    except (TypeError, AttributeError):
        # this works with Flask-SQLAlchemy>=3
        return current_app.extensions['migrate'].db.engines.get(bind_key)
def get_engine_url(bind_key=None):
    try:
        return get_engine(bind_key).url.render_as_string(
            hide_password=False).replace('%', '%%')
    except AttributeError:
        return str(get_engine(bind_key).url).replace('%', '%%')
config.set_main_option('sqlalchemy.url', get_engine_url())
bind_names = []
if current_app.config.get('SQLALCHEMY_BINDS') is not None:
    bind_names = list(current_app.config['SQLALCHEMY_BINDS'].keys())
else:
    get_bind_names = getattr(current_app.extensions['migrate'].db,
                             'bind_names', None)
    if get_bind_names:
        bind_names = get_bind_names()
for bind in bind_names:
    context.config.set_section_option(
        bind, "sqlalchemy.url", get_engine_url(bind_key=bind))
target_db = current_app.extensions['migrate'].db
def get_metadata(bind):
    """Return the metadata for a bind."""
    if bind == '':
        bind = None
    if hasattr(target_db, 'metadatas'):
...(truncado)

===== ./venv/lib/python3.13/site-packages/dotenv/version.py =====
__version__ = "1.1.1"
...(truncado)

===== ./venv/lib/python3.13/site-packages/dotenv/variables.py =====
import re
from abc import ABCMeta, abstractmethod
from typing import Iterator, Mapping, Optional, Pattern
_posix_variable: Pattern[str] = re.compile(
    r"""
    \$\{
        (?P<name>[^\}:]*)
        (?::-
            (?P<default>[^\}]*)
        )?
    \}
    """,
    re.VERBOSE,
)
class Atom(metaclass=ABCMeta):
    def __ne__(self, other: object) -> bool:
        result = self.__eq__(other)
        if result is NotImplemented:
            return NotImplemented
        return not result
    @abstractmethod
    def resolve(self, env: Mapping[str, Optional[str]]) -> str: ...
class Literal(Atom):
    def __init__(self, value: str) -> None:
        self.value = value
    def __repr__(self) -> str:
        return f"Literal(value={self.value})"
    def __eq__(self, other: object) -> bool:
        if not isinstance(other, self.__class__):
            return NotImplemented
        return self.value == other.value
    def __hash__(self) -> int:
        return hash((self.__class__, self.value))
    def resolve(self, env: Mapping[str, Optional[str]]) -> str:
        return self.value
class Variable(Atom):
    def __init__(self, name: str, default: Optional[str]) -> None:
        self.name = name
        self.default = default
    def __repr__(self) -> str:
...(truncado)

===== ./venv/lib/python3.13/site-packages/dotenv/__init__.py =====
from typing import Any, Optional
from .main import (dotenv_values, find_dotenv, get_key, load_dotenv, set_key,
                   unset_key)
def load_ipython_extension(ipython: Any) -> None:
    from .ipython import load_ipython_extension
    load_ipython_extension(ipython)
def get_cli_string(
    path: Optional[str] = None,
    action: Optional[str] = None,
    key: Optional[str] = None,
    value: Optional[str] = None,
    quote: Optional[str] = None,
):
    """Returns a string suitable for running as a shell script.
    Useful for converting a arguments passed to a fabric task
    to be passed to a `local` or `run` command.
    """
    command = ['dotenv']
    if quote:
        command.append(f'-q {quote}')
    if path:
        command.append(f'-f {path}')
    if action:
        command.append(action)
        if key:
            command.append(key)
            if value:
                if ' ' in value:
                    command.append(f'"{value}"')
                else:
                    command.append(value)
    return ' '.join(command).strip()
__all__ = ['get_cli_string',
           'load_dotenv',
           'dotenv_values',
           'get_key',
           'set_key',
           'unset_key',
           'find_dotenv',
           'load_ipython_extension']
...(truncado)

===== ./venv/lib/python3.13/site-packages/dotenv/parser.py =====
import codecs
import re
from typing import (IO, Iterator, Match, NamedTuple, Optional,  # noqa:F401
                    Pattern, Sequence, Tuple)
def make_regex(string: str, extra_flags: int = 0) -> Pattern[str]:
    return re.compile(string, re.UNICODE | extra_flags)
_newline = make_regex(r"(\r\n|\n|\r)")
_multiline_whitespace = make_regex(r"\s*", extra_flags=re.MULTILINE)
_whitespace = make_regex(r"[^\S\r\n]*")
_export = make_regex(r"(?:export[^\S\r\n]+)?")
_single_quoted_key = make_regex(r"'([^']+)'")
_unquoted_key = make_regex(r"([^=\#\s]+)")
_equal_sign = make_regex(r"(=[^\S\r\n]*)")
_single_quoted_value = make_regex(r"'((?:\\'|[^'])*)'")
_double_quoted_value = make_regex(r'"((?:\\"|[^"])*)"')
_unquoted_value = make_regex(r"([^\r\n]*)")
_comment = make_regex(r"(?:[^\S\r\n]*#[^\r\n]*)?")
_end_of_line = make_regex(r"[^\S\r\n]*(?:\r\n|\n|\r|$)")
_rest_of_line = make_regex(r"[^\r\n]*(?:\r|\n|\r\n)?")
_double_quote_escapes = make_regex(r"\\[\\'\"abfnrtv]")
_single_quote_escapes = make_regex(r"\\[\\']")
class Original(NamedTuple):
    string: str
    line: int
class Binding(NamedTuple):
    key: Optional[str]
    value: Optional[str]
    original: Original
    error: bool
class Position:
    def __init__(self, chars: int, line: int) -> None:
        self.chars = chars
        self.line = line
    @classmethod
    def start(cls) -> "Position":
        return cls(chars=0, line=1)
    def set(self, other: "Position") -> None:
        self.chars = other.chars
        self.line = other.line
    def advance(self, string: str) -> None:
...(truncado)

===== ./venv/lib/python3.13/site-packages/dotenv/cli.py =====
import json
import os
import shlex
import sys
from contextlib import contextmanager
from typing import Any, Dict, IO, Iterator, List, Optional
if sys.platform == 'win32':
    from subprocess import Popen
try:
    import click
except ImportError:
    sys.stderr.write('It seems python-dotenv is not installed with cli option. \n'
                     'Run pip install "python-dotenv[cli]" to fix this.')
    sys.exit(1)
from .main import dotenv_values, set_key, unset_key
from .version import __version__
def enumerate_env() -> Optional[str]:
    """
    Return a path for the ${pwd}/.env file.
    If pwd does not exist, return None.
    """
    try:
        cwd = os.getcwd()
    except FileNotFoundError:
        return None
    path = os.path.join(cwd, '.env')
    return path
@click.group()
@click.option('-f', '--file', default=enumerate_env(),
              type=click.Path(file_okay=True),
              help="Location of the .env file, defaults to .env file in current working directory.")
@click.option('-q', '--quote', default='always',
              type=click.Choice(['always', 'never', 'auto']),
              help="Whether to quote or not the variable values. Default mode is always. This does not affect parsing.")
@click.option('-e', '--export', default=False,
              type=click.BOOL,
              help="Whether to write the dot file as an executable bash script.")
@click.version_option(version=__version__)
@click.pass_context
def cli(ctx: click.Context, file: Any, quote: Any, export: Any) -> None:
...(truncado)

===== ./venv/lib/python3.13/site-packages/dotenv/ipython.py =====
from IPython.core.magic import Magics, line_magic, magics_class  # type: ignore
from IPython.core.magic_arguments import (argument, magic_arguments,  # type: ignore
                                          parse_argstring)  # type: ignore
from .main import find_dotenv, load_dotenv
@magics_class
class IPythonDotEnv(Magics):
    @magic_arguments()
    @argument(
        '-o', '--override', action='store_true',
        help="Indicate to override existing variables"
    )
    @argument(
        '-v', '--verbose', action='store_true',
        help="Indicate function calls to be verbose"
    )
    @argument('dotenv_path', nargs='?', type=str, default='.env',
              help='Search in increasingly higher folders for the `dotenv_path`')
    @line_magic
    def dotenv(self, line):
        args = parse_argstring(self.dotenv, line)
        # Locate the .env file
        dotenv_path = args.dotenv_path
        try:
            dotenv_path = find_dotenv(dotenv_path, True, True)
        except IOError:
            print("cannot find .env file")
            return
        # Load the .env file
        load_dotenv(dotenv_path, verbose=args.verbose, override=args.override)
def load_ipython_extension(ipython):
    """Register the %dotenv magic."""
    ipython.register_magics(IPythonDotEnv)
...(truncado)

===== ./venv/lib/python3.13/site-packages/dotenv/main.py =====
import io
import logging
import os
import pathlib
import shutil
import sys
import tempfile
from collections import OrderedDict
from contextlib import contextmanager
from typing import IO, Dict, Iterable, Iterator, Mapping, Optional, Tuple, Union
from .parser import Binding, parse_stream
from .variables import parse_variables
StrPath = Union[str, "os.PathLike[str]"]
logger = logging.getLogger(__name__)
def with_warn_for_invalid_lines(mappings: Iterator[Binding]) -> Iterator[Binding]:
    for mapping in mappings:
        if mapping.error:
            logger.warning(
                "python-dotenv could not parse statement starting at line %s",
                mapping.original.line,
            )
        yield mapping
class DotEnv:
    def __init__(
        self,
        dotenv_path: Optional[StrPath],
        stream: Optional[IO[str]] = None,
        verbose: bool = False,
        encoding: Optional[str] = None,
        interpolate: bool = True,
        override: bool = True,
    ) -> None:
        self.dotenv_path: Optional[StrPath] = dotenv_path
        self.stream: Optional[IO[str]] = stream
        self._dict: Optional[Dict[str, Optional[str]]] = None
        self.verbose: bool = verbose
        self.encoding: Optional[str] = encoding
        self.interpolate: bool = interpolate
        self.override: bool = override
    @contextmanager
...(truncado)

===== ./venv/lib/python3.13/site-packages/dotenv/__main__.py =====
"""Entry point for cli, enables execution with `python -m dotenv`"""
from .cli import cli
if __name__ == "__main__":
    cli()
...(truncado)

===== ./venv/lib/python3.13/site-packages/mako/pyparser.py =====
"""Handles parsing of Python code.
Parsing to AST is done via _ast on Python > 2.5, otherwise the compiler
module is used.
"""
import operator
import _ast
from mako import _ast_util
from mako import compat
from mako import exceptions
from mako import util
reserved = {"True", "False", "None", "print"}
arg_id = operator.attrgetter("arg")
util.restore__ast(_ast)
def parse(code, mode="exec", **exception_kwargs):
    """Parse an expression into AST"""
    try:
        return _ast_util.parse(code, "<unknown>", mode)
    except Exception as e:
        raise exceptions.SyntaxException(
            "(%s) %s (%r)"
            % (
                compat.exception_as().__class__.__name__,
                compat.exception_as(),
                code[0:50],
            ),
            **exception_kwargs,
        ) from e
class FindIdentifiers(_ast_util.NodeVisitor):
    def __init__(self, listener, **exception_kwargs):
        self.in_function = False
        self.in_assign_targets = False
        self.local_ident_stack = set()
        self.listener = listener
        self.exception_kwargs = exception_kwargs
    def _add_declared(self, name):
        if not self.in_function:
            self.listener.declared_identifiers.add(name)
        else:
            self.local_ident_stack.add(name)
    def visit_ClassDef(self, node):
...(truncado)

===== ./venv/lib/python3.13/site-packages/mako/cmd.py =====
from argparse import ArgumentParser
from os.path import dirname
from os.path import isfile
import sys
from mako import exceptions
from mako.lookup import TemplateLookup
from mako.template import Template
def varsplit(var):
    if "=" not in var:
        return (var, "")
    return var.split("=", 1)
def _exit():
    sys.stderr.write(exceptions.text_error_template().render())
    sys.exit(1)
def cmdline(argv=None):
    parser = ArgumentParser()
    parser.add_argument(
        "--var",
        default=[],
        action="append",
        help="variable (can be used multiple times, use name=value)",
    )
    parser.add_argument(
        "--template-dir",
        default=[],
        action="append",
        help="Directory to use for template lookup (multiple "
        "directories may be provided). If not given then if the "
        "template is read from stdin, the value defaults to be "
        "the current directory, otherwise it defaults to be the "
        "parent directory of the file provided.",
    )
    parser.add_argument(
        "--output-encoding", default=None, help="force output encoding"
    )
    parser.add_argument(
        "--output-file",
        default=None,
        help="Write to file upon successful render instead of stdout",
    )
...(truncado)

===== ./venv/lib/python3.13/site-packages/mako/compat.py =====
import collections
from importlib import metadata as importlib_metadata
from importlib import util
import inspect
import sys
win32 = sys.platform.startswith("win")
pypy = hasattr(sys, "pypy_version_info")
ArgSpec = collections.namedtuple(
    "ArgSpec", ["args", "varargs", "keywords", "defaults"]
)
def inspect_getargspec(func):
    """getargspec based on fully vendored getfullargspec from Python 3.3."""
    if inspect.ismethod(func):
        func = func.__func__
    if not inspect.isfunction(func):
        raise TypeError(f"{func!r} is not a Python function")
    co = func.__code__
    if not inspect.iscode(co):
        raise TypeError(f"{co!r} is not a code object")
    nargs = co.co_argcount
    names = co.co_varnames
    nkwargs = co.co_kwonlyargcount
    args = list(names[:nargs])
    nargs += nkwargs
    varargs = None
    if co.co_flags & inspect.CO_VARARGS:
        varargs = co.co_varnames[nargs]
        nargs = nargs + 1
    varkw = None
    if co.co_flags & inspect.CO_VARKEYWORDS:
        varkw = co.co_varnames[nargs]
    return ArgSpec(args, varargs, varkw, func.__defaults__)
def load_module(module_id, path):
    spec = util.spec_from_file_location(module_id, path)
    module = util.module_from_spec(spec)
    spec.loader.exec_module(module)
    return module
def exception_as():
    return sys.exc_info()[1]
def exception_name(exc):
...(truncado)

===== ./venv/lib/python3.13/site-packages/mako/util.py =====
from ast import parse
import codecs
import collections
import operator
import os
import re
import timeit
from .compat import importlib_metadata_get
def update_wrapper(decorated, fn):
    decorated.__wrapped__ = fn
    decorated.__name__ = fn.__name__
    return decorated
class PluginLoader:
    def __init__(self, group):
        self.group = group
        self.impls = {}
    def load(self, name):
        if name in self.impls:
            return self.impls[name]()
        for impl in importlib_metadata_get(self.group):
            if impl.name == name:
                self.impls[name] = impl.load
                return impl.load()
        from mako import exceptions
        raise exceptions.RuntimeException(
            "Can't load plugin %s %s" % (self.group, name)
        )
    def register(self, name, modulepath, objname):
        def load():
            mod = __import__(modulepath)
            for token in modulepath.split(".")[1:]:
                mod = getattr(mod, token)
            return getattr(mod, objname)
        self.impls[name] = load
def verify_directory(dir_):
    """create and/or verify a filesystem directory."""
    tries = 0
    while not os.path.exists(dir_):
        try:
            tries += 1
...(truncado)

===== ./venv/lib/python3.13/site-packages/mako/_ast_util.py =====
"""
    ast
    ~~~
    This is a stripped down version of Armin Ronacher's ast module.
    :copyright: Copyright 2008 by Armin Ronacher.
    :license: Python License.
"""
from _ast import Add
from _ast import And
from _ast import AST
from _ast import BitAnd
from _ast import BitOr
from _ast import BitXor
from _ast import Div
from _ast import Eq
from _ast import FloorDiv
from _ast import Gt
from _ast import GtE
from _ast import If
from _ast import In
from _ast import Invert
from _ast import Is
from _ast import IsNot
from _ast import LShift
from _ast import Lt
from _ast import LtE
from _ast import Mod
from _ast import Mult
from _ast import Name
from _ast import Not
from _ast import NotEq
from _ast import NotIn
from _ast import Or
from _ast import PyCF_ONLY_AST
from _ast import RShift
from _ast import Sub
from _ast import UAdd
from _ast import USub
BOOLOP_SYMBOLS = {And: "and", Or: "or"}
BINOP_SYMBOLS = {
...(truncado)

===== ./venv/lib/python3.13/site-packages/mako/ext/linguaplugin.py =====
import contextlib
import io
from lingua.extractors import Extractor
from lingua.extractors import get_extractor
from lingua.extractors import Message
from mako.ext.extract import MessageExtractor
class LinguaMakoExtractor(Extractor, MessageExtractor):
    """Mako templates"""
    use_bytes = False
    extensions = [".mako"]
    default_config = {"encoding": "utf-8", "comment-tags": ""}
    def __call__(self, filename, options, fileobj=None):
        self.options = options
        self.filename = filename
        self.python_extractor = get_extractor("x.py")
        if fileobj is None:
            ctx = open(filename, "r")
        else:
            ctx = contextlib.nullcontext(fileobj)
        with ctx as file_:
            yield from self.process_file(file_)
    def process_python(self, code, code_lineno, translator_strings):
        source = code.getvalue().strip()
        if source.endswith(":"):
            if source in ("try:", "else:") or source.startswith("except"):
                source = ""  # Ignore try/except and else
            elif source.startswith("elif"):
                source = source[2:]  # Replace "elif" with "if"
            source += "pass"
        code = io.StringIO(source)
        for msg in self.python_extractor(
            self.filename, self.options, code, code_lineno - 1
        ):
            if translator_strings:
                msg = Message(
                    msg.msgctxt,
                    msg.msgid,
                    msg.msgid_plural,
                    msg.flags,
                    " ".join(translator_strings + [msg.comment]),
...(truncado)

===== ./venv/lib/python3.13/site-packages/mako/ext/__init__.py =====
...(truncado)

===== ./venv/lib/python3.13/site-packages/mako/ext/preprocessors.py =====
"""preprocessing functions, used with the 'preprocessor'
argument on Template, TemplateLookup"""
import re
def convert_comments(text):
    """preprocess old style comments.
    example:
    from mako.ext.preprocessors import convert_comments
    t = Template(..., preprocessor=convert_comments)"""
    return re.sub(r"(?<=\n)\s*#[^#]", "##", text)
...(truncado)

===== ./venv/lib/python3.13/site-packages/mako/ext/beaker_cache.py =====
"""Provide a :class:`.CacheImpl` for the Beaker caching system."""
from mako import exceptions
from mako.cache import CacheImpl
try:
    from beaker import cache as beaker_cache
except:
    has_beaker = False
else:
    has_beaker = True
_beaker_cache = None
class BeakerCacheImpl(CacheImpl):
    """A :class:`.CacheImpl` provided for the Beaker caching system.
    This plugin is used by default, based on the default
    value of ``'beaker'`` for the ``cache_impl`` parameter of the
    :class:`.Template` or :class:`.TemplateLookup` classes.
    """
    def __init__(self, cache):
        if not has_beaker:
            raise exceptions.RuntimeException(
                "Can't initialize Beaker plugin; Beaker is not installed."
            )
        global _beaker_cache
        if _beaker_cache is None:
            if "manager" in cache.template.cache_args:
                _beaker_cache = cache.template.cache_args["manager"]
            else:
                _beaker_cache = beaker_cache.CacheManager()
        super().__init__(cache)
    def _get_cache(self, **kw):
        expiretime = kw.pop("timeout", None)
        if "dir" in kw:
            kw["data_dir"] = kw.pop("dir")
        elif self.cache.template.module_directory:
            kw["data_dir"] = self.cache.template.module_directory
        if "manager" in kw:
            kw.pop("manager")
        if kw.get("type") == "memcached":
            kw["type"] = "ext:memcached"
        if "region" in kw:
            region = kw.pop("region")
...(truncado)

===== ./venv/lib/python3.13/site-packages/mako/ext/autohandler.py =====
"""adds autohandler functionality to Mako templates.
requires that the TemplateLookup class is used with templates.
usage::
    <%!
        from mako.ext.autohandler import autohandler
    %>
    <%inherit file="${autohandler(template, context)}"/>
or with custom autohandler filename::
    <%!
        from mako.ext.autohandler import autohandler
    %>
    <%inherit file="${autohandler(template, context, name='somefilename')}"/>
"""
import os
import posixpath
import re
def autohandler(template, context, name="autohandler"):
    lookup = context.lookup
    _template_uri = template.module._template_uri
    if not lookup.filesystem_checks:
        try:
            return lookup._uri_cache[(autohandler, _template_uri, name)]
        except KeyError:
            pass
    tokens = re.findall(r"([^/]+)", posixpath.dirname(_template_uri)) + [name]
    while len(tokens):
        path = "/" + "/".join(tokens)
        if path != _template_uri and _file_exists(lookup, path):
            if not lookup.filesystem_checks:
                return lookup._uri_cache.setdefault(
                    (autohandler, _template_uri, name), path
                )
            else:
                return path
        if len(tokens) == 1:
            break
        tokens[-2:] = [name]
    if not lookup.filesystem_checks:
        return lookup._uri_cache.setdefault(
            (autohandler, _template_uri, name), None
...(truncado)

===== ./venv/lib/python3.13/site-packages/mako/ext/babelplugin.py =====
"""gettext message extraction via Babel: https://pypi.org/project/Babel/"""
from babel.messages.extract import extract_python
from mako.ext.extract import MessageExtractor
class BabelMakoExtractor(MessageExtractor):
    def __init__(self, keywords, comment_tags, options):
        self.keywords = keywords
        self.options = options
        self.config = {
            "comment-tags": " ".join(comment_tags),
            "encoding": options.get(
                "input_encoding", options.get("encoding", None)
            ),
        }
        super().__init__()
    def __call__(self, fileobj):
        return self.process_file(fileobj)
    def process_python(self, code, code_lineno, translator_strings):
        comment_tags = self.config["comment-tags"]
        for (
            lineno,
            funcname,
            messages,
            python_translator_comments,
        ) in extract_python(code, self.keywords, comment_tags, self.options):
            yield (
                code_lineno + (lineno - 1),
                funcname,
                messages,
                translator_strings + python_translator_comments,
            )
def extract(fileobj, keywords, comment_tags, options):
    """Extract messages from Mako templates.
    :param fileobj: the file-like object the messages should be extracted from
    :param keywords: a list of keywords (i.e. function names) that should be
                     recognized as translation functions
    :param comment_tags: a list of translator tags to search for and include
                         in the results
    :param options: a dictionary of additional options (optional)
    :return: an iterator over ``(lineno, funcname, message, comments)`` tuples
    :rtype: ``iterator``
...(truncado)

===== ./venv/lib/python3.13/site-packages/mako/ext/extract.py =====
from io import BytesIO
from io import StringIO
import re
from mako import lexer
from mako import parsetree
class MessageExtractor:
    use_bytes = True
    def process_file(self, fileobj):
        template_node = lexer.Lexer(
            fileobj.read(), input_encoding=self.config["encoding"]
        ).parse()
        yield from self.extract_nodes(template_node.get_children())
    def extract_nodes(self, nodes):
        translator_comments = []
        in_translator_comments = False
        input_encoding = self.config["encoding"] or "ascii"
        comment_tags = list(
            filter(None, re.split(r"\s+", self.config["comment-tags"]))
        )
        for node in nodes:
            child_nodes = None
            if (
                in_translator_comments
                and isinstance(node, parsetree.Text)
                and not node.content.strip()
            ):
                # Ignore whitespace within translator comments
                continue
            if isinstance(node, parsetree.Comment):
                value = node.text.strip()
                if in_translator_comments:
                    translator_comments.extend(
                        self._split_comment(node.lineno, value)
                    )
                    continue
                for comment_tag in comment_tags:
                    if value.startswith(comment_tag):
                        in_translator_comments = True
                        translator_comments.extend(
                            self._split_comment(node.lineno, value)
...(truncado)

===== ./venv/lib/python3.13/site-packages/mako/ext/pygmentplugin.py =====
from pygments import highlight
from pygments.formatters.html import HtmlFormatter
from pygments.lexer import bygroups
from pygments.lexer import DelegatingLexer
from pygments.lexer import include
from pygments.lexer import RegexLexer
from pygments.lexer import using
from pygments.lexers.agile import Python3Lexer
from pygments.lexers.agile import PythonLexer
from pygments.lexers.web import CssLexer
from pygments.lexers.web import HtmlLexer
from pygments.lexers.web import JavascriptLexer
from pygments.lexers.web import XmlLexer
from pygments.token import Comment
from pygments.token import Keyword
from pygments.token import Name
from pygments.token import Operator
from pygments.token import Other
from pygments.token import String
from pygments.token import Text
class MakoLexer(RegexLexer):
    name = "Mako"
    aliases = ["mako"]
    filenames = ["*.mao"]
    tokens = {
        "root": [
            (
                r"(\s*)(\%)(\s*end(?:\w+))(\n|\Z)",
                bygroups(Text, Comment.Preproc, Keyword, Other),
            ),
            (
                r"(\s*)(\%(?!%))([^\n]*)(\n|\Z)",
                bygroups(Text, Comment.Preproc, using(PythonLexer), Other),
            ),
            (
                r"(\s*)(##[^\n]*)(\n|\Z)",
                bygroups(Text, Comment.Preproc, Other),
            ),
            (r"""(?s)<%doc>.*?</%doc>""", Comment.Preproc),
            (
...(truncado)

===== ./venv/lib/python3.13/site-packages/mako/ext/turbogears.py =====
from mako import compat
from mako.lookup import TemplateLookup
from mako.template import Template
class TGPlugin:
    """TurboGears compatible Template Plugin."""
    def __init__(self, extra_vars_func=None, options=None, extension="mak"):
        self.extra_vars_func = extra_vars_func
        self.extension = extension
        if not options:
            options = {}
        # Pull the options out and initialize the lookup
        lookup_options = {}
        for k, v in options.items():
            if k.startswith("mako."):
                lookup_options[k[5:]] = v
            elif k in ["directories", "filesystem_checks", "module_directory"]:
                lookup_options[k] = v
        self.lookup = TemplateLookup(**lookup_options)
        self.tmpl_options = {}
        # transfer lookup args to template args, based on those available
        # in getargspec
        for kw in compat.inspect_getargspec(Template.__init__)[0]:
            if kw in lookup_options:
                self.tmpl_options[kw] = lookup_options[kw]
    def load_template(self, templatename, template_string=None):
        """Loads a template from a file or a string"""
        if template_string is not None:
            return Template(template_string, **self.tmpl_options)
        # Translate TG dot notation to normal / template path
        if "/" not in templatename:
            templatename = (
                "/" + templatename.replace(".", "/") + "." + self.extension
            )
        # Lookup template
        return self.lookup.get_template(templatename)
    def render(
        self, info, format="html", fragment=False, template=None  # noqa
    ):
        if isinstance(template, str):
            template = self.load_template(template)
...(truncado)

===== ./venv/lib/python3.13/site-packages/mako/lookup.py =====
import os
import posixpath
import re
import stat
import threading
from mako import exceptions
from mako import util
from mako.template import Template
class TemplateCollection:
    """Represent a collection of :class:`.Template` objects,
    identifiable via URI.
    A :class:`.TemplateCollection` is linked to the usage of
    all template tags that address other templates, such
    as ``<%include>``, ``<%namespace>``, and ``<%inherit>``.
    The ``file`` attribute of each of those tags refers
    to a string URI that is passed to that :class:`.Template`
    object's :class:`.TemplateCollection` for resolution.
    :class:`.TemplateCollection` is an abstract class,
    with the usual default implementation being :class:`.TemplateLookup`.
    """
    def has_template(self, uri):
        """Return ``True`` if this :class:`.TemplateLookup` is
        capable of returning a :class:`.Template` object for the
        given ``uri``.
        :param uri: String URI of the template to be resolved.
        """
        try:
            self.get_template(uri)
            return True
        except exceptions.TemplateLookupException:
            return False
    def get_template(self, uri, relativeto=None):
        """Return a :class:`.Template` object corresponding to the given
        ``uri``.
        The default implementation raises
        :class:`.NotImplementedError`. Implementations should
        raise :class:`.TemplateLookupException` if the given ``uri``
        cannot be resolved.
        :param uri: String URI of the template to be resolved.
        :param relativeto: if present, the given ``uri`` is assumed to
...(truncado)

===== ./venv/lib/python3.13/site-packages/mako/cache.py =====
from mako import util
_cache_plugins = util.PluginLoader("mako.cache")
register_plugin = _cache_plugins.register
register_plugin("beaker", "mako.ext.beaker_cache", "BeakerCacheImpl")
class Cache:
    """Represents a data content cache made available to the module
    space of a specific :class:`.Template` object.
    .. versionadded:: 0.6
       :class:`.Cache` by itself is mostly a
       container for a :class:`.CacheImpl` object, which implements
       a fixed API to provide caching services; specific subclasses exist to
       implement different
       caching strategies.   Mako includes a backend that works with
       the Beaker caching system.   Beaker itself then supports
       a number of backends (i.e. file, memory, memcached, etc.)
    The construction of a :class:`.Cache` is part of the mechanics
    of a :class:`.Template`, and programmatic access to this
    cache is typically via the :attr:`.Template.cache` attribute.
    """
    impl = None
    """Provide the :class:`.CacheImpl` in use by this :class:`.Cache`.
    This accessor allows a :class:`.CacheImpl` with additional
    methods beyond that of :class:`.Cache` to be used programmatically.
    """
    id = None
    """Return the 'id' that identifies this cache.
    This is a value that should be globally unique to the
    :class:`.Template` associated with this cache, and can
    be used by a caching system to name a local container
    for data specific to this template.
    """
    starttime = None
    """Epochal time value for when the owning :class:`.Template` was
    first compiled.
    A cache implementation may wish to invalidate data earlier than
    this timestamp; this has the effect of the cache for a specific
    :class:`.Template` starting clean any time the :class:`.Template`
    is recompiled, such as when the original template file changed on
    the filesystem.
    """
...(truncado)

===== ./venv/lib/python3.13/site-packages/mako/__init__.py =====
__version__ = "1.3.10"
...(truncado)

===== ./venv/lib/python3.13/site-packages/mako/runtime.py =====
"""provides runtime services for templates, including Context,
Namespace, and various helper functions."""
import builtins
import functools
import sys
from mako import compat
from mako import exceptions
from mako import util
class Context:
    """Provides runtime namespace, output buffer, and various
    callstacks for templates.
    See :ref:`runtime_toplevel` for detail on the usage of
    :class:`.Context`.
    """
    def __init__(self, buffer, **data):
        self._buffer_stack = [buffer]
        self._data = data
        self._kwargs = data.copy()
        self._with_template = None
        self._outputting_as_unicode = None
        self.namespaces = {}
        # "capture" function which proxies to the
        # generic "capture" function
        self._data["capture"] = functools.partial(capture, self)
        # "caller" stack used by def calls with content
        self.caller_stack = self._data["caller"] = CallerStack()
    def _set_with_template(self, t):
        self._with_template = t
        illegal_names = t.reserved_names.intersection(self._data)
        if illegal_names:
            raise exceptions.NameConflictError(
                "Reserved words passed to render(): %s"
                % ", ".join(illegal_names)
            )
    @property
    def lookup(self):
        """Return the :class:`.TemplateLookup` associated
        with this :class:`.Context`.
        """
        return self._with_template.lookup
...(truncado)

===== ./venv/lib/python3.13/site-packages/mako/testing/exclusions.py =====
import pytest
from mako.ext.beaker_cache import has_beaker
from mako.util import update_wrapper
try:
    import babel.messages.extract as babel
except ImportError:
    babel = None
try:
    import lingua
except ImportError:
    lingua = None
try:
    import dogpile.cache  # noqa
except ImportError:
    has_dogpile_cache = False
else:
    has_dogpile_cache = True
requires_beaker = pytest.mark.skipif(
    not has_beaker, reason="Beaker is required for these tests."
)
requires_babel = pytest.mark.skipif(
    babel is None, reason="babel not installed: skipping babelplugin test"
)
requires_lingua = pytest.mark.skipif(
    lingua is None, reason="lingua not installed: skipping linguaplugin test"
)
requires_dogpile_cache = pytest.mark.skipif(
    not has_dogpile_cache,
    reason="dogpile.cache is required to run these tests",
)
def _pygments_version():
    try:
        import pygments
        version = pygments.__version__
    except:
        version = "0"
    return version
requires_pygments_14 = pytest.mark.skipif(
    _pygments_version() < "1.4", reason="Requires pygments 1.4 or greater"
)
...(truncado)

===== ./venv/lib/python3.13/site-packages/mako/testing/config.py =====
from dataclasses import dataclass
from pathlib import Path
from ._config import ReadsCfg
from .helpers import make_path
@dataclass
class Config(ReadsCfg):
    module_base: Path
    template_base: Path
    section_header = "mako_testing"
    converters = {Path: make_path}
config = Config.from_cfg_file("./setup.cfg")
...(truncado)

===== ./venv/lib/python3.13/site-packages/mako/testing/__init__.py =====
...(truncado)

===== ./venv/lib/python3.13/site-packages/mako/testing/assertions.py =====
import contextlib
import re
import sys
def eq_(a, b, msg=None):
    """Assert a == b, with repr messaging on failure."""
    assert a == b, msg or "%r != %r" % (a, b)
def ne_(a, b, msg=None):
    """Assert a != b, with repr messaging on failure."""
    assert a != b, msg or "%r == %r" % (a, b)
def in_(a, b, msg=None):
    """Assert a in b, with repr messaging on failure."""
    assert a in b, msg or "%r not in %r" % (a, b)
def not_in(a, b, msg=None):
    """Assert a in not b, with repr messaging on failure."""
    assert a not in b, msg or "%r is in %r" % (a, b)
def _assert_proper_exception_context(exception):
    """assert that any exception we're catching does not have a __context__
    without a __cause__, and that __suppress_context__ is never set.
    Python 3 will report nested as exceptions as "during the handling of
    error X, error Y occurred". That's not what we want to do. We want
    these exceptions in a cause chain.
    """
    if (
        exception.__context__ is not exception.__cause__
        and not exception.__suppress_context__
    ):
        assert False, (
            "Exception %r was correctly raised but did not set a cause, "
            "within context %r as its cause."
            % (exception, exception.__context__)
        )
def _assert_proper_cause_cls(exception, cause_cls):
    """assert that any exception we're catching does not have a __context__
    without a __cause__, and that __suppress_context__ is never set.
    Python 3 will report nested as exceptions as "during the handling of
    error X, error Y occurred". That's not what we want to do. We want
    these exceptions in a cause chain.
    """
    assert isinstance(exception.__cause__, cause_cls), (
        "Exception %r was correctly raised but has cause %r, which does not "
...(truncado)

===== ./venv/lib/python3.13/site-packages/mako/testing/_config.py =====
import configparser
import dataclasses
from dataclasses import dataclass
from pathlib import Path
from typing import Callable
from typing import ClassVar
from typing import Optional
from typing import Union
from .helpers import make_path
class ConfigError(BaseException):
    pass
class MissingConfig(ConfigError):
    pass
class MissingConfigSection(ConfigError):
    pass
class MissingConfigItem(ConfigError):
    pass
class ConfigValueTypeError(ConfigError):
    pass
class _GetterDispatch:
    def __init__(self, initialdata, default_getter: Callable):
        self.default_getter = default_getter
        self.data = initialdata
    def get_fn_for_type(self, type_):
        return self.data.get(type_, self.default_getter)
    def get_typed_value(self, type_, name):
        get_fn = self.get_fn_for_type(type_)
        return get_fn(name)
def _parse_cfg_file(filespec: Union[Path, str]):
    cfg = configparser.ConfigParser()
    try:
        filepath = make_path(filespec, check_exists=True)
    except FileNotFoundError as e:
        raise MissingConfig(f"No config file found at {filespec}") from e
    else:
        with open(filepath, encoding="utf-8") as f:
            cfg.read_file(f)
        return cfg
def _build_getter(cfg_obj, cfg_section, method, converter=None):
    def caller(option, **kwargs):
...(truncado)

===== ./venv/lib/python3.13/site-packages/mako/testing/helpers.py =====
import contextlib
import pathlib
from pathlib import Path
import re
import time
from typing import Union
from unittest import mock
def flatten_result(result):
    return re.sub(r"[\s\r\n]+", " ", result).strip()
def result_lines(result):
    return [
        x.strip()
        for x in re.split(r"\r?\n", re.sub(r" +", " ", result))
        if x.strip() != ""
    ]
def result_raw_lines(result):
    return [x for x in re.split(r"\r?\n", result) if x.strip() != ""]
def make_path(
    filespec: Union[Path, str],
    make_absolute: bool = True,
    check_exists: bool = False,
) -> Path:
    path = Path(filespec)
    if make_absolute:
        path = path.resolve(strict=check_exists)
    if check_exists and (not path.exists()):
        raise FileNotFoundError(f"No file or directory at {filespec}")
    return path
def _unlink_path(path, missing_ok=False):
    # Replicate 3.8+ functionality in 3.7
    cm = contextlib.nullcontext()
    if missing_ok:
        cm = contextlib.suppress(FileNotFoundError)
    with cm:
        path.unlink()
def replace_file_with_dir(pathspec):
    path = pathlib.Path(pathspec)
    _unlink_path(path, missing_ok=True)
    path.mkdir(exist_ok=True)
    return path
...(truncado)

===== ./venv/lib/python3.13/site-packages/mako/testing/fixtures.py =====
import os
from mako.cache import CacheImpl
from mako.cache import register_plugin
from mako.template import Template
from .assertions import eq_
from .config import config
class TemplateTest:
    def _file_template(self, filename, **kw):
        filepath = self._file_path(filename)
        return Template(
            uri=filename,
            filename=filepath,
            module_directory=config.module_base,
            **kw,
        )
    def _file_path(self, filename):
        name, ext = os.path.splitext(filename)
        py3k_path = os.path.join(config.template_base, name + "_py3k" + ext)
        if os.path.exists(py3k_path):
            return py3k_path
        return os.path.join(config.template_base, filename)
    def _do_file_test(
        self,
        filename,
        expected,
        filters=None,
        unicode_=True,
        template_args=None,
        **kw,
    ):
        t1 = self._file_template(filename, **kw)
        self._do_test(
            t1,
            expected,
            filters=filters,
            unicode_=unicode_,
            template_args=template_args,
        )
    def _do_memory_test(
        self,
...(truncado)

===== ./venv/lib/python3.13/site-packages/mako/lexer.py =====
"""provides the Lexer class for parsing template strings into parse trees."""
import codecs
import re
from mako import exceptions
from mako import parsetree
from mako.pygen import adjust_whitespace
_regexp_cache = {}
class Lexer:
    def __init__(
        self, text, filename=None, input_encoding=None, preprocessor=None
    ):
        self.text = text
        self.filename = filename
        self.template = parsetree.TemplateNode(self.filename)
        self.matched_lineno = 1
        self.matched_charpos = 0
        self.lineno = 1
        self.match_position = 0
        self.tag = []
        self.control_line = []
        self.ternary_stack = []
        self.encoding = input_encoding
        if preprocessor is None:
            self.preprocessor = []
        elif not hasattr(preprocessor, "__iter__"):
            self.preprocessor = [preprocessor]
        else:
            self.preprocessor = preprocessor
    @property
    def exception_kwargs(self):
        return {
            "source": self.text,
            "lineno": self.matched_lineno,
            "pos": self.matched_charpos,
            "filename": self.filename,
        }
    def match(self, regexp, flags=None):
        """compile the given regexp, cache the reg, and call match_reg()."""
        try:
            reg = _regexp_cache[(regexp, flags)]
...(truncado)

===== ./venv/lib/python3.13/site-packages/mako/template.py =====
"""Provides the Template class, a facade for parsing, generating and executing
template strings, as well as template runtime operations."""
import json
import os
import re
import shutil
import stat
import tempfile
import types
import weakref
from mako import cache
from mako import codegen
from mako import compat
from mako import exceptions
from mako import runtime
from mako import util
from mako.lexer import Lexer
class Template:
    r"""Represents a compiled template.
    :class:`.Template` includes a reference to the original
    template source (via the :attr:`.source` attribute)
    as well as the source code of the
    generated Python module (i.e. the :attr:`.code` attribute),
    as well as a reference to an actual Python module.
    :class:`.Template` is constructed using either a literal string
    representing the template text, or a filename representing a filesystem
    path to a source file.
    :param text: textual template source.  This argument is mutually
     exclusive versus the ``filename`` parameter.
    :param filename: filename of the source template.  This argument is
     mutually exclusive versus the ``text`` parameter.
    :param buffer_filters: string list of filters to be applied
     to the output of ``%def``\ s which are buffered, cached, or otherwise
     filtered, after all filters
     defined with the ``%def`` itself have been applied. Allows the
     creation of default expression filters that let the output
     of return-valued ``%def``\ s "opt out" of that filtering via
     passing special attributes or objects.
    :param cache_args: Dictionary of cache configuration arguments that
     will be passed to the :class:`.CacheImpl`.   See :ref:`caching_toplevel`.
...(truncado)

===== ./venv/lib/python3.13/site-packages/mako/ast.py =====
"""utilities for analyzing expressions and blocks of Python
code, as well as generating Python from AST nodes"""
import re
from mako import exceptions
from mako import pyparser
class PythonCode:
    """represents information about a string containing Python code"""
    def __init__(self, code, **exception_kwargs):
        self.code = code
        # represents all identifiers which are assigned to at some point in
        # the code
        self.declared_identifiers = set()
        # represents all identifiers which are referenced before their
        # assignment, if any
        self.undeclared_identifiers = set()
        # note that an identifier can be in both the undeclared and declared
        # lists.
        # using AST to parse instead of using code.co_varnames,
        # code.co_names has several advantages:
        # - we can locate an identifier as "undeclared" even if
        # its declared later in the same block of code
        # - AST is less likely to break with version changes
        # (for example, the behavior of co_names changed a little bit
        # in python version 2.5)
        if isinstance(code, str):
            expr = pyparser.parse(code.lstrip(), "exec", **exception_kwargs)
        else:
            expr = code
        f = pyparser.FindIdentifiers(self, **exception_kwargs)
        f.visit(expr)
class ArgumentList:
    """parses a fragment of code as a comma-separated list of expressions"""
    def __init__(self, code, **exception_kwargs):
        self.codeargs = []
        self.args = []
        self.declared_identifiers = set()
        self.undeclared_identifiers = set()
        if isinstance(code, str):
            if re.match(r"\S", code) and not re.match(r",\s*$", code):
                # if theres text and no trailing comma, insure its parsed
...(truncado)

===== ./venv/lib/python3.13/site-packages/mako/exceptions.py =====
"""exception classes"""
import sys
import traceback
from mako import compat
from mako import util
class MakoException(Exception):
    pass
class RuntimeException(MakoException):
    pass
def _format_filepos(lineno, pos, filename):
    if filename is None:
        return " at line: %d char: %d" % (lineno, pos)
    else:
        return " in file '%s' at line: %d char: %d" % (filename, lineno, pos)
class CompileException(MakoException):
    def __init__(self, message, source, lineno, pos, filename):
        MakoException.__init__(
            self, message + _format_filepos(lineno, pos, filename)
        )
        self.lineno = lineno
        self.pos = pos
        self.filename = filename
        self.source = source
class SyntaxException(MakoException):
    def __init__(self, message, source, lineno, pos, filename):
        MakoException.__init__(
            self, message + _format_filepos(lineno, pos, filename)
        )
        self.lineno = lineno
        self.pos = pos
        self.filename = filename
        self.source = source
class UnsupportedError(MakoException):
    """raised when a retired feature is used."""
class NameConflictError(MakoException):
    """raised when a reserved word is used inappropriately"""
class TemplateLookupException(MakoException):
    pass
class TopLevelLookupException(TemplateLookupException):
    pass
...(truncado)

===== ./venv/lib/python3.13/site-packages/mako/parsetree.py =====
"""defines the parse tree components for Mako templates."""
import re
from mako import ast
from mako import exceptions
from mako import filters
from mako import util
class Node:
    """base class for a Node in the parse tree."""
    def __init__(self, source, lineno, pos, filename):
        self.source = source
        self.lineno = lineno
        self.pos = pos
        self.filename = filename
    @property
    def exception_kwargs(self):
        return {
            "source": self.source,
            "lineno": self.lineno,
            "pos": self.pos,
            "filename": self.filename,
        }
    def get_children(self):
        return []
    def accept_visitor(self, visitor):
        def traverse(node):
            for n in node.get_children():
                n.accept_visitor(visitor)
        method = getattr(visitor, "visit" + self.__class__.__name__, traverse)
        method(self)
class TemplateNode(Node):
    """a 'container' node that stores the overall collection of nodes."""
    def __init__(self, filename):
        super().__init__("", 0, 0, filename)
        self.nodes = []
        self.page_attributes = {}
    def get_children(self):
        return self.nodes
    def __repr__(self):
        return "TemplateNode(%s, %r)" % (
            util.sorted_dict_repr(self.page_attributes),
...(truncado)

===== ./venv/lib/python3.13/site-packages/mako/codegen.py =====
"""provides functionality for rendering a parsetree constructing into module
source code."""
import json
import re
import time
from mako import ast
from mako import exceptions
from mako import filters
from mako import parsetree
from mako import util
from mako.pygen import PythonPrinter
MAGIC_NUMBER = 10
TOPLEVEL_DECLARED = {"UNDEFINED", "STOP_RENDERING"}
RESERVED_NAMES = {"context", "loop"}.union(TOPLEVEL_DECLARED)
def compile(  # noqa
    node,
    uri,
    filename=None,
    default_filters=None,
    buffer_filters=None,
    imports=None,
    future_imports=None,
    source_encoding=None,
    generate_magic_comment=True,
    strict_undefined=False,
    enable_loop=True,
    reserved_names=frozenset(),
):
    """Generate module source code given a parsetree node,
    uri, and optional source filename"""
    buf = util.FastEncodingBuffer()
    printer = PythonPrinter(buf)
    _GenerateRenderMethod(
        printer,
        _CompileContext(
            uri,
            filename,
            default_filters,
            buffer_filters,
            imports,
...(truncado)

===== ./venv/lib/python3.13/site-packages/mako/filters.py =====
import codecs
from html.entities import codepoint2name
from html.entities import name2codepoint
import re
from urllib.parse import quote_plus
import markupsafe
html_escape = markupsafe.escape
xml_escapes = {
    "&": "&amp;",
    ">": "&gt;",
    "<": "&lt;",
    '"': "&#34;",  # also &quot; in html-only
    "'": "&#39;",  # also &apos; in html-only
}
def xml_escape(string):
    return re.sub(r'([&<"\'>])', lambda m: xml_escapes[m.group()], string)
def url_escape(string):
    # convert into a list of octets
    string = string.encode("utf8")
    return quote_plus(string)
def trim(string):
    return string.strip()
class Decode:
    def __getattr__(self, key):
        def decode(x):
            if isinstance(x, str):
                return x
            elif not isinstance(x, bytes):
                return decode(str(x))
            else:
                return str(x, encoding=key)
        return decode
decode = Decode()
class XMLEntityEscaper:
    def __init__(self, codepoint2name, name2codepoint):
        self.codepoint2entity = {
            c: str("&%s;" % n) for c, n in codepoint2name.items()
        }
        self.name2codepoint = name2codepoint
    def escape_entities(self, text):
...(truncado)

===== ./venv/lib/python3.13/site-packages/mako/pygen.py =====
"""utilities for generating and formatting literal Python code."""
import re
from mako import exceptions
class PythonPrinter:
    def __init__(self, stream):
        # indentation counter
        self.indent = 0
        # a stack storing information about why we incremented
        # the indentation counter, to help us determine if we
        # should decrement it
        self.indent_detail = []
        # the string of whitespace multiplied by the indent
        # counter to produce a line
        self.indentstring = "    "
        # the stream we are writing to
        self.stream = stream
        # current line number
        self.lineno = 1
        # a list of lines that represents a buffered "block" of code,
        # which can be later printed relative to an indent level
        self.line_buffer = []
        self.in_indent_lines = False
        self._reset_multi_line_flags()
        # mapping of generated python lines to template
        # source lines
        self.source_map = {}
        self._re_space_comment = re.compile(r"^\s*#")
        self._re_space = re.compile(r"^\s*$")
        self._re_indent = re.compile(r":[ \t]*(?:#.*)?$")
        self._re_compound = re.compile(r"^\s*(if|try|elif|while|for|with)")
        self._re_indent_keyword = re.compile(
            r"^\s*(def|class|else|elif|except|finally)"
        )
        self._re_unindentor = re.compile(r"^\s*(else|elif|except|finally).*\:")
    def _update_lineno(self, num):
        self.lineno += num
    def start_source(self, lineno):
        if self.lineno not in self.source_map:
            self.source_map[self.lineno] = lineno
    def write_blanks(self, num):
...(truncado)

===== ./venv/lib/python3.13/site-packages/jinja2/compiler.py =====
"""Compiles nodes from the parser into Python code."""
import typing as t
from contextlib import contextmanager
from functools import update_wrapper
from io import StringIO
from itertools import chain
from keyword import iskeyword as is_python_keyword
from markupsafe import escape
from markupsafe import Markup
from . import nodes
from .exceptions import TemplateAssertionError
from .idtracking import Symbols
from .idtracking import VAR_LOAD_ALIAS
from .idtracking import VAR_LOAD_PARAMETER
from .idtracking import VAR_LOAD_RESOLVE
from .idtracking import VAR_LOAD_UNDEFINED
from .nodes import EvalContext
from .optimizer import Optimizer
from .utils import _PassArg
from .utils import concat
from .visitor import NodeVisitor
if t.TYPE_CHECKING:
    import typing_extensions as te
    from .environment import Environment
F = t.TypeVar("F", bound=t.Callable[..., t.Any])
operators = {
    "eq": "==",
    "ne": "!=",
    "gt": ">",
    "gteq": ">=",
    "lt": "<",
    "lteq": "<=",
    "in": "in",
    "notin": "not in",
}
def optimizeconst(f: F) -> F:
    def new_func(
        self: "CodeGenerator", node: nodes.Expr, frame: "Frame", **kwargs: t.Any
    ) -> t.Any:
        # Only optimize if the frame is not volatile
...(truncado)

===== ./venv/lib/python3.13/site-packages/jinja2/async_utils.py =====
import inspect
import typing as t
from functools import WRAPPER_ASSIGNMENTS
from functools import wraps
from .utils import _PassArg
from .utils import pass_eval_context
if t.TYPE_CHECKING:
    import typing_extensions as te
V = t.TypeVar("V")
def async_variant(normal_func):  # type: ignore
    def decorator(async_func):  # type: ignore
        pass_arg = _PassArg.from_obj(normal_func)
        need_eval_context = pass_arg is None
        if pass_arg is _PassArg.environment:
            def is_async(args: t.Any) -> bool:
                return t.cast(bool, args[0].is_async)
        else:
            def is_async(args: t.Any) -> bool:
                return t.cast(bool, args[0].environment.is_async)
        # Take the doc and annotations from the sync function, but the
        # name from the async function. Pallets-Sphinx-Themes
        # build_function_directive expects __wrapped__ to point to the
        # sync function.
        async_func_attrs = ("__module__", "__name__", "__qualname__")
        normal_func_attrs = tuple(set(WRAPPER_ASSIGNMENTS).difference(async_func_attrs))
        @wraps(normal_func, assigned=normal_func_attrs)
        @wraps(async_func, assigned=async_func_attrs, updated=())
        def wrapper(*args, **kwargs):  # type: ignore
            b = is_async(args)
            if need_eval_context:
                args = args[1:]
            if b:
                return async_func(*args, **kwargs)
            return normal_func(*args, **kwargs)
        if need_eval_context:
            wrapper = pass_eval_context(wrapper)
        wrapper.jinja_async_variant = True  # type: ignore[attr-defined]
        return wrapper
    return decorator
_common_primitives = {int, float, bool, str, list, dict, tuple, type(None)}
...(truncado)

===== ./venv/lib/python3.13/site-packages/jinja2/constants.py =====
LOREM_IPSUM_WORDS = """\
a ac accumsan ad adipiscing aenean aliquam aliquet amet ante aptent arcu at
auctor augue bibendum blandit class commodo condimentum congue consectetuer
consequat conubia convallis cras cubilia cum curabitur curae cursus dapibus
diam dictum dictumst dignissim dis dolor donec dui duis egestas eget eleifend
elementum elit enim erat eros est et etiam eu euismod facilisi facilisis fames
faucibus felis fermentum feugiat fringilla fusce gravida habitant habitasse hac
hendrerit hymenaeos iaculis id imperdiet in inceptos integer interdum ipsum
justo lacinia lacus laoreet lectus leo libero ligula litora lobortis lorem
luctus maecenas magna magnis malesuada massa mattis mauris metus mi molestie
mollis montes morbi mus nam nascetur natoque nec neque netus nibh nisi nisl non
nonummy nostra nulla nullam nunc odio orci ornare parturient pede pellentesque
penatibus per pharetra phasellus placerat platea porta porttitor posuere
potenti praesent pretium primis proin pulvinar purus quam quis quisque rhoncus
ridiculus risus rutrum sagittis sapien scelerisque sed sem semper senectus sit
sociis sociosqu sodales sollicitudin suscipit suspendisse taciti tellus tempor
tempus tincidunt torquent tortor tristique turpis ullamcorper ultrices
ultricies urna ut varius vehicula vel velit venenatis vestibulum vitae vivamus
viverra volutpat vulputate"""
...(truncado)

===== ./venv/lib/python3.13/site-packages/jinja2/loaders.py =====
"""API and implementations for loading templates from different data
sources.
"""
import importlib.util
import os
import posixpath
import sys
import typing as t
import weakref
import zipimport
from collections import abc
from hashlib import sha1
from importlib import import_module
from types import ModuleType
from .exceptions import TemplateNotFound
from .utils import internalcode
if t.TYPE_CHECKING:
    from .environment import Environment
    from .environment import Template
def split_template_path(template: str) -> t.List[str]:
    """Split a path into segments and perform a sanity check.  If it detects
    '..' in the path it will raise a `TemplateNotFound` error.
    """
    pieces = []
    for piece in template.split("/"):
        if (
            os.path.sep in piece
            or (os.path.altsep and os.path.altsep in piece)
            or piece == os.path.pardir
        ):
            raise TemplateNotFound(template)
        elif piece and piece != ".":
            pieces.append(piece)
    return pieces
class BaseLoader:
    """Baseclass for all loaders.  Subclass this and override `get_source` to
    implement a custom loading mechanism.  The environment provides a
    `get_template` method that calls the loader's `load` method to get the
    :class:`Template` object.
    A very basic example for a loader that looks up templates on the file
...(truncado)

===== ./venv/lib/python3.13/site-packages/jinja2/__init__.py =====
"""Jinja is a template engine written in pure Python. It provides a
non-XML syntax that supports inline expressions and an optional
sandboxed environment.
"""
from .bccache import BytecodeCache as BytecodeCache
from .bccache import FileSystemBytecodeCache as FileSystemBytecodeCache
from .bccache import MemcachedBytecodeCache as MemcachedBytecodeCache
from .environment import Environment as Environment
from .environment import Template as Template
from .exceptions import TemplateAssertionError as TemplateAssertionError
from .exceptions import TemplateError as TemplateError
from .exceptions import TemplateNotFound as TemplateNotFound
from .exceptions import TemplateRuntimeError as TemplateRuntimeError
from .exceptions import TemplatesNotFound as TemplatesNotFound
from .exceptions import TemplateSyntaxError as TemplateSyntaxError
from .exceptions import UndefinedError as UndefinedError
from .loaders import BaseLoader as BaseLoader
from .loaders import ChoiceLoader as ChoiceLoader
from .loaders import DictLoader as DictLoader
from .loaders import FileSystemLoader as FileSystemLoader
from .loaders import FunctionLoader as FunctionLoader
from .loaders import ModuleLoader as ModuleLoader
from .loaders import PackageLoader as PackageLoader
from .loaders import PrefixLoader as PrefixLoader
from .runtime import ChainableUndefined as ChainableUndefined
from .runtime import DebugUndefined as DebugUndefined
from .runtime import make_logging_undefined as make_logging_undefined
from .runtime import StrictUndefined as StrictUndefined
from .runtime import Undefined as Undefined
from .utils import clear_caches as clear_caches
from .utils import is_undefined as is_undefined
from .utils import pass_context as pass_context
from .utils import pass_environment as pass_environment
from .utils import pass_eval_context as pass_eval_context
from .utils import select_autoescape as select_autoescape
__version__ = "3.1.6"
...(truncado)

===== ./venv/lib/python3.13/site-packages/jinja2/idtracking.py =====
import typing as t
from . import nodes
from .visitor import NodeVisitor
if t.TYPE_CHECKING:
    import typing_extensions as te
VAR_LOAD_PARAMETER = "param"
VAR_LOAD_RESOLVE = "resolve"
VAR_LOAD_ALIAS = "alias"
VAR_LOAD_UNDEFINED = "undefined"
def find_symbols(
    nodes: t.Iterable[nodes.Node], parent_symbols: t.Optional["Symbols"] = None
) -> "Symbols":
    sym = Symbols(parent=parent_symbols)
    visitor = FrameSymbolVisitor(sym)
    for node in nodes:
        visitor.visit(node)
    return sym
def symbols_for_node(
    node: nodes.Node, parent_symbols: t.Optional["Symbols"] = None
) -> "Symbols":
    sym = Symbols(parent=parent_symbols)
    sym.analyze_node(node)
    return sym
class Symbols:
    def __init__(
        self, parent: t.Optional["Symbols"] = None, level: t.Optional[int] = None
    ) -> None:
        if level is None:
            if parent is None:
                level = 0
            else:
                level = parent.level + 1
        self.level: int = level
        self.parent = parent
        self.refs: t.Dict[str, str] = {}
        self.loads: t.Dict[str, t.Any] = {}
        self.stores: t.Set[str] = set()
    def analyze_node(self, node: nodes.Node, **kwargs: t.Any) -> None:
        visitor = RootVisitor(self)
        visitor.visit(node, **kwargs)
...(truncado)

===== ./venv/lib/python3.13/site-packages/jinja2/runtime.py =====
"""The runtime functions and state used by compiled templates."""
import functools
import sys
import typing as t
from collections import abc
from itertools import chain
from markupsafe import escape  # noqa: F401
from markupsafe import Markup
from markupsafe import soft_str
from .async_utils import auto_aiter
from .async_utils import auto_await  # noqa: F401
from .exceptions import TemplateNotFound  # noqa: F401
from .exceptions import TemplateRuntimeError  # noqa: F401
from .exceptions import UndefinedError
from .nodes import EvalContext
from .utils import _PassArg
from .utils import concat
from .utils import internalcode
from .utils import missing
from .utils import Namespace  # noqa: F401
from .utils import object_type_repr
from .utils import pass_eval_context
V = t.TypeVar("V")
F = t.TypeVar("F", bound=t.Callable[..., t.Any])
if t.TYPE_CHECKING:
    import logging
    import typing_extensions as te
    from .environment import Environment
    class LoopRenderFunc(te.Protocol):
        def __call__(
            self,
            reciter: t.Iterable[V],
            loop_render_func: "LoopRenderFunc",
            depth: int = 0,
        ) -> str: ...
exported = [
    "LoopContext",
    "TemplateReference",
    "Macro",
    "Markup",
...(truncado)

===== ./venv/lib/python3.13/site-packages/jinja2/parser.py =====
"""Parse tokens from the lexer into nodes for the compiler."""
import typing
import typing as t
from . import nodes
from .exceptions import TemplateAssertionError
from .exceptions import TemplateSyntaxError
from .lexer import describe_token
from .lexer import describe_token_expr
if t.TYPE_CHECKING:
    import typing_extensions as te
    from .environment import Environment
_ImportInclude = t.TypeVar("_ImportInclude", nodes.Import, nodes.Include)
_MacroCall = t.TypeVar("_MacroCall", nodes.Macro, nodes.CallBlock)
_statement_keywords = frozenset(
    [
        "for",
        "if",
        "block",
        "extends",
        "print",
        "macro",
        "include",
        "from",
        "import",
        "set",
        "with",
        "autoescape",
    ]
)
_compare_operators = frozenset(["eq", "ne", "lt", "lteq", "gt", "gteq"])
_math_nodes: t.Dict[str, t.Type[nodes.Expr]] = {
    "add": nodes.Add,
    "sub": nodes.Sub,
    "mul": nodes.Mul,
    "div": nodes.Div,
    "floordiv": nodes.FloorDiv,
    "mod": nodes.Mod,
}
class Parser:
    """This is the central parsing class Jinja uses.  It's passed to
...(truncado)

===== ./venv/lib/python3.13/site-packages/jinja2/sandbox.py =====
"""A sandbox layer that ensures unsafe operations cannot be performed.
Useful when the template itself comes from an untrusted source.
"""
import operator
import types
import typing as t
from _string import formatter_field_name_split  # type: ignore
from collections import abc
from collections import deque
from functools import update_wrapper
from string import Formatter
from markupsafe import EscapeFormatter
from markupsafe import Markup
from .environment import Environment
from .exceptions import SecurityError
from .runtime import Context
from .runtime import Undefined
F = t.TypeVar("F", bound=t.Callable[..., t.Any])
MAX_RANGE = 100000
UNSAFE_FUNCTION_ATTRIBUTES: t.Set[str] = set()
UNSAFE_METHOD_ATTRIBUTES: t.Set[str] = set()
UNSAFE_GENERATOR_ATTRIBUTES = {"gi_frame", "gi_code"}
UNSAFE_COROUTINE_ATTRIBUTES = {"cr_frame", "cr_code"}
UNSAFE_ASYNC_GENERATOR_ATTRIBUTES = {"ag_code", "ag_frame"}
_mutable_spec: t.Tuple[t.Tuple[t.Type[t.Any], t.FrozenSet[str]], ...] = (
    (
        abc.MutableSet,
        frozenset(
            [
                "add",
                "clear",
                "difference_update",
                "discard",
                "pop",
                "remove",
                "symmetric_difference_update",
                "update",
            ]
        ),
    ),
...(truncado)

===== ./venv/lib/python3.13/site-packages/jinja2/visitor.py =====
"""API for traversing the AST nodes. Implemented by the compiler and
meta introspection.
"""
import typing as t
from .nodes import Node
if t.TYPE_CHECKING:
    import typing_extensions as te
    class VisitCallable(te.Protocol):
        def __call__(self, node: Node, *args: t.Any, **kwargs: t.Any) -> t.Any: ...
class NodeVisitor:
    """Walks the abstract syntax tree and call visitor functions for every
    node found.  The visitor functions may return values which will be
    forwarded by the `visit` method.
    Per default the visitor functions for the nodes are ``'visit_'`` +
    class name of the node.  So a `TryFinally` node visit function would
    be `visit_TryFinally`.  This behavior can be changed by overriding
    the `get_visitor` function.  If no visitor function exists for a node
    (return value `None`) the `generic_visit` visitor is used instead.
    """
    def get_visitor(self, node: Node) -> "t.Optional[VisitCallable]":
        """Return the visitor function for this node or `None` if no visitor
        exists for this node.  In that case the generic visit function is
        used instead.
        """
        return getattr(self, f"visit_{type(node).__name__}", None)
    def visit(self, node: Node, *args: t.Any, **kwargs: t.Any) -> t.Any:
        """Visit a node."""
        f = self.get_visitor(node)
        if f is not None:
            return f(node, *args, **kwargs)
        return self.generic_visit(node, *args, **kwargs)
    def generic_visit(self, node: Node, *args: t.Any, **kwargs: t.Any) -> t.Any:
        """Called if no explicit visitor function exists for a node."""
        for child_node in node.iter_child_nodes():
            self.visit(child_node, *args, **kwargs)
class NodeTransformer(NodeVisitor):
    """Walks the abstract syntax tree and allows modifications of nodes.
    The `NodeTransformer` will walk the AST and use the return value of the
    visitor functions to replace or remove the old node.  If the return
    value of the visitor function is `None` the node will be removed
...(truncado)

===== ./venv/lib/python3.13/site-packages/jinja2/utils.py =====
import enum
import json
import os
import re
import typing as t
from collections import abc
from collections import deque
from random import choice
from random import randrange
from threading import Lock
from types import CodeType
from urllib.parse import quote_from_bytes
import markupsafe
if t.TYPE_CHECKING:
    import typing_extensions as te
F = t.TypeVar("F", bound=t.Callable[..., t.Any])
class _MissingType:
    def __repr__(self) -> str:
        return "missing"
    def __reduce__(self) -> str:
        return "missing"
missing: t.Any = _MissingType()
"""Special singleton representing missing values for the runtime."""
internal_code: t.MutableSet[CodeType] = set()
concat = "".join
def pass_context(f: F) -> F:
    """Pass the :class:`~jinja2.runtime.Context` as the first argument
    to the decorated function when called while rendering a template.
    Can be used on functions, filters, and tests.
    If only ``Context.eval_context`` is needed, use
    :func:`pass_eval_context`. If only ``Context.environment`` is
    needed, use :func:`pass_environment`.
    .. versionadded:: 3.0.0
        Replaces ``contextfunction`` and ``contextfilter``.
    """
    f.jinja_pass_arg = _PassArg.context  # type: ignore
    return f
def pass_eval_context(f: F) -> F:
    """Pass the :class:`~jinja2.nodes.EvalContext` as the first argument
    to the decorated function when called while rendering a template.
...(truncado)

===== ./venv/lib/python3.13/site-packages/jinja2/debug.py =====
import sys
import typing as t
from types import CodeType
from types import TracebackType
from .exceptions import TemplateSyntaxError
from .utils import internal_code
from .utils import missing
if t.TYPE_CHECKING:
    from .runtime import Context
def rewrite_traceback_stack(source: t.Optional[str] = None) -> BaseException:
    """Rewrite the current exception to replace any tracebacks from
    within compiled template code with tracebacks that look like they
    came from the template source.
    This must be called within an ``except`` block.
    :param source: For ``TemplateSyntaxError``, the original source if
        known.
    :return: The original exception with the rewritten traceback.
    """
    _, exc_value, tb = sys.exc_info()
    exc_value = t.cast(BaseException, exc_value)
    tb = t.cast(TracebackType, tb)
    if isinstance(exc_value, TemplateSyntaxError) and not exc_value.translated:
        exc_value.translated = True
        exc_value.source = source
        # Remove the old traceback, otherwise the frames from the
        # compiler still show up.
        exc_value.with_traceback(None)
        # Outside of runtime, so the frame isn't executing template
        # code, but it still needs to point at the template.
        tb = fake_traceback(
            exc_value, None, exc_value.filename or "<unknown>", exc_value.lineno
        )
    else:
        # Skip the frame for the render function.
        tb = tb.tb_next
    stack = []
    # Build the stack of traceback object, replacing any in template
    # code with the source file and line information.
    while tb is not None:
        # Skip frames decorated with @internalcode. These are internal
...(truncado)

===== ./venv/lib/python3.13/site-packages/jinja2/lexer.py =====
"""Implements a Jinja / Python combination lexer. The ``Lexer`` class
is used to do some preprocessing. It filters out invalid operators like
the bitshift operators we don't allow in templates. It separates
template code and python code in expressions.
"""
import re
import typing as t
from ast import literal_eval
from collections import deque
from sys import intern
from ._identifier import pattern as name_re
from .exceptions import TemplateSyntaxError
from .utils import LRUCache
if t.TYPE_CHECKING:
    import typing_extensions as te
    from .environment import Environment
_lexer_cache: t.MutableMapping[t.Tuple, "Lexer"] = LRUCache(50)  # type: ignore
whitespace_re = re.compile(r"\s+")
newline_re = re.compile(r"(\r\n|\r|\n)")
string_re = re.compile(
    r"('([^'\\]*(?:\\.[^'\\]*)*)'" r'|"([^"\\]*(?:\\.[^"\\]*)*)")', re.S
)
integer_re = re.compile(
    r"""
    (
        0b(_?[0-1])+ # binary
    |
        0o(_?[0-7])+ # octal
    |
        0x(_?[\da-f])+ # hex
    |
        [1-9](_?\d)* # decimal
    |
        0(_?0)* # decimal zero
    )
    """,
    re.IGNORECASE | re.VERBOSE,
)
float_re = re.compile(
    r"""
...(truncado)

===== ./venv/lib/python3.13/site-packages/jinja2/environment.py =====
"""Classes for managing templates and their runtime and compile time
options.
"""
import os
import typing
import typing as t
import weakref
from collections import ChainMap
from functools import lru_cache
from functools import partial
from functools import reduce
from types import CodeType
from markupsafe import Markup
from . import nodes
from .compiler import CodeGenerator
from .compiler import generate
from .defaults import BLOCK_END_STRING
from .defaults import BLOCK_START_STRING
from .defaults import COMMENT_END_STRING
from .defaults import COMMENT_START_STRING
from .defaults import DEFAULT_FILTERS  # type: ignore[attr-defined]
from .defaults import DEFAULT_NAMESPACE
from .defaults import DEFAULT_POLICIES
from .defaults import DEFAULT_TESTS  # type: ignore[attr-defined]
from .defaults import KEEP_TRAILING_NEWLINE
from .defaults import LINE_COMMENT_PREFIX
from .defaults import LINE_STATEMENT_PREFIX
from .defaults import LSTRIP_BLOCKS
from .defaults import NEWLINE_SEQUENCE
from .defaults import TRIM_BLOCKS
from .defaults import VARIABLE_END_STRING
from .defaults import VARIABLE_START_STRING
from .exceptions import TemplateNotFound
from .exceptions import TemplateRuntimeError
from .exceptions import TemplatesNotFound
from .exceptions import TemplateSyntaxError
from .exceptions import UndefinedError
from .lexer import get_lexer
from .lexer import Lexer
from .lexer import TokenStream
...(truncado)

===== ./venv/lib/python3.13/site-packages/jinja2/_identifier.py =====
import re
pattern = re.compile(
    r"[\w·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-ٰٟۖ-ۜ۟-۪ۤۧۨ-ܑۭܰ-݊ަ-ް߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࣓-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣঁ-ঃ়া-ৄেৈো-্ৗৢৣ৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑੰੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍ୖୗୢୣஂா-ூெ-ைொ-்ௗఀ-ఄా-ౄె-ైొ-్ౕౖౢౣಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣංඃ්ා-ුූෘ-ෟෲෳัิ-ฺ็-๎ັິ-ູົຼ່-ໍ༹༘༙༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏႚ-ႝ፝-፟ᜒ-᜔ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝᠋-᠍ᢅᢆᢩᤠ-ᤫᤰ-᤻ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼᪰-᪽ᬀ-ᬄ᬴-᭄᭫-᭳ᮀ-ᮂᮡ-ᮭ᯦-᯳ᰤ-᰷᳐-᳔᳒-᳨᳭ᳲ-᳴᳷-᳹᷀-᷹᷻-᷿‿⁀⁔⃐-⃥⃜⃡-⃰℘℮⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧꢀꢁꢴ-ꣅ꣠-꣱ꣿꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀ꧥꨩ-ꨶꩃꩌꩍꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭ﬞ︀-️︠-︯︳︴﹍-﹏＿𐇽𐋠𐍶-𐍺𐨁-𐨃𐨅𐨆𐨌-𐨏𐨸-𐨿𐨺𐫦𐫥𐴤-𐽆𐴧-𐽐𑀀-𑀂𑀸-𑁆𑁿-𑂂𑂰-𑂺𑄀-𑄂𑄧-𑄴𑅅𑅆𑅳𑆀-𑆂𑆳-𑇀𑇉-𑇌𑈬-𑈷𑈾𑋟-𑋪𑌀-𑌃𑌻𑌼𑌾-𑍄𑍇𑍈𑍋-𑍍𑍗𑍢𑍣𑍦-𑍬𑍰-𑍴𑐵-𑑆𑑞𑒰-𑓃𑖯-𑖵𑖸-𑗀𑗜𑗝𑘰-𑙀𑚫-𑚷𑜝-𑜫𑠬-𑠺𑨁-𑨊𑨳-𑨹𑨻-𑨾𑩇𑩑-𑩛𑪊-𑪙𑰯-𑰶𑰸-𑰿𑲒-𑲧𑲩-𑲶𑴱-𑴶𑴺𑴼𑴽𑴿-𑵅𑵇𑶊-𑶎𑶐𑶑𑶓-𑶗𑻳-𑻶𖫰-𖫴𖬰-𖬶𖽑-𖽾𖾏-𖾒𛲝𛲞𝅥-𝅩𝅭-𝅲𝅻-𝆂𝆅-𝆋𝆪-𝆭𝉂-𝉄𝨀-𝨶𝨻-𝩬𝩵𝪄𝪛-𝪟𝪡-𝪯𞀀-𞀆𞀈-𞀘𞀛-𞀡𞀣𞀤𞀦-𞣐𞀪-𞣖𞥄-𞥊󠄀-󠇯]+"  # noqa: B950
)
...(truncado)

===== ./venv/lib/python3.13/site-packages/jinja2/optimizer.py =====
"""The optimizer tries to constant fold expressions and modify the AST
in place so that it should be faster to evaluate.
Because the AST does not contain all the scoping information and the
compiler has to find that out, we cannot do all the optimizations we
want. For example, loop unrolling doesn't work because unrolled loops
would have a different scope. The solution would be a second syntax tree
that stored the scoping rules.
"""
import typing as t
from . import nodes
from .visitor import NodeTransformer
if t.TYPE_CHECKING:
    from .environment import Environment
def optimize(node: nodes.Node, environment: "Environment") -> nodes.Node:
    """The context hint can be used to perform an static optimization
    based on the context given."""
    optimizer = Optimizer(environment)
    return t.cast(nodes.Node, optimizer.visit(node))
class Optimizer(NodeTransformer):
    def __init__(self, environment: "t.Optional[Environment]") -> None:
        self.environment = environment
    def generic_visit(
        self, node: nodes.Node, *args: t.Any, **kwargs: t.Any
    ) -> nodes.Node:
        node = super().generic_visit(node, *args, **kwargs)
        # Do constant folding. Some other nodes besides Expr have
        # as_const, but folding them causes errors later on.
        if isinstance(node, nodes.Expr):
            try:
                return nodes.Const.from_untrusted(
                    node.as_const(args[0] if args else None),
                    lineno=node.lineno,
                    environment=self.environment,
                )
            except nodes.Impossible:
                pass
        return node
...(truncado)

===== ./venv/lib/python3.13/site-packages/jinja2/exceptions.py =====
import typing as t
if t.TYPE_CHECKING:
    from .runtime import Undefined
class TemplateError(Exception):
    """Baseclass for all template errors."""
    def __init__(self, message: t.Optional[str] = None) -> None:
        super().__init__(message)
    @property
    def message(self) -> t.Optional[str]:
        return self.args[0] if self.args else None
class TemplateNotFound(IOError, LookupError, TemplateError):
    """Raised if a template does not exist.
    .. versionchanged:: 2.11
        If the given name is :class:`Undefined` and no message was
        provided, an :exc:`UndefinedError` is raised.
    """
    # Silence the Python warning about message being deprecated since
    # it's not valid here.
    message: t.Optional[str] = None
    def __init__(
        self,
        name: t.Optional[t.Union[str, "Undefined"]],
        message: t.Optional[str] = None,
    ) -> None:
        IOError.__init__(self, name)
        if message is None:
            from .runtime import Undefined
            if isinstance(name, Undefined):
                name._fail_with_undefined_error()
            message = name
        self.message = message
        self.name = name
        self.templates = [name]
    def __str__(self) -> str:
        return str(self.message)
class TemplatesNotFound(TemplateNotFound):
    """Like :class:`TemplateNotFound` but raised if multiple templates
    are selected.  This is a subclass of :class:`TemplateNotFound`
    exception, so just catching the base exception will catch both.
    .. versionchanged:: 2.11
...(truncado)

===== ./venv/lib/python3.13/site-packages/jinja2/defaults.py =====
import typing as t
from .filters import FILTERS as DEFAULT_FILTERS  # noqa: F401
from .tests import TESTS as DEFAULT_TESTS  # noqa: F401
from .utils import Cycler
from .utils import generate_lorem_ipsum
from .utils import Joiner
from .utils import Namespace
if t.TYPE_CHECKING:
    import typing_extensions as te
BLOCK_START_STRING = "{%"
BLOCK_END_STRING = "%}"
VARIABLE_START_STRING = "{{"
VARIABLE_END_STRING = "}}"
COMMENT_START_STRING = "{#"
COMMENT_END_STRING = "#}"
LINE_STATEMENT_PREFIX: t.Optional[str] = None
LINE_COMMENT_PREFIX: t.Optional[str] = None
TRIM_BLOCKS = False
LSTRIP_BLOCKS = False
NEWLINE_SEQUENCE: "te.Literal['\\n', '\\r\\n', '\\r']" = "\n"
KEEP_TRAILING_NEWLINE = False
DEFAULT_NAMESPACE = {
    "range": range,
    "dict": dict,
    "lipsum": generate_lorem_ipsum,
    "cycler": Cycler,
    "joiner": Joiner,
    "namespace": Namespace,
}
DEFAULT_POLICIES: t.Dict[str, t.Any] = {
    "compiler.ascii_str": True,
    "urlize.rel": "noopener",
    "urlize.target": None,
    "urlize.extra_schemes": None,
    "truncate.leeway": 5,
    "json.dumps_function": None,
    "json.dumps_kwargs": {"sort_keys": True},
    "ext.i18n.trimmed": False,
}
...(truncado)

===== ./venv/lib/python3.13/site-packages/jinja2/nativetypes.py =====
import typing as t
from ast import literal_eval
from ast import parse
from itertools import chain
from itertools import islice
from types import GeneratorType
from . import nodes
from .compiler import CodeGenerator
from .compiler import Frame
from .compiler import has_safe_repr
from .environment import Environment
from .environment import Template
def native_concat(values: t.Iterable[t.Any]) -> t.Optional[t.Any]:
    """Return a native Python type from the list of compiled nodes. If
    the result is a single node, its value is returned. Otherwise, the
    nodes are concatenated as strings. If the result can be parsed with
    :func:`ast.literal_eval`, the parsed value is returned. Otherwise,
    the string is returned.
    :param values: Iterable of outputs to concatenate.
    """
    head = list(islice(values, 2))
    if not head:
        return None
    if len(head) == 1:
        raw = head[0]
        if not isinstance(raw, str):
            return raw
    else:
        if isinstance(values, GeneratorType):
            values = chain(head, values)
        raw = "".join([str(v) for v in values])
    try:
        return literal_eval(
            # In Python 3.10+ ast.literal_eval removes leading spaces/tabs
            # from the given string. For backwards compatibility we need to
            # parse the string ourselves without removing leading spaces/tabs.
            parse(raw, mode="eval")
        )
    except (ValueError, SyntaxError, MemoryError):
        return raw
...(truncado)

===== ./venv/lib/python3.13/site-packages/jinja2/nodes.py =====
"""AST nodes generated by the parser for the compiler. Also provides
some node tree helper functions used by the parser and compiler in order
to normalize nodes.
"""
import inspect
import operator
import typing as t
from collections import deque
from markupsafe import Markup
from .utils import _PassArg
if t.TYPE_CHECKING:
    import typing_extensions as te
    from .environment import Environment
_NodeBound = t.TypeVar("_NodeBound", bound="Node")
_binop_to_func: t.Dict[str, t.Callable[[t.Any, t.Any], t.Any]] = {
    "*": operator.mul,
    "/": operator.truediv,
    "//": operator.floordiv,
    "**": operator.pow,
    "%": operator.mod,
    "+": operator.add,
    "-": operator.sub,
}
_uaop_to_func: t.Dict[str, t.Callable[[t.Any], t.Any]] = {
    "not": operator.not_,
    "+": operator.pos,
    "-": operator.neg,
}
_cmpop_to_func: t.Dict[str, t.Callable[[t.Any, t.Any], t.Any]] = {
    "eq": operator.eq,
    "ne": operator.ne,
    "gt": operator.gt,
    "gteq": operator.ge,
    "lt": operator.lt,
    "lteq": operator.le,
    "in": lambda a, b: a in b,
    "notin": lambda a, b: a not in b,
}
class Impossible(Exception):
    """Raised if the node could not perform a requested action."""
...(truncado)

===== ./venv/lib/python3.13/site-packages/jinja2/tests.py =====
"""Built-in template tests used with the ``is`` operator."""
import operator
import typing as t
from collections import abc
from numbers import Number
from .runtime import Undefined
from .utils import pass_environment
if t.TYPE_CHECKING:
    from .environment import Environment
def test_odd(value: int) -> bool:
    """Return true if the variable is odd."""
    return value % 2 == 1
def test_even(value: int) -> bool:
    """Return true if the variable is even."""
    return value % 2 == 0
def test_divisibleby(value: int, num: int) -> bool:
    """Check if a variable is divisible by a number."""
    return value % num == 0
def test_defined(value: t.Any) -> bool:
    """Return true if the variable is defined:
    .. sourcecode:: jinja
        {% if variable is defined %}
            value of variable: {{ variable }}
        {% else %}
            variable is not defined
        {% endif %}
    See the :func:`default` filter for a simple way to set undefined
    variables.
    """
    return not isinstance(value, Undefined)
def test_undefined(value: t.Any) -> bool:
    """Like :func:`defined` but the other way round."""
    return isinstance(value, Undefined)
@pass_environment
def test_filter(env: "Environment", value: str) -> bool:
    """Check if a filter exists by name. Useful if a filter may be
    optionally available.
    .. code-block:: jinja
        {% if 'markdown' is filter %}
            {{ value | markdown }}
...(truncado)

===== ./venv/lib/python3.13/site-packages/jinja2/bccache.py =====
"""The optional bytecode cache system. This is useful if you have very
complex template situations and the compilation of all those templates
slows down your application too much.
Situations where this is useful are often forking web applications that
are initialized on the first request.
"""
import errno
import fnmatch
import marshal
import os
import pickle
import stat
import sys
import tempfile
import typing as t
from hashlib import sha1
from io import BytesIO
from types import CodeType
if t.TYPE_CHECKING:
    import typing_extensions as te
    from .environment import Environment
    class _MemcachedClient(te.Protocol):
        def get(self, key: str) -> bytes: ...
        def set(
            self, key: str, value: bytes, timeout: t.Optional[int] = None
        ) -> None: ...
bc_version = 5
bc_magic = (
    b"j2"
    + pickle.dumps(bc_version, 2)
    + pickle.dumps((sys.version_info[0] << 24) | sys.version_info[1], 2)
)
class Bucket:
    """Buckets are used to store the bytecode for one template.  It's created
    and initialized by the bytecode cache and passed to the loading functions.
    The buckets get an internal checksum from the cache assigned and use this
    to automatically reject outdated cache material.  Individual bytecode
    cache subclasses don't have to care about cache invalidation.
    """
    def __init__(self, environment: "Environment", key: str, checksum: str) -> None:
...(truncado)

===== ./venv/lib/python3.13/site-packages/jinja2/filters.py =====
"""Built-in template filters used with the ``|`` operator."""
import math
import random
import re
import typing
import typing as t
from collections import abc
from inspect import getattr_static
from itertools import chain
from itertools import groupby
from markupsafe import escape
from markupsafe import Markup
from markupsafe import soft_str
from .async_utils import async_variant
from .async_utils import auto_aiter
from .async_utils import auto_await
from .async_utils import auto_to_list
from .exceptions import FilterArgumentError
from .runtime import Undefined
from .utils import htmlsafe_json_dumps
from .utils import pass_context
from .utils import pass_environment
from .utils import pass_eval_context
from .utils import pformat
from .utils import url_quote
from .utils import urlize
if t.TYPE_CHECKING:
    import typing_extensions as te
    from .environment import Environment
    from .nodes import EvalContext
    from .runtime import Context
    from .sandbox import SandboxedEnvironment  # noqa: F401
    class HasHTML(te.Protocol):
        def __html__(self) -> str:
            pass
F = t.TypeVar("F", bound=t.Callable[..., t.Any])
K = t.TypeVar("K")
V = t.TypeVar("V")
def ignore_case(value: V) -> V:
    """For use as a postprocessor for :func:`make_attrgetter`. Converts strings
...(truncado)

===== ./venv/lib/python3.13/site-packages/jinja2/ext.py =====
"""Extension API for adding custom tags and behavior."""
import pprint
import re
import typing as t
from markupsafe import Markup
from . import defaults
from . import nodes
from .environment import Environment
from .exceptions import TemplateAssertionError
from .exceptions import TemplateSyntaxError
from .runtime import concat  # type: ignore
from .runtime import Context
from .runtime import Undefined
from .utils import import_string
from .utils import pass_context
if t.TYPE_CHECKING:
    import typing_extensions as te
    from .lexer import Token
    from .lexer import TokenStream
    from .parser import Parser
    class _TranslationsBasic(te.Protocol):
        def gettext(self, message: str) -> str: ...
        def ngettext(self, singular: str, plural: str, n: int) -> str:
            pass
    class _TranslationsContext(_TranslationsBasic):
        def pgettext(self, context: str, message: str) -> str: ...
        def npgettext(
            self, context: str, singular: str, plural: str, n: int
        ) -> str: ...
    _SupportedTranslations = t.Union[_TranslationsBasic, _TranslationsContext]
GETTEXT_FUNCTIONS: t.Tuple[str, ...] = (
    "_",
    "gettext",
    "ngettext",
    "pgettext",
    "npgettext",
)
_ws_re = re.compile(r"\s*\n\s*")
class Extension:
    """Extensions can be used to add extra functionality to the Jinja template
...(truncado)

===== ./venv/lib/python3.13/site-packages/jinja2/meta.py =====
"""Functions that expose information about templates that might be
interesting for introspection.
"""
import typing as t
from . import nodes
from .compiler import CodeGenerator
from .compiler import Frame
if t.TYPE_CHECKING:
    from .environment import Environment
class TrackingCodeGenerator(CodeGenerator):
    """We abuse the code generator for introspection."""
    def __init__(self, environment: "Environment") -> None:
        super().__init__(environment, "<introspection>", "<introspection>")
        self.undeclared_identifiers: t.Set[str] = set()
    def write(self, x: str) -> None:
        """Don't write."""
    def enter_frame(self, frame: Frame) -> None:
        """Remember all undeclared identifiers."""
        super().enter_frame(frame)
        for _, (action, param) in frame.symbols.loads.items():
            if action == "resolve" and param not in self.environment.globals:
                self.undeclared_identifiers.add(param)
def find_undeclared_variables(ast: nodes.Template) -> t.Set[str]:
    """Returns a set of all variables in the AST that will be looked up from
    the context at runtime.  Because at compile time it's not known which
    variables will be used depending on the path the execution takes at
    runtime, all variables are returned.
    >>> from jinja2 import Environment, meta
    >>> env = Environment()
    >>> ast = env.parse('{% set foo = 42 %}{{ bar + foo }}')
    >>> meta.find_undeclared_variables(ast) == {'bar'}
    True
    .. admonition:: Implementation
       Internally the code generator is used for finding undeclared variables.
       This is good to know because the code generator might raise a
       :exc:`TemplateAssertionError` during compilation and as a matter of
       fact this function can currently raise that exception as well.
    """
    codegen = TrackingCodeGenerator(ast.environment)  # type: ignore
    codegen.visit(ast)
...(truncado)

===== ./venv/lib/python3.13/site-packages/flask_wtf/csrf.py =====
import hashlib
import hmac
import logging
import os
from urllib.parse import urlparse
from flask import Blueprint
from flask import current_app
from flask import g
from flask import request
from flask import session
from itsdangerous import BadData
from itsdangerous import SignatureExpired
from itsdangerous import URLSafeTimedSerializer
from werkzeug.exceptions import BadRequest
from wtforms import ValidationError
from wtforms.csrf.core import CSRF
__all__ = ("generate_csrf", "validate_csrf", "CSRFProtect")
logger = logging.getLogger(__name__)
def generate_csrf(secret_key=None, token_key=None):
    """Generate a CSRF token. The token is cached for a request, so multiple
    calls to this function will generate the same token.
    During testing, it might be useful to access the signed token in
    ``g.csrf_token`` and the raw token in ``session['csrf_token']``.
    :param secret_key: Used to securely sign the token. Default is
        ``WTF_CSRF_SECRET_KEY`` or ``SECRET_KEY``.
    :param token_key: Key where token is stored in session for comparison.
        Default is ``WTF_CSRF_FIELD_NAME`` or ``'csrf_token'``.
    """
    secret_key = _get_config(
        secret_key,
        "WTF_CSRF_SECRET_KEY",
        current_app.secret_key,
        message="A secret key is required to use CSRF.",
    )
    field_name = _get_config(
        token_key,
        "WTF_CSRF_FIELD_NAME",
        "csrf_token",
        message="A field name is required to use CSRF.",
    )
...(truncado)

===== ./venv/lib/python3.13/site-packages/flask_wtf/__init__.py =====
from .csrf import CSRFProtect
from .form import FlaskForm
from .form import Form
from .recaptcha import Recaptcha
from .recaptcha import RecaptchaField
from .recaptcha import RecaptchaWidget
__version__ = "1.2.2"
__all__ = [
    "CSRFProtect",
    "FlaskForm",
    "Form",
    "Recaptcha",
    "RecaptchaField",
    "RecaptchaWidget",
]
...(truncado)

===== ./venv/lib/python3.13/site-packages/flask_wtf/file.py =====
from collections import abc
from werkzeug.datastructures import FileStorage
from wtforms import FileField as _FileField
from wtforms import MultipleFileField as _MultipleFileField
from wtforms.validators import DataRequired
from wtforms.validators import StopValidation
from wtforms.validators import ValidationError
class FileField(_FileField):
    """Werkzeug-aware subclass of :class:`wtforms.fields.FileField`."""
    def process_formdata(self, valuelist):
        valuelist = (x for x in valuelist if isinstance(x, FileStorage) and x)
        data = next(valuelist, None)
        if data is not None:
            self.data = data
        else:
            self.raw_data = ()
class MultipleFileField(_MultipleFileField):
    """Werkzeug-aware subclass of :class:`wtforms.fields.MultipleFileField`.
    .. versionadded:: 1.2.0
    """
    def process_formdata(self, valuelist):
        valuelist = (x for x in valuelist if isinstance(x, FileStorage) and x)
        data = list(valuelist) or None
        if data is not None:
            self.data = data
        else:
            self.raw_data = ()
class FileRequired(DataRequired):
    """Validates that the uploaded files(s) is a Werkzeug
    :class:`~werkzeug.datastructures.FileStorage` object.
    :param message: error message
    You can also use the synonym ``file_required``.
    """
    def __call__(self, form, field):
        field_data = [field.data] if not isinstance(field.data, list) else field.data
        if not (
            all(isinstance(x, FileStorage) and x for x in field_data) and field_data
        ):
            raise StopValidation(
                self.message or field.gettext("This field is required.")
...(truncado)

===== ./venv/lib/python3.13/site-packages/flask_wtf/recaptcha/fields.py =====
from wtforms.fields import Field
from . import widgets
from .validators import Recaptcha
__all__ = ["RecaptchaField"]
class RecaptchaField(Field):
    widget = widgets.RecaptchaWidget()
    # error message if recaptcha validation fails
    recaptcha_error = None
    def __init__(self, label="", validators=None, **kwargs):
        validators = validators or [Recaptcha()]
        super().__init__(label, validators, **kwargs)
...(truncado)

===== ./venv/lib/python3.13/site-packages/flask_wtf/recaptcha/validators.py =====
import json
from urllib import request as http
from urllib.parse import urlencode
from flask import current_app
from flask import request
from wtforms import ValidationError
RECAPTCHA_VERIFY_SERVER_DEFAULT = "https://www.google.com/recaptcha/api/siteverify"
RECAPTCHA_ERROR_CODES = {
    "missing-input-secret": "The secret parameter is missing.",
    "invalid-input-secret": "The secret parameter is invalid or malformed.",
    "missing-input-response": "The response parameter is missing.",
    "invalid-input-response": "The response parameter is invalid or malformed.",
}
__all__ = ["Recaptcha"]
class Recaptcha:
    """Validates a ReCaptcha."""
    def __init__(self, message=None):
        if message is None:
            message = RECAPTCHA_ERROR_CODES["missing-input-response"]
        self.message = message
    def __call__(self, form, field):
        if current_app.testing:
            return True
        if request.is_json:
            response = request.json.get("g-recaptcha-response", "")
        else:
            response = request.form.get("g-recaptcha-response", "")
        remote_ip = request.remote_addr
        if not response:
            raise ValidationError(field.gettext(self.message))
        if not self._validate_recaptcha(response, remote_ip):
            field.recaptcha_error = "incorrect-captcha-sol"
            raise ValidationError(field.gettext(self.message))
    def _validate_recaptcha(self, response, remote_addr):
        """Performs the actual validation."""
        try:
            private_key = current_app.config["RECAPTCHA_PRIVATE_KEY"]
        except KeyError:
            raise RuntimeError("No RECAPTCHA_PRIVATE_KEY config set") from None
        verify_server = current_app.config.get("RECAPTCHA_VERIFY_SERVER")
...(truncado)

===== ./venv/lib/python3.13/site-packages/flask_wtf/recaptcha/__init__.py =====
from .fields import RecaptchaField
from .validators import Recaptcha
from .widgets import RecaptchaWidget
__all__ = ["RecaptchaField", "RecaptchaWidget", "Recaptcha"]
...(truncado)

===== ./venv/lib/python3.13/site-packages/flask_wtf/recaptcha/widgets.py =====
from urllib.parse import urlencode
from flask import current_app
from markupsafe import Markup
RECAPTCHA_SCRIPT_DEFAULT = "https://www.google.com/recaptcha/api.js"
RECAPTCHA_DIV_CLASS_DEFAULT = "g-recaptcha"
RECAPTCHA_TEMPLATE = """
<script src='%s' async defer></script>
<div class="%s" %s></div>
"""
__all__ = ["RecaptchaWidget"]
class RecaptchaWidget:
    def recaptcha_html(self, public_key):
        html = current_app.config.get("RECAPTCHA_HTML")
        if html:
            return Markup(html)
        params = current_app.config.get("RECAPTCHA_PARAMETERS")
        script = current_app.config.get("RECAPTCHA_SCRIPT")
        if not script:
            script = RECAPTCHA_SCRIPT_DEFAULT
        if params:
            script += "?" + urlencode(params)
        attrs = current_app.config.get("RECAPTCHA_DATA_ATTRS", {})
        attrs["sitekey"] = public_key
        snippet = " ".join(f'data-{k}="{attrs[k]}"' for k in attrs)  # noqa: B028, B907
        div_class = current_app.config.get("RECAPTCHA_DIV_CLASS")
        if not div_class:
            div_class = RECAPTCHA_DIV_CLASS_DEFAULT
        return Markup(RECAPTCHA_TEMPLATE % (script, div_class, snippet))
    def __call__(self, field, error=None, **kwargs):
        """Returns the recaptcha input HTML."""
        try:
            public_key = current_app.config["RECAPTCHA_PUBLIC_KEY"]
        except KeyError:
            raise RuntimeError("RECAPTCHA_PUBLIC_KEY config not set") from None
        return self.recaptcha_html(public_key)
...(truncado)

===== ./venv/lib/python3.13/site-packages/flask_wtf/form.py =====
from flask import current_app
from flask import request
from flask import session
from markupsafe import Markup
from werkzeug.datastructures import CombinedMultiDict
from werkzeug.datastructures import ImmutableMultiDict
from werkzeug.utils import cached_property
from wtforms import Form
from wtforms.meta import DefaultMeta
from wtforms.widgets import HiddenInput
from .csrf import _FlaskFormCSRF
try:
    from .i18n import translations
except ImportError:
    translations = None  # babel not installed
SUBMIT_METHODS = {"POST", "PUT", "PATCH", "DELETE"}
_Auto = object()
class FlaskForm(Form):
    """Flask-specific subclass of WTForms :class:`~wtforms.form.Form`.
    If ``formdata`` is not specified, this will use :attr:`flask.request.form`
    and :attr:`flask.request.files`.  Explicitly pass ``formdata=None`` to
    prevent this.
    """
    class Meta(DefaultMeta):
        csrf_class = _FlaskFormCSRF
        csrf_context = session  # not used, provided for custom csrf_class
        @cached_property
        def csrf(self):
            return current_app.config.get("WTF_CSRF_ENABLED", True)
        @cached_property
        def csrf_secret(self):
            return current_app.config.get("WTF_CSRF_SECRET_KEY", current_app.secret_key)
        @cached_property
        def csrf_field_name(self):
            return current_app.config.get("WTF_CSRF_FIELD_NAME", "csrf_token")
        @cached_property
        def csrf_time_limit(self):
            return current_app.config.get("WTF_CSRF_TIME_LIMIT", 3600)
        def wrap_formdata(self, form, formdata):
            if formdata is _Auto:
...(truncado)

===== ./venv/lib/python3.13/site-packages/flask_wtf/i18n.py =====
from babel import support
from flask import current_app
from flask import request
from flask_babel import get_locale
from wtforms.i18n import messages_path
__all__ = ("Translations", "translations")
def _get_translations():
    """Returns the correct gettext translations.
    Copy from flask-babel with some modifications.
    """
    if not request:
        return None
    # babel should be in extensions for get_locale
    if "babel" not in current_app.extensions:
        return None
    translations = getattr(request, "wtforms_translations", None)
    if translations is None:
        translations = support.Translations.load(
            messages_path(), [get_locale()], domain="wtforms"
        )
        request.wtforms_translations = translations
    return translations
class Translations:
    def gettext(self, string):
        t = _get_translations()
        return string if t is None else t.ugettext(string)
    def ngettext(self, singular, plural, n):
        t = _get_translations()
        if t is None:
            return singular if n == 1 else plural
        return t.ungettext(singular, plural, n)
translations = Translations()
...(truncado)

===== ./venv/lib/python3.13/site-packages/flask_wtf/_compat.py =====
import warnings
class FlaskWTFDeprecationWarning(DeprecationWarning):
    pass
warnings.simplefilter("always", FlaskWTFDeprecationWarning)
warnings.filterwarnings(
    "ignore", category=FlaskWTFDeprecationWarning, module="wtforms|flask_wtf"
)
...(truncado)

===== ./venv/lib/python3.13/site-packages/werkzeug/middleware/dispatcher.py =====
"""
Application Dispatcher
======================
This middleware creates a single WSGI application that dispatches to
multiple other WSGI applications mounted at different URL paths.
A common example is writing a Single Page Application, where you have a
backend API and a frontend written in JavaScript that does the routing
in the browser rather than requesting different pages from the server.
The frontend is a single HTML and JS file that should be served for any
path besides "/api".
This example dispatches to an API app under "/api", an admin app
under "/admin", and an app that serves frontend files for all other
requests::
    app = DispatcherMiddleware(serve_frontend, {
        '/api': api_app,
        '/admin': admin_app,
    })
In production, you might instead handle this at the HTTP server level,
serving files or proxying to application servers based on location. The
API and admin apps would each be deployed with a separate WSGI server,
and the static files would be served directly by the HTTP server.
.. autoclass:: DispatcherMiddleware
:copyright: 2007 Pallets
:license: BSD-3-Clause
"""
from __future__ import annotations
import typing as t
if t.TYPE_CHECKING:
    from _typeshed.wsgi import StartResponse
    from _typeshed.wsgi import WSGIApplication
    from _typeshed.wsgi import WSGIEnvironment
class DispatcherMiddleware:
    """Combine multiple applications as a single WSGI application.
    Requests are dispatched to an application based on the path it is
    mounted under.
    :param app: The WSGI application to dispatch to if the request
        doesn't match a mounted path.
    :param mounts: Maps path prefixes to applications for dispatching.
    """
    def __init__(
...(truncado)

===== ./venv/lib/python3.13/site-packages/werkzeug/middleware/proxy_fix.py =====
"""
X-Forwarded-For Proxy Fix
=========================
This module provides a middleware that adjusts the WSGI environ based on
``X-Forwarded-`` headers that proxies in front of an application may
set.
When an application is running behind a proxy server, WSGI may see the
request as coming from that server rather than the real client. Proxies
set various headers to track where the request actually came from.
This middleware should only be used if the application is actually
behind such a proxy, and should be configured with the number of proxies
that are chained in front of it. Not all proxies set all the headers.
Since incoming headers can be faked, you must set how many proxies are
setting each header so the middleware knows what to trust.
.. autoclass:: ProxyFix
:copyright: 2007 Pallets
:license: BSD-3-Clause
"""
from __future__ import annotations
import typing as t
from ..http import parse_list_header
if t.TYPE_CHECKING:
    from _typeshed.wsgi import StartResponse
    from _typeshed.wsgi import WSGIApplication
    from _typeshed.wsgi import WSGIEnvironment
class ProxyFix:
    """Adjust the WSGI environ based on ``X-Forwarded-`` that proxies in
    front of the application may set.
    -   ``X-Forwarded-For`` sets ``REMOTE_ADDR``.
    -   ``X-Forwarded-Proto`` sets ``wsgi.url_scheme``.
    -   ``X-Forwarded-Host`` sets ``HTTP_HOST``, ``SERVER_NAME``, and
        ``SERVER_PORT``.
    -   ``X-Forwarded-Port`` sets ``HTTP_HOST`` and ``SERVER_PORT``.
    -   ``X-Forwarded-Prefix`` sets ``SCRIPT_NAME``.
    You must tell the middleware how many proxies set each header so it
    knows what values to trust. It is a security issue to trust values
    that came from the client rather than a proxy.
    The original values of the headers are stored in the WSGI
    environ as ``werkzeug.proxy_fix.orig``, a dict.
    :param app: The WSGI application to wrap.
...(truncado)

===== ./venv/lib/python3.13/site-packages/werkzeug/middleware/shared_data.py =====
"""
Serve Shared Static Files
=========================
.. autoclass:: SharedDataMiddleware
    :members: is_allowed
:copyright: 2007 Pallets
:license: BSD-3-Clause
"""
from __future__ import annotations
import collections.abc as cabc
import importlib.util
import mimetypes
import os
import posixpath
import typing as t
from datetime import datetime
from datetime import timezone
from io import BytesIO
from time import time
from zlib import adler32
from ..http import http_date
from ..http import is_resource_modified
from ..security import safe_join
from ..utils import get_content_type
from ..wsgi import get_path_info
from ..wsgi import wrap_file
_TOpener = t.Callable[[], tuple[t.IO[bytes], datetime, int]]
_TLoader = t.Callable[[t.Optional[str]], tuple[t.Optional[str], t.Optional[_TOpener]]]
if t.TYPE_CHECKING:
    from _typeshed.wsgi import StartResponse
    from _typeshed.wsgi import WSGIApplication
    from _typeshed.wsgi import WSGIEnvironment
class SharedDataMiddleware:
    """A WSGI middleware which provides static content for development
    environments or simple server setups. Its usage is quite simple::
        import os
        from werkzeug.middleware.shared_data import SharedDataMiddleware
        app = SharedDataMiddleware(app, {
            '/shared': os.path.join(os.path.dirname(__file__), 'shared')
        })
...(truncado)

===== ./venv/lib/python3.13/site-packages/werkzeug/middleware/http_proxy.py =====
"""
Basic HTTP Proxy
================
.. autoclass:: ProxyMiddleware
:copyright: 2007 Pallets
:license: BSD-3-Clause
"""
from __future__ import annotations
import typing as t
from http import client
from urllib.parse import quote
from urllib.parse import urlsplit
from ..datastructures import EnvironHeaders
from ..http import is_hop_by_hop_header
from ..wsgi import get_input_stream
if t.TYPE_CHECKING:
    from _typeshed.wsgi import StartResponse
    from _typeshed.wsgi import WSGIApplication
    from _typeshed.wsgi import WSGIEnvironment
class ProxyMiddleware:
    """Proxy requests under a path to an external server, routing other
    requests to the app.
    This middleware can only proxy HTTP requests, as HTTP is the only
    protocol handled by the WSGI server. Other protocols, such as
    WebSocket requests, cannot be proxied at this layer. This should
    only be used for development, in production a real proxy server
    should be used.
    The middleware takes a dict mapping a path prefix to a dict
    describing the host to be proxied to::
        app = ProxyMiddleware(app, {
            "/static/": {
                "target": "http://127.0.0.1:5001/",
            }
        })
    Each host has the following options:
    ``target``:
        The target URL to dispatch to. This is required.
    ``remove_prefix``:
        Whether to remove the prefix from the URL before dispatching it
        to the target. The default is ``False``.
...(truncado)

===== ./venv/lib/python3.13/site-packages/werkzeug/middleware/__init__.py =====
...(truncado)

===== ./venv/lib/python3.13/site-packages/werkzeug/middleware/profiler.py =====
"""
Application Profiler
====================
This module provides a middleware that profiles each request with the
:mod:`cProfile` module. This can help identify bottlenecks in your code
that may be slowing down your application.
.. autoclass:: ProfilerMiddleware
:copyright: 2007 Pallets
:license: BSD-3-Clause
"""
from __future__ import annotations
import os.path
import sys
import time
import typing as t
from pstats import Stats
try:
    from cProfile import Profile
except ImportError:
    from profile import Profile  # type: ignore
if t.TYPE_CHECKING:
    from _typeshed.wsgi import StartResponse
    from _typeshed.wsgi import WSGIApplication
    from _typeshed.wsgi import WSGIEnvironment
class ProfilerMiddleware:
    """Wrap a WSGI application and profile the execution of each
    request. Responses are buffered so that timings are more exact.
    If ``stream`` is given, :class:`pstats.Stats` are written to it
    after each request. If ``profile_dir`` is given, :mod:`cProfile`
    data files are saved to that directory, one file per request.
    The filename can be customized by passing ``filename_format``. If
    it is a string, it will be formatted using :meth:`str.format` with
    the following fields available:
    -   ``{method}`` - The request method; GET, POST, etc.
    -   ``{path}`` - The request path or 'root' should one not exist.
    -   ``{elapsed}`` - The elapsed time of the request in milliseconds.
    -   ``{time}`` - The time of the request.
    If it is a callable, it will be called with the WSGI ``environ`` and
    be expected to return a filename string. The ``environ`` dictionary
    will also have the ``"werkzeug.profiler"`` key populated with a
...(truncado)

===== ./venv/lib/python3.13/site-packages/werkzeug/middleware/lint.py =====
"""
WSGI Protocol Linter
====================
This module provides a middleware that performs sanity checks on the
behavior of the WSGI server and application. It checks that the
:pep:`3333` WSGI spec is properly implemented. It also warns on some
common HTTP errors such as non-empty responses for 304 status codes.
.. autoclass:: LintMiddleware
:copyright: 2007 Pallets
:license: BSD-3-Clause
"""
from __future__ import annotations
import typing as t
from types import TracebackType
from urllib.parse import urlparse
from warnings import warn
from ..datastructures import Headers
from ..http import is_entity_header
from ..wsgi import FileWrapper
if t.TYPE_CHECKING:
    from _typeshed.wsgi import StartResponse
    from _typeshed.wsgi import WSGIApplication
    from _typeshed.wsgi import WSGIEnvironment
class WSGIWarning(Warning):
    """Warning class for WSGI warnings."""
class HTTPWarning(Warning):
    """Warning class for HTTP warnings."""
def check_type(context: str, obj: object, need: type = str) -> None:
    if type(obj) is not need:
        warn(
            f"{context!r} requires {need.__name__!r}, got {type(obj).__name__!r}.",
            WSGIWarning,
            stacklevel=3,
        )
class InputStream:
    def __init__(self, stream: t.IO[bytes]) -> None:
        self._stream = stream
    def read(self, *args: t.Any) -> bytes:
        if len(args) == 0:
            warn(
...(truncado)

===== ./venv/lib/python3.13/site-packages/werkzeug/wrappers/request.py =====
from __future__ import annotations
import collections.abc as cabc
import functools
import json
import typing as t
from io import BytesIO
from .._internal import _wsgi_decoding_dance
from ..datastructures import CombinedMultiDict
from ..datastructures import EnvironHeaders
from ..datastructures import FileStorage
from ..datastructures import ImmutableMultiDict
from ..datastructures import iter_multi_items
from ..datastructures import MultiDict
from ..exceptions import BadRequest
from ..exceptions import UnsupportedMediaType
from ..formparser import default_stream_factory
from ..formparser import FormDataParser
from ..sansio.request import Request as _SansIORequest
from ..utils import cached_property
from ..utils import environ_property
from ..wsgi import _get_server
from ..wsgi import get_input_stream
if t.TYPE_CHECKING:
    from _typeshed.wsgi import WSGIApplication
    from _typeshed.wsgi import WSGIEnvironment
class Request(_SansIORequest):
    """Represents an incoming WSGI HTTP request, with headers and body
    taken from the WSGI environment. Has properties and methods for
    using the functionality defined by various HTTP specs. The data in
    requests object is read-only.
    Text data is assumed to use UTF-8 encoding, which should be true for
    the vast majority of modern clients. Using an encoding set by the
    client is unsafe in Python due to extra encodings it provides, such
    as ``zip``. To change the assumed encoding, subclass and replace
    :attr:`charset`.
    :param environ: The WSGI environ is generated by the WSGI server and
        contains information about the server configuration and client
        request.
    :param populate_request: Add this request object to the WSGI environ
        as ``environ['werkzeug.request']``. Can be useful when
...(truncado)

===== ./venv/lib/python3.13/site-packages/werkzeug/wrappers/__init__.py =====
from .request import Request as Request
from .response import Response as Response
from .response import ResponseStream as ResponseStream
...(truncado)

===== ./venv/lib/python3.13/site-packages/werkzeug/wrappers/response.py =====
from __future__ import annotations
import json
import typing as t
from http import HTTPStatus
from urllib.parse import urljoin
from .._internal import _get_environ
from ..datastructures import Headers
from ..http import generate_etag
from ..http import http_date
from ..http import is_resource_modified
from ..http import parse_etags
from ..http import parse_range_header
from ..http import remove_entity_headers
from ..sansio.response import Response as _SansIOResponse
from ..urls import iri_to_uri
from ..utils import cached_property
from ..wsgi import _RangeWrapper
from ..wsgi import ClosingIterator
from ..wsgi import get_current_url
if t.TYPE_CHECKING:
    from _typeshed.wsgi import StartResponse
    from _typeshed.wsgi import WSGIApplication
    from _typeshed.wsgi import WSGIEnvironment
    from .request import Request
def _iter_encoded(iterable: t.Iterable[str | bytes]) -> t.Iterator[bytes]:
    for item in iterable:
        if isinstance(item, str):
            yield item.encode()
        else:
            yield item
class Response(_SansIOResponse):
    """Represents an outgoing WSGI HTTP response with body, status, and
    headers. Has properties and methods for using the functionality
    defined by various HTTP specs.
    The response body is flexible to support different use cases. The
    simple form is passing bytes, or a string which will be encoded as
    UTF-8. Passing an iterable of bytes or strings makes this a
    streaming response. A generator is particularly useful for building
    a CSV file in memory or using SSE (Server Sent Events). A file-like
    object is also iterable, although the
...(truncado)

===== ./venv/lib/python3.13/site-packages/werkzeug/sansio/multipart.py =====
from __future__ import annotations
import re
import typing as t
from dataclasses import dataclass
from enum import auto
from enum import Enum
from ..datastructures import Headers
from ..exceptions import RequestEntityTooLarge
from ..http import parse_options_header
class Event:
    pass
@dataclass(frozen=True)
class Preamble(Event):
    data: bytes
@dataclass(frozen=True)
class Field(Event):
    name: str
    headers: Headers
@dataclass(frozen=True)
class File(Event):
    name: str
    filename: str
    headers: Headers
@dataclass(frozen=True)
class Data(Event):
    data: bytes
    more_data: bool
@dataclass(frozen=True)
class Epilogue(Event):
    data: bytes
class NeedData(Event):
    pass
NEED_DATA = NeedData()
class State(Enum):
    PREAMBLE = auto()
    PART = auto()
    DATA = auto()
    DATA_START = auto()
    EPILOGUE = auto()
    COMPLETE = auto()
...(truncado)

===== ./venv/lib/python3.13/site-packages/werkzeug/sansio/request.py =====
from __future__ import annotations
import typing as t
from datetime import datetime
from urllib.parse import parse_qsl
from ..datastructures import Accept
from ..datastructures import Authorization
from ..datastructures import CharsetAccept
from ..datastructures import ETags
from ..datastructures import Headers
from ..datastructures import HeaderSet
from ..datastructures import IfRange
from ..datastructures import ImmutableList
from ..datastructures import ImmutableMultiDict
from ..datastructures import LanguageAccept
from ..datastructures import MIMEAccept
from ..datastructures import MultiDict
from ..datastructures import Range
from ..datastructures import RequestCacheControl
from ..http import parse_accept_header
from ..http import parse_cache_control_header
from ..http import parse_date
from ..http import parse_etags
from ..http import parse_if_range_header
from ..http import parse_list_header
from ..http import parse_options_header
from ..http import parse_range_header
from ..http import parse_set_header
from ..user_agent import UserAgent
from ..utils import cached_property
from ..utils import header_property
from .http import parse_cookie
from .utils import get_content_length
from .utils import get_current_url
from .utils import get_host
class Request:
    """Represents the non-IO parts of a HTTP request, including the
    method, URL info, and headers.
    This class is not meant for general use. It should only be used when
    implementing WSGI, ASGI, or another HTTP application spec. Werkzeug
    provides a WSGI implementation at :cls:`werkzeug.wrappers.Request`.
...(truncado)

===== ./venv/lib/python3.13/site-packages/werkzeug/sansio/__init__.py =====
...(truncado)

===== ./venv/lib/python3.13/site-packages/werkzeug/sansio/response.py =====
from __future__ import annotations
import typing as t
from datetime import datetime
from datetime import timedelta
from datetime import timezone
from http import HTTPStatus
from ..datastructures import CallbackDict
from ..datastructures import ContentRange
from ..datastructures import ContentSecurityPolicy
from ..datastructures import Headers
from ..datastructures import HeaderSet
from ..datastructures import ResponseCacheControl
from ..datastructures import WWWAuthenticate
from ..http import COEP
from ..http import COOP
from ..http import dump_age
from ..http import dump_cookie
from ..http import dump_header
from ..http import dump_options_header
from ..http import http_date
from ..http import HTTP_STATUS_CODES
from ..http import parse_age
from ..http import parse_cache_control_header
from ..http import parse_content_range_header
from ..http import parse_csp_header
from ..http import parse_date
from ..http import parse_options_header
from ..http import parse_set_header
from ..http import quote_etag
from ..http import unquote_etag
from ..utils import get_content_type
from ..utils import header_property
if t.TYPE_CHECKING:
    from ..datastructures.cache_control import _CacheControl
def _set_property(name: str, doc: str | None = None) -> property:
    def fget(self: Response) -> HeaderSet:
        def on_update(header_set: HeaderSet) -> None:
            if not header_set and name in self.headers:
                del self.headers[name]
            elif header_set:
...(truncado)

===== ./venv/lib/python3.13/site-packages/werkzeug/sansio/utils.py =====
from __future__ import annotations
import typing as t
from urllib.parse import quote
from .._internal import _plain_int
from ..exceptions import SecurityError
from ..urls import uri_to_iri
def host_is_trusted(hostname: str | None, trusted_list: t.Iterable[str]) -> bool:
    """Check if a host matches a list of trusted names.
    :param hostname: The name to check.
    :param trusted_list: A list of valid names to match. If a name
        starts with a dot it will match all subdomains.
    .. versionadded:: 0.9
    """
    if not hostname:
        return False
    try:
        hostname = hostname.partition(":")[0].encode("idna").decode("ascii")
    except UnicodeEncodeError:
        return False
    if isinstance(trusted_list, str):
        trusted_list = [trusted_list]
    for ref in trusted_list:
        if ref.startswith("."):
            ref = ref[1:]
            suffix_match = True
        else:
            suffix_match = False
        try:
            ref = ref.partition(":")[0].encode("idna").decode("ascii")
        except UnicodeEncodeError:
            return False
        if ref == hostname or (suffix_match and hostname.endswith(f".{ref}")):
            return True
    return False
def get_host(
    scheme: str,
    host_header: str | None,
    server: tuple[str, int | None] | None = None,
    trusted_hosts: t.Iterable[str] | None = None,
) -> str:
...(truncado)

===== ./venv/lib/python3.13/site-packages/werkzeug/sansio/http.py =====
from __future__ import annotations
import re
import typing as t
from datetime import datetime
from .._internal import _dt_as_utc
from ..http import generate_etag
from ..http import parse_date
from ..http import parse_etags
from ..http import parse_if_range_header
from ..http import unquote_etag
_etag_re = re.compile(r'([Ww]/)?(?:"(.*?)"|(.*?))(?:\s*,\s*|$)')
def is_resource_modified(
    http_range: str | None = None,
    http_if_range: str | None = None,
    http_if_modified_since: str | None = None,
    http_if_none_match: str | None = None,
    http_if_match: str | None = None,
    etag: str | None = None,
    data: bytes | None = None,
    last_modified: datetime | str | None = None,
    ignore_if_range: bool = True,
) -> bool:
    """Convenience method for conditional requests.
    :param http_range: Range HTTP header
    :param http_if_range: If-Range HTTP header
    :param http_if_modified_since: If-Modified-Since HTTP header
    :param http_if_none_match: If-None-Match HTTP header
    :param http_if_match: If-Match HTTP header
    :param etag: the etag for the response for comparison.
    :param data: or alternatively the data of the response to automatically
                 generate an etag using :func:`generate_etag`.
    :param last_modified: an optional date of the last modification.
    :param ignore_if_range: If `False`, `If-Range` header will be taken into
                            account.
    :return: `True` if the resource was modified, otherwise `False`.
    .. versionadded:: 2.2
    """
    if etag is None and data is not None:
        etag = generate_etag(data)
    elif data is not None:
...(truncado)

===== ./venv/lib/python3.13/site-packages/werkzeug/user_agent.py =====
from __future__ import annotations
class UserAgent:
    """Represents a parsed user agent header value.
    The default implementation does no parsing, only the :attr:`string`
    attribute is set. A subclass may parse the string to set the
    common attributes or expose other information. Set
    :attr:`werkzeug.wrappers.Request.user_agent_class` to use a
    subclass.
    :param string: The header value to parse.
    .. versionadded:: 2.0
        This replaces the previous ``useragents`` module, but does not
        provide a built-in parser.
    """
    platform: str | None = None
    """The OS name, if it could be parsed from the string."""
    browser: str | None = None
    """The browser name, if it could be parsed from the string."""
    version: str | None = None
    """The browser version, if it could be parsed from the string."""
    language: str | None = None
    """The browser language, if it could be parsed from the string."""
    def __init__(self, string: str) -> None:
        self.string: str = string
        """The original header value."""
    def __repr__(self) -> str:
        return f"<{type(self).__name__} {self.browser}/{self.version}>"
    def __str__(self) -> str:
        return self.string
    def __bool__(self) -> bool:
        return bool(self.browser)
    def to_header(self) -> str:
        """Convert to a header value."""
        return self.string
...(truncado)

===== ./venv/lib/python3.13/site-packages/werkzeug/_reloader.py =====
from __future__ import annotations
import fnmatch
import os
import subprocess
import sys
import threading
import time
import typing as t
from itertools import chain
from pathlib import PurePath
from ._internal import _log
_ignore_always = tuple({sys.base_prefix, sys.base_exec_prefix})
prefix = {*_ignore_always, sys.prefix, sys.exec_prefix}
if hasattr(sys, "real_prefix"):
    # virtualenv < 20
    prefix.add(sys.real_prefix)
_stat_ignore_scan = tuple(prefix)
del prefix
_ignore_common_dirs = {
    "__pycache__",
    ".git",
    ".hg",
    ".tox",
    ".nox",
    ".pytest_cache",
    ".mypy_cache",
}
def _iter_module_paths() -> t.Iterator[str]:
    """Find the filesystem paths associated with imported modules."""
    # List is in case the value is modified by the app while updating.
    for module in list(sys.modules.values()):
        name = getattr(module, "__file__", None)
        if name is None or name.startswith(_ignore_always):
            continue
        while not os.path.isfile(name):
            # Zip file, find the base file without the module path.
            old = name
            name = os.path.dirname(name)
            if name == old:  # skip if it was all directories somehow
                break
...(truncado)

===== ./venv/lib/python3.13/site-packages/werkzeug/_internal.py =====
from __future__ import annotations
import logging
import re
import sys
import typing as t
from datetime import datetime
from datetime import timezone
if t.TYPE_CHECKING:
    from _typeshed.wsgi import WSGIEnvironment
    from .wrappers.request import Request
_logger: logging.Logger | None = None
class _Missing:
    def __repr__(self) -> str:
        return "no value"
    def __reduce__(self) -> str:
        return "_missing"
_missing = _Missing()
def _wsgi_decoding_dance(s: str) -> str:
    return s.encode("latin1").decode(errors="replace")
def _wsgi_encoding_dance(s: str) -> str:
    return s.encode().decode("latin1")
def _get_environ(obj: WSGIEnvironment | Request) -> WSGIEnvironment:
    env = getattr(obj, "environ", obj)
    assert isinstance(
        env, dict
    ), f"{type(obj).__name__!r} is not a WSGI environment (has to be a dict)"
    return env
def _has_level_handler(logger: logging.Logger) -> bool:
    """Check if there is a handler in the logging chain that will handle
    the given logger's effective level.
    """
    level = logger.getEffectiveLevel()
    current = logger
    while current:
        if any(handler.level <= level for handler in current.handlers):
            return True
        if not current.propagate:
            break
        current = current.parent  # type: ignore
    return False
...(truncado)

===== ./venv/lib/python3.13/site-packages/werkzeug/serving.py =====
"""A WSGI and HTTP server for use **during development only**. This
server is convenient to use, but is not designed to be particularly
stable, secure, or efficient. Use a dedicate WSGI server and HTTP
server when deploying to production.
It provides features like interactive debugging and code reloading. Use
``run_simple`` to start the server. Put this in a ``run.py`` script:
.. code-block:: python
    from myapp import create_app
    from werkzeug import run_simple
"""
from __future__ import annotations
import errno
import io
import os
import selectors
import socket
import socketserver
import sys
import typing as t
from datetime import datetime as dt
from datetime import timedelta
from datetime import timezone
from http.server import BaseHTTPRequestHandler
from http.server import HTTPServer
from urllib.parse import unquote
from urllib.parse import urlsplit
from ._internal import _log
from ._internal import _wsgi_encoding_dance
from .exceptions import InternalServerError
from .urls import uri_to_iri
try:
    import ssl
    connection_dropped_errors: tuple[type[Exception], ...] = (
        ConnectionError,
        socket.timeout,
        ssl.SSLEOFError,
    )
except ImportError:
    class _SslDummy:
        def __getattr__(self, name: str) -> t.Any:
...(truncado)

===== ./venv/lib/python3.13/site-packages/werkzeug/datastructures/auth.py =====
from __future__ import annotations
import base64
import binascii
import collections.abc as cabc
import typing as t
from ..http import dump_header
from ..http import parse_dict_header
from ..http import quote_header_value
from .structures import CallbackDict
if t.TYPE_CHECKING:
    import typing_extensions as te
class Authorization:
    """Represents the parts of an ``Authorization`` request header.
    :attr:`.Request.authorization` returns an instance if the header is set.
    An instance can be used with the test :class:`.Client` request methods' ``auth``
    parameter to send the header in test requests.
    Depending on the auth scheme, either :attr:`parameters` or :attr:`token` will be
    set. The ``Basic`` scheme's token is decoded into the ``username`` and ``password``
    parameters.
    For convenience, ``auth["key"]`` and ``auth.key`` both access the key in the
    :attr:`parameters` dict, along with ``auth.get("key")`` and ``"key" in auth``.
    .. versionchanged:: 2.3
        The ``token`` parameter and attribute was added to support auth schemes that use
        a token instead of parameters, such as ``Bearer``.
    .. versionchanged:: 2.3
        The object is no longer a ``dict``.
    .. versionchanged:: 0.5
        The object is an immutable dict.
    """
    def __init__(
        self,
        auth_type: str,
        data: dict[str, str | None] | None = None,
        token: str | None = None,
    ) -> None:
        self.type = auth_type
        """The authorization scheme, like ``basic``, ``digest``, or ``bearer``."""
        if data is None:
            data = {}
        self.parameters = data
...(truncado)

===== ./venv/lib/python3.13/site-packages/werkzeug/datastructures/mixins.py =====
from __future__ import annotations
import collections.abc as cabc
import typing as t
from functools import update_wrapper
from itertools import repeat
from .._internal import _missing
if t.TYPE_CHECKING:
    import typing_extensions as te
K = t.TypeVar("K")
V = t.TypeVar("V")
T = t.TypeVar("T")
F = t.TypeVar("F", bound=cabc.Callable[..., t.Any])
def _immutable_error(self: t.Any) -> t.NoReturn:
    raise TypeError(f"{type(self).__name__!r} objects are immutable")
class ImmutableListMixin:
    """Makes a :class:`list` immutable.
    .. versionadded:: 0.5
    :private:
    """
    _hash_cache: int | None = None
    def __hash__(self) -> int:
        if self._hash_cache is not None:
            return self._hash_cache
        rv = self._hash_cache = hash(tuple(self))  # type: ignore[arg-type]
        return rv
    def __reduce_ex__(self, protocol: t.SupportsIndex) -> t.Any:
        return type(self), (list(self),)  # type: ignore[call-overload]
    def __delitem__(self, key: t.Any) -> t.NoReturn:
        _immutable_error(self)
    def __iadd__(self, other: t.Any) -> t.NoReturn:
        _immutable_error(self)
    def __imul__(self, other: t.Any) -> t.NoReturn:
        _immutable_error(self)
    def __setitem__(self, key: t.Any, value: t.Any) -> t.NoReturn:
        _immutable_error(self)
    def append(self, item: t.Any) -> t.NoReturn:
        _immutable_error(self)
    def remove(self, item: t.Any) -> t.NoReturn:
        _immutable_error(self)
    def extend(self, iterable: t.Any) -> t.NoReturn:
...(truncado)

===== ./venv/lib/python3.13/site-packages/werkzeug/datastructures/range.py =====
from __future__ import annotations
import collections.abc as cabc
import typing as t
from datetime import datetime
if t.TYPE_CHECKING:
    import typing_extensions as te
T = t.TypeVar("T")
class IfRange:
    """Very simple object that represents the `If-Range` header in parsed
    form.  It will either have neither a etag or date or one of either but
    never both.
    .. versionadded:: 0.7
    """
    def __init__(self, etag: str | None = None, date: datetime | None = None):
        #: The etag parsed and unquoted.  Ranges always operate on strong
        #: etags so the weakness information is not necessary.
        self.etag = etag
        #: The date in parsed format or `None`.
        self.date = date
    def to_header(self) -> str:
        """Converts the object back into an HTTP header."""
        if self.date is not None:
            return http.http_date(self.date)
        if self.etag is not None:
            return http.quote_etag(self.etag)
        return ""
    def __str__(self) -> str:
        return self.to_header()
    def __repr__(self) -> str:
        return f"<{type(self).__name__} {str(self)!r}>"
class Range:
    """Represents a ``Range`` header. All methods only support only
    bytes as the unit. Stores a list of ranges if given, but the methods
    only work if only one range is provided.
    :raise ValueError: If the ranges provided are invalid.
    .. versionchanged:: 0.15
        The ranges passed in are validated.
    .. versionadded:: 0.7
    """
    def __init__(
...(truncado)

===== ./venv/lib/python3.13/site-packages/werkzeug/datastructures/__init__.py =====
from __future__ import annotations
import typing as t
from .accept import Accept as Accept
from .accept import CharsetAccept as CharsetAccept
from .accept import LanguageAccept as LanguageAccept
from .accept import MIMEAccept as MIMEAccept
from .auth import Authorization as Authorization
from .auth import WWWAuthenticate as WWWAuthenticate
from .cache_control import RequestCacheControl as RequestCacheControl
from .cache_control import ResponseCacheControl as ResponseCacheControl
from .csp import ContentSecurityPolicy as ContentSecurityPolicy
from .etag import ETags as ETags
from .file_storage import FileMultiDict as FileMultiDict
from .file_storage import FileStorage as FileStorage
from .headers import EnvironHeaders as EnvironHeaders
from .headers import Headers as Headers
from .mixins import ImmutableDictMixin as ImmutableDictMixin
from .mixins import ImmutableHeadersMixin as ImmutableHeadersMixin
from .mixins import ImmutableListMixin as ImmutableListMixin
from .mixins import ImmutableMultiDictMixin as ImmutableMultiDictMixin
from .mixins import UpdateDictMixin as UpdateDictMixin
from .range import ContentRange as ContentRange
from .range import IfRange as IfRange
from .range import Range as Range
from .structures import CallbackDict as CallbackDict
from .structures import CombinedMultiDict as CombinedMultiDict
from .structures import HeaderSet as HeaderSet
from .structures import ImmutableDict as ImmutableDict
from .structures import ImmutableList as ImmutableList
from .structures import ImmutableMultiDict as ImmutableMultiDict
from .structures import ImmutableTypeConversionDict as ImmutableTypeConversionDict
from .structures import iter_multi_items as iter_multi_items
from .structures import MultiDict as MultiDict
from .structures import TypeConversionDict as TypeConversionDict
def __getattr__(name: str) -> t.Any:
    import warnings
    if name == "OrderedMultiDict":
        from .structures import _OrderedMultiDict
        warnings.warn(
            "'OrderedMultiDict' is deprecated and will be removed in Werkzeug"
...(truncado)

===== ./venv/lib/python3.13/site-packages/werkzeug/datastructures/csp.py =====
from __future__ import annotations
import collections.abc as cabc
import typing as t
from .structures import CallbackDict
def csp_property(key: str) -> t.Any:
    """Return a new property object for a content security policy header.
    Useful if you want to add support for a csp extension in a
    subclass.
    """
    return property(
        lambda x: x._get_value(key),
        lambda x, v: x._set_value(key, v),
        lambda x: x._del_value(key),
        f"accessor for {key!r}",
    )
class ContentSecurityPolicy(CallbackDict[str, str]):
    """Subclass of a dict that stores values for a Content Security Policy
    header. It has accessors for all the level 3 policies.
    Because the csp directives in the HTTP header use dashes the
    python descriptors use underscores for that.
    To get a header of the :class:`ContentSecuirtyPolicy` object again
    you can convert the object into a string or call the
    :meth:`to_header` method.  If you plan to subclass it and add your
    own items have a look at the sourcecode for that class.
    .. versionadded:: 1.0.0
       Support for Content Security Policy headers was added.
    """
    base_uri: str | None = csp_property("base-uri")
    child_src: str | None = csp_property("child-src")
    connect_src: str | None = csp_property("connect-src")
    default_src: str | None = csp_property("default-src")
    font_src: str | None = csp_property("font-src")
    form_action: str | None = csp_property("form-action")
    frame_ancestors: str | None = csp_property("frame-ancestors")
    frame_src: str | None = csp_property("frame-src")
    img_src: str | None = csp_property("img-src")
    manifest_src: str | None = csp_property("manifest-src")
    media_src: str | None = csp_property("media-src")
    navigate_to: str | None = csp_property("navigate-to")
    object_src: str | None = csp_property("object-src")
...(truncado)

===== ./venv/lib/python3.13/site-packages/werkzeug/datastructures/etag.py =====
from __future__ import annotations
import collections.abc as cabc
class ETags(cabc.Collection[str]):
    """A set that can be used to check if one etag is present in a collection
    of etags.
    """
    def __init__(
        self,
        strong_etags: cabc.Iterable[str] | None = None,
        weak_etags: cabc.Iterable[str] | None = None,
        star_tag: bool = False,
    ):
        if not star_tag and strong_etags:
            self._strong = frozenset(strong_etags)
        else:
            self._strong = frozenset()
        self._weak = frozenset(weak_etags or ())
        self.star_tag = star_tag
    def as_set(self, include_weak: bool = False) -> set[str]:
        """Convert the `ETags` object into a python set.  Per default all the
        weak etags are not part of this set."""
        rv = set(self._strong)
        if include_weak:
            rv.update(self._weak)
        return rv
    def is_weak(self, etag: str) -> bool:
        """Check if an etag is weak."""
        return etag in self._weak
    def is_strong(self, etag: str) -> bool:
        """Check if an etag is strong."""
        return etag in self._strong
    def contains_weak(self, etag: str) -> bool:
        """Check if an etag is part of the set including weak and strong tags."""
        return self.is_weak(etag) or self.contains(etag)
    def contains(self, etag: str) -> bool:
        """Check if an etag is part of the set ignoring weak tags.
        It is also possible to use the ``in`` operator.
        """
        if self.star_tag:
            return True
...(truncado)

===== ./venv/lib/python3.13/site-packages/werkzeug/datastructures/cache_control.py =====
from __future__ import annotations
import collections.abc as cabc
import typing as t
from inspect import cleandoc
from .mixins import ImmutableDictMixin
from .structures import CallbackDict
def cache_control_property(
    key: str, empty: t.Any, type: type[t.Any] | None, *, doc: str | None = None
) -> t.Any:
    """Return a new property object for a cache header. Useful if you
    want to add support for a cache extension in a subclass.
    :param key: The attribute name present in the parsed cache-control header dict.
    :param empty: The value to use if the key is present without a value.
    :param type: The type to convert the string value to instead of a string. If
        conversion raises a ``ValueError``, the returned value is ``None``.
    :param doc: The docstring for the property. If not given, it is generated
        based on the other params.
    .. versionchanged:: 3.1
        Added the ``doc`` param.
    .. versionchanged:: 2.0
        Renamed from ``cache_property``.
    """
    if doc is None:
        parts = [f"The ``{key}`` attribute."]
        if type is bool:
            parts.append("A ``bool``, either present or not.")
        else:
            if type is None:
                parts.append("A ``str``,")
            else:
                parts.append(f"A ``{type.__name__}``,")
            if empty is not None:
                parts.append(f"``{empty!r}`` if present with no value,")
            parts.append("or ``None`` if not present.")
        doc = " ".join(parts)
    return property(
        lambda x: x._get_cache_value(key, empty, type),
        lambda x, v: x._set_cache_value(key, v, type),
        lambda x: x._del_cache_value(key),
        doc=cleandoc(doc),
...(truncado)

===== ./venv/lib/python3.13/site-packages/werkzeug/datastructures/accept.py =====
from __future__ import annotations
import codecs
import collections.abc as cabc
import re
import typing as t
from .structures import ImmutableList
class Accept(ImmutableList[tuple[str, float]]):
    """An :class:`Accept` object is just a list subclass for lists of
    ``(value, quality)`` tuples.  It is automatically sorted by specificity
    and quality.
    All :class:`Accept` objects work similar to a list but provide extra
    functionality for working with the data.  Containment checks are
    normalized to the rules of that header:
    >>> a = CharsetAccept([('ISO-8859-1', 1), ('utf-8', 0.7)])
    >>> a.best
    'ISO-8859-1'
    >>> 'iso-8859-1' in a
    True
    >>> 'UTF8' in a
    True
    >>> 'utf7' in a
    False
    To get the quality for an item you can use normal item lookup:
    >>> print a['utf-8']
    0.7
    >>> a['utf7']
    0
    .. versionchanged:: 0.5
       :class:`Accept` objects are forced immutable now.
    .. versionchanged:: 1.0.0
       :class:`Accept` internal values are no longer ordered
       alphabetically for equal quality tags. Instead the initial
       order is preserved.
    """
    def __init__(
        self, values: Accept | cabc.Iterable[tuple[str, float]] | None = ()
    ) -> None:
        if values is None:
            super().__init__()
            self.provided = False
...(truncado)

===== ./venv/lib/python3.13/site-packages/werkzeug/datastructures/file_storage.py =====
from __future__ import annotations
import collections.abc as cabc
import mimetypes
import os
import typing as t
from io import BytesIO
from os import fsdecode
from os import fspath
from .._internal import _plain_int
from .headers import Headers
from .structures import MultiDict
class FileStorage:
    """The :class:`FileStorage` class is a thin wrapper over incoming files.
    It is used by the request object to represent uploaded files.  All the
    attributes of the wrapper stream are proxied by the file storage so
    it's possible to do ``storage.read()`` instead of the long form
    ``storage.stream.read()``.
    """
    def __init__(
        self,
        stream: t.IO[bytes] | None = None,
        filename: str | None = None,
        name: str | None = None,
        content_type: str | None = None,
        content_length: int | None = None,
        headers: Headers | None = None,
    ):
        self.name = name
        self.stream = stream or BytesIO()
        # If no filename is provided, attempt to get the filename from
        # the stream object. Python names special streams like
        # ``<stderr>`` with angular brackets, skip these streams.
        if filename is None:
            filename = getattr(stream, "name", None)
            if filename is not None:
                filename = fsdecode(filename)
            if filename and filename[0] == "<" and filename[-1] == ">":
                filename = None
        else:
            filename = fsdecode(filename)
...(truncado)

===== ./venv/lib/python3.13/site-packages/werkzeug/datastructures/structures.py =====
from __future__ import annotations
import collections.abc as cabc
import typing as t
from copy import deepcopy
from .. import exceptions
from .._internal import _missing
from .mixins import ImmutableDictMixin
from .mixins import ImmutableListMixin
from .mixins import ImmutableMultiDictMixin
from .mixins import UpdateDictMixin
if t.TYPE_CHECKING:
    import typing_extensions as te
K = t.TypeVar("K")
V = t.TypeVar("V")
T = t.TypeVar("T")
def iter_multi_items(
    mapping: (
        MultiDict[K, V]
        | cabc.Mapping[K, V | list[V] | tuple[V, ...] | set[V]]
        | cabc.Iterable[tuple[K, V]]
    ),
) -> cabc.Iterator[tuple[K, V]]:
    """Iterates over the items of a mapping yielding keys and values
    without dropping any from more complex structures.
    """
    if isinstance(mapping, MultiDict):
        yield from mapping.items(multi=True)
    elif isinstance(mapping, cabc.Mapping):
        for key, value in mapping.items():
            if isinstance(value, (list, tuple, set)):
                for v in value:
                    yield key, v
            else:
                yield key, value
    else:
        yield from mapping
class ImmutableList(ImmutableListMixin, list[V]):  # type: ignore[misc]
    """An immutable :class:`list`.
    .. versionadded:: 0.5
    :private:
...(truncado)

===== ./venv/lib/python3.13/site-packages/werkzeug/datastructures/headers.py =====
from __future__ import annotations
import collections.abc as cabc
import re
import typing as t
from .._internal import _missing
from ..exceptions import BadRequestKeyError
from .mixins import ImmutableHeadersMixin
from .structures import iter_multi_items
from .structures import MultiDict
if t.TYPE_CHECKING:
    import typing_extensions as te
    from _typeshed.wsgi import WSGIEnvironment
T = t.TypeVar("T")
class Headers:
    """An object that stores some headers. It has a dict-like interface,
    but is ordered, can store the same key multiple times, and iterating
    yields ``(key, value)`` pairs instead of only keys.
    This data structure is useful if you want a nicer way to handle WSGI
    headers which are stored as tuples in a list.
    From Werkzeug 0.3 onwards, the :exc:`KeyError` raised by this class is
    also a subclass of the :class:`~exceptions.BadRequest` HTTP exception
    and will render a page for a ``400 BAD REQUEST`` if caught in a
    catch-all for HTTP exceptions.
    Headers is mostly compatible with the Python :class:`wsgiref.headers.Headers`
    class, with the exception of `__getitem__`.  :mod:`wsgiref` will return
    `None` for ``headers['missing']``, whereas :class:`Headers` will raise
    a :class:`KeyError`.
    To create a new ``Headers`` object, pass it a list, dict, or
    other ``Headers`` object with default values. These values are
    validated the same way values added later are.
    :param defaults: The list of default values for the :class:`Headers`.
    .. versionchanged:: 3.1
        Implement ``|`` and ``|=`` operators.
    .. versionchanged:: 2.1.0
        Default values are validated the same as values added later.
    .. versionchanged:: 0.9
       This data structure now stores unicode values similar to how the
       multi dicts do it.  The main difference is that bytes can be set as
       well which will automatically be latin1 decoded.
    .. versionchanged:: 0.9
...(truncado)

===== ./venv/lib/python3.13/site-packages/werkzeug/local.py =====
from __future__ import annotations
import copy
import math
import operator
import typing as t
from contextvars import ContextVar
from functools import partial
from functools import update_wrapper
from operator import attrgetter
from .wsgi import ClosingIterator
if t.TYPE_CHECKING:
    from _typeshed.wsgi import StartResponse
    from _typeshed.wsgi import WSGIApplication
    from _typeshed.wsgi import WSGIEnvironment
T = t.TypeVar("T")
F = t.TypeVar("F", bound=t.Callable[..., t.Any])
def release_local(local: Local | LocalStack[t.Any]) -> None:
    """Release the data for the current context in a :class:`Local` or
    :class:`LocalStack` without using a :class:`LocalManager`.
    This should not be needed for modern use cases, and may be removed
    in the future.
    .. versionadded:: 0.6.1
    """
    local.__release_local__()
class Local:
    """Create a namespace of context-local data. This wraps a
    :class:`ContextVar` containing a :class:`dict` value.
    This may incur a performance penalty compared to using individual
    context vars, as it has to copy data to avoid mutating the dict
    between nested contexts.
    :param context_var: The :class:`~contextvars.ContextVar` to use as
        storage for this local. If not given, one will be created.
        Context vars not created at the global scope may interfere with
        garbage collection.
    .. versionchanged:: 2.0
        Uses ``ContextVar`` instead of a custom storage implementation.
    """
    __slots__ = ("__storage",)
    def __init__(self, context_var: ContextVar[dict[str, t.Any]] | None = None) -> None:
        if context_var is None:
...(truncado)

===== ./venv/lib/python3.13/site-packages/werkzeug/security.py =====
from __future__ import annotations
import hashlib
import hmac
import os
import posixpath
import secrets
SALT_CHARS = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
DEFAULT_PBKDF2_ITERATIONS = 1_000_000
_os_alt_seps: list[str] = list(
    sep for sep in [os.sep, os.path.altsep] if sep is not None and sep != "/"
)
def gen_salt(length: int) -> str:
    """Generate a random string of SALT_CHARS with specified ``length``."""
    if length <= 0:
        raise ValueError("Salt length must be at least 1.")
    return "".join(secrets.choice(SALT_CHARS) for _ in range(length))
def _hash_internal(method: str, salt: str, password: str) -> tuple[str, str]:
    method, *args = method.split(":")
    salt_bytes = salt.encode()
    password_bytes = password.encode()
    if method == "scrypt":
        if not args:
            n = 2**15
            r = 8
            p = 1
        else:
            try:
                n, r, p = map(int, args)
            except ValueError:
                raise ValueError("'scrypt' takes 3 arguments.") from None
        maxmem = 132 * n * r * p  # ideally 128, but some extra seems needed
        return (
            hashlib.scrypt(
                password_bytes, salt=salt_bytes, n=n, r=r, p=p, maxmem=maxmem
            ).hex(),
            f"scrypt:{n}:{r}:{p}",
        )
    elif method == "pbkdf2":
        len_args = len(args)
        if len_args == 0:
...(truncado)

===== ./venv/lib/python3.13/site-packages/werkzeug/__init__.py =====
from .serving import run_simple as run_simple
from .test import Client as Client
from .wrappers import Request as Request
from .wrappers import Response as Response
...(truncado)

===== ./venv/lib/python3.13/site-packages/werkzeug/test.py =====
from __future__ import annotations
import dataclasses
import mimetypes
import sys
import typing as t
from collections import defaultdict
from datetime import datetime
from io import BytesIO
from itertools import chain
from random import random
from tempfile import TemporaryFile
from time import time
from urllib.parse import unquote
from urllib.parse import urlsplit
from urllib.parse import urlunsplit
from ._internal import _get_environ
from ._internal import _wsgi_decoding_dance
from ._internal import _wsgi_encoding_dance
from .datastructures import Authorization
from .datastructures import CallbackDict
from .datastructures import CombinedMultiDict
from .datastructures import EnvironHeaders
from .datastructures import FileMultiDict
from .datastructures import Headers
from .datastructures import MultiDict
from .http import dump_cookie
from .http import dump_options_header
from .http import parse_cookie
from .http import parse_date
from .http import parse_options_header
from .sansio.multipart import Data
from .sansio.multipart import Epilogue
from .sansio.multipart import Field
from .sansio.multipart import File
from .sansio.multipart import MultipartEncoder
from .sansio.multipart import Preamble
from .urls import _urlencode
from .urls import iri_to_uri
from .utils import cached_property
from .utils import get_content_type
...(truncado)

===== ./venv/lib/python3.13/site-packages/werkzeug/formparser.py =====
from __future__ import annotations
import typing as t
from io import BytesIO
from urllib.parse import parse_qsl
from ._internal import _plain_int
from .datastructures import FileStorage
from .datastructures import Headers
from .datastructures import MultiDict
from .exceptions import RequestEntityTooLarge
from .http import parse_options_header
from .sansio.multipart import Data
from .sansio.multipart import Epilogue
from .sansio.multipart import Field
from .sansio.multipart import File
from .sansio.multipart import MultipartDecoder
from .sansio.multipart import NeedData
from .wsgi import get_content_length
from .wsgi import get_input_stream
try:
    from tempfile import SpooledTemporaryFile
except ImportError:
    from tempfile import TemporaryFile
    SpooledTemporaryFile = None  # type: ignore
if t.TYPE_CHECKING:
    import typing as te
    from _typeshed.wsgi import WSGIEnvironment
    t_parse_result = tuple[
        t.IO[bytes], MultiDict[str, str], MultiDict[str, FileStorage]
    ]
    class TStreamFactory(te.Protocol):
        def __call__(
            self,
            total_content_length: int | None,
            content_type: str | None,
            filename: str | None,
            content_length: int | None = None,
        ) -> t.IO[bytes]: ...
F = t.TypeVar("F", bound=t.Callable[..., t.Any])
def default_stream_factory(
    total_content_length: int | None,
...(truncado)

===== ./venv/lib/python3.13/site-packages/werkzeug/utils.py =====
from __future__ import annotations
import io
import mimetypes
import os
import pkgutil
import re
import sys
import typing as t
import unicodedata
from datetime import datetime
from time import time
from urllib.parse import quote
from zlib import adler32
from markupsafe import escape
from ._internal import _DictAccessorProperty
from ._internal import _missing
from ._internal import _TAccessorValue
from .datastructures import Headers
from .exceptions import NotFound
from .exceptions import RequestedRangeNotSatisfiable
from .security import safe_join
from .wsgi import wrap_file
if t.TYPE_CHECKING:
    from _typeshed.wsgi import WSGIEnvironment
    from .wrappers.request import Request
    from .wrappers.response import Response
_T = t.TypeVar("_T")
_entity_re = re.compile(r"&([^;]+);")
_filename_ascii_strip_re = re.compile(r"[^A-Za-z0-9_.-]")
_windows_device_files = {
    "CON",
    "PRN",
    "AUX",
    "NUL",
    *(f"COM{i}" for i in range(10)),
    *(f"LPT{i}" for i in range(10)),
}
class cached_property(property, t.Generic[_T]):
    """A :func:`property` that is only evaluated once. Subsequent access
    returns the cached value. Setting the property sets the cached
...(truncado)

===== ./venv/lib/python3.13/site-packages/werkzeug/http.py =====
from __future__ import annotations
import email.utils
import re
import typing as t
import warnings
from datetime import date
from datetime import datetime
from datetime import time
from datetime import timedelta
from datetime import timezone
from enum import Enum
from hashlib import sha1
from time import mktime
from time import struct_time
from urllib.parse import quote
from urllib.parse import unquote
from urllib.request import parse_http_list as _parse_list_header
from ._internal import _dt_as_utc
from ._internal import _plain_int
if t.TYPE_CHECKING:
    from _typeshed.wsgi import WSGIEnvironment
_token_chars = frozenset(
    "!#$%&'*+-.0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ^_`abcdefghijklmnopqrstuvwxyz|~"
)
_etag_re = re.compile(r'([Ww]/)?(?:"(.*?)"|(.*?))(?:\s*,\s*|$)')
_entity_headers = frozenset(
    [
        "allow",
        "content-encoding",
        "content-language",
        "content-length",
        "content-location",
        "content-md5",
        "content-range",
        "content-type",
        "expires",
        "last-modified",
    ]
)
_hop_by_hop_headers = frozenset(
...(truncado)

===== ./venv/lib/python3.13/site-packages/werkzeug/exceptions.py =====
"""Implements a number of Python exceptions which can be raised from within
a view to trigger a standard HTTP non-200 response.
Usage Example
-------------
.. code-block:: python
    from werkzeug.wrappers.request import Request
    from werkzeug.exceptions import HTTPException, NotFound
    def view(request):
        raise NotFound()
    @Request.application
    def application(request):
        try:
            return view(request)
        except HTTPException as e:
            return e
As you can see from this example those exceptions are callable WSGI
applications. However, they are not Werkzeug response objects. You
can get a response object by calling ``get_response()`` on a HTTP
exception.
Keep in mind that you may have to pass an environ (WSGI) or scope
(ASGI) to ``get_response()`` because some errors fetch additional
information relating to the request.
If you want to hook in a different exception page to say, a 404 status
code, you can add a second except for a specific subclass of an error:
.. code-block:: python
    @Request.application
    def application(request):
        try:
            return view(request)
        except NotFound as e:
            return not_found(request)
        except HTTPException as e:
            return e
"""
from __future__ import annotations
import typing as t
from datetime import datetime
from markupsafe import escape
from markupsafe import Markup
from ._internal import _get_environ
...(truncado)

===== ./venv/lib/python3.13/site-packages/werkzeug/routing/matcher.py =====
from __future__ import annotations
import re
import typing as t
from dataclasses import dataclass
from dataclasses import field
from .converters import ValidationError
from .exceptions import NoMatch
from .exceptions import RequestAliasRedirect
from .exceptions import RequestPath
from .rules import Rule
from .rules import RulePart
class SlashRequired(Exception):
    pass
@dataclass
class State:
    """A representation of a rule state.
    This includes the *rules* that correspond to the state and the
    possible *static* and *dynamic* transitions to the next state.
    """
    dynamic: list[tuple[RulePart, State]] = field(default_factory=list)
    rules: list[Rule] = field(default_factory=list)
    static: dict[str, State] = field(default_factory=dict)
class StateMachineMatcher:
    def __init__(self, merge_slashes: bool) -> None:
        self._root = State()
        self.merge_slashes = merge_slashes
    def add(self, rule: Rule) -> None:
        state = self._root
        for part in rule._parts:
            if part.static:
                state.static.setdefault(part.content, State())
                state = state.static[part.content]
            else:
                for test_part, new_state in state.dynamic:
                    if test_part == part:
                        state = new_state
                        break
                else:
                    new_state = State()
                    state.dynamic.append((part, new_state))
...(truncado)

===== ./venv/lib/python3.13/site-packages/werkzeug/routing/__init__.py =====
"""When it comes to combining multiple controller or view functions
(however you want to call them) you need a dispatcher. A simple way
would be applying regular expression tests on the ``PATH_INFO`` and
calling registered callback functions that return the value then.
This module implements a much more powerful system than simple regular
expression matching because it can also convert values in the URLs and
build URLs.
Here a simple example that creates a URL map for an application with
two subdomains (www and kb) and some URL rules:
.. code-block:: python
    m = Map([
        # Static URLs
        Rule('/', endpoint='static/index'),
        Rule('/about', endpoint='static/about'),
        Rule('/help', endpoint='static/help'),
        # Knowledge Base
        Subdomain('kb', [
            Rule('/', endpoint='kb/index'),
            Rule('/browse/', endpoint='kb/browse'),
            Rule('/browse/<int:id>/', endpoint='kb/browse'),
            Rule('/browse/<int:id>/<int:page>', endpoint='kb/browse')
        ])
    ], default_subdomain='www')
If the application doesn't use subdomains it's perfectly fine to not set
the default subdomain and not use the `Subdomain` rule factory. The
endpoint in the rules can be anything, for example import paths or
unique identifiers. The WSGI application can use those endpoints to get the
handler for that URL.  It doesn't have to be a string at all but it's
recommended.
Now it's possible to create a URL adapter for one of the subdomains and
build URLs:
.. code-block:: python
    c = m.bind('example.com')
    c.build("kb/browse", dict(id=42))
    'http://kb.example.com/browse/42/'
    c.build("kb/browse", dict())
    'http://kb.example.com/browse/'
    c.build("kb/browse", dict(id=42, page=3))
    'http://kb.example.com/browse/42/3'
    c.build("static/about")
...(truncado)

===== ./venv/lib/python3.13/site-packages/werkzeug/routing/rules.py =====
from __future__ import annotations
import ast
import re
import typing as t
from dataclasses import dataclass
from string import Template
from types import CodeType
from urllib.parse import quote
from ..datastructures import iter_multi_items
from ..urls import _urlencode
from .converters import ValidationError
if t.TYPE_CHECKING:
    from .converters import BaseConverter
    from .map import Map
class Weighting(t.NamedTuple):
    number_static_weights: int
    static_weights: list[tuple[int, int]]
    number_argument_weights: int
    argument_weights: list[int]
@dataclass
class RulePart:
    """A part of a rule.
    Rules can be represented by parts as delimited by `/` with
    instances of this class representing those parts. The *content* is
    either the raw content if *static* or a regex string to match
    against. The *weight* can be used to order parts when matching.
    """
    content: str
    final: bool
    static: bool
    suffixed: bool
    weight: Weighting
_part_re = re.compile(
    r"""
    (?:
        (?P<slash>/)                                 # a slash
      |
        (?P<static>[^</]+)                           # static rule data
      |
        (?:
...(truncado)

===== ./venv/lib/python3.13/site-packages/werkzeug/routing/map.py =====
from __future__ import annotations
import typing as t
import warnings
from pprint import pformat
from threading import Lock
from urllib.parse import quote
from urllib.parse import urljoin
from urllib.parse import urlunsplit
from .._internal import _get_environ
from .._internal import _wsgi_decoding_dance
from ..datastructures import ImmutableDict
from ..datastructures import MultiDict
from ..exceptions import BadHost
from ..exceptions import HTTPException
from ..exceptions import MethodNotAllowed
from ..exceptions import NotFound
from ..urls import _urlencode
from ..wsgi import get_host
from .converters import DEFAULT_CONVERTERS
from .exceptions import BuildError
from .exceptions import NoMatch
from .exceptions import RequestAliasRedirect
from .exceptions import RequestPath
from .exceptions import RequestRedirect
from .exceptions import WebsocketMismatch
from .matcher import StateMachineMatcher
from .rules import _simple_rule_re
from .rules import Rule
if t.TYPE_CHECKING:
    from _typeshed.wsgi import WSGIApplication
    from _typeshed.wsgi import WSGIEnvironment
    from ..wrappers.request import Request
    from .converters import BaseConverter
    from .rules import RuleFactory
class Map:
    """The map class stores all the URL rules and some configuration
    parameters.  Some of the configuration values are only stored on the
    `Map` instance since those affect all rules, others are just defaults
    and can be overridden for each rule.  Note that you have to specify all
    arguments besides the `rules` as keyword arguments!
...(truncado)

===== ./venv/lib/python3.13/site-packages/werkzeug/routing/exceptions.py =====
from __future__ import annotations
import difflib
import typing as t
from ..exceptions import BadRequest
from ..exceptions import HTTPException
from ..utils import cached_property
from ..utils import redirect
if t.TYPE_CHECKING:
    from _typeshed.wsgi import WSGIEnvironment
    from ..wrappers.request import Request
    from ..wrappers.response import Response
    from .map import MapAdapter
    from .rules import Rule
class RoutingException(Exception):
    """Special exceptions that require the application to redirect, notifying
    about missing urls, etc.
    :internal:
    """
class RequestRedirect(HTTPException, RoutingException):
    """Raise if the map requests a redirect. This is for example the case if
    `strict_slashes` are activated and an url that requires a trailing slash.
    The attribute `new_url` contains the absolute destination url.
    """
    code = 308
    def __init__(self, new_url: str) -> None:
        super().__init__(new_url)
        self.new_url = new_url
    def get_response(
        self,
        environ: WSGIEnvironment | Request | None = None,
        scope: dict[str, t.Any] | None = None,
    ) -> Response:
        return redirect(self.new_url, self.code)
class RequestPath(RoutingException):
    """Internal exception."""
    __slots__ = ("path_info",)
    def __init__(self, path_info: str) -> None:
        super().__init__()
        self.path_info = path_info
class RequestAliasRedirect(RoutingException):  # noqa: B903
...(truncado)

===== ./venv/lib/python3.13/site-packages/werkzeug/routing/converters.py =====
from __future__ import annotations
import re
import typing as t
import uuid
from urllib.parse import quote
if t.TYPE_CHECKING:
    from .map import Map
class ValidationError(ValueError):
    """Validation error.  If a rule converter raises this exception the rule
    does not match the current URL and the next URL is tried.
    """
class BaseConverter:
    """Base class for all converters.
    .. versionchanged:: 2.3
        ``part_isolating`` defaults to ``False`` if ``regex`` contains a ``/``.
    """
    regex = "[^/]+"
    weight = 100
    part_isolating = True
    def __init_subclass__(cls, **kwargs: t.Any) -> None:
        super().__init_subclass__(**kwargs)
        # If the converter isn't inheriting its regex, disable part_isolating by default
        # if the regex contains a / character.
        if "regex" in cls.__dict__ and "part_isolating" not in cls.__dict__:
            cls.part_isolating = "/" not in cls.regex
    def __init__(self, map: Map, *args: t.Any, **kwargs: t.Any) -> None:
        self.map = map
    def to_python(self, value: str) -> t.Any:
        return value
    def to_url(self, value: t.Any) -> str:
        # safe = https://url.spec.whatwg.org/#url-path-segment-string
        return quote(str(value), safe="!$&'()*+,/:;=@")
class UnicodeConverter(BaseConverter):
    """This converter is the default converter and accepts any string but
    only one path segment.  Thus the string can not include a slash.
    This is the default validator.
    Example::
        Rule('/pages/<page>'),
        Rule('/<string(length=2):lang_code>')
    :param map: the :class:`Map`.
...(truncado)

===== ./venv/lib/python3.13/site-packages/werkzeug/urls.py =====
from __future__ import annotations
import codecs
import re
import typing as t
import urllib.parse
from urllib.parse import quote
from urllib.parse import unquote
from urllib.parse import urlencode
from urllib.parse import urlsplit
from urllib.parse import urlunsplit
from .datastructures import iter_multi_items
def _codec_error_url_quote(e: UnicodeError) -> tuple[str, int]:
    """Used in :func:`uri_to_iri` after unquoting to re-quote any
    invalid bytes.
    """
    # the docs state that UnicodeError does have these attributes,
    # but mypy isn't picking them up
    out = quote(e.object[e.start : e.end], safe="")  # type: ignore
    return out, e.end  # type: ignore
codecs.register_error("werkzeug.url_quote", _codec_error_url_quote)
def _make_unquote_part(name: str, chars: str) -> t.Callable[[str], str]:
    """Create a function that unquotes all percent encoded characters except those
    given. This allows working with unquoted characters if possible while not changing
    the meaning of a given part of a URL.
    """
    choices = "|".join(f"{ord(c):02X}" for c in sorted(chars))
    pattern = re.compile(f"((?:%(?:{choices}))+)", re.I)
    def _unquote_partial(value: str) -> str:
        parts = iter(pattern.split(value))
        out = []
        for part in parts:
            out.append(unquote(part, "utf-8", "werkzeug.url_quote"))
            out.append(next(parts, ""))
        return "".join(out)
    _unquote_partial.__name__ = f"_unquote_{name}"
    return _unquote_partial
_always_unsafe = bytes((*range(0x21), 0x25, 0x7F)).decode()
_unquote_fragment = _make_unquote_part("fragment", _always_unsafe)
_unquote_query = _make_unquote_part("query", _always_unsafe + "&=+#")
_unquote_path = _make_unquote_part("path", _always_unsafe + "/?#")
...(truncado)

===== ./venv/lib/python3.13/site-packages/werkzeug/debug/console.py =====
from __future__ import annotations
import code
import sys
import typing as t
from contextvars import ContextVar
from types import CodeType
from markupsafe import escape
from .repr import debug_repr
from .repr import dump
from .repr import helper
_stream: ContextVar[HTMLStringO] = ContextVar("werkzeug.debug.console.stream")
_ipy: ContextVar[_InteractiveConsole] = ContextVar("werkzeug.debug.console.ipy")
class HTMLStringO:
    """A StringO version that HTML escapes on write."""
    def __init__(self) -> None:
        self._buffer: list[str] = []
    def isatty(self) -> bool:
        return False
    def close(self) -> None:
        pass
    def flush(self) -> None:
        pass
    def seek(self, n: int, mode: int = 0) -> None:
        pass
    def readline(self) -> str:
        if len(self._buffer) == 0:
            return ""
        ret = self._buffer[0]
        del self._buffer[0]
        return ret
    def reset(self) -> str:
        val = "".join(self._buffer)
        del self._buffer[:]
        return val
    def _write(self, x: str) -> None:
        self._buffer.append(x)
    def write(self, x: str) -> None:
        self._write(escape(x))
    def writelines(self, x: t.Iterable[str]) -> None:
        self._write(escape("".join(x)))
...(truncado)

===== ./venv/lib/python3.13/site-packages/werkzeug/debug/tbtools.py =====
from __future__ import annotations
import itertools
import linecache
import os
import re
import sys
import sysconfig
import traceback
import typing as t
from markupsafe import escape
from ..utils import cached_property
from .console import Console
HEADER = """\
<!doctype html>
<html lang=en>
  <head>
    <title>%(title)s // Werkzeug Debugger</title>
    <link rel="stylesheet" href="?__debugger__=yes&amp;cmd=resource&amp;f=style.css">
    <link rel="shortcut icon"
        href="?__debugger__=yes&amp;cmd=resource&amp;f=console.png">
    <script src="?__debugger__=yes&amp;cmd=resource&amp;f=debugger.js"></script>
    <script>
      var CONSOLE_MODE = %(console)s,
          EVALEX = %(evalex)s,
          EVALEX_TRUSTED = %(evalex_trusted)s,
          SECRET = "%(secret)s";
    </script>
  </head>
  <body style="background-color: #fff">
    <div class="debugger">
"""
FOOTER = """\
      <div class="footer">
        Brought to you by <strong class="arthur">DON'T PANIC</strong>, your
        friendly Werkzeug powered traceback interpreter.
      </div>
    </div>
    <div class="pin-prompt">
      <div class="inner">
        <h3>Console Locked</h3>
...(truncado)

===== ./venv/lib/python3.13/site-packages/werkzeug/debug/__init__.py =====
from __future__ import annotations
import getpass
import hashlib
import json
import os
import pkgutil
import re
import sys
import time
import typing as t
import uuid
from contextlib import ExitStack
from io import BytesIO
from itertools import chain
from multiprocessing import Value
from os.path import basename
from os.path import join
from zlib import adler32
from .._internal import _log
from ..exceptions import NotFound
from ..exceptions import SecurityError
from ..http import parse_cookie
from ..sansio.utils import host_is_trusted
from ..security import gen_salt
from ..utils import send_file
from ..wrappers.request import Request
from ..wrappers.response import Response
from .console import Console
from .tbtools import DebugFrameSummary
from .tbtools import DebugTraceback
from .tbtools import render_console_html
if t.TYPE_CHECKING:
    from _typeshed.wsgi import StartResponse
    from _typeshed.wsgi import WSGIApplication
    from _typeshed.wsgi import WSGIEnvironment
PIN_TIME = 60 * 60 * 24 * 7
def hash_pin(pin: str) -> str:
    return hashlib.sha1(f"{pin} added salt".encode("utf-8", "replace")).hexdigest()[:12]
_machine_id: str | bytes | None = None
def get_machine_id() -> str | bytes | None:
...(truncado)

===== ./venv/lib/python3.13/site-packages/werkzeug/debug/shared/style.css =====
body, input  { font-family: sans-serif; color: #000; text-align: center;
               margin: 1em; padding: 0; font-size: 15px; }
h1, h2, h3   { font-weight: normal; }

input        { background-color: #fff; margin: 0; text-align: left;
               outline: none !important; }
input[type="submit"] { padding: 3px 6px; }
a            { color: #11557C; }
a:hover      { color: #177199; }
pre, code,
textarea     { font-family: monospace; font-size: 14px; }

div.debugger { text-align: left; padding: 12px; margin: auto;
               background-color: white; }
h1           { font-size: 36px; margin: 0 0 0.3em 0; }
div.detail { cursor: pointer; }
div.detail p { margin: 0 0 8px 13px; font-size: 14px; white-space: pre-wrap;
               font-family: monospace; }
div.explanation { margin: 20px 13px; font-size: 15px; color: #555; }
div.footer   { font-size: 13px; text-align: right; margin: 30px 0;
               color: #86989B; }

h2           { font-size: 16px; margin: 1.3em 0 0.0 0; padding: 9px;
               background-color: #11557C; color: white; }
h2 em, h3 em { font-style: normal; color: #A5D6D9; font-weight: normal; }

div.traceback, div.plain { border: 1px solid #ddd; margin: 0 0 1em 0; padding: 10px; }
div.plain p      { margin: 0; }
div.plain textarea,
div.plain pre { margin: 10px 0 0 0; padding: 4px;
                background-color: #E8EFF0; border: 1px solid #D3E7E9; }
div.plain textarea { width: 99%; height: 300px; }
div.traceback h3 { font-size: 1em; margin: 0 0 0.8em 0; }
div.traceback ul { list-style: none; margin: 0; padding: 0 0 0 1em; }
div.traceback h4 { font-size: 13px; font-weight: normal; margin: 0.7em 0 0.1em 0; }
div.traceback pre { margin: 0; padding: 5px 0 3px 15px;
                    background-color: #E8EFF0; border: 1px solid #D3E7E9; }
div.traceback .library .current { background: white; color: #555; }
div.traceback .expanded .current { background: #E8EFF0; color: black; }
div.traceback pre:hover { background-color: #DDECEE; color: black; cursor: pointer; }
...(truncado)

===== ./venv/lib/python3.13/site-packages/werkzeug/debug/repr.py =====
"""Object representations for debugging purposes. Unlike the default
repr, these expose more information and produce HTML instead of ASCII.
Together with the CSS and JavaScript of the debugger this gives a
colorful and more compact output.
"""
from __future__ import annotations
import codecs
import re
import sys
import typing as t
from collections import deque
from traceback import format_exception_only
from markupsafe import escape
missing = object()
_paragraph_re = re.compile(r"(?:\r\n|\r|\n){2,}")
RegexType = type(_paragraph_re)
HELP_HTML = """\
<div class=box>
  <h3>%(title)s</h3>
  <pre class=help>%(text)s</pre>
</div>\
"""
OBJECT_DUMP_HTML = """\
<div class=box>
  <h3>%(title)s</h3>
  %(repr)s
  <table>%(items)s</table>
</div>\
"""
def debug_repr(obj: object) -> str:
    """Creates a debug repr of an object as HTML string."""
    return DebugReprGenerator().repr(obj)
def dump(obj: object = missing) -> None:
    """Print the object details to stdout._write (for the interactive
    console of the web debugger.
    """
    gen = DebugReprGenerator()
    if obj is missing:
        rv = gen.dump_locals(sys._getframe(1).f_locals)
    else:
...(truncado)

===== ./venv/lib/python3.13/site-packages/werkzeug/wsgi.py =====
from __future__ import annotations
import io
import typing as t
from functools import partial
from functools import update_wrapper
from .exceptions import ClientDisconnected
from .exceptions import RequestEntityTooLarge
from .sansio import utils as _sansio_utils
from .sansio.utils import host_is_trusted  # noqa: F401 # Imported as part of API
if t.TYPE_CHECKING:
    from _typeshed.wsgi import WSGIApplication
    from _typeshed.wsgi import WSGIEnvironment
def responder(f: t.Callable[..., WSGIApplication]) -> WSGIApplication:
    """Marks a function as responder.  Decorate a function with it and it
    will automatically call the return value as WSGI application.
    Example::
        @responder
        def application(environ, start_response):
            return Response('Hello World!')
    """
    return update_wrapper(lambda *a: f(*a)(*a[-2:]), f)
def get_current_url(
    environ: WSGIEnvironment,
    root_only: bool = False,
    strip_querystring: bool = False,
    host_only: bool = False,
    trusted_hosts: t.Iterable[str] | None = None,
) -> str:
    """Recreate the URL for a request from the parts in a WSGI
    environment.
    The URL is an IRI, not a URI, so it may contain Unicode characters.
    Use :func:`~werkzeug.urls.iri_to_uri` to convert it to ASCII.
    :param environ: The WSGI environment to get the URL parts from.
    :param root_only: Only build the root path, don't include the
        remaining path or query string.
    :param strip_querystring: Don't include the query string.
    :param host_only: Only build the scheme and host.
    :param trusted_hosts: A list of trusted host names to validate the
        host against.
    """
...(truncado)

===== ./venv/lib/python3.13/site-packages/werkzeug/testapp.py =====
"""A small application that can be used to test a WSGI server and check
it for WSGI compliance.
"""
from __future__ import annotations
import importlib.metadata
import os
import sys
import typing as t
from textwrap import wrap
from markupsafe import escape
from .wrappers.request import Request
from .wrappers.response import Response
TEMPLATE = """\
<!doctype html>
<html lang=en>
<title>WSGI Information</title>
<style type="text/css">
  @import url(https://fonts.googleapis.com/css?family=Ubuntu);
  body       { font-family: 'Lucida Grande', 'Lucida Sans Unicode', 'Geneva',
               'Verdana', sans-serif; background-color: white; color: #000;
               font-size: 15px; text-align: center; }
  div.box    { text-align: left; width: 45em; margin: auto; padding: 50px 0;
               background-color: white; }
  h1, h2     { font-family: 'Ubuntu', 'Lucida Grande', 'Lucida Sans Unicode',
               'Geneva', 'Verdana', sans-serif; font-weight: normal; }
  h1         { margin: 0 0 30px 0; }
  h2         { font-size: 1.4em; margin: 1em 0 0.5em 0; }
  table      { width: 100%%; border-collapse: collapse; border: 1px solid #AFC5C9 }
  table th   { background-color: #AFC1C4; color: white; font-size: 0.72em;
               font-weight: normal; width: 18em; vertical-align: top;
               padding: 0.5em 0 0.1em 0.5em; }
  table td   { border: 1px solid #AFC5C9; padding: 0.1em 0 0.1em 0.5em; }
  code       { font-family: 'Consolas', 'Monaco', 'Bitstream Vera Sans Mono',
               monospace; font-size: 0.7em; }
  ul li      { line-height: 1.5em; }
  ul.path    { font-size: 0.7em; margin: 0 -30px; padding: 8px 30px;
               list-style: none; background: #E8EFF0; }
  ul.path li { line-height: 1.6em; }
  li.virtual { color: #999; text-decoration: underline; }
  li.exp     { background: white; }
...(truncado)

===== ./venv/lib/python3.13/site-packages/click/_winconsole.py =====
from __future__ import annotations
import collections.abc as cabc
import io
import sys
import time
import typing as t
from ctypes import Array
from ctypes import byref
from ctypes import c_char
from ctypes import c_char_p
from ctypes import c_int
from ctypes import c_ssize_t
from ctypes import c_ulong
from ctypes import c_void_p
from ctypes import POINTER
from ctypes import py_object
from ctypes import Structure
from ctypes.wintypes import DWORD
from ctypes.wintypes import HANDLE
from ctypes.wintypes import LPCWSTR
from ctypes.wintypes import LPWSTR
from ._compat import _NonClosingTextIOWrapper
assert sys.platform == "win32"
import msvcrt  # noqa: E402
from ctypes import windll  # noqa: E402
from ctypes import WINFUNCTYPE  # noqa: E402
c_ssize_p = POINTER(c_ssize_t)
kernel32 = windll.kernel32
GetStdHandle = kernel32.GetStdHandle
ReadConsoleW = kernel32.ReadConsoleW
WriteConsoleW = kernel32.WriteConsoleW
GetConsoleMode = kernel32.GetConsoleMode
GetLastError = kernel32.GetLastError
GetCommandLineW = WINFUNCTYPE(LPWSTR)(("GetCommandLineW", windll.kernel32))
CommandLineToArgvW = WINFUNCTYPE(POINTER(LPWSTR), LPCWSTR, POINTER(c_int))(
    ("CommandLineToArgvW", windll.shell32)
)
LocalFree = WINFUNCTYPE(c_void_p, c_void_p)(("LocalFree", windll.kernel32))
STDIN_HANDLE = GetStdHandle(-10)
STDOUT_HANDLE = GetStdHandle(-11)
...(truncado)

===== ./venv/lib/python3.13/site-packages/click/_textwrap.py =====
from __future__ import annotations
import collections.abc as cabc
import textwrap
from contextlib import contextmanager
class TextWrapper(textwrap.TextWrapper):
    def _handle_long_word(
        self,
        reversed_chunks: list[str],
        cur_line: list[str],
        cur_len: int,
        width: int,
    ) -> None:
        space_left = max(width - cur_len, 1)
        if self.break_long_words:
            last = reversed_chunks[-1]
            cut = last[:space_left]
            res = last[space_left:]
            cur_line.append(cut)
            reversed_chunks[-1] = res
        elif not cur_line:
            cur_line.append(reversed_chunks.pop())
    @contextmanager
    def extra_indent(self, indent: str) -> cabc.Iterator[None]:
        old_initial_indent = self.initial_indent
        old_subsequent_indent = self.subsequent_indent
        self.initial_indent += indent
        self.subsequent_indent += indent
        try:
            yield
        finally:
            self.initial_indent = old_initial_indent
            self.subsequent_indent = old_subsequent_indent
    def indent_only(self, text: str) -> str:
        rv = []
        for idx, line in enumerate(text.splitlines()):
            indent = self.initial_indent
            if idx > 0:
                indent = self.subsequent_indent
            rv.append(f"{indent}{line}")
        return "\n".join(rv)
...(truncado)

===== ./venv/lib/python3.13/site-packages/click/globals.py =====
from __future__ import annotations
import typing as t
from threading import local
if t.TYPE_CHECKING:
    from .core import Context
_local = local()
@t.overload
def get_current_context(silent: t.Literal[False] = False) -> Context: ...
@t.overload
def get_current_context(silent: bool = ...) -> Context | None: ...
def get_current_context(silent: bool = False) -> Context | None:
    """Returns the current click context.  This can be used as a way to
    access the current context object from anywhere.  This is a more implicit
    alternative to the :func:`pass_context` decorator.  This function is
    primarily useful for helpers such as :func:`echo` which might be
    interested in changing its behavior based on the current context.
    To push the current context, :meth:`Context.scope` can be used.
    .. versionadded:: 5.0
    :param silent: if set to `True` the return value is `None` if no context
                   is available.  The default behavior is to raise a
                   :exc:`RuntimeError`.
    """
    try:
        return t.cast("Context", _local.stack[-1])
    except (AttributeError, IndexError) as e:
        if not silent:
            raise RuntimeError("There is no active click context.") from e
    return None
def push_context(ctx: Context) -> None:
    """Pushes a new context to the current stack."""
    _local.__dict__.setdefault("stack", []).append(ctx)
def pop_context() -> None:
    """Removes the top level from the stack."""
    _local.stack.pop()
def resolve_color_default(color: bool | None = None) -> bool | None:
    """Internal helper to get the default value of the color flag.  If a
    value is passed it's returned unchanged, otherwise it's looked up from
    the current context.
    """
    if color is not None:
...(truncado)

===== ./venv/lib/python3.13/site-packages/click/__init__.py =====
"""
Click is a simple Python module inspired by the stdlib optparse to make
writing command line scripts fun. Unlike other modules, it's based
around a simple API that does not come with too much magic and is
composable.
"""
from __future__ import annotations
from .core import Argument as Argument
from .core import Command as Command
from .core import CommandCollection as CommandCollection
from .core import Context as Context
from .core import Group as Group
from .core import Option as Option
from .core import Parameter as Parameter
from .decorators import argument as argument
from .decorators import command as command
from .decorators import confirmation_option as confirmation_option
from .decorators import group as group
from .decorators import help_option as help_option
from .decorators import make_pass_decorator as make_pass_decorator
from .decorators import option as option
from .decorators import pass_context as pass_context
from .decorators import pass_obj as pass_obj
from .decorators import password_option as password_option
from .decorators import version_option as version_option
from .exceptions import Abort as Abort
from .exceptions import BadArgumentUsage as BadArgumentUsage
from .exceptions import BadOptionUsage as BadOptionUsage
from .exceptions import BadParameter as BadParameter
from .exceptions import ClickException as ClickException
from .exceptions import FileError as FileError
from .exceptions import MissingParameter as MissingParameter
from .exceptions import NoSuchOption as NoSuchOption
from .exceptions import UsageError as UsageError
from .formatting import HelpFormatter as HelpFormatter
from .formatting import wrap_text as wrap_text
from .globals import get_current_context as get_current_context
from .termui import clear as clear
from .termui import confirm as confirm
from .termui import echo_via_pager as echo_via_pager
...(truncado)

===== ./venv/lib/python3.13/site-packages/click/core.py =====
from __future__ import annotations
import collections.abc as cabc
import enum
import errno
import inspect
import os
import sys
import typing as t
from collections import abc
from collections import Counter
from contextlib import AbstractContextManager
from contextlib import contextmanager
from contextlib import ExitStack
from functools import update_wrapper
from gettext import gettext as _
from gettext import ngettext
from itertools import repeat
from types import TracebackType
from . import types
from .exceptions import Abort
from .exceptions import BadParameter
from .exceptions import ClickException
from .exceptions import Exit
from .exceptions import MissingParameter
from .exceptions import NoArgsIsHelpError
from .exceptions import UsageError
from .formatting import HelpFormatter
from .formatting import join_options
from .globals import pop_context
from .globals import push_context
from .parser import _flag_needs_value
from .parser import _OptionParser
from .parser import _split_opt
from .termui import confirm
from .termui import prompt
from .termui import style
from .utils import _detect_program_name
from .utils import _expand_args
from .utils import echo
from .utils import make_default_short_help
...(truncado)

===== ./venv/lib/python3.13/site-packages/click/types.py =====
from __future__ import annotations
import collections.abc as cabc
import enum
import os
import stat
import sys
import typing as t
from datetime import datetime
from gettext import gettext as _
from gettext import ngettext
from ._compat import _get_argv_encoding
from ._compat import open_stream
from .exceptions import BadParameter
from .utils import format_filename
from .utils import LazyFile
from .utils import safecall
if t.TYPE_CHECKING:
    import typing_extensions as te
    from .core import Context
    from .core import Parameter
    from .shell_completion import CompletionItem
ParamTypeValue = t.TypeVar("ParamTypeValue")
class ParamType:
    """Represents the type of a parameter. Validates and converts values
    from the command line or Python into the correct type.
    To implement a custom type, subclass and implement at least the
    following:
    -   The :attr:`name` class attribute must be set.
    -   Calling an instance of the type with ``None`` must return
        ``None``. This is already implemented by default.
    -   :meth:`convert` must convert string values to the correct type.
    -   :meth:`convert` must accept values that are already the correct
        type.
    -   It must be able to convert a value if the ``ctx`` and ``param``
        arguments are ``None``. This can occur when converting prompt
        input.
    """
    is_composite: t.ClassVar[bool] = False
    arity: t.ClassVar[int] = 1
    #: the descriptive name of this type
...(truncado)

===== ./venv/lib/python3.13/site-packages/click/formatting.py =====
from __future__ import annotations
import collections.abc as cabc
from contextlib import contextmanager
from gettext import gettext as _
from ._compat import term_len
from .parser import _split_opt
FORCED_WIDTH: int | None = None
def measure_table(rows: cabc.Iterable[tuple[str, str]]) -> tuple[int, ...]:
    widths: dict[int, int] = {}
    for row in rows:
        for idx, col in enumerate(row):
            widths[idx] = max(widths.get(idx, 0), term_len(col))
    return tuple(y for x, y in sorted(widths.items()))
def iter_rows(
    rows: cabc.Iterable[tuple[str, str]], col_count: int
) -> cabc.Iterator[tuple[str, ...]]:
    for row in rows:
        yield row + ("",) * (col_count - len(row))
def wrap_text(
    text: str,
    width: int = 78,
    initial_indent: str = "",
    subsequent_indent: str = "",
    preserve_paragraphs: bool = False,
) -> str:
    """A helper function that intelligently wraps text.  By default, it
    assumes that it operates on a single paragraph of text but if the
    `preserve_paragraphs` parameter is provided it will intelligently
    handle paragraphs (defined by two empty lines).
    If paragraphs are handled, a paragraph can be prefixed with an empty
    line containing the ``\\b`` character (``\\x08``) to indicate that
    no rewrapping should happen in that block.
    :param text: the text that should be rewrapped.
    :param width: the maximum width for the text.
    :param initial_indent: the initial indent that should be placed on the
                           first line as a string.
    :param subsequent_indent: the indent string that should be placed on
                              each consecutive line.
    :param preserve_paragraphs: if this flag is set then the wrapping will
                                intelligently handle paragraphs.
...(truncado)

===== ./venv/lib/python3.13/site-packages/click/parser.py =====
"""
This module started out as largely a copy paste from the stdlib's
optparse module with the features removed that we do not need from
optparse because we implement them in Click on a higher level (for
instance type handling, help formatting and a lot more).
The plan is to remove more and more from here over time.
The reason this is a different module and not optparse from the stdlib
is that there are differences in 2.x and 3.x about the error messages
generated and optparse in the stdlib uses gettext for no good reason
and might cause us issues.
Click uses parts of optparse written by Gregory P. Ward and maintained
by the Python Software Foundation. This is limited to code in parser.py.
Copyright 2001-2006 Gregory P. Ward. All rights reserved.
Copyright 2002-2006 Python Software Foundation. All rights reserved.
"""
from __future__ import annotations
import collections.abc as cabc
import typing as t
from collections import deque
from gettext import gettext as _
from gettext import ngettext
from .exceptions import BadArgumentUsage
from .exceptions import BadOptionUsage
from .exceptions import NoSuchOption
from .exceptions import UsageError
if t.TYPE_CHECKING:
    from .core import Argument as CoreArgument
    from .core import Context
    from .core import Option as CoreOption
    from .core import Parameter as CoreParameter
V = t.TypeVar("V")
_flag_needs_value = object()
def _unpack_args(
    args: cabc.Sequence[str], nargs_spec: cabc.Sequence[int]
) -> tuple[cabc.Sequence[str | cabc.Sequence[str | None] | None], list[str]]:
    """Given an iterable of arguments and an iterable of nargs specifications,
    it returns a tuple with all the unpacked arguments at the first index
    and all remaining arguments as the second.
    The nargs specification is the number of arguments that should be consumed
    or `-1` to indicate that this position should eat up all the remainders.
...(truncado)

===== ./venv/lib/python3.13/site-packages/click/termui.py =====
from __future__ import annotations
import collections.abc as cabc
import inspect
import io
import itertools
import sys
import typing as t
from contextlib import AbstractContextManager
from gettext import gettext as _
from ._compat import isatty
from ._compat import strip_ansi
from .exceptions import Abort
from .exceptions import UsageError
from .globals import resolve_color_default
from .types import Choice
from .types import convert_type
from .types import ParamType
from .utils import echo
from .utils import LazyFile
if t.TYPE_CHECKING:
    from ._termui_impl import ProgressBar
V = t.TypeVar("V")
visible_prompt_func: t.Callable[[str], str] = input
_ansi_colors = {
    "black": 30,
    "red": 31,
    "green": 32,
    "yellow": 33,
    "blue": 34,
    "magenta": 35,
    "cyan": 36,
    "white": 37,
    "reset": 39,
    "bright_black": 90,
    "bright_red": 91,
    "bright_green": 92,
    "bright_yellow": 93,
    "bright_blue": 94,
    "bright_magenta": 95,
    "bright_cyan": 96,
...(truncado)

===== ./venv/lib/python3.13/site-packages/click/utils.py =====
from __future__ import annotations
import collections.abc as cabc
import os
import re
import sys
import typing as t
from functools import update_wrapper
from types import ModuleType
from types import TracebackType
from ._compat import _default_text_stderr
from ._compat import _default_text_stdout
from ._compat import _find_binary_writer
from ._compat import auto_wrap_for_ansi
from ._compat import binary_streams
from ._compat import open_stream
from ._compat import should_strip_ansi
from ._compat import strip_ansi
from ._compat import text_streams
from ._compat import WIN
from .globals import resolve_color_default
if t.TYPE_CHECKING:
    import typing_extensions as te
    P = te.ParamSpec("P")
R = t.TypeVar("R")
def _posixify(name: str) -> str:
    return "-".join(name.split()).lower()
def safecall(func: t.Callable[P, R]) -> t.Callable[P, R | None]:
    """Wraps a function so that it swallows exceptions."""
    def wrapper(*args: P.args, **kwargs: P.kwargs) -> R | None:
        try:
            return func(*args, **kwargs)
        except Exception:
            pass
        return None
    return update_wrapper(wrapper, func)
def make_str(value: t.Any) -> str:
    """Converts a value into a valid string."""
    if isinstance(value, bytes):
        try:
            return value.decode(sys.getfilesystemencoding())
...(truncado)

===== ./venv/lib/python3.13/site-packages/click/exceptions.py =====
from __future__ import annotations
import collections.abc as cabc
import typing as t
from gettext import gettext as _
from gettext import ngettext
from ._compat import get_text_stderr
from .globals import resolve_color_default
from .utils import echo
from .utils import format_filename
if t.TYPE_CHECKING:
    from .core import Command
    from .core import Context
    from .core import Parameter
def _join_param_hints(param_hint: cabc.Sequence[str] | str | None) -> str | None:
    if param_hint is not None and not isinstance(param_hint, str):
        return " / ".join(repr(x) for x in param_hint)
    return param_hint
class ClickException(Exception):
    """An exception that Click can handle and show to the user."""
    #: The exit code for this exception.
    exit_code = 1
    def __init__(self, message: str) -> None:
        super().__init__(message)
        # The context will be removed by the time we print the message, so cache
        # the color settings here to be used later on (in `show`)
        self.show_color: bool | None = resolve_color_default()
        self.message = message
    def format_message(self) -> str:
        return self.message
    def __str__(self) -> str:
        return self.message
    def show(self, file: t.IO[t.Any] | None = None) -> None:
        if file is None:
            file = get_text_stderr()
        echo(
            _("Error: {message}").format(message=self.format_message()),
            file=file,
            color=self.show_color,
        )
class UsageError(ClickException):
...(truncado)

===== ./venv/lib/python3.13/site-packages/click/shell_completion.py =====
from __future__ import annotations
import collections.abc as cabc
import os
import re
import typing as t
from gettext import gettext as _
from .core import Argument
from .core import Command
from .core import Context
from .core import Group
from .core import Option
from .core import Parameter
from .core import ParameterSource
from .utils import echo
def shell_complete(
    cli: Command,
    ctx_args: cabc.MutableMapping[str, t.Any],
    prog_name: str,
    complete_var: str,
    instruction: str,
) -> int:
    """Perform shell completion for the given CLI program.
    :param cli: Command being called.
    :param ctx_args: Extra arguments to pass to
        ``cli.make_context``.
    :param prog_name: Name of the executable in the shell.
    :param complete_var: Name of the environment variable that holds
        the completion instruction.
    :param instruction: Value of ``complete_var`` with the completion
        instruction and shell, in the form ``instruction_shell``.
    :return: Status code to exit with.
    """
    shell, _, instruction = instruction.partition("_")
    comp_cls = get_completion_class(shell)
    if comp_cls is None:
        return 1
    comp = comp_cls(cli, ctx_args, prog_name, complete_var)
    if instruction == "source":
        echo(comp.source())
        return 0
...(truncado)

===== ./venv/lib/python3.13/site-packages/click/_compat.py =====
from __future__ import annotations
import codecs
import collections.abc as cabc
import io
import os
import re
import sys
import typing as t
from types import TracebackType
from weakref import WeakKeyDictionary
CYGWIN = sys.platform.startswith("cygwin")
WIN = sys.platform.startswith("win")
auto_wrap_for_ansi: t.Callable[[t.TextIO], t.TextIO] | None = None
_ansi_re = re.compile(r"\033\[[;?0-9]*[a-zA-Z]")
def _make_text_stream(
    stream: t.BinaryIO,
    encoding: str | None,
    errors: str | None,
    force_readable: bool = False,
    force_writable: bool = False,
) -> t.TextIO:
    if encoding is None:
        encoding = get_best_encoding(stream)
    if errors is None:
        errors = "replace"
    return _NonClosingTextIOWrapper(
        stream,
        encoding,
        errors,
        line_buffering=True,
        force_readable=force_readable,
        force_writable=force_writable,
    )
def is_ascii_encoding(encoding: str) -> bool:
    """Checks if a given encoding is ascii."""
    try:
        return codecs.lookup(encoding).name == "ascii"
    except LookupError:
        return False
def get_best_encoding(stream: t.IO[t.Any]) -> str:
...(truncado)

===== ./venv/lib/python3.13/site-packages/click/_termui_impl.py =====
"""
This module contains implementations for the termui module. To keep the
import time of Click down, some infrequently used functionality is
placed in this module and only imported as needed.
"""
from __future__ import annotations
import collections.abc as cabc
import contextlib
import math
import os
import shlex
import sys
import time
import typing as t
from gettext import gettext as _
from io import StringIO
from pathlib import Path
from shutil import which
from types import TracebackType
from ._compat import _default_text_stdout
from ._compat import CYGWIN
from ._compat import get_best_encoding
from ._compat import isatty
from ._compat import open_stream
from ._compat import strip_ansi
from ._compat import term_len
from ._compat import WIN
from .exceptions import ClickException
from .utils import echo
V = t.TypeVar("V")
if os.name == "nt":
    BEFORE_BAR = "\r"
    AFTER_BAR = "\n"
else:
    BEFORE_BAR = "\r\033[?25l"
    AFTER_BAR = "\033[?25h\n"
class ProgressBar(t.Generic[V]):
    def __init__(
        self,
        iterable: cabc.Iterable[V] | None,
...(truncado)

===== ./venv/lib/python3.13/site-packages/click/testing.py =====
from __future__ import annotations
import collections.abc as cabc
import contextlib
import io
import os
import shlex
import shutil
import sys
import tempfile
import typing as t
from types import TracebackType
from . import _compat
from . import formatting
from . import termui
from . import utils
from ._compat import _find_binary_reader
if t.TYPE_CHECKING:
    from _typeshed import ReadableBuffer
    from .core import Command
class EchoingStdin:
    def __init__(self, input: t.BinaryIO, output: t.BinaryIO) -> None:
        self._input = input
        self._output = output
        self._paused = False
    def __getattr__(self, x: str) -> t.Any:
        return getattr(self._input, x)
    def _echo(self, rv: bytes) -> bytes:
        if not self._paused:
            self._output.write(rv)
        return rv
    def read(self, n: int = -1) -> bytes:
        return self._echo(self._input.read(n))
    def read1(self, n: int = -1) -> bytes:
        return self._echo(self._input.read1(n))  # type: ignore
    def readline(self, n: int = -1) -> bytes:
        return self._echo(self._input.readline(n))
    def readlines(self) -> list[bytes]:
        return [self._echo(x) for x in self._input.readlines()]
    def __iter__(self) -> cabc.Iterator[bytes]:
        return iter(self._echo(x) for x in self._input)
...(truncado)

===== ./venv/lib/python3.13/site-packages/click/decorators.py =====
from __future__ import annotations
import inspect
import typing as t
from functools import update_wrapper
from gettext import gettext as _
from .core import Argument
from .core import Command
from .core import Context
from .core import Group
from .core import Option
from .core import Parameter
from .globals import get_current_context
from .utils import echo
if t.TYPE_CHECKING:
    import typing_extensions as te
    P = te.ParamSpec("P")
R = t.TypeVar("R")
T = t.TypeVar("T")
_AnyCallable = t.Callable[..., t.Any]
FC = t.TypeVar("FC", bound="_AnyCallable | Command")
def pass_context(f: t.Callable[te.Concatenate[Context, P], R]) -> t.Callable[P, R]:
    """Marks a callback as wanting to receive the current context
    object as first argument.
    """
    def new_func(*args: P.args, **kwargs: P.kwargs) -> R:
        return f(get_current_context(), *args, **kwargs)
    return update_wrapper(new_func, f)
def pass_obj(f: t.Callable[te.Concatenate[T, P], R]) -> t.Callable[P, R]:
    """Similar to :func:`pass_context`, but only pass the object on the
    context onwards (:attr:`Context.obj`).  This is useful if that object
    represents the state of a nested system.
    """
    def new_func(*args: P.args, **kwargs: P.kwargs) -> R:
        return f(get_current_context().obj, *args, **kwargs)
    return update_wrapper(new_func, f)
def make_pass_decorator(
    object_type: type[T], ensure: bool = False
) -> t.Callable[[t.Callable[te.Concatenate[T, P], R]], t.Callable[P, R]]:
    """Given an object type this creates a decorator that will work
    similar to :func:`pass_obj` but instead of passing the object of the
...(truncado)

===== ./venv/lib/python3.13/site-packages/gunicorn/pidfile.py =====
import errno
import os
import tempfile
class Pidfile:
    """\
    Manage a PID file. If a specific name is provided
    it and '"%s.oldpid" % name' will be used. Otherwise
    we create a temp file using os.mkstemp.
    """
    def __init__(self, fname):
        self.fname = fname
        self.pid = None
    def create(self, pid):
        oldpid = self.validate()
        if oldpid:
            if oldpid == os.getpid():
                return
            msg = "Already running on PID %s (or pid file '%s' is stale)"
            raise RuntimeError(msg % (oldpid, self.fname))
        self.pid = pid
        # Write pidfile
        fdir = os.path.dirname(self.fname)
        if fdir and not os.path.isdir(fdir):
            raise RuntimeError("%s doesn't exist. Can't create pidfile." % fdir)
        fd, fname = tempfile.mkstemp(dir=fdir)
        os.write(fd, ("%s\n" % self.pid).encode('utf-8'))
        if self.fname:
            os.rename(fname, self.fname)
        else:
            self.fname = fname
        os.close(fd)
        # set permissions to -rw-r--r--
        os.chmod(self.fname, 420)
    def rename(self, path):
        self.unlink()
        self.fname = path
        self.create(self.pid)
    def unlink(self):
        """ delete pidfile"""
        try:
...(truncado)

===== ./venv/lib/python3.13/site-packages/gunicorn/reloader.py =====
import os
import os.path
import re
import sys
import time
import threading
COMPILED_EXT_RE = re.compile(r'py[co]$')
class Reloader(threading.Thread):
    def __init__(self, extra_files=None, interval=1, callback=None):
        super().__init__()
        self.daemon = True
        self._extra_files = set(extra_files or ())
        self._interval = interval
        self._callback = callback
    def add_extra_file(self, filename):
        self._extra_files.add(filename)
    def get_files(self):
        fnames = [
            COMPILED_EXT_RE.sub('py', module.__file__)
            for module in tuple(sys.modules.values())
            if getattr(module, '__file__', None)
        ]
        fnames.extend(self._extra_files)
        return fnames
    def run(self):
        mtimes = {}
        while True:
            for filename in self.get_files():
                try:
                    mtime = os.stat(filename).st_mtime
                except OSError:
                    continue
                old_time = mtimes.get(filename)
                if old_time is None:
                    mtimes[filename] = mtime
                    continue
                elif mtime > old_time:
                    if self._callback:
                        self._callback(filename)
            time.sleep(self._interval)
...(truncado)

===== ./venv/lib/python3.13/site-packages/gunicorn/config.py =====
import argparse
import copy
import grp
import inspect
import ipaddress
import os
import pwd
import re
import shlex
import ssl
import sys
import textwrap
from gunicorn import __version__, util
from gunicorn.errors import ConfigError
from gunicorn.reloader import reloader_engines
KNOWN_SETTINGS = []
PLATFORM = sys.platform
def make_settings(ignore=None):
    settings = {}
    ignore = ignore or ()
    for s in KNOWN_SETTINGS:
        setting = s()
        if setting.name in ignore:
            continue
        settings[setting.name] = setting.copy()
    return settings
def auto_int(_, x):
    # for compatible with octal numbers in python3
    if re.match(r'0(\d)', x, re.IGNORECASE):
        x = x.replace('0', '0o', 1)
    return int(x, 0)
class Config:
    def __init__(self, usage=None, prog=None):
        self.settings = make_settings()
        self.usage = usage
        self.prog = prog or os.path.basename(sys.argv[0])
        self.env_orig = os.environ.copy()
    def __str__(self):
        lines = []
        kmax = max(len(k) for k in self.settings)
...(truncado)

===== ./venv/lib/python3.13/site-packages/gunicorn/app/wsgiapp.py =====
import os
from gunicorn.errors import ConfigError
from gunicorn.app.base import Application
from gunicorn import util
class WSGIApplication(Application):
    def init(self, parser, opts, args):
        self.app_uri = None
        if opts.paste:
            from .pasterapp import has_logging_config
            config_uri = os.path.abspath(opts.paste)
            config_file = config_uri.split('#')[0]
            if not os.path.exists(config_file):
                raise ConfigError("%r not found" % config_file)
            self.cfg.set("default_proc_name", config_file)
            self.app_uri = config_uri
            if has_logging_config(config_file):
                self.cfg.set("logconfig", config_file)
            return
        if len(args) > 0:
            self.cfg.set("default_proc_name", args[0])
            self.app_uri = args[0]
    def load_config(self):
        super().load_config()
        if self.app_uri is None:
            if self.cfg.wsgi_app is not None:
                self.app_uri = self.cfg.wsgi_app
            else:
                raise ConfigError("No application module specified.")
    def load_wsgiapp(self):
        return util.import_app(self.app_uri)
    def load_pasteapp(self):
        from .pasterapp import get_wsgi_app
        return get_wsgi_app(self.app_uri, defaults=self.cfg.paste_global_conf)
    def load(self):
        if self.cfg.paste is not None:
            return self.load_pasteapp()
        else:
            return self.load_wsgiapp()
def run(prog=None):
    """\
...(truncado)

===== ./venv/lib/python3.13/site-packages/gunicorn/app/__init__.py =====
...(truncado)

===== ./venv/lib/python3.13/site-packages/gunicorn/app/pasterapp.py =====
import configparser
import os
from paste.deploy import loadapp
from gunicorn.app.wsgiapp import WSGIApplication
from gunicorn.config import get_default_config_file
def get_wsgi_app(config_uri, name=None, defaults=None):
    if ':' not in config_uri:
        config_uri = "config:%s" % config_uri
    return loadapp(
        config_uri,
        name=name,
        relative_to=os.getcwd(),
        global_conf=defaults,
    )
def has_logging_config(config_file):
    parser = configparser.ConfigParser()
    parser.read([config_file])
    return parser.has_section('loggers')
def serve(app, global_conf, **local_conf):
    """\
    A Paste Deployment server runner.
    Example configuration:
        [server:main]
        use = egg:gunicorn#main
        host = 127.0.0.1
        port = 5000
    """
    config_file = global_conf['__file__']
    gunicorn_config_file = local_conf.pop('config', None)
    host = local_conf.pop('host', '')
    port = local_conf.pop('port', '')
    if host and port:
        local_conf['bind'] = '%s:%s' % (host, port)
    elif host:
        local_conf['bind'] = host.split(',')
    class PasterServerApplication(WSGIApplication):
        def load_config(self):
            self.cfg.set("default_proc_name", config_file)
            if has_logging_config(config_file):
                self.cfg.set("logconfig", config_file)
...(truncado)

===== ./venv/lib/python3.13/site-packages/gunicorn/app/base.py =====
import importlib.util
import importlib.machinery
import os
import sys
import traceback
from gunicorn import util
from gunicorn.arbiter import Arbiter
from gunicorn.config import Config, get_default_config_file
from gunicorn import debug
class BaseApplication:
    """
    An application interface for configuring and loading
    the various necessities for any given web framework.
    """
    def __init__(self, usage=None, prog=None):
        self.usage = usage
        self.cfg = None
        self.callable = None
        self.prog = prog
        self.logger = None
        self.do_load_config()
    def do_load_config(self):
        """
        Loads the configuration
        """
        try:
            self.load_default_config()
            self.load_config()
        except Exception as e:
            print("\nError: %s" % str(e), file=sys.stderr)
            sys.stderr.flush()
            sys.exit(1)
    def load_default_config(self):
        # init configuration
        self.cfg = Config(self.usage, prog=self.prog)
    def init(self, parser, opts, args):
        raise NotImplementedError
    def load(self):
        raise NotImplementedError
    def load_config(self):
...(truncado)

===== ./venv/lib/python3.13/site-packages/gunicorn/instrument/__init__.py =====
...(truncado)

===== ./venv/lib/python3.13/site-packages/gunicorn/instrument/statsd.py =====
"Bare-bones implementation of statsD's protocol, client-side"
import logging
import socket
from re import sub
from gunicorn.glogging import Logger
METRIC_VAR = "metric"
VALUE_VAR = "value"
MTYPE_VAR = "mtype"
GAUGE_TYPE = "gauge"
COUNTER_TYPE = "counter"
HISTOGRAM_TYPE = "histogram"
class Statsd(Logger):
    """statsD-based instrumentation, that passes as a logger
    """
    def __init__(self, cfg):
        Logger.__init__(self, cfg)
        self.prefix = sub(r"^(.+[^.]+)\.*$", "\\g<1>.", cfg.statsd_prefix)
        if isinstance(cfg.statsd_host, str):
            address_family = socket.AF_UNIX
        else:
            address_family = socket.AF_INET
        try:
            self.sock = socket.socket(address_family, socket.SOCK_DGRAM)
            self.sock.connect(cfg.statsd_host)
        except Exception:
            self.sock = None
        self.dogstatsd_tags = cfg.dogstatsd_tags
    # Log errors and warnings
    def critical(self, msg, *args, **kwargs):
        Logger.critical(self, msg, *args, **kwargs)
        self.increment("gunicorn.log.critical", 1)
    def error(self, msg, *args, **kwargs):
        Logger.error(self, msg, *args, **kwargs)
        self.increment("gunicorn.log.error", 1)
    def warning(self, msg, *args, **kwargs):
        Logger.warning(self, msg, *args, **kwargs)
        self.increment("gunicorn.log.warning", 1)
    def exception(self, msg, *args, **kwargs):
        Logger.exception(self, msg, *args, **kwargs)
        self.increment("gunicorn.log.exception", 1)
...(truncado)

===== ./venv/lib/python3.13/site-packages/gunicorn/util.py =====
import ast
import email.utils
import errno
import fcntl
import html
import importlib
import inspect
import io
import logging
import os
import pwd
import random
import re
import socket
import sys
import textwrap
import time
import traceback
import warnings
try:
    import importlib.metadata as importlib_metadata
except (ModuleNotFoundError, ImportError):
    import importlib_metadata
from gunicorn.errors import AppImportError
from gunicorn.workers import SUPPORTED_WORKERS
import urllib.parse
REDIRECT_TO = getattr(os, 'devnull', '/dev/null')
hop_headers = set("""
    connection keep-alive proxy-authenticate proxy-authorization
    te trailers transfer-encoding upgrade
    server date
    """.split())
try:
    from setproctitle import setproctitle
    def _setproctitle(title):
        setproctitle("gunicorn: %s" % title)
except ImportError:
    def _setproctitle(title):
        pass
def load_entry_point(distribution, group, name):
...(truncado)

===== ./venv/lib/python3.13/site-packages/gunicorn/systemd.py =====
import os
import socket
SD_LISTEN_FDS_START = 3
def listen_fds(unset_environment=True):
    """
    Get the number of sockets inherited from systemd socket activation.
    :param unset_environment: clear systemd environment variables unless False
    :type unset_environment: bool
    :return: the number of sockets to inherit from systemd socket activation
    :rtype: int
    Returns zero immediately if $LISTEN_PID is not set to the current pid.
    Otherwise, returns the number of systemd activation sockets specified by
    $LISTEN_FDS.
    When $LISTEN_PID matches the current pid, unsets the environment variables
    unless the ``unset_environment`` flag is ``False``.
    .. note::
        Unlike the sd_listen_fds C function, this implementation does not set
        the FD_CLOEXEC flag because the gunicorn arbiter never needs to do this.
    .. seealso::
        `<https://www.freedesktop.org/software/systemd/man/sd_listen_fds.html>`_
    """
    fds = int(os.environ.get('LISTEN_FDS', 0))
    listen_pid = int(os.environ.get('LISTEN_PID', 0))
    if listen_pid != os.getpid():
        return 0
    if unset_environment:
        os.environ.pop('LISTEN_PID', None)
        os.environ.pop('LISTEN_FDS', None)
    return fds
def sd_notify(state, logger, unset_environment=False):
    """Send a notification to systemd. state is a string; see
    the man page of sd_notify (http://www.freedesktop.org/software/systemd/man/sd_notify.html)
    for a description of the allowable values.
    If the unset_environment parameter is True, sd_notify() will unset
    the $NOTIFY_SOCKET environment variable before returning (regardless of
    whether the function call itself succeeded or not). Further calls to
    sd_notify() will then fail, but the variable is no longer inherited by
    child processes.
    """
    addr = os.environ.get('NOTIFY_SOCKET')
...(truncado)

===== ./venv/lib/python3.13/site-packages/gunicorn/__init__.py =====
version_info = (23, 0, 0)
__version__ = ".".join([str(v) for v in version_info])
SERVER = "gunicorn"
SERVER_SOFTWARE = "%s/%s" % (SERVER, __version__)
...(truncado)

===== ./venv/lib/python3.13/site-packages/gunicorn/sock.py =====
import errno
import os
import socket
import ssl
import stat
import sys
import time
from gunicorn import util
class BaseSocket:
    def __init__(self, address, conf, log, fd=None):
        self.log = log
        self.conf = conf
        self.cfg_addr = address
        if fd is None:
            sock = socket.socket(self.FAMILY, socket.SOCK_STREAM)
            bound = False
        else:
            sock = socket.fromfd(fd, self.FAMILY, socket.SOCK_STREAM)
            os.close(fd)
            bound = True
        self.sock = self.set_options(sock, bound=bound)
    def __str__(self):
        return "<socket %d>" % self.sock.fileno()
    def __getattr__(self, name):
        return getattr(self.sock, name)
    def set_options(self, sock, bound=False):
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        if (self.conf.reuse_port
                and hasattr(socket, 'SO_REUSEPORT')):  # pragma: no cover
            try:
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, 1)
            except OSError as err:
                if err.errno not in (errno.ENOPROTOOPT, errno.EINVAL):
                    raise
        if not bound:
            self.bind(sock)
        sock.setblocking(0)
        # make sure that the socket can be inherited
        if hasattr(sock, "set_inheritable"):
            sock.set_inheritable(True)
...(truncado)

===== ./venv/lib/python3.13/site-packages/gunicorn/http/body.py =====
import io
import sys
from gunicorn.http.errors import (NoMoreData, ChunkMissingTerminator,
                                  InvalidChunkSize)
class ChunkedReader:
    def __init__(self, req, unreader):
        self.req = req
        self.parser = self.parse_chunked(unreader)
        self.buf = io.BytesIO()
    def read(self, size):
        if not isinstance(size, int):
            raise TypeError("size must be an integer type")
        if size < 0:
            raise ValueError("Size must be positive.")
        if size == 0:
            return b""
        if self.parser:
            while self.buf.tell() < size:
                try:
                    self.buf.write(next(self.parser))
                except StopIteration:
                    self.parser = None
                    break
        data = self.buf.getvalue()
        ret, rest = data[:size], data[size:]
        self.buf = io.BytesIO()
        self.buf.write(rest)
        return ret
    def parse_trailers(self, unreader, data):
        buf = io.BytesIO()
        buf.write(data)
        idx = buf.getvalue().find(b"\r\n\r\n")
        done = buf.getvalue()[:2] == b"\r\n"
        while idx < 0 and not done:
            self.get_data(unreader, buf)
            idx = buf.getvalue().find(b"\r\n\r\n")
            done = buf.getvalue()[:2] == b"\r\n"
        if done:
            unreader.unread(buf.getvalue()[2:])
            return b""
...(truncado)

===== ./venv/lib/python3.13/site-packages/gunicorn/http/__init__.py =====
from gunicorn.http.message import Message, Request
from gunicorn.http.parser import RequestParser
__all__ = ['Message', 'Request', 'RequestParser']
...(truncado)

===== ./venv/lib/python3.13/site-packages/gunicorn/http/message.py =====
import io
import re
import socket
from gunicorn.http.body import ChunkedReader, LengthReader, EOFReader, Body
from gunicorn.http.errors import (
    InvalidHeader, InvalidHeaderName, NoMoreData,
    InvalidRequestLine, InvalidRequestMethod, InvalidHTTPVersion,
    LimitRequestLine, LimitRequestHeaders,
    UnsupportedTransferCoding, ObsoleteFolding,
)
from gunicorn.http.errors import InvalidProxyLine, ForbiddenProxyRequest
from gunicorn.http.errors import InvalidSchemeHeaders
from gunicorn.util import bytes_to_str, split_request_uri
MAX_REQUEST_LINE = 8190
MAX_HEADERS = 32768
DEFAULT_MAX_HEADERFIELD_SIZE = 8190
RFC9110_5_6_2_TOKEN_SPECIALS = r"!#$%&'*+-.^_`|~"
TOKEN_RE = re.compile(r"[%s0-9a-zA-Z]+" % (re.escape(RFC9110_5_6_2_TOKEN_SPECIALS)))
METHOD_BADCHAR_RE = re.compile("[a-z#]")
VERSION_RE = re.compile(r"HTTP/(\d)\.(\d)")
RFC9110_5_5_INVALID_AND_DANGEROUS = re.compile(r"[\0\r\n]")
class Message:
    def __init__(self, cfg, unreader, peer_addr):
        self.cfg = cfg
        self.unreader = unreader
        self.peer_addr = peer_addr
        self.remote_addr = peer_addr
        self.version = None
        self.headers = []
        self.trailers = []
        self.body = None
        self.scheme = "https" if cfg.is_ssl else "http"
        self.must_close = False
        # set headers limits
        self.limit_request_fields = cfg.limit_request_fields
        if (self.limit_request_fields <= 0
                or self.limit_request_fields > MAX_HEADERS):
            self.limit_request_fields = MAX_HEADERS
        self.limit_request_field_size = cfg.limit_request_field_size
        if self.limit_request_field_size < 0:
...(truncado)

===== ./venv/lib/python3.13/site-packages/gunicorn/http/unreader.py =====
import io
import os
class Unreader:
    def __init__(self):
        self.buf = io.BytesIO()
    def chunk(self):
        raise NotImplementedError()
    def read(self, size=None):
        if size is not None and not isinstance(size, int):
            raise TypeError("size parameter must be an int or long.")
        if size is not None:
            if size == 0:
                return b""
            if size < 0:
                size = None
        self.buf.seek(0, os.SEEK_END)
        if size is None and self.buf.tell():
            ret = self.buf.getvalue()
            self.buf = io.BytesIO()
            return ret
        if size is None:
            d = self.chunk()
            return d
        while self.buf.tell() < size:
            chunk = self.chunk()
            if not chunk:
                ret = self.buf.getvalue()
                self.buf = io.BytesIO()
                return ret
            self.buf.write(chunk)
        data = self.buf.getvalue()
        self.buf = io.BytesIO()
        self.buf.write(data[size:])
        return data[:size]
    def unread(self, data):
        self.buf.seek(0, os.SEEK_END)
        self.buf.write(data)
class SocketUnreader(Unreader):
    def __init__(self, sock, max_chunk=8192):
        super().__init__()
...(truncado)

===== ./venv/lib/python3.13/site-packages/gunicorn/http/parser.py =====
from gunicorn.http.message import Request
from gunicorn.http.unreader import SocketUnreader, IterUnreader
class Parser:
    mesg_class = None
    def __init__(self, cfg, source, source_addr):
        self.cfg = cfg
        if hasattr(source, "recv"):
            self.unreader = SocketUnreader(source)
        else:
            self.unreader = IterUnreader(source)
        self.mesg = None
        self.source_addr = source_addr
        # request counter (for keepalive connetions)
        self.req_count = 0
    def __iter__(self):
        return self
    def __next__(self):
        # Stop if HTTP dictates a stop.
        if self.mesg and self.mesg.should_close():
            raise StopIteration()
        # Discard any unread body of the previous message
        if self.mesg:
            data = self.mesg.body.read(8192)
            while data:
                data = self.mesg.body.read(8192)
        # Parse the next request
        self.req_count += 1
        self.mesg = self.mesg_class(self.cfg, self.unreader, self.source_addr, self.req_count)
        if not self.mesg:
            raise StopIteration()
        return self.mesg
    next = __next__
class RequestParser(Parser):
    mesg_class = Request
...(truncado)

===== ./venv/lib/python3.13/site-packages/gunicorn/http/errors.py =====
class ParseException(Exception):
    pass
class NoMoreData(IOError):
    def __init__(self, buf=None):
        self.buf = buf
    def __str__(self):
        return "No more data after: %r" % self.buf
class ConfigurationProblem(ParseException):
    def __init__(self, info):
        self.info = info
        self.code = 500
    def __str__(self):
        return "Configuration problem: %s" % self.info
class InvalidRequestLine(ParseException):
    def __init__(self, req):
        self.req = req
        self.code = 400
    def __str__(self):
        return "Invalid HTTP request line: %r" % self.req
class InvalidRequestMethod(ParseException):
    def __init__(self, method):
        self.method = method
    def __str__(self):
        return "Invalid HTTP method: %r" % self.method
class InvalidHTTPVersion(ParseException):
    def __init__(self, version):
        self.version = version
    def __str__(self):
        return "Invalid HTTP Version: %r" % (self.version,)
class InvalidHeader(ParseException):
    def __init__(self, hdr, req=None):
        self.hdr = hdr
        self.req = req
    def __str__(self):
        return "Invalid HTTP Header: %r" % self.hdr
class ObsoleteFolding(ParseException):
    def __init__(self, hdr):
        self.hdr = hdr
    def __str__(self):
        return "Obsolete line folding is unacceptable: %r" % (self.hdr, )
...(truncado)

===== ./venv/lib/python3.13/site-packages/gunicorn/http/wsgi.py =====
import io
import logging
import os
import re
import sys
from gunicorn.http.message import TOKEN_RE
from gunicorn.http.errors import ConfigurationProblem, InvalidHeader, InvalidHeaderName
from gunicorn import SERVER_SOFTWARE, SERVER
from gunicorn import util
BLKSIZE = 0x3FFFFFFF
HEADER_VALUE_RE = re.compile(r'[ \t\x21-\x7e\x80-\xff]*')
log = logging.getLogger(__name__)
class FileWrapper:
    def __init__(self, filelike, blksize=8192):
        self.filelike = filelike
        self.blksize = blksize
        if hasattr(filelike, 'close'):
            self.close = filelike.close
    def __getitem__(self, key):
        data = self.filelike.read(self.blksize)
        if data:
            return data
        raise IndexError
class WSGIErrorsWrapper(io.RawIOBase):
    def __init__(self, cfg):
        # There is no public __init__ method for RawIOBase so
        # we don't need to call super() in the __init__ method.
        # pylint: disable=super-init-not-called
        errorlog = logging.getLogger("gunicorn.error")
        handlers = errorlog.handlers
        self.streams = []
        if cfg.errorlog == "-":
            self.streams.append(sys.stderr)
            handlers = handlers[1:]
        for h in handlers:
            if hasattr(h, "stream"):
                self.streams.append(h.stream)
    def write(self, data):
        for stream in self.streams:
            try:
...(truncado)

===== ./venv/lib/python3.13/site-packages/gunicorn/debug.py =====
"""The debug module contains utilities and functions for better
debugging Gunicorn."""
import sys
import linecache
import re
import inspect
__all__ = ['spew', 'unspew']
_token_spliter = re.compile(r'\W+')
class Spew:
    def __init__(self, trace_names=None, show_values=True):
        self.trace_names = trace_names
        self.show_values = show_values
    def __call__(self, frame, event, arg):
        if event == 'line':
            lineno = frame.f_lineno
            if '__file__' in frame.f_globals:
                filename = frame.f_globals['__file__']
                if (filename.endswith('.pyc') or
                        filename.endswith('.pyo')):
                    filename = filename[:-1]
                name = frame.f_globals['__name__']
                line = linecache.getline(filename, lineno)
            else:
                name = '[unknown]'
                try:
                    src = inspect.getsourcelines(frame)
                    line = src[lineno]
                except OSError:
                    line = 'Unknown code named [%s].  VM instruction #%d' % (
                        frame.f_code.co_name, frame.f_lasti)
            if self.trace_names is None or name in self.trace_names:
                print('%s:%s: %s' % (name, lineno, line.rstrip()))
                if not self.show_values:
                    return self
                details = []
                tokens = _token_spliter.split(line)
                for tok in tokens:
                    if tok in frame.f_globals:
                        details.append('%s=%r' % (tok, frame.f_globals[tok]))
                    if tok in frame.f_locals:
...(truncado)

===== ./venv/lib/python3.13/site-packages/gunicorn/arbiter.py =====
import errno
import os
import random
import select
import signal
import sys
import time
import traceback
from gunicorn.errors import HaltServer, AppImportError
from gunicorn.pidfile import Pidfile
from gunicorn import sock, systemd, util
from gunicorn import __version__, SERVER_SOFTWARE
class Arbiter:
    """
    Arbiter maintain the workers processes alive. It launches or
    kills them if needed. It also manages application reloading
    via SIGHUP/USR2.
    """
    # A flag indicating if a worker failed to
    # to boot. If a worker process exist with
    # this error code, the arbiter will terminate.
    WORKER_BOOT_ERROR = 3
    # A flag indicating if an application failed to be loaded
    APP_LOAD_ERROR = 4
    START_CTX = {}
    LISTENERS = []
    WORKERS = {}
    PIPE = []
    # I love dynamic languages
    SIG_QUEUE = []
    SIGNALS = [getattr(signal, "SIG%s" % x)
               for x in "HUP QUIT INT TERM TTIN TTOU USR1 USR2 WINCH".split()]
    SIG_NAMES = dict(
        (getattr(signal, name), name[3:].lower()) for name in dir(signal)
        if name[:3] == "SIG" and name[3] != "_"
    )
    def __init__(self, app):
        os.environ["SERVER_SOFTWARE"] = SERVER_SOFTWARE
        self._num_workers = None
        self._last_logged_active_worker_count = None
...(truncado)

===== ./venv/lib/python3.13/site-packages/gunicorn/workers/sync.py =====
from datetime import datetime
import errno
import os
import select
import socket
import ssl
import sys
from gunicorn import http
from gunicorn.http import wsgi
from gunicorn import sock
from gunicorn import util
from gunicorn.workers import base
class StopWaiting(Exception):
    """ exception raised to stop waiting for a connection """
class SyncWorker(base.Worker):
    def accept(self, listener):
        client, addr = listener.accept()
        client.setblocking(1)
        util.close_on_exec(client)
        self.handle(listener, client, addr)
    def wait(self, timeout):
        try:
            self.notify()
            ret = select.select(self.wait_fds, [], [], timeout)
            if ret[0]:
                if self.PIPE[0] in ret[0]:
                    os.read(self.PIPE[0], 1)
                return ret[0]
        except OSError as e:
            if e.args[0] == errno.EINTR:
                return self.sockets
            if e.args[0] == errno.EBADF:
                if self.nr < 0:
                    return self.sockets
                else:
                    raise StopWaiting
            raise
    def is_parent_alive(self):
        # If our parent changed then we shut down.
        if self.ppid != os.getppid():
...(truncado)

===== ./venv/lib/python3.13/site-packages/gunicorn/workers/base_async.py =====
from datetime import datetime
import errno
import socket
import ssl
import sys
from gunicorn import http
from gunicorn.http import wsgi
from gunicorn import util
from gunicorn.workers import base
ALREADY_HANDLED = object()
class AsyncWorker(base.Worker):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.worker_connections = self.cfg.worker_connections
    def timeout_ctx(self):
        raise NotImplementedError()
    def is_already_handled(self, respiter):
        # some workers will need to overload this function to raise a StopIteration
        return respiter == ALREADY_HANDLED
    def handle(self, listener, client, addr):
        req = None
        try:
            parser = http.RequestParser(self.cfg, client, addr)
            try:
                listener_name = listener.getsockname()
                if not self.cfg.keepalive:
                    req = next(parser)
                    self.handle_request(listener_name, req, client, addr)
                else:
                    # keepalive loop
                    proxy_protocol_info = {}
                    while True:
                        req = None
                        with self.timeout_ctx():
                            req = next(parser)
                        if not req:
                            break
                        if req.proxy_protocol_info:
                            proxy_protocol_info = req.proxy_protocol_info
                        else:
...(truncado)

===== ./venv/lib/python3.13/site-packages/gunicorn/workers/gtornado.py =====
import os
import sys
try:
    import tornado
except ImportError:
    raise RuntimeError("You need tornado installed to use this worker.")
import tornado.web
import tornado.httpserver
from tornado.ioloop import IOLoop, PeriodicCallback
from tornado.wsgi import WSGIContainer
from gunicorn.workers.base import Worker
from gunicorn import __version__ as gversion
from gunicorn.sock import ssl_context
TORNADO5 = tornado.version_info >= (5, 0, 0)
class TornadoWorker(Worker):
    @classmethod
    def setup(cls):
        web = sys.modules.pop("tornado.web")
        old_clear = web.RequestHandler.clear
        def clear(self):
            old_clear(self)
            if "Gunicorn" not in self._headers["Server"]:
                self._headers["Server"] += " (Gunicorn/%s)" % gversion
        web.RequestHandler.clear = clear
        sys.modules["tornado.web"] = web
    def handle_exit(self, sig, frame):
        if self.alive:
            super().handle_exit(sig, frame)
    def handle_request(self):
        self.nr += 1
        if self.alive and self.nr >= self.max_requests:
            self.log.info("Autorestarting worker after current request.")
            self.alive = False
    def watchdog(self):
        if self.alive:
            self.notify()
        if self.ppid != os.getppid():
            self.log.info("Parent changed, shutting down: %s", self)
            self.alive = False
    def heartbeat(self):
...(truncado)

===== ./venv/lib/python3.13/site-packages/gunicorn/workers/__init__.py =====
SUPPORTED_WORKERS = {
    "sync": "gunicorn.workers.sync.SyncWorker",
    "eventlet": "gunicorn.workers.geventlet.EventletWorker",
    "gevent": "gunicorn.workers.ggevent.GeventWorker",
    "gevent_wsgi": "gunicorn.workers.ggevent.GeventPyWSGIWorker",
    "gevent_pywsgi": "gunicorn.workers.ggevent.GeventPyWSGIWorker",
    "tornado": "gunicorn.workers.gtornado.TornadoWorker",
    "gthread": "gunicorn.workers.gthread.ThreadWorker",
}
...(truncado)

===== ./venv/lib/python3.13/site-packages/gunicorn/workers/geventlet.py =====
from functools import partial
import sys
try:
    import eventlet
except ImportError:
    raise RuntimeError("eventlet worker requires eventlet 0.24.1 or higher")
else:
    from packaging.version import parse as parse_version
    if parse_version(eventlet.__version__) < parse_version('0.24.1'):
        raise RuntimeError("eventlet worker requires eventlet 0.24.1 or higher")
from eventlet import hubs, greenthread
from eventlet.greenio import GreenSocket
import eventlet.wsgi
import greenlet
from gunicorn.workers.base_async import AsyncWorker
from gunicorn.sock import ssl_wrap_socket
EVENTLET_WSGI_LOCAL = getattr(eventlet.wsgi, "WSGI_LOCAL", None)
EVENTLET_ALREADY_HANDLED = getattr(eventlet.wsgi, "ALREADY_HANDLED", None)
def _eventlet_socket_sendfile(self, file, offset=0, count=None):
    # Based on the implementation in gevent which in turn is slightly
    # modified from the standard library implementation.
    if self.gettimeout() == 0:
        raise ValueError("non-blocking sockets are not supported")
    if offset:
        file.seek(offset)
    blocksize = min(count, 8192) if count else 8192
    total_sent = 0
    # localize variable access to minimize overhead
    file_read = file.read
    sock_send = self.send
    try:
        while True:
            if count:
                blocksize = min(count - total_sent, blocksize)
                if blocksize <= 0:
                    break
            data = memoryview(file_read(blocksize))
            if not data:
                break  # EOF
            while True:
...(truncado)

===== ./venv/lib/python3.13/site-packages/gunicorn/workers/workertmp.py =====
import os
import time
import platform
import tempfile
from gunicorn import util
PLATFORM = platform.system()
IS_CYGWIN = PLATFORM.startswith('CYGWIN')
class WorkerTmp:
    def __init__(self, cfg):
        old_umask = os.umask(cfg.umask)
        fdir = cfg.worker_tmp_dir
        if fdir and not os.path.isdir(fdir):
            raise RuntimeError("%s doesn't exist. Can't create workertmp." % fdir)
        fd, name = tempfile.mkstemp(prefix="wgunicorn-", dir=fdir)
        os.umask(old_umask)
        # change the owner and group of the file if the worker will run as
        # a different user or group, so that the worker can modify the file
        if cfg.uid != os.geteuid() or cfg.gid != os.getegid():
            util.chown(name, cfg.uid, cfg.gid)
        # unlink the file so we don't leak temporary files
        try:
            if not IS_CYGWIN:
                util.unlink(name)
            # In Python 3.8, open() emits RuntimeWarning if buffering=1 for binary mode.
            # Because we never write to this file, pass 0 to switch buffering off.
            self._tmp = os.fdopen(fd, 'w+b', 0)
        except Exception:
            os.close(fd)
            raise
    def notify(self):
        new_time = time.monotonic()
        os.utime(self._tmp.fileno(), (new_time, new_time))
    def last_update(self):
        return os.fstat(self._tmp.fileno()).st_mtime
    def fileno(self):
        return self._tmp.fileno()
    def close(self):
        return self._tmp.close()
...(truncado)

===== ./venv/lib/python3.13/site-packages/gunicorn/workers/ggevent.py =====
import os
import sys
from datetime import datetime
from functools import partial
import time
try:
    import gevent
except ImportError:
    raise RuntimeError("gevent worker requires gevent 1.4 or higher")
else:
    from packaging.version import parse as parse_version
    if parse_version(gevent.__version__) < parse_version('1.4'):
        raise RuntimeError("gevent worker requires gevent 1.4 or higher")
from gevent.pool import Pool
from gevent.server import StreamServer
from gevent import hub, monkey, socket, pywsgi
import gunicorn
from gunicorn.http.wsgi import base_environ
from gunicorn.sock import ssl_context
from gunicorn.workers.base_async import AsyncWorker
VERSION = "gevent/%s gunicorn/%s" % (gevent.__version__, gunicorn.__version__)
class GeventWorker(AsyncWorker):
    server_class = None
    wsgi_handler = None
    def patch(self):
        monkey.patch_all()
        # patch sockets
        sockets = []
        for s in self.sockets:
            sockets.append(socket.socket(s.FAMILY, socket.SOCK_STREAM,
                                         fileno=s.sock.fileno()))
        self.sockets = sockets
    def notify(self):
        super().notify()
        if self.ppid != os.getppid():
            self.log.info("Parent changed, shutting down: %s", self)
            sys.exit(0)
    def timeout_ctx(self):
        return gevent.Timeout(self.cfg.keepalive, False)
    def run(self):
...(truncado)

===== ./venv/lib/python3.13/site-packages/gunicorn/workers/gthread.py =====
from concurrent import futures
import errno
import os
import selectors
import socket
import ssl
import sys
import time
from collections import deque
from datetime import datetime
from functools import partial
from threading import RLock
from . import base
from .. import http
from .. import util
from .. import sock
from ..http import wsgi
class TConn:
    def __init__(self, cfg, sock, client, server):
        self.cfg = cfg
        self.sock = sock
        self.client = client
        self.server = server
        self.timeout = None
        self.parser = None
        self.initialized = False
        # set the socket to non blocking
        self.sock.setblocking(False)
    def init(self):
        self.initialized = True
        self.sock.setblocking(True)
        if self.parser is None:
            # wrap the socket if needed
            if self.cfg.is_ssl:
                self.sock = sock.ssl_wrap_socket(self.sock, self.cfg)
            # initialize the parser
            self.parser = http.RequestParser(self.cfg, self.sock, self.client)
    def set_timeout(self):
        # set the timeout
        self.timeout = time.time() + self.cfg.keepalive
...(truncado)

===== ./venv/lib/python3.13/site-packages/gunicorn/workers/base.py =====
import io
import os
import signal
import sys
import time
import traceback
from datetime import datetime
from random import randint
from ssl import SSLError
from gunicorn import util
from gunicorn.http.errors import (
    ForbiddenProxyRequest, InvalidHeader,
    InvalidHeaderName, InvalidHTTPVersion,
    InvalidProxyLine, InvalidRequestLine,
    InvalidRequestMethod, InvalidSchemeHeaders,
    LimitRequestHeaders, LimitRequestLine,
    UnsupportedTransferCoding,
    ConfigurationProblem, ObsoleteFolding,
)
from gunicorn.http.wsgi import Response, default_environ
from gunicorn.reloader import reloader_engines
from gunicorn.workers.workertmp import WorkerTmp
class Worker:
    SIGNALS = [getattr(signal, "SIG%s" % x) for x in (
        "ABRT HUP QUIT INT TERM USR1 USR2 WINCH CHLD".split()
    )]
    PIPE = []
    def __init__(self, age, ppid, sockets, app, timeout, cfg, log):
        """\
        This is called pre-fork so it shouldn't do anything to the
        current process. If there's a need to make process wide
        changes you'll want to do that in ``self.init_process()``.
        """
        self.age = age
        self.pid = "[booting]"
        self.ppid = ppid
        self.sockets = sockets
        self.app = app
        self.timeout = timeout
        self.cfg = cfg
...(truncado)

===== ./venv/lib/python3.13/site-packages/gunicorn/errors.py =====
class HaltServer(BaseException):
    def __init__(self, reason, exit_status=1):
        self.reason = reason
        self.exit_status = exit_status
    def __str__(self):
        return "<HaltServer %r %d>" % (self.reason, self.exit_status)
class ConfigError(Exception):
    """ Exception raised on config error """
class AppImportError(Exception):
    """ Exception raised when loading an application """
...(truncado)

===== ./venv/lib/python3.13/site-packages/gunicorn/glogging.py =====
import base64
import binascii
import json
import time
import logging
logging.Logger.manager.emittedNoHandlerWarning = 1  # noqa
from logging.config import dictConfig
from logging.config import fileConfig
import os
import socket
import sys
import threading
import traceback
from gunicorn import util
SYSLOG_FACILITIES = {
    "auth": 4,
    "authpriv": 10,
    "cron": 9,
    "daemon": 3,
    "ftp": 11,
    "kern": 0,
    "lpr": 6,
    "mail": 2,
    "news": 7,
    "security": 4,  # DEPRECATED
    "syslog": 5,
    "user": 1,
    "uucp": 8,
    "local0": 16,
    "local1": 17,
    "local2": 18,
    "local3": 19,
    "local4": 20,
    "local5": 21,
    "local6": 22,
    "local7": 23
}
CONFIG_DEFAULTS = {
    "version": 1,
    "disable_existing_loggers": False,
...(truncado)

===== ./venv/lib/python3.13/site-packages/gunicorn/__main__.py =====
from gunicorn.app.wsgiapp import run
if __name__ == "__main__":
    # see config.py - argparse defaults to basename(argv[0]) == "__main__.py"
    # todo: let runpy.run_module take care of argv[0] rewriting
    run(prog="gunicorn")
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/connectors/asyncio.py =====
"""generic asyncio-adapted versions of DBAPI connection and cursor"""
from __future__ import annotations
import asyncio
import collections
import sys
from typing import Any
from typing import AsyncIterator
from typing import Deque
from typing import Iterator
from typing import NoReturn
from typing import Optional
from typing import Sequence
from typing import TYPE_CHECKING
from ..engine import AdaptedConnection
from ..util.concurrency import await_fallback
from ..util.concurrency import await_only
from ..util.typing import Protocol
if TYPE_CHECKING:
    from ..engine.interfaces import _DBAPICursorDescription
    from ..engine.interfaces import _DBAPIMultiExecuteParams
    from ..engine.interfaces import _DBAPISingleExecuteParams
    from ..engine.interfaces import DBAPIModule
    from ..util.typing import Self
class AsyncIODBAPIConnection(Protocol):
    """protocol representing an async adapted version of a
    :pep:`249` database connection.
    """
    # note that async DBAPIs dont agree if close() should be awaitable,
    # so it is omitted here and picked up by the __getattr__ hook below
    async def commit(self) -> None: ...
    def cursor(self, *args: Any, **kwargs: Any) -> AsyncIODBAPICursor: ...
    async def rollback(self) -> None: ...
    def __getattr__(self, key: str) -> Any: ...
    def __setattr__(self, key: str, value: Any) -> None: ...
class AsyncIODBAPICursor(Protocol):
    """protocol representing an async adapted version
    of a :pep:`249` database cursor.
    """
    def __aenter__(self) -> Any: ...
    @property
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/connectors/__init__.py =====
from ..engine.interfaces import Dialect
class Connector(Dialect):
    """Base class for dialect mixins, for DBAPIs that work
    across entirely different database backends.
    Currently the only such mixin is pyodbc.
    """
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/connectors/aioodbc.py =====
from __future__ import annotations
from typing import TYPE_CHECKING
from .asyncio import AsyncAdapt_dbapi_connection
from .asyncio import AsyncAdapt_dbapi_cursor
from .asyncio import AsyncAdapt_dbapi_ss_cursor
from .asyncio import AsyncAdaptFallback_dbapi_connection
from .pyodbc import PyODBCConnector
from .. import pool
from .. import util
from ..util.concurrency import await_fallback
from ..util.concurrency import await_only
if TYPE_CHECKING:
    from ..engine.interfaces import ConnectArgsType
    from ..engine.url import URL
class AsyncAdapt_aioodbc_cursor(AsyncAdapt_dbapi_cursor):
    __slots__ = ()
    def setinputsizes(self, *inputsizes):
        # see https://github.com/aio-libs/aioodbc/issues/451
        return self._cursor._impl.setinputsizes(*inputsizes)
        # how it's supposed to work
        # return self.await_(self._cursor.setinputsizes(*inputsizes))
class AsyncAdapt_aioodbc_ss_cursor(
    AsyncAdapt_aioodbc_cursor, AsyncAdapt_dbapi_ss_cursor
):
    __slots__ = ()
class AsyncAdapt_aioodbc_connection(AsyncAdapt_dbapi_connection):
    _cursor_cls = AsyncAdapt_aioodbc_cursor
    _ss_cursor_cls = AsyncAdapt_aioodbc_ss_cursor
    __slots__ = ()
    @property
    def autocommit(self):
        return self._connection.autocommit
    @autocommit.setter
    def autocommit(self, value):
        # https://github.com/aio-libs/aioodbc/issues/448
        # self._connection.autocommit = value
        self._connection._conn.autocommit = value
    def ping(self, reconnect):
        return self.await_(self._connection.ping(reconnect))
    def add_output_converter(self, *arg, **kw):
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/connectors/pyodbc.py =====
from __future__ import annotations
import re
import typing
from typing import Any
from typing import Dict
from typing import List
from typing import Optional
from typing import Tuple
from typing import Union
from urllib.parse import unquote_plus
from . import Connector
from .. import ExecutionContext
from .. import pool
from .. import util
from ..engine import ConnectArgsType
from ..engine import Connection
from ..engine import interfaces
from ..engine import URL
from ..sql.type_api import TypeEngine
if typing.TYPE_CHECKING:
    from ..engine.interfaces import DBAPIModule
    from ..engine.interfaces import IsolationLevel
class PyODBCConnector(Connector):
    driver = "pyodbc"
    # this is no longer False for pyodbc in general
    supports_sane_rowcount_returning = True
    supports_sane_multi_rowcount = False
    supports_native_decimal = True
    default_paramstyle = "named"
    fast_executemany = False
    # for non-DSN connections, this *may* be used to
    # hold the desired driver name
    pyodbc_driver_name: Optional[str] = None
    def __init__(self, use_setinputsizes: bool = False, **kw: Any):
        super().__init__(**kw)
        if use_setinputsizes:
            self.bind_typing = interfaces.BindTyping.SETINPUTSIZES
    @classmethod
    def import_dbapi(cls) -> DBAPIModule:
        return __import__("pyodbc")
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/util/queue.py =====
"""An adaptation of Py2.3/2.4's Queue module which supports reentrant
behavior, using RLock instead of Lock for its mutex object.  The
Queue object is used exclusively by the sqlalchemy.pool.QueuePool
class.
This is to support the connection pool's usage of weakref callbacks to return
connections to the underlying Queue, which can in extremely
rare cases be invoked within the ``get()`` method of the Queue itself,
producing a ``put()`` inside the ``get()`` and therefore a reentrant
condition.
"""
from __future__ import annotations
import asyncio
from collections import deque
import threading
from time import time as _time
import typing
from typing import Any
from typing import Awaitable
from typing import Deque
from typing import Generic
from typing import Optional
from typing import TypeVar
from .concurrency import await_fallback
from .concurrency import await_only
from .langhelpers import memoized_property
_T = TypeVar("_T", bound=Any)
__all__ = ["Empty", "Full", "Queue"]
class Empty(Exception):
    "Exception raised by Queue.get(block=0)/get_nowait()."
    pass
class Full(Exception):
    "Exception raised by Queue.put(block=0)/put_nowait()."
    pass
class QueueCommon(Generic[_T]):
    maxsize: int
    use_lifo: bool
    def __init__(self, maxsize: int = 0, use_lifo: bool = False): ...
    def empty(self) -> bool:
        raise NotImplementedError()
    def full(self) -> bool:
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/util/_concurrency_py3k.py =====
from __future__ import annotations
import asyncio
from contextvars import Context
import sys
import typing
from typing import Any
from typing import Awaitable
from typing import Callable
from typing import Coroutine
from typing import Optional
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union
from .langhelpers import memoized_property
from .. import exc
from ..util import py311
from ..util.typing import Literal
from ..util.typing import Protocol
from ..util.typing import Self
from ..util.typing import TypeGuard
_T = TypeVar("_T")
if typing.TYPE_CHECKING:
    class greenlet(Protocol):
        dead: bool
        gr_context: Optional[Context]
        def __init__(self, fn: Callable[..., Any], driver: greenlet): ...
        def throw(self, *arg: Any) -> Any:
            return None
        def switch(self, value: Any) -> Any:
            return None
    def getcurrent() -> greenlet: ...
else:
    from greenlet import getcurrent
    from greenlet import greenlet
_has_gr_context = hasattr(getcurrent(), "gr_context")
def is_exit_exception(e: BaseException) -> bool:
    # note asyncio.CancelledError is already BaseException
    # so was an exit exception in any case
    return not isinstance(e, Exception) or isinstance(
        e, (asyncio.TimeoutError, asyncio.CancelledError)
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/util/topological.py =====
"""Topological sorting algorithms."""
from __future__ import annotations
from typing import Any
from typing import Collection
from typing import DefaultDict
from typing import Iterable
from typing import Iterator
from typing import Sequence
from typing import Set
from typing import Tuple
from typing import TypeVar
from .. import util
from ..exc import CircularDependencyError
_T = TypeVar("_T", bound=Any)
__all__ = ["sort", "sort_as_subsets", "find_cycles"]
def sort_as_subsets(
    tuples: Collection[Tuple[_T, _T]], allitems: Collection[_T]
) -> Iterator[Sequence[_T]]:
    edges: DefaultDict[_T, Set[_T]] = util.defaultdict(set)
    for parent, child in tuples:
        edges[child].add(parent)
    todo = list(allitems)
    todo_set = set(allitems)
    while todo_set:
        output = []
        for node in todo:
            if todo_set.isdisjoint(edges[node]):
                output.append(node)
        if not output:
            raise CircularDependencyError(
                "Circular dependency detected.",
                find_cycles(tuples, allitems),
                _gen_edges(edges),
            )
        todo_set.difference_update(output)
        todo = [t for t in todo if t in todo_set]
        yield output
def sort(
    tuples: Collection[Tuple[_T, _T]],
    allitems: Collection[_T],
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/util/compat.py =====
"""Handle Python version/platform incompatibilities."""
from __future__ import annotations
import base64
import dataclasses
import hashlib
import inspect
import operator
import platform
import sys
import typing
from typing import Any
from typing import Callable
from typing import Dict
from typing import Iterable
from typing import List
from typing import Mapping
from typing import Optional
from typing import Sequence
from typing import Set
from typing import Tuple
from typing import Type
from typing import TypeVar
py314b1 = sys.version_info >= (3, 14, 0, "beta", 1)
py314 = sys.version_info >= (3, 14)
py313 = sys.version_info >= (3, 13)
py312 = sys.version_info >= (3, 12)
py311 = sys.version_info >= (3, 11)
py310 = sys.version_info >= (3, 10)
py39 = sys.version_info >= (3, 9)
py38 = sys.version_info >= (3, 8)
pypy = platform.python_implementation() == "PyPy"
cpython = platform.python_implementation() == "CPython"
win32 = sys.platform.startswith("win")
osx = sys.platform.startswith("darwin")
arm = "aarch" in platform.machine().lower()
is64bit = sys.maxsize > 2**32
has_refcount_gc = bool(cpython)
dottedgetter = operator.attrgetter
_T_co = TypeVar("_T_co", covariant=True)
class FullArgSpec(typing.NamedTuple):
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/util/preloaded.py =====
"""supplies the "preloaded" registry to resolve circular module imports at
runtime.
"""
from __future__ import annotations
import sys
from typing import Any
from typing import Callable
from typing import TYPE_CHECKING
from typing import TypeVar
_FN = TypeVar("_FN", bound=Callable[..., Any])
if TYPE_CHECKING:
    from sqlalchemy import dialects as _dialects
    from sqlalchemy import orm as _orm
    from sqlalchemy.engine import cursor as _engine_cursor
    from sqlalchemy.engine import default as _engine_default
    from sqlalchemy.engine import reflection as _engine_reflection
    from sqlalchemy.engine import result as _engine_result
    from sqlalchemy.engine import url as _engine_url
    from sqlalchemy.orm import attributes as _orm_attributes
    from sqlalchemy.orm import base as _orm_base
    from sqlalchemy.orm import clsregistry as _orm_clsregistry
    from sqlalchemy.orm import decl_api as _orm_decl_api
    from sqlalchemy.orm import decl_base as _orm_decl_base
    from sqlalchemy.orm import dependency as _orm_dependency
    from sqlalchemy.orm import descriptor_props as _orm_descriptor_props
    from sqlalchemy.orm import mapperlib as _orm_mapper
    from sqlalchemy.orm import properties as _orm_properties
    from sqlalchemy.orm import relationships as _orm_relationships
    from sqlalchemy.orm import session as _orm_session
    from sqlalchemy.orm import state as _orm_state
    from sqlalchemy.orm import strategies as _orm_strategies
    from sqlalchemy.orm import strategy_options as _orm_strategy_options
    from sqlalchemy.orm import util as _orm_util
    from sqlalchemy.sql import default_comparator as _sql_default_comparator
    from sqlalchemy.sql import dml as _sql_dml
    from sqlalchemy.sql import elements as _sql_elements
    from sqlalchemy.sql import functions as _sql_functions
    from sqlalchemy.sql import naming as _sql_naming
    from sqlalchemy.sql import schema as _sql_schema
    from sqlalchemy.sql import selectable as _sql_selectable
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/util/concurrency.py =====
from __future__ import annotations
import asyncio  # noqa
import typing
from typing import Any
from typing import Callable
from typing import Coroutine
from typing import TypeVar
have_greenlet = False
greenlet_error = None
try:
    import greenlet  # type: ignore[import-untyped,unused-ignore]  # noqa: F401,E501
except ImportError as e:
    greenlet_error = str(e)
    pass
else:
    have_greenlet = True
    from ._concurrency_py3k import await_only as await_only
    from ._concurrency_py3k import await_fallback as await_fallback
    from ._concurrency_py3k import in_greenlet as in_greenlet
    from ._concurrency_py3k import greenlet_spawn as greenlet_spawn
    from ._concurrency_py3k import is_exit_exception as is_exit_exception
    from ._concurrency_py3k import AsyncAdaptedLock as AsyncAdaptedLock
    from ._concurrency_py3k import _Runner
_T = TypeVar("_T")
class _AsyncUtil:
    """Asyncio util for test suite/ util only"""
    def __init__(self) -> None:
        if have_greenlet:
            self.runner = _Runner()
    def run(
        self,
        fn: Callable[..., Coroutine[Any, Any, _T]],
        *args: Any,
        **kwargs: Any,
    ) -> _T:
        """Run coroutine on the loop"""
        return self.runner.run(fn(*args, **kwargs))
    def run_in_greenlet(
        self, fn: Callable[..., _T], *args: Any, **kwargs: Any
    ) -> _T:
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/util/_has_cy.py =====
import os
import typing
def _import_cy_extensions():
    # all cython extension extension modules are treated as optional by the
    # setup, so to ensure that all are compiled, all should be imported here
    from ..cyextension import collections
    from ..cyextension import immutabledict
    from ..cyextension import processors
    from ..cyextension import resultproxy
    from ..cyextension import util
    return (collections, immutabledict, processors, resultproxy, util)
_CYEXTENSION_MSG: str
if not typing.TYPE_CHECKING:
    if os.environ.get("DISABLE_SQLALCHEMY_CEXT_RUNTIME"):
        HAS_CYEXTENSION = False
        _CYEXTENSION_MSG = "DISABLE_SQLALCHEMY_CEXT_RUNTIME is set"
    else:
        try:
            _import_cy_extensions()
        except ImportError as err:
            HAS_CYEXTENSION = False
            _CYEXTENSION_MSG = str(err)
        else:
            _CYEXTENSION_MSG = "Loaded"
            HAS_CYEXTENSION = True
else:
    HAS_CYEXTENSION = False
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/util/__init__.py =====
from collections import defaultdict as defaultdict
from functools import partial as partial
from functools import update_wrapper as update_wrapper
from . import preloaded as preloaded
from ._collections import coerce_generator_arg as coerce_generator_arg
from ._collections import coerce_to_immutabledict as coerce_to_immutabledict
from ._collections import column_dict as column_dict
from ._collections import column_set as column_set
from ._collections import EMPTY_DICT as EMPTY_DICT
from ._collections import EMPTY_SET as EMPTY_SET
from ._collections import FacadeDict as FacadeDict
from ._collections import flatten_iterator as flatten_iterator
from ._collections import has_dupes as has_dupes
from ._collections import has_intersection as has_intersection
from ._collections import IdentitySet as IdentitySet
from ._collections import immutabledict as immutabledict
from ._collections import LRUCache as LRUCache
from ._collections import merge_lists_w_ordering as merge_lists_w_ordering
from ._collections import NONE_SET as NONE_SET
from ._collections import ordered_column_set as ordered_column_set
from ._collections import OrderedDict as OrderedDict
from ._collections import OrderedIdentitySet as OrderedIdentitySet
from ._collections import OrderedProperties as OrderedProperties
from ._collections import OrderedSet as OrderedSet
from ._collections import PopulateDict as PopulateDict
from ._collections import Properties as Properties
from ._collections import ReadOnlyContainer as ReadOnlyContainer
from ._collections import ReadOnlyProperties as ReadOnlyProperties
from ._collections import ScopedRegistry as ScopedRegistry
from ._collections import sort_dictionary as sort_dictionary
from ._collections import ThreadLocalRegistry as ThreadLocalRegistry
from ._collections import to_column_set as to_column_set
from ._collections import to_list as to_list
from ._collections import to_set as to_set
from ._collections import unique_list as unique_list
from ._collections import UniqueAppender as UniqueAppender
from ._collections import update_copy as update_copy
from ._collections import WeakPopulateDict as WeakPopulateDict
from ._collections import WeakSequence as WeakSequence
from .compat import anext_ as anext_
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/util/deprecations.py =====
"""Helpers related to deprecation of functions, methods, classes, other
functionality."""
from __future__ import annotations
import re
from typing import Any
from typing import Callable
from typing import Dict
from typing import Match
from typing import Optional
from typing import Sequence
from typing import Set
from typing import Tuple
from typing import Type
from typing import TypeVar
from typing import Union
from . import compat
from .langhelpers import _hash_limit_string
from .langhelpers import _warnings_warn
from .langhelpers import decorator
from .langhelpers import inject_docstring_text
from .langhelpers import inject_param_text
from .. import exc
_T = TypeVar("_T", bound=Any)
_F = TypeVar("_F", bound="Callable[..., Any]")
def _warn_with_version(
    msg: str,
    version: str,
    type_: Type[exc.SADeprecationWarning],
    stacklevel: int,
    code: Optional[str] = None,
) -> None:
    warn = type_(msg, code=code)
    warn.deprecated_since = version
    _warnings_warn(warn, stacklevel=stacklevel + 1)
def warn_deprecated(
    msg: str, version: str, stacklevel: int = 3, code: Optional[str] = None
) -> None:
    _warn_with_version(
        msg, version, exc.SADeprecationWarning, stacklevel, code=code
    )
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/util/_collections.py =====
"""Collection classes and helpers."""
from __future__ import annotations
import operator
import threading
import types
import typing
from typing import Any
from typing import Callable
from typing import cast
from typing import Container
from typing import Dict
from typing import FrozenSet
from typing import Generic
from typing import Iterable
from typing import Iterator
from typing import List
from typing import Mapping
from typing import NoReturn
from typing import Optional
from typing import overload
from typing import Sequence
from typing import Set
from typing import Tuple
from typing import TypeVar
from typing import Union
from typing import ValuesView
import weakref
from ._has_cy import HAS_CYEXTENSION
from .typing import is_non_string_iterable
from .typing import Literal
from .typing import Protocol
if typing.TYPE_CHECKING or not HAS_CYEXTENSION:
    from ._py_collections import immutabledict as immutabledict
    from ._py_collections import IdentitySet as IdentitySet
    from ._py_collections import ReadOnlyContainer as ReadOnlyContainer
    from ._py_collections import ImmutableDictBase as ImmutableDictBase
    from ._py_collections import OrderedSet as OrderedSet
    from ._py_collections import unique_list as unique_list
else:
    from sqlalchemy.cyextension.immutabledict import (
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py =====
"""Routines to help with the creation, loading and introspection of
modules, classes, hierarchies, attributes, functions, and methods.
"""
from __future__ import annotations
import collections
import enum
from functools import update_wrapper
import inspect
import itertools
import operator
import re
import sys
import textwrap
import threading
import types
from types import CodeType
from typing import Any
from typing import Callable
from typing import cast
from typing import Dict
from typing import FrozenSet
from typing import Generic
from typing import Iterator
from typing import List
from typing import Mapping
from typing import NoReturn
from typing import Optional
from typing import overload
from typing import Sequence
from typing import Set
from typing import Tuple
from typing import Type
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union
import warnings
from . import _collections
from . import compat
from ._has_cy import HAS_CYEXTENSION
from .typing import Literal
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/util/typing.py =====
from __future__ import annotations
import builtins
from collections import deque
import collections.abc as collections_abc
import re
import sys
import typing
from typing import Any
from typing import Callable
from typing import Dict
from typing import ForwardRef
from typing import Generic
from typing import Iterable
from typing import Mapping
from typing import NewType
from typing import NoReturn
from typing import Optional
from typing import overload
from typing import Set
from typing import Tuple
from typing import Type
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union
import typing_extensions
from . import compat
if True:  # zimports removes the tailing comments
    from typing_extensions import Annotated as Annotated  # 3.8
    from typing_extensions import Concatenate as Concatenate  # 3.10
    from typing_extensions import (
        dataclass_transform as dataclass_transform,  # 3.11,
    )
    from typing_extensions import Final as Final  # 3.8
    from typing_extensions import final as final  # 3.8
    from typing_extensions import get_args as get_args  # 3.10
    from typing_extensions import get_origin as get_origin  # 3.10
    from typing_extensions import Literal as Literal  # 3.8
    from typing_extensions import NotRequired as NotRequired  # 3.11
    from typing_extensions import ParamSpec as ParamSpec  # 3.10
    from typing_extensions import Protocol as Protocol  # 3.8
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/util/tool_support.py =====
"""support routines for the helpers in tools/.
These aren't imported by the enclosing util package as the are not
needed for normal library use.
"""
from __future__ import annotations
from argparse import ArgumentParser
from argparse import Namespace
import contextlib
import difflib
import os
from pathlib import Path
import shlex
import shutil
import subprocess
import sys
from typing import Any
from typing import Dict
from typing import Iterator
from typing import Optional
from typing import Union
from . import compat
class code_writer_cmd:
    parser: ArgumentParser
    args: Namespace
    suppress_output: bool
    diffs_detected: bool
    source_root: Path
    pyproject_toml_path: Path
    def __init__(self, tool_script: str):
        self.source_root = Path(tool_script).parent.parent
        self.pyproject_toml_path = self.source_root / Path("pyproject.toml")
        assert self.pyproject_toml_path.exists()
        self.parser = ArgumentParser()
        self.parser.add_argument(
            "--stdout",
            action="store_true",
            help="Write to stdout instead of saving to file",
        )
        self.parser.add_argument(
            "-c",
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/util/_py_collections.py =====
from __future__ import annotations
from itertools import filterfalse
from typing import AbstractSet
from typing import Any
from typing import Callable
from typing import cast
from typing import Collection
from typing import Dict
from typing import Iterable
from typing import Iterator
from typing import List
from typing import Mapping
from typing import NoReturn
from typing import Optional
from typing import Set
from typing import Tuple
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union
from ..util.typing import Self
_T = TypeVar("_T", bound=Any)
_S = TypeVar("_S", bound=Any)
_KT = TypeVar("_KT", bound=Any)
_VT = TypeVar("_VT", bound=Any)
class ReadOnlyContainer:
    __slots__ = ()
    def _readonly(self, *arg: Any, **kw: Any) -> NoReturn:
        raise TypeError(
            "%s object is immutable and/or readonly" % self.__class__.__name__
        )
    def _immutable(self, *arg: Any, **kw: Any) -> NoReturn:
        raise TypeError("%s object is immutable" % self.__class__.__name__)
    def __delitem__(self, key: Any) -> NoReturn:
        self._readonly()
    def __setitem__(self, key: Any, value: Any) -> NoReturn:
        self._readonly()
    def __setattr__(self, key: str, value: Any) -> NoReturn:
        self._readonly()
class ImmutableDictBase(ReadOnlyContainer, Dict[_KT, _VT]):
    if TYPE_CHECKING:
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/log.py =====
"""Logging control and utilities.
Control of logging for SA can be performed from the regular python logging
module.  The regular dotted module namespace is used, starting at
'sqlalchemy'.  For class-level logging, the class name is appended.
The "echo" keyword parameter, available on SQLA :class:`_engine.Engine`
and :class:`_pool.Pool` objects, corresponds to a logger specific to that
instance only.
"""
from __future__ import annotations
import logging
import sys
from typing import Any
from typing import Optional
from typing import overload
from typing import Set
from typing import Type
from typing import TypeVar
from typing import Union
from .util import py311
from .util import py38
from .util.typing import Literal
if py38:
    STACKLEVEL = True
    # needed as of py3.11.0b1
    # #8019
    STACKLEVEL_OFFSET = 2 if py311 else 1
else:
    STACKLEVEL = False
    STACKLEVEL_OFFSET = 0
_IT = TypeVar("_IT", bound="Identified")
_EchoFlagType = Union[None, bool, Literal["debug"]]
rootlogger = logging.getLogger("sqlalchemy")
if rootlogger.level == logging.NOTSET:
    rootlogger.setLevel(logging.WARN)
def _add_default_handler(logger: logging.Logger) -> None:
    handler = logging.StreamHandler(sys.stdout)
    handler.setFormatter(
        logging.Formatter("%(asctime)s %(levelname)s %(name)s %(message)s")
    )
    logger.addHandler(handler)
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/events.py =====
"""Core event interfaces."""
from __future__ import annotations
from .engine.events import ConnectionEvents
from .engine.events import DialectEvents
from .pool import PoolResetState
from .pool.events import PoolEvents
from .sql.base import SchemaEventTarget
from .sql.events import DDLEvents
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/ext/instrumentation.py =====
"""Extensible class instrumentation.
The :mod:`sqlalchemy.ext.instrumentation` package provides for alternate
systems of class instrumentation within the ORM.  Class instrumentation
refers to how the ORM places attributes on the class which maintain
data and track changes to that data, as well as event hooks installed
on the class.
.. note::
    The extension package is provided for the benefit of integration
    with other object management packages, which already perform
    their own instrumentation.  It is not intended for general use.
For examples of how the instrumentation extension is used,
see the example :ref:`examples_instrumentation`.
"""
import weakref
from .. import util
from ..orm import attributes
from ..orm import base as orm_base
from ..orm import collections
from ..orm import exc as orm_exc
from ..orm import instrumentation as orm_instrumentation
from ..orm import util as orm_util
from ..orm.instrumentation import _default_dict_getter
from ..orm.instrumentation import _default_manager_getter
from ..orm.instrumentation import _default_opt_manager_getter
from ..orm.instrumentation import _default_state_getter
from ..orm.instrumentation import ClassManager
from ..orm.instrumentation import InstrumentationFactory
INSTRUMENTATION_MANAGER = "__sa_instrumentation_manager__"
"""Attribute, elects custom instrumentation when present on a mapped class.
Allows a class to specify a slightly or wildly different technique for
tracking changes made to mapped attributes and collections.
Only one instrumentation implementation is allowed in a given object
inheritance hierarchy.
The value of this attribute must be a callable and will be passed a class
object.  The callable must return one of:
  - An instance of an :class:`.InstrumentationManager` or subclass
  - An object implementing all or some of InstrumentationManager (TODO)
  - A dictionary of callables, implementing all or some of the above (TODO)
  - An instance of a :class:`.ClassManager` or subclass
This attribute is consulted by SQLAlchemy instrumentation
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/ext/compiler.py =====
r"""Provides an API for creation of custom ClauseElements and compilers.
Synopsis
========
Usage involves the creation of one or more
:class:`~sqlalchemy.sql.expression.ClauseElement` subclasses and one or
more callables defining its compilation::
    from sqlalchemy.ext.compiler import compiles
    from sqlalchemy.sql.expression import ColumnClause
    class MyColumn(ColumnClause):
        inherit_cache = True
    @compiles(MyColumn)
    def compile_mycolumn(element, compiler, **kw):
        return "[%s]" % element.name
Above, ``MyColumn`` extends :class:`~sqlalchemy.sql.expression.ColumnClause`,
the base expression element for named column objects. The ``compiles``
decorator registers itself with the ``MyColumn`` class so that it is invoked
when the object is compiled to a string::
    from sqlalchemy import select
    s = select(MyColumn("x"), MyColumn("y"))
    print(str(s))
Produces:
.. sourcecode:: sql
    SELECT [x], [y]
Dialect-specific compilation rules
==================================
Compilers can also be made dialect-specific. The appropriate compiler will be
invoked for the dialect in use::
    from sqlalchemy.schema import DDLElement
    class AlterColumn(DDLElement):
        inherit_cache = False
        def __init__(self, column, cmd):
            self.column = column
            self.cmd = cmd
    @compiles(AlterColumn)
    def visit_alter_column(element, compiler, **kw):
        return "ALTER COLUMN %s ..." % element.column.name
    @compiles(AlterColumn, "postgresql")
    def visit_alter_column(element, compiler, **kw):
        return "ALTER TABLE %s ALTER COLUMN %s ..." % (
            element.table.name,
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/ext/orderinglist.py =====
"""A custom list that manages index/position information for contained
elements.
:author: Jason Kirtland
``orderinglist`` is a helper for mutable ordered relationships.  It will
intercept list operations performed on a :func:`_orm.relationship`-managed
collection and
automatically synchronize changes in list position onto a target scalar
attribute.
Example: A ``slide`` table, where each row refers to zero or more entries
in a related ``bullet`` table.   The bullets within a slide are
displayed in order based on the value of the ``position`` column in the
``bullet`` table.   As entries are reordered in memory, the value of the
``position`` attribute should be updated to reflect the new sort order::
    Base = declarative_base()
    class Slide(Base):
        __tablename__ = "slide"
        id = Column(Integer, primary_key=True)
        name = Column(String)
        bullets = relationship("Bullet", order_by="Bullet.position")
    class Bullet(Base):
        __tablename__ = "bullet"
        id = Column(Integer, primary_key=True)
        slide_id = Column(Integer, ForeignKey("slide.id"))
        position = Column(Integer)
        text = Column(String)
The standard relationship mapping will produce a list-like attribute on each
``Slide`` containing all related ``Bullet`` objects,
but coping with changes in ordering is not handled automatically.
When appending a ``Bullet`` into ``Slide.bullets``, the ``Bullet.position``
attribute will remain unset until manually assigned.   When the ``Bullet``
is inserted into the middle of the list, the following ``Bullet`` objects
will also need to be renumbered.
The :class:`.OrderingList` object automates this task, managing the
``position`` attribute on all ``Bullet`` objects in the collection.  It is
constructed using the :func:`.ordering_list` factory::
    from sqlalchemy.ext.orderinglist import ordering_list
    Base = declarative_base()
    class Slide(Base):
        __tablename__ = "slide"
        id = Column(Integer, primary_key=True)
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/ext/hybrid.py =====
r"""Define attributes on ORM-mapped classes that have "hybrid" behavior.
"hybrid" means the attribute has distinct behaviors defined at the
class level and at the instance level.
The :mod:`~sqlalchemy.ext.hybrid` extension provides a special form of
method decorator and has minimal dependencies on the rest of SQLAlchemy.
Its basic theory of operation can work with any descriptor-based expression
system.
Consider a mapping ``Interval``, representing integer ``start`` and ``end``
values. We can define higher level functions on mapped classes that produce SQL
expressions at the class level, and Python expression evaluation at the
instance level.  Below, each function decorated with :class:`.hybrid_method` or
:class:`.hybrid_property` may receive ``self`` as an instance of the class, or
may receive the class directly, depending on context::
    from __future__ import annotations
    from sqlalchemy.ext.hybrid import hybrid_method
    from sqlalchemy.ext.hybrid import hybrid_property
    from sqlalchemy.orm import DeclarativeBase
    from sqlalchemy.orm import Mapped
    from sqlalchemy.orm import mapped_column
    class Base(DeclarativeBase):
        pass
    class Interval(Base):
        __tablename__ = "interval"
        id: Mapped[int] = mapped_column(primary_key=True)
        start: Mapped[int]
        end: Mapped[int]
        def __init__(self, start: int, end: int):
            self.start = start
            self.end = end
        @hybrid_property
        def length(self) -> int:
            return self.end - self.start
        @hybrid_method
        def contains(self, point: int) -> bool:
            return (self.start <= point) & (point <= self.end)
        @hybrid_method
        def intersects(self, other: Interval) -> bool:
            return self.contains(other.start) | self.contains(other.end)
Above, the ``length`` property returns the difference between the
``end`` and ``start`` attributes.  With an instance of ``Interval``,
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/ext/__init__.py =====
from .. import util as _sa_util
_sa_util.preloaded.import_prefix("sqlalchemy.ext")
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/ext/indexable.py =====
"""Define attributes on ORM-mapped classes that have "index" attributes for
columns with :class:`_types.Indexable` types.
"index" means the attribute is associated with an element of an
:class:`_types.Indexable` column with the predefined index to access it.
The :class:`_types.Indexable` types include types such as
:class:`_types.ARRAY`, :class:`_types.JSON` and
:class:`_postgresql.HSTORE`.
The :mod:`~sqlalchemy.ext.indexable` extension provides
:class:`_schema.Column`-like interface for any element of an
:class:`_types.Indexable` typed column. In simple cases, it can be
treated as a :class:`_schema.Column` - mapped attribute.
Synopsis
========
Given ``Person`` as a model with a primary key and JSON data field.
While this field may have any number of elements encoded within it,
we would like to refer to the element called ``name`` individually
as a dedicated attribute which behaves like a standalone column::
    from sqlalchemy import Column, JSON, Integer
    from sqlalchemy.ext.declarative import declarative_base
    from sqlalchemy.ext.indexable import index_property
    Base = declarative_base()
    class Person(Base):
        __tablename__ = "person"
        id = Column(Integer, primary_key=True)
        data = Column(JSON)
        name = index_property("data", "name")
Above, the ``name`` attribute now behaves like a mapped column.   We
can compose a new ``Person`` and set the value of ``name``::
    >>> person = Person(name="Alchemist")
The value is now accessible::
    >>> person.name
    'Alchemist'
Behind the scenes, the JSON field was initialized to a new blank dictionary
and the field was set::
    >>> person.data
    {'name': 'Alchemist'}
The field is mutable in place::
    >>> person.name = "Renamed"
    >>> person.name
    'Renamed'
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/ext/mypy/util.py =====
from __future__ import annotations
import re
from typing import Any
from typing import Iterable
from typing import Iterator
from typing import List
from typing import Optional
from typing import overload
from typing import Tuple
from typing import Type as TypingType
from typing import TypeVar
from typing import Union
from mypy import version
from mypy.messages import format_type as _mypy_format_type
from mypy.nodes import CallExpr
from mypy.nodes import ClassDef
from mypy.nodes import CLASSDEF_NO_INFO
from mypy.nodes import Context
from mypy.nodes import Expression
from mypy.nodes import FuncDef
from mypy.nodes import IfStmt
from mypy.nodes import JsonDict
from mypy.nodes import MemberExpr
from mypy.nodes import NameExpr
from mypy.nodes import Statement
from mypy.nodes import SymbolTableNode
from mypy.nodes import TypeAlias
from mypy.nodes import TypeInfo
from mypy.options import Options
from mypy.plugin import ClassDefContext
from mypy.plugin import DynamicClassDefContext
from mypy.plugin import SemanticAnalyzerPluginInterface
from mypy.plugins.common import deserialize_and_fixup_type
from mypy.typeops import map_type_from_supertype
from mypy.types import CallableType
from mypy.types import get_proper_type
from mypy.types import Instance
from mypy.types import NoneType
from mypy.types import Type
from mypy.types import TypeVarType
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/ext/mypy/__init__.py =====
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/ext/mypy/names.py =====
from __future__ import annotations
from typing import Dict
from typing import List
from typing import Optional
from typing import Set
from typing import Tuple
from typing import Union
from mypy.nodes import ARG_POS
from mypy.nodes import CallExpr
from mypy.nodes import ClassDef
from mypy.nodes import Decorator
from mypy.nodes import Expression
from mypy.nodes import FuncDef
from mypy.nodes import MemberExpr
from mypy.nodes import NameExpr
from mypy.nodes import OverloadedFuncDef
from mypy.nodes import SymbolNode
from mypy.nodes import TypeAlias
from mypy.nodes import TypeInfo
from mypy.plugin import SemanticAnalyzerPluginInterface
from mypy.types import CallableType
from mypy.types import get_proper_type
from mypy.types import Instance
from mypy.types import UnboundType
from ... import util
COLUMN: int = util.symbol("COLUMN")
RELATIONSHIP: int = util.symbol("RELATIONSHIP")
REGISTRY: int = util.symbol("REGISTRY")
COLUMN_PROPERTY: int = util.symbol("COLUMN_PROPERTY")
TYPEENGINE: int = util.symbol("TYPEENGNE")
MAPPED: int = util.symbol("MAPPED")
DECLARATIVE_BASE: int = util.symbol("DECLARATIVE_BASE")
DECLARATIVE_META: int = util.symbol("DECLARATIVE_META")
MAPPED_DECORATOR: int = util.symbol("MAPPED_DECORATOR")
SYNONYM_PROPERTY: int = util.symbol("SYNONYM_PROPERTY")
COMPOSITE_PROPERTY: int = util.symbol("COMPOSITE_PROPERTY")
DECLARED_ATTR: int = util.symbol("DECLARED_ATTR")
MAPPER_PROPERTY: int = util.symbol("MAPPER_PROPERTY")
AS_DECLARATIVE: int = util.symbol("AS_DECLARATIVE")
AS_DECLARATIVE_BASE: int = util.symbol("AS_DECLARATIVE_BASE")
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/ext/mypy/plugin.py =====
"""
Mypy plugin for SQLAlchemy ORM.
"""
from __future__ import annotations
from typing import Callable
from typing import List
from typing import Optional
from typing import Tuple
from typing import Type as TypingType
from typing import Union
from mypy import nodes
from mypy.mro import calculate_mro
from mypy.mro import MroError
from mypy.nodes import Block
from mypy.nodes import ClassDef
from mypy.nodes import GDEF
from mypy.nodes import MypyFile
from mypy.nodes import NameExpr
from mypy.nodes import SymbolTable
from mypy.nodes import SymbolTableNode
from mypy.nodes import TypeInfo
from mypy.plugin import AttributeContext
from mypy.plugin import ClassDefContext
from mypy.plugin import DynamicClassDefContext
from mypy.plugin import Plugin
from mypy.plugin import SemanticAnalyzerPluginInterface
from mypy.types import get_proper_type
from mypy.types import Instance
from mypy.types import Type
from . import decl_class
from . import names
from . import util
try:
    __import__("sqlalchemy-stubs")
except ImportError:
    pass
else:
    raise ImportError(
        "The SQLAlchemy mypy plugin in SQLAlchemy "
        "2.0 does not work with sqlalchemy-stubs or "
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/ext/mypy/infer.py =====
from __future__ import annotations
from typing import Optional
from typing import Sequence
from mypy.maptype import map_instance_to_supertype
from mypy.nodes import AssignmentStmt
from mypy.nodes import CallExpr
from mypy.nodes import Expression
from mypy.nodes import FuncDef
from mypy.nodes import LambdaExpr
from mypy.nodes import MemberExpr
from mypy.nodes import NameExpr
from mypy.nodes import RefExpr
from mypy.nodes import StrExpr
from mypy.nodes import TypeInfo
from mypy.nodes import Var
from mypy.plugin import SemanticAnalyzerPluginInterface
from mypy.subtypes import is_subtype
from mypy.types import AnyType
from mypy.types import CallableType
from mypy.types import get_proper_type
from mypy.types import Instance
from mypy.types import NoneType
from mypy.types import ProperType
from mypy.types import TypeOfAny
from mypy.types import UnionType
from . import names
from . import util
def infer_type_from_right_hand_nameexpr(
    api: SemanticAnalyzerPluginInterface,
    stmt: AssignmentStmt,
    node: Var,
    left_hand_explicit_type: Optional[ProperType],
    infer_from_right_side: RefExpr,
) -> Optional[ProperType]:
    type_id = names.type_id_for_callee(infer_from_right_side)
    if type_id is None:
        return None
    elif type_id is names.MAPPED:
        python_type_for_type = _infer_type_from_mapped(
            api, stmt, node, left_hand_explicit_type, infer_from_right_side
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/ext/mypy/decl_class.py =====
from __future__ import annotations
from typing import List
from typing import Optional
from typing import Union
from mypy.nodes import AssignmentStmt
from mypy.nodes import CallExpr
from mypy.nodes import ClassDef
from mypy.nodes import Decorator
from mypy.nodes import LambdaExpr
from mypy.nodes import ListExpr
from mypy.nodes import MemberExpr
from mypy.nodes import NameExpr
from mypy.nodes import PlaceholderNode
from mypy.nodes import RefExpr
from mypy.nodes import StrExpr
from mypy.nodes import SymbolNode
from mypy.nodes import SymbolTableNode
from mypy.nodes import TempNode
from mypy.nodes import TypeInfo
from mypy.nodes import Var
from mypy.plugin import SemanticAnalyzerPluginInterface
from mypy.types import AnyType
from mypy.types import CallableType
from mypy.types import get_proper_type
from mypy.types import Instance
from mypy.types import NoneType
from mypy.types import ProperType
from mypy.types import Type
from mypy.types import TypeOfAny
from mypy.types import UnboundType
from mypy.types import UnionType
from . import apply
from . import infer
from . import names
from . import util
def scan_declarative_assignments_and_apply_types(
    cls: ClassDef,
    api: SemanticAnalyzerPluginInterface,
    is_mixin_scan: bool = False,
) -> Optional[List[util.SQLAlchemyAttribute]]:
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/ext/mypy/apply.py =====
from __future__ import annotations
from typing import List
from typing import Optional
from typing import Union
from mypy.nodes import ARG_NAMED_OPT
from mypy.nodes import Argument
from mypy.nodes import AssignmentStmt
from mypy.nodes import CallExpr
from mypy.nodes import ClassDef
from mypy.nodes import MDEF
from mypy.nodes import MemberExpr
from mypy.nodes import NameExpr
from mypy.nodes import RefExpr
from mypy.nodes import StrExpr
from mypy.nodes import SymbolTableNode
from mypy.nodes import TempNode
from mypy.nodes import TypeInfo
from mypy.nodes import Var
from mypy.plugin import SemanticAnalyzerPluginInterface
from mypy.plugins.common import add_method_to_class
from mypy.types import AnyType
from mypy.types import get_proper_type
from mypy.types import Instance
from mypy.types import NoneTyp
from mypy.types import ProperType
from mypy.types import TypeOfAny
from mypy.types import UnboundType
from mypy.types import UnionType
from . import infer
from . import util
from .names import expr_to_mapped_constructor
from .names import NAMED_TYPE_SQLA_MAPPED
def apply_mypy_mapped_attr(
    cls: ClassDef,
    api: SemanticAnalyzerPluginInterface,
    item: Union[NameExpr, StrExpr],
    attributes: List[util.SQLAlchemyAttribute],
) -> None:
    if isinstance(item, NameExpr):
        name = item.name
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/ext/declarative/__init__.py =====
from .extensions import AbstractConcreteBase
from .extensions import ConcreteBase
from .extensions import DeferredReflection
from ... import util
from ...orm.decl_api import as_declarative as _as_declarative
from ...orm.decl_api import declarative_base as _declarative_base
from ...orm.decl_api import DeclarativeMeta
from ...orm.decl_api import declared_attr
from ...orm.decl_api import has_inherited_table as _has_inherited_table
from ...orm.decl_api import synonym_for as _synonym_for
@util.moved_20(
    "The ``declarative_base()`` function is now available as "
    ":func:`sqlalchemy.orm.declarative_base`."
)
def declarative_base(*arg, **kw):
    return _declarative_base(*arg, **kw)
@util.moved_20(
    "The ``as_declarative()`` function is now available as "
    ":func:`sqlalchemy.orm.as_declarative`"
)
def as_declarative(*arg, **kw):
    return _as_declarative(*arg, **kw)
@util.moved_20(
    "The ``has_inherited_table()`` function is now available as "
    ":func:`sqlalchemy.orm.has_inherited_table`."
)
def has_inherited_table(*arg, **kw):
    return _has_inherited_table(*arg, **kw)
@util.moved_20(
    "The ``synonym_for()`` function is now available as "
    ":func:`sqlalchemy.orm.synonym_for`"
)
def synonym_for(*arg, **kw):
    return _synonym_for(*arg, **kw)
__all__ = [
    "declarative_base",
    "synonym_for",
    "has_inherited_table",
    "instrument_declarative",
    "declared_attr",
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/ext/declarative/extensions.py =====
"""Public API functions and helpers for declarative."""
from __future__ import annotations
import collections
import contextlib
from typing import Any
from typing import Callable
from typing import TYPE_CHECKING
from typing import Union
from ... import exc as sa_exc
from ...engine import Connection
from ...engine import Engine
from ...orm import exc as orm_exc
from ...orm import relationships
from ...orm.base import _mapper_or_none
from ...orm.clsregistry import _resolver
from ...orm.decl_base import _DeferredMapperConfig
from ...orm.util import polymorphic_union
from ...schema import Table
from ...util import OrderedDict
if TYPE_CHECKING:
    from ...sql.schema import MetaData
class ConcreteBase:
    """A helper class for 'concrete' declarative mappings.
    :class:`.ConcreteBase` will use the :func:`.polymorphic_union`
    function automatically, against all tables mapped as a subclass
    to this class.   The function is called via the
    ``__declare_last__()`` function, which is essentially
    a hook for the :meth:`.after_configured` event.
    :class:`.ConcreteBase` produces a mapped
    table for the class itself.  Compare to :class:`.AbstractConcreteBase`,
    which does not.
    Example::
        from sqlalchemy.ext.declarative import ConcreteBase
        class Employee(ConcreteBase, Base):
            __tablename__ = "employee"
            employee_id = Column(Integer, primary_key=True)
            name = Column(String(50))
            __mapper_args__ = {
                "polymorphic_identity": "employee",
                "concrete": True,
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/ext/serializer.py =====
"""Serializer/Deserializer objects for usage with SQLAlchemy query structures,
allowing "contextual" deserialization.
.. legacy::
    The serializer extension is **legacy** and should not be used for
    new development.
Any SQLAlchemy query structure, either based on sqlalchemy.sql.*
or sqlalchemy.orm.* can be used.  The mappers, Tables, Columns, Session
etc. which are referenced by the structure are not persisted in serialized
form, but are instead re-associated with the query structure
when it is deserialized.
.. warning:: The serializer extension uses pickle to serialize and
   deserialize objects, so the same security consideration mentioned
   in the `python documentation
   <https://docs.python.org/3/library/pickle.html>`_ apply.
Usage is nearly the same as that of the standard Python pickle module::
    from sqlalchemy.ext.serializer import loads, dumps
    metadata = MetaData(bind=some_engine)
    Session = scoped_session(sessionmaker())
    # ... define mappers
    query = (
        Session.query(MyClass)
        .filter(MyClass.somedata == "foo")
        .order_by(MyClass.sortkey)
    )
    # pickle the query
    serialized = dumps(query)
    # unpickle.  Pass in metadata + scoped_session
    query2 = loads(serialized, metadata, Session)
    print(query2.all())
Similar restrictions as when using raw pickle apply; mapped classes must be
themselves be pickleable, meaning they are importable from a module-level
namespace.
The serializer module is only appropriate for query structures.  It is not
needed for:
* instances of user-defined classes.   These contain no references to engines,
  sessions or expression constructs in the typical case and can be serialized
  directly.
* Table metadata that is to be loaded entirely from the serialized structure
  (i.e. is not already declared in the application).   Regular
  pickle.loads()/dumps() can be used to fully dump any ``MetaData`` object,
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/ext/baked.py =====
"""Baked query extension.
Provides a creational pattern for the :class:`.query.Query` object which
allows the fully constructed object, Core select statement, and string
compiled result to be fully cached.
"""
import collections.abc as collections_abc
import logging
from .. import exc as sa_exc
from .. import util
from ..orm import exc as orm_exc
from ..orm.query import Query
from ..orm.session import Session
from ..sql import func
from ..sql import literal_column
from ..sql import util as sql_util
log = logging.getLogger(__name__)
class Bakery:
    """Callable which returns a :class:`.BakedQuery`.
    This object is returned by the class method
    :meth:`.BakedQuery.bakery`.  It exists as an object
    so that the "cache" can be easily inspected.
    .. versionadded:: 1.2
    """
    __slots__ = "cls", "cache"
    def __init__(self, cls_, cache):
        self.cls = cls_
        self.cache = cache
    def __call__(self, initial_fn, *args):
        return self.cls(self.cache, initial_fn, args)
class BakedQuery:
    """A builder object for :class:`.query.Query` objects."""
    __slots__ = "steps", "_bakery", "_cache_key", "_spoiled"
    def __init__(self, bakery, initial_fn, args=()):
        self._cache_key = ()
        self._update_cache_key(initial_fn, args)
        self.steps = [initial_fn]
        self._spoiled = False
        self._bakery = bakery
    @classmethod
    def bakery(cls, size=200, _size_alert=None):
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/ext/automap.py =====
r"""Define an extension to the :mod:`sqlalchemy.ext.declarative` system
which automatically generates mapped classes and relationships from a database
schema, typically though not necessarily one which is reflected.
It is hoped that the :class:`.AutomapBase` system provides a quick
and modernized solution to the problem that the very famous
`SQLSoup <https://pypi.org/project/sqlsoup/>`_
also tries to solve, that of generating a quick and rudimentary object
model from an existing database on the fly.  By addressing the issue strictly
at the mapper configuration level, and integrating fully with existing
Declarative class techniques, :class:`.AutomapBase` seeks to provide
a well-integrated approach to the issue of expediently auto-generating ad-hoc
mappings.
.. tip:: The :ref:`automap_toplevel` extension is geared towards a
   "zero declaration" approach, where a complete ORM model including classes
   and pre-named relationships can be generated on the fly from a database
   schema. For applications that still want to use explicit class declarations
   including explicit relationship definitions in conjunction with reflection
   of tables, the :class:`.DeferredReflection` class, described at
   :ref:`orm_declarative_reflected_deferred_reflection`, is a better choice.
.. _automap_basic_use:
Basic Use
=========
The simplest usage is to reflect an existing database into a new model.
We create a new :class:`.AutomapBase` class in a similar manner as to how
we create a declarative base class, using :func:`.automap_base`.
We then call :meth:`.AutomapBase.prepare` on the resulting base class,
asking it to reflect the schema and produce mappings::
    from sqlalchemy.ext.automap import automap_base
    from sqlalchemy.orm import Session
    from sqlalchemy import create_engine
    Base = automap_base()
    # engine, suppose it has two tables 'user' and 'address' set up
    engine = create_engine("sqlite:///mydatabase.db")
    # reflect the tables
    Base.prepare(autoload_with=engine)
    # mapped classes are now created with names by default
    # matching that of the table name.
    User = Base.classes.user
    Address = Base.classes.address
    session = Session(engine)
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/ext/asyncio/scoping.py =====
from __future__ import annotations
from typing import Any
from typing import Callable
from typing import Generic
from typing import Iterable
from typing import Iterator
from typing import Optional
from typing import overload
from typing import Sequence
from typing import Tuple
from typing import Type
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union
from .session import _AS
from .session import async_sessionmaker
from .session import AsyncSession
from ... import exc as sa_exc
from ... import util
from ...orm.session import Session
from ...util import create_proxy_methods
from ...util import ScopedRegistry
from ...util import warn
from ...util import warn_deprecated
if TYPE_CHECKING:
    from .engine import AsyncConnection
    from .result import AsyncResult
    from .result import AsyncScalarResult
    from .session import AsyncSessionTransaction
    from ...engine import Connection
    from ...engine import CursorResult
    from ...engine import Engine
    from ...engine import Result
    from ...engine import Row
    from ...engine import RowMapping
    from ...engine.interfaces import _CoreAnyExecuteParams
    from ...engine.interfaces import CoreExecuteOptionsParameter
    from ...engine.result import ScalarResult
    from ...orm._typing import _IdentityKeyType
    from ...orm._typing import _O
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/ext/asyncio/session.py =====
from __future__ import annotations
import asyncio
from typing import Any
from typing import Awaitable
from typing import Callable
from typing import cast
from typing import Dict
from typing import Generic
from typing import Iterable
from typing import Iterator
from typing import NoReturn
from typing import Optional
from typing import overload
from typing import Sequence
from typing import Tuple
from typing import Type
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union
from . import engine
from .base import ReversibleProxy
from .base import StartableContext
from .result import _ensure_sync_result
from .result import AsyncResult
from .result import AsyncScalarResult
from ... import util
from ...orm import close_all_sessions as _sync_close_all_sessions
from ...orm import object_session
from ...orm import Session
from ...orm import SessionTransaction
from ...orm import state as _instance_state
from ...util.concurrency import greenlet_spawn
from ...util.typing import Concatenate
from ...util.typing import ParamSpec
if TYPE_CHECKING:
    from .engine import AsyncConnection
    from .engine import AsyncEngine
    from ...engine import Connection
    from ...engine import CursorResult
    from ...engine import Engine
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/ext/asyncio/__init__.py =====
from .engine import async_engine_from_config as async_engine_from_config
from .engine import AsyncConnection as AsyncConnection
from .engine import AsyncEngine as AsyncEngine
from .engine import AsyncTransaction as AsyncTransaction
from .engine import create_async_engine as create_async_engine
from .engine import create_async_pool_from_url as create_async_pool_from_url
from .result import AsyncMappingResult as AsyncMappingResult
from .result import AsyncResult as AsyncResult
from .result import AsyncScalarResult as AsyncScalarResult
from .result import AsyncTupleResult as AsyncTupleResult
from .scoping import async_scoped_session as async_scoped_session
from .session import async_object_session as async_object_session
from .session import async_session as async_session
from .session import async_sessionmaker as async_sessionmaker
from .session import AsyncAttrs as AsyncAttrs
from .session import AsyncSession as AsyncSession
from .session import AsyncSessionTransaction as AsyncSessionTransaction
from .session import close_all_sessions as close_all_sessions
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/ext/asyncio/result.py =====
from __future__ import annotations
import operator
from typing import Any
from typing import AsyncIterator
from typing import Optional
from typing import overload
from typing import Sequence
from typing import Tuple
from typing import TYPE_CHECKING
from typing import TypeVar
from . import exc as async_exc
from ... import util
from ...engine import Result
from ...engine.result import _NO_ROW
from ...engine.result import _R
from ...engine.result import _WithKeys
from ...engine.result import FilterResult
from ...engine.result import FrozenResult
from ...engine.result import ResultMetaData
from ...engine.row import Row
from ...engine.row import RowMapping
from ...sql.base import _generative
from ...util.concurrency import greenlet_spawn
from ...util.typing import Literal
from ...util.typing import Self
if TYPE_CHECKING:
    from ...engine import CursorResult
    from ...engine.result import _KeyIndexType
    from ...engine.result import _UniqueFilterType
_T = TypeVar("_T", bound=Any)
_TP = TypeVar("_TP", bound=Tuple[Any, ...])
class AsyncCommon(FilterResult[_R]):
    __slots__ = ()
    _real_result: Result[Any]
    _metadata: ResultMetaData
    async def close(self) -> None:  # type: ignore[override]
        """Close this result."""
        await greenlet_spawn(self._real_result.close)
    @property
    def closed(self) -> bool:
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/ext/asyncio/engine.py =====
from __future__ import annotations
import asyncio
import contextlib
from typing import Any
from typing import AsyncIterator
from typing import Callable
from typing import Dict
from typing import Generator
from typing import NoReturn
from typing import Optional
from typing import overload
from typing import Tuple
from typing import Type
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union
from . import exc as async_exc
from .base import asyncstartablecontext
from .base import GeneratorStartableContext
from .base import ProxyComparable
from .base import StartableContext
from .result import _ensure_sync_result
from .result import AsyncResult
from .result import AsyncScalarResult
from ... import exc
from ... import inspection
from ... import util
from ...engine import Connection
from ...engine import create_engine as _create_engine
from ...engine import create_pool_from_url as _create_pool_from_url
from ...engine import Engine
from ...engine.base import NestedTransaction
from ...engine.base import Transaction
from ...exc import ArgumentError
from ...util.concurrency import greenlet_spawn
from ...util.typing import Concatenate
from ...util.typing import ParamSpec
if TYPE_CHECKING:
    from ...engine.cursor import CursorResult
    from ...engine.interfaces import _CoreAnyExecuteParams
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/ext/asyncio/exc.py =====
from ... import exc
class AsyncMethodRequired(exc.InvalidRequestError):
    """an API can't be used because its result would not be
    compatible with async"""
class AsyncContextNotStarted(exc.InvalidRequestError):
    """a startable context manager has not been started."""
class AsyncContextAlreadyStarted(exc.InvalidRequestError):
    """a startable context manager is already started."""
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/ext/asyncio/base.py =====
from __future__ import annotations
import abc
import functools
from typing import Any
from typing import AsyncGenerator
from typing import AsyncIterator
from typing import Awaitable
from typing import Callable
from typing import ClassVar
from typing import Dict
from typing import Generator
from typing import Generic
from typing import NoReturn
from typing import Optional
from typing import overload
from typing import Tuple
from typing import TypeVar
import weakref
from . import exc as async_exc
from ... import util
from ...util.typing import Literal
from ...util.typing import Self
_T = TypeVar("_T", bound=Any)
_T_co = TypeVar("_T_co", bound=Any, covariant=True)
_PT = TypeVar("_PT", bound=Any)
class ReversibleProxy(Generic[_PT]):
    _proxy_objects: ClassVar[
        Dict[weakref.ref[Any], weakref.ref[ReversibleProxy[Any]]]
    ] = {}
    __slots__ = ("__weakref__",)
    @overload
    def _assign_proxied(self, target: _PT) -> _PT: ...
    @overload
    def _assign_proxied(self, target: None) -> None: ...
    def _assign_proxied(self, target: Optional[_PT]) -> Optional[_PT]:
        if target is not None:
            target_ref: weakref.ref[_PT] = weakref.ref(
                target, ReversibleProxy._target_gced
            )
            proxy_ref = weakref.ref(
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/ext/horizontal_shard.py =====
"""Horizontal sharding support.
Defines a rudimental 'horizontal sharding' system which allows a Session to
distribute queries and persistence operations across multiple databases.
For a usage example, see the :ref:`examples_sharding` example included in
the source distribution.
.. deepalchemy:: The horizontal sharding extension is an advanced feature,
   involving a complex statement -> database interaction as well as
   use of semi-public APIs for non-trivial cases.   Simpler approaches to
   refering to multiple database "shards", most commonly using a distinct
   :class:`_orm.Session` per "shard", should always be considered first
   before using this more complex and less-production-tested system.
"""
from __future__ import annotations
from typing import Any
from typing import Callable
from typing import Dict
from typing import Iterable
from typing import Optional
from typing import Tuple
from typing import Type
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union
from .. import event
from .. import exc
from .. import inspect
from .. import util
from ..orm import PassiveFlag
from ..orm._typing import OrmExecuteOptionsParameter
from ..orm.interfaces import ORMOption
from ..orm.mapper import Mapper
from ..orm.query import Query
from ..orm.session import _BindArguments
from ..orm.session import _PKIdentityArgument
from ..orm.session import Session
from ..util.typing import Protocol
from ..util.typing import Self
if TYPE_CHECKING:
    from ..engine.base import Connection
    from ..engine.base import Engine
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/ext/mutable.py =====
r"""Provide support for tracking of in-place changes to scalar values,
which are propagated into ORM change events on owning parent objects.
.. _mutable_scalars:
Establishing Mutability on Scalar Column Values
===============================================
A typical example of a "mutable" structure is a Python dictionary.
Following the example introduced in :ref:`types_toplevel`, we
begin with a custom type that marshals Python dictionaries into
JSON strings before being persisted::
    from sqlalchemy.types import TypeDecorator, VARCHAR
    import json
    class JSONEncodedDict(TypeDecorator):
        "Represents an immutable structure as a json-encoded string."
        impl = VARCHAR
        def process_bind_param(self, value, dialect):
            if value is not None:
                value = json.dumps(value)
            return value
        def process_result_value(self, value, dialect):
            if value is not None:
                value = json.loads(value)
            return value
The usage of ``json`` is only for the purposes of example. The
:mod:`sqlalchemy.ext.mutable` extension can be used
with any type whose target Python type may be mutable, including
:class:`.PickleType`, :class:`_postgresql.ARRAY`, etc.
When using the :mod:`sqlalchemy.ext.mutable` extension, the value itself
tracks all parents which reference it.  Below, we illustrate a simple
version of the :class:`.MutableDict` dictionary object, which applies
the :class:`.Mutable` mixin to a plain Python dictionary::
    from sqlalchemy.ext.mutable import Mutable
    class MutableDict(Mutable, dict):
        @classmethod
        def coerce(cls, key, value):
            "Convert plain dictionaries to MutableDict."
            if not isinstance(value, MutableDict):
                if isinstance(value, dict):
                    return MutableDict(value)
                # this call will raise ValueError
                return Mutable.coerce(key, value)
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/ext/associationproxy.py =====
"""Contain the ``AssociationProxy`` class.
The ``AssociationProxy`` is a Python property object which provides
transparent proxied access to the endpoint of an association object.
See the example ``examples/association/proxied_association.py``.
"""
from __future__ import annotations
import operator
import typing
from typing import AbstractSet
from typing import Any
from typing import Callable
from typing import cast
from typing import Collection
from typing import Dict
from typing import Generic
from typing import ItemsView
from typing import Iterable
from typing import Iterator
from typing import KeysView
from typing import List
from typing import Mapping
from typing import MutableMapping
from typing import MutableSequence
from typing import MutableSet
from typing import NoReturn
from typing import Optional
from typing import overload
from typing import Set
from typing import Tuple
from typing import Type
from typing import TypeVar
from typing import Union
from typing import ValuesView
from .. import ColumnElement
from .. import exc
from .. import inspect
from .. import orm
from .. import util
from ..orm import collections
from ..orm import InspectionAttrExtensionType
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/__init__.py =====
from __future__ import annotations
from typing import Any
from . import util as _util
from .engine import AdaptedConnection as AdaptedConnection
from .engine import BaseRow as BaseRow
from .engine import BindTyping as BindTyping
from .engine import ChunkedIteratorResult as ChunkedIteratorResult
from .engine import Compiled as Compiled
from .engine import Connection as Connection
from .engine import create_engine as create_engine
from .engine import create_mock_engine as create_mock_engine
from .engine import create_pool_from_url as create_pool_from_url
from .engine import CreateEnginePlugin as CreateEnginePlugin
from .engine import CursorResult as CursorResult
from .engine import Dialect as Dialect
from .engine import Engine as Engine
from .engine import engine_from_config as engine_from_config
from .engine import ExceptionContext as ExceptionContext
from .engine import ExecutionContext as ExecutionContext
from .engine import FrozenResult as FrozenResult
from .engine import Inspector as Inspector
from .engine import IteratorResult as IteratorResult
from .engine import make_url as make_url
from .engine import MappingResult as MappingResult
from .engine import MergedResult as MergedResult
from .engine import NestedTransaction as NestedTransaction
from .engine import Result as Result
from .engine import result_tuple as result_tuple
from .engine import ResultProxy as ResultProxy
from .engine import RootTransaction as RootTransaction
from .engine import Row as Row
from .engine import RowMapping as RowMapping
from .engine import ScalarResult as ScalarResult
from .engine import Transaction as Transaction
from .engine import TwoPhaseTransaction as TwoPhaseTransaction
from .engine import TypeCompiler as TypeCompiler
from .engine import URL as URL
from .inspection import inspect as inspect
from .pool import AssertionPool as AssertionPool
from .pool import AsyncAdaptedQueuePool as AsyncAdaptedQueuePool
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/types.py =====
"""Compatibility namespace for sqlalchemy.sql.types."""
from __future__ import annotations
from .sql.sqltypes import _Binary as _Binary
from .sql.sqltypes import ARRAY as ARRAY
from .sql.sqltypes import BIGINT as BIGINT
from .sql.sqltypes import BigInteger as BigInteger
from .sql.sqltypes import BINARY as BINARY
from .sql.sqltypes import BLOB as BLOB
from .sql.sqltypes import BOOLEAN as BOOLEAN
from .sql.sqltypes import Boolean as Boolean
from .sql.sqltypes import CHAR as CHAR
from .sql.sqltypes import CLOB as CLOB
from .sql.sqltypes import Concatenable as Concatenable
from .sql.sqltypes import DATE as DATE
from .sql.sqltypes import Date as Date
from .sql.sqltypes import DATETIME as DATETIME
from .sql.sqltypes import DateTime as DateTime
from .sql.sqltypes import DECIMAL as DECIMAL
from .sql.sqltypes import DOUBLE as DOUBLE
from .sql.sqltypes import Double as Double
from .sql.sqltypes import DOUBLE_PRECISION as DOUBLE_PRECISION
from .sql.sqltypes import Enum as Enum
from .sql.sqltypes import FLOAT as FLOAT
from .sql.sqltypes import Float as Float
from .sql.sqltypes import Indexable as Indexable
from .sql.sqltypes import INT as INT
from .sql.sqltypes import INTEGER as INTEGER
from .sql.sqltypes import Integer as Integer
from .sql.sqltypes import Interval as Interval
from .sql.sqltypes import JSON as JSON
from .sql.sqltypes import LargeBinary as LargeBinary
from .sql.sqltypes import MatchType as MatchType
from .sql.sqltypes import NCHAR as NCHAR
from .sql.sqltypes import NULLTYPE as NULLTYPE
from .sql.sqltypes import NullType as NullType
from .sql.sqltypes import NUMERIC as NUMERIC
from .sql.sqltypes import Numeric as Numeric
from .sql.sqltypes import NVARCHAR as NVARCHAR
from .sql.sqltypes import PickleType as PickleType
from .sql.sqltypes import REAL as REAL
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/inspection.py =====
"""The inspection module provides the :func:`_sa.inspect` function,
which delivers runtime information about a wide variety
of SQLAlchemy objects, both within the Core as well as the
ORM.
The :func:`_sa.inspect` function is the entry point to SQLAlchemy's
public API for viewing the configuration and construction
of in-memory objects.   Depending on the type of object
passed to :func:`_sa.inspect`, the return value will either be
a related object which provides a known interface, or in many
cases it will return the object itself.
The rationale for :func:`_sa.inspect` is twofold.  One is that
it replaces the need to be aware of a large variety of "information
getting" functions in SQLAlchemy, such as
:meth:`_reflection.Inspector.from_engine` (deprecated in 1.4),
:func:`.orm.attributes.instance_state`, :func:`_orm.class_mapper`,
and others.    The other is that the return value of :func:`_sa.inspect`
is guaranteed to obey a documented API, thus allowing third party
tools which build on top of SQLAlchemy configurations to be constructed
in a forwards-compatible way.
"""
from __future__ import annotations
from typing import Any
from typing import Callable
from typing import Dict
from typing import Generic
from typing import Optional
from typing import overload
from typing import Type
from typing import TypeVar
from typing import Union
from . import exc
from .util.typing import Literal
from .util.typing import Protocol
_T = TypeVar("_T", bound=Any)
_TCov = TypeVar("_TCov", bound=Any, covariant=True)
_F = TypeVar("_F", bound=Callable[..., Any])
_IN = TypeVar("_IN", bound=Any)
_registrars: Dict[type, Union[Literal[True], Callable[[Any], Any]]] = {}
class Inspectable(Generic[_T]):
    """define a class as inspectable.
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/testing/pickleable.py =====
"""Classes used in pickling tests, need to be at the module level for
unpickling.
"""
from __future__ import annotations
from .entities import ComparableEntity
from ..schema import Column
from ..types import String
class User(ComparableEntity):
    pass
class Order(ComparableEntity):
    pass
class Dingaling(ComparableEntity):
    pass
class EmailUser(User):
    pass
class Address(ComparableEntity):
    pass
class Child1(ComparableEntity):
    pass
class Child2(ComparableEntity):
    pass
class Parent(ComparableEntity):
    pass
class Screen:
    def __init__(self, obj, parent=None):
        self.obj = obj
        self.parent = parent
class Mixin:
    email_address = Column(String)
class AddressWMixin(Mixin, ComparableEntity):
    pass
class Foo:
    def __init__(self, moredata, stuff="im stuff"):
        self.data = "im data"
        self.stuff = stuff
        self.moredata = moredata
    __hash__ = object.__hash__
    def __eq__(self, other):
        return (
            other.data == self.data
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/testing/exclusions.py =====
import contextlib
import operator
import re
import sys
from . import config
from .. import util
from ..util import decorator
from ..util.compat import inspect_getfullargspec
def skip_if(predicate, reason=None):
    rule = compound()
    pred = _as_predicate(predicate, reason)
    rule.skips.add(pred)
    return rule
def fails_if(predicate, reason=None):
    rule = compound()
    pred = _as_predicate(predicate, reason)
    rule.fails.add(pred)
    return rule
class compound:
    def __init__(self):
        self.fails = set()
        self.skips = set()
    def __add__(self, other):
        return self.add(other)
    def as_skips(self):
        rule = compound()
        rule.skips.update(self.skips)
        rule.skips.update(self.fails)
        return rule
    def add(self, *others):
        copy = compound()
        copy.fails.update(self.fails)
        copy.skips.update(self.skips)
        for other in others:
            copy.fails.update(other.fails)
            copy.skips.update(other.skips)
        return copy
    def not_(self):
        copy = compound()
        copy.fails.update(NotPredicate(fail) for fail in self.fails)
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/testing/config.py =====
from __future__ import annotations
from argparse import Namespace
import collections
import inspect
import typing
from typing import Any
from typing import Callable
from typing import Iterable
from typing import NoReturn
from typing import Optional
from typing import Tuple
from typing import TypeVar
from typing import Union
from . import mock
from . import requirements as _requirements
from .util import fail
from .. import util
requirements = _requirements.SuiteRequirements()
db = None
db_url = None
db_opts = None
file_config = None
test_schema = None
test_schema_2 = None
any_async = False
_current = None
ident = "main"
options: Namespace = None  # type: ignore
if typing.TYPE_CHECKING:
    from .plugin.plugin_base import FixtureFunctions
    _fixture_functions: FixtureFunctions
else:
    class _NullFixtureFunctions:
        def _null_decorator(self):
            def go(fn):
                return fn
            return go
        def skip_test_exception(self, *arg, **kw):
            return Exception()
        @property
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/testing/engines.py =====
from __future__ import annotations
import collections
import re
import typing
from typing import Any
from typing import Dict
from typing import Optional
import warnings
import weakref
from . import config
from .util import decorator
from .util import gc_collect
from .. import event
from .. import pool
from ..util import await_only
from ..util.typing import Literal
if typing.TYPE_CHECKING:
    from ..engine import Engine
    from ..engine.url import URL
    from ..ext.asyncio import AsyncEngine
class ConnectionKiller:
    def __init__(self):
        self.proxy_refs = weakref.WeakKeyDictionary()
        self.testing_engines = collections.defaultdict(set)
        self.dbapi_connections = set()
    def add_pool(self, pool):
        event.listen(pool, "checkout", self._add_conn)
        event.listen(pool, "checkin", self._remove_conn)
        event.listen(pool, "close", self._remove_conn)
        event.listen(pool, "close_detached", self._remove_conn)
        # note we are keeping "invalidated" here, as those are still
        # opened connections we would like to roll back
    def _add_conn(self, dbapi_con, con_record, con_proxy):
        self.dbapi_connections.add(dbapi_con)
        self.proxy_refs[con_proxy] = True
    def _remove_conn(self, dbapi_conn, *arg):
        self.dbapi_connections.discard(dbapi_conn)
    def add_engine(self, engine, scope):
        self.add_pool(engine.pool)
        assert scope in ("class", "global", "function", "fixture")
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/testing/util.py =====
from __future__ import annotations
from collections import deque
from collections import namedtuple
import contextlib
import decimal
import gc
from itertools import chain
import pickle
import random
import sys
from sys import getsizeof
import time
import types
from typing import Any
from . import config
from . import mock
from .. import inspect
from ..engine import Connection
from ..schema import Column
from ..schema import DropConstraint
from ..schema import DropTable
from ..schema import ForeignKeyConstraint
from ..schema import MetaData
from ..schema import Table
from ..sql import schema
from ..sql.sqltypes import Integer
from ..util import decorator
from ..util import defaultdict
from ..util import has_refcount_gc
from ..util import inspect_getfullargspec
if not has_refcount_gc:
    def non_refcount_gc_collect(*args):
        gc.collect()
        gc.collect()
    gc_collect = lazy_gc = non_refcount_gc_collect
else:
    # assume CPython - straight gc.collect, lazy_gc() is a pass
    gc_collect = gc.collect
    def lazy_gc():
        pass
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/testing/warnings.py =====
from __future__ import annotations
import warnings
from . import assertions
from .. import exc
from .. import exc as sa_exc
from ..exc import SATestSuiteWarning
from ..util.langhelpers import _warnings_warn
def warn_test_suite(message):
    _warnings_warn(message, category=SATestSuiteWarning)
def setup_filters():
    """hook for setting up warnings filters.
    SQLAlchemy-specific classes must only be here and not in pytest config,
    as we need to delay importing SQLAlchemy until conftest.py has been
    processed.
    NOTE: filters on subclasses of DeprecationWarning or
    PendingDeprecationWarning have no effect if added here, since pytest
    will add at each test the following filters
    ``always::PendingDeprecationWarning`` and ``always::DeprecationWarning``
    that will take precedence over any added here.
    """
    warnings.filterwarnings("error", category=exc.SAWarning)
    warnings.filterwarnings("always", category=exc.SATestSuiteWarning)
def assert_warnings(fn, warning_msgs, regex=False):
    """Assert that each of the given warnings are emitted by fn.
    Deprecated.  Please use assertions.expect_warnings().
    """
    with assertions._expect_warnings(
        sa_exc.SAWarning, warning_msgs, regex=regex
    ):
        return fn()
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/testing/asyncio.py =====
from __future__ import annotations
from functools import wraps
import inspect
from . import config
from ..util.concurrency import _AsyncUtil
ENABLE_ASYNCIO = True
_async_util = _AsyncUtil()  # it has lazy init so just always create one
def _shutdown():
    """called when the test finishes"""
    _async_util.close()
def _run_coroutine_function(fn, *args, **kwargs):
    return _async_util.run(fn, *args, **kwargs)
def _assume_async(fn, *args, **kwargs):
    """Run a function in an asyncio loop unconditionally.
    This function is used for provisioning features like
    testing a database connection for server info.
    Note that for blocking IO database drivers, this means they block the
    event loop.
    """
    if not ENABLE_ASYNCIO:
        return fn(*args, **kwargs)
    return _async_util.run_in_greenlet(fn, *args, **kwargs)
def _maybe_async_provisioning(fn, *args, **kwargs):
    """Run a function in an asyncio loop if any current drivers might need it.
    This function is used for provisioning features that take
    place outside of a specific database driver being selected, so if the
    current driver that happens to be used for the provisioning operation
    is an async driver, it will run in asyncio and not fail.
    Note that for blocking IO database drivers, this means they block the
    event loop.
    """
    if not ENABLE_ASYNCIO:
        return fn(*args, **kwargs)
    if config.any_async:
        return _async_util.run_in_greenlet(fn, *args, **kwargs)
    else:
        return fn(*args, **kwargs)
def _maybe_async(fn, *args, **kwargs):
    """Run a function in an asyncio loop if the current selected driver is
    async.
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/testing/plugin/bootstrap.py =====
"""
Bootstrapper for test framework plugins.
The entire rationale for this system is to get the modules in plugin/
imported without importing all of the supporting library, so that we can
set up things for testing before coverage starts.
The rationale for all of plugin/ being *in* the supporting library in the
first place is so that the testing and plugin suite is available to other
libraries, mainly external SQLAlchemy and Alembic dialects, to make use
of the same test environment and standard suites available to
SQLAlchemy/Alembic themselves without the need to ship/install a separate
package outside of SQLAlchemy.
"""
import importlib.util
import os
import sys
bootstrap_file = locals()["bootstrap_file"]
to_bootstrap = locals()["to_bootstrap"]
def load_file_as_module(name):
    path = os.path.join(os.path.dirname(bootstrap_file), "%s.py" % name)
    spec = importlib.util.spec_from_file_location(name, path)
    assert spec is not None
    assert spec.loader is not None
    mod = importlib.util.module_from_spec(spec)
    spec.loader.exec_module(mod)
    return mod
if to_bootstrap == "pytest":
    sys.modules["sqla_plugin_base"] = load_file_as_module("plugin_base")
    sys.modules["sqla_plugin_base"].bootstrapped_as_sqlalchemy = True
    sys.modules["sqla_pytestplugin"] = load_file_as_module("pytestplugin")
else:
    raise Exception("unknown bootstrap: %s" % to_bootstrap)  # noqa
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/testing/plugin/plugin_base.py =====
from __future__ import annotations
import abc
from argparse import Namespace
import configparser
import logging
import os
from pathlib import Path
import re
import sys
from typing import Any
from sqlalchemy.testing import asyncio
"""Testing extensions.
this module is designed to work as a testing-framework-agnostic library,
created so that multiple test frameworks can be supported at once
(mostly so that we can migrate to new ones). The current target
is pytest.
"""
bootstrapped_as_sqlalchemy = False
log = logging.getLogger("sqlalchemy.testing.plugin_base")
fixtures = None
engines = None
exclusions = None
warnings = None
profiling = None
provision = None
assertions = None
requirements = None
config = None
testing = None
util = None
file_config = None
logging = None
include_tags = set()
exclude_tags = set()
options: Namespace = None  # type: ignore
def setup_options(make_option):
    make_option(
        "--log-info",
        action="callback",
        type=str,
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/testing/plugin/__init__.py =====
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/testing/plugin/pytestplugin.py =====
from __future__ import annotations
import argparse
import collections
from functools import update_wrapper
import inspect
import itertools
import operator
import os
import re
import sys
from typing import TYPE_CHECKING
import uuid
import pytest
try:
    # installed by bootstrap.py
    if not TYPE_CHECKING:
        import sqla_plugin_base as plugin_base
except ImportError:
    # assume we're a package, use traditional import
    from . import plugin_base
def pytest_addoption(parser):
    group = parser.getgroup("sqlalchemy")
    def make_option(name, **kw):
        callback_ = kw.pop("callback", None)
        if callback_:
            class CallableAction(argparse.Action):
                def __call__(
                    self, parser, namespace, values, option_string=None
                ):
                    callback_(option_string, values, parser)
            kw["action"] = CallableAction
        zeroarg_callback = kw.pop("zeroarg_callback", None)
        if zeroarg_callback:
            class CallableAction(argparse.Action):
                def __init__(
                    self,
                    option_strings,
                    dest,
                    default=False,
                    required=False,
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/testing/__init__.py =====
from unittest import mock
from . import config
from .assertions import assert_raises
from .assertions import assert_raises_context_ok
from .assertions import assert_raises_message
from .assertions import assert_raises_message_context_ok
from .assertions import assert_warns
from .assertions import assert_warns_message
from .assertions import AssertsCompiledSQL
from .assertions import AssertsExecutionResults
from .assertions import ComparesIndexes
from .assertions import ComparesTables
from .assertions import emits_warning
from .assertions import emits_warning_on
from .assertions import eq_
from .assertions import eq_ignore_whitespace
from .assertions import eq_regex
from .assertions import expect_deprecated
from .assertions import expect_deprecated_20
from .assertions import expect_raises
from .assertions import expect_raises_message
from .assertions import expect_warnings
from .assertions import in_
from .assertions import int_within_variance
from .assertions import is_
from .assertions import is_false
from .assertions import is_instance_of
from .assertions import is_none
from .assertions import is_not
from .assertions import is_not_
from .assertions import is_not_none
from .assertions import is_true
from .assertions import le_
from .assertions import ne_
from .assertions import not_in
from .assertions import not_in_
from .assertions import startswith_
from .assertions import uses_deprecated
from .config import add_to_marker
from .config import async_test
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/testing/assertions.py =====
from __future__ import annotations
from collections import defaultdict
import contextlib
from copy import copy
from itertools import filterfalse
import re
import sys
import warnings
from . import assertsql
from . import config
from . import engines
from . import mock
from .exclusions import db_spec
from .util import fail
from .. import exc as sa_exc
from .. import schema
from .. import sql
from .. import types as sqltypes
from .. import util
from ..engine import default
from ..engine import url
from ..sql.selectable import LABEL_STYLE_TABLENAME_PLUS_COL
from ..util import decorator
def expect_warnings(*messages, **kw):
    """Context manager which expects one or more warnings.
    With no arguments, squelches all SAWarning emitted via
    sqlalchemy.util.warn and sqlalchemy.util.warn_limited.   Otherwise
    pass string expressions that will match selected warnings via regex;
    all non-matching warnings are sent through.
    The expect version **asserts** that the warnings were in fact seen.
    Note that the test suite sets SAWarning warnings to raise exceptions.
    """  # noqa
    return _expect_warnings_sqla_only(sa_exc.SAWarning, messages, **kw)
@contextlib.contextmanager
def expect_warnings_on(db, *messages, **kw):
    """Context manager which expects one or more warnings on specific
    dialects.
    The expect version **asserts** that the warnings were in fact seen.
    """
    spec = db_spec(db)
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/testing/assertsql.py =====
from __future__ import annotations
import collections
import contextlib
import itertools
import re
from .. import event
from ..engine import url
from ..engine.default import DefaultDialect
from ..schema import BaseDDLElement
class AssertRule:
    is_consumed = False
    errormessage = None
    consume_statement = True
    def process_statement(self, execute_observed):
        pass
    def no_more_statements(self):
        assert False, (
            "All statements are complete, but pending "
            "assertion rules remain"
        )
class SQLMatchRule(AssertRule):
    pass
class CursorSQL(SQLMatchRule):
    def __init__(self, statement, params=None, consume_statement=True):
        self.statement = statement
        self.params = params
        self.consume_statement = consume_statement
    def process_statement(self, execute_observed):
        stmt = execute_observed.statements[0]
        if self.statement != stmt.statement or (
            self.params is not None and self.params != stmt.parameters
        ):
            self.consume_statement = True
            self.errormessage = (
                "Testing for exact SQL %s parameters %s received %s %s"
                % (
                    self.statement,
                    self.params,
                    stmt.statement,
                    stmt.parameters,
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/testing/provision.py =====
from __future__ import annotations
import collections
import logging
from . import config
from . import engines
from . import util
from .. import exc
from .. import inspect
from ..engine import url as sa_url
from ..sql import ddl
from ..sql import schema
log = logging.getLogger(__name__)
FOLLOWER_IDENT = None
class register:
    def __init__(self, decorator=None):
        self.fns = {}
        self.decorator = decorator
    @classmethod
    def init(cls, fn):
        return register().for_db("*")(fn)
    @classmethod
    def init_decorator(cls, decorator):
        return register(decorator).for_db("*")
    def for_db(self, *dbnames):
        def decorate(fn):
            if self.decorator:
                fn = self.decorator(fn)
            for dbname in dbnames:
                self.fns[dbname] = fn
            return self
        return decorate
    def __call__(self, cfg, *arg, **kw):
        if isinstance(cfg, str):
            url = sa_url.make_url(cfg)
        elif isinstance(cfg, sa_url.URL):
            url = cfg
        else:
            url = cfg.db.url
        backend = url.get_backend_name()
        if backend in self.fns:
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/testing/requirements.py =====
"""Global database feature support policy.
Provides decorators to mark tests requiring specific feature support from the
target database.
External dialect test suites should subclass SuiteRequirements
to provide specific inclusion/exclusions.
"""
from __future__ import annotations
import os
import platform
from . import asyncio as _test_asyncio
from . import exclusions
from .exclusions import only_on
from .. import create_engine
from .. import util
from ..pool import QueuePool
class Requirements:
    pass
class SuiteRequirements(Requirements):
    @property
    def create_table(self):
        """target platform can emit basic CreateTable DDL."""
        return exclusions.open()
    @property
    def drop_table(self):
        """target platform can emit basic DropTable DDL."""
        return exclusions.open()
    @property
    def table_ddl_if_exists(self):
        """target platform supports IF NOT EXISTS / IF EXISTS for tables."""
        return exclusions.closed()
    @property
    def index_ddl_if_exists(self):
        """target platform supports IF NOT EXISTS / IF EXISTS for indexes."""
        return exclusions.closed()
    @property
    def uuid_data_type(self):
        """Return databases that support the UUID datatype."""
        return exclusions.closed()
    @property
    def foreign_keys(self):
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/testing/fixtures/orm.py =====
from __future__ import annotations
from typing import Any
import sqlalchemy as sa
from .base import TestBase
from .sql import TablesTest
from .. import assertions
from .. import config
from .. import schema
from ..entities import BasicEntity
from ..entities import ComparableEntity
from ..util import adict
from ... import orm
from ...orm import DeclarativeBase
from ...orm import events as orm_events
from ...orm import registry
class ORMTest(TestBase):
    @config.fixture
    def fixture_session(self):
        return fixture_session()
class MappedTest(ORMTest, TablesTest, assertions.AssertsExecutionResults):
    # 'once', 'each', None
    run_setup_classes = "once"
    # 'once', 'each', None
    run_setup_mappers = "each"
    classes: Any = None
    @config.fixture(autouse=True, scope="class")
    def _setup_tables_test_class(self):
        cls = self.__class__
        cls._init_class()
        if cls.classes is None:
            cls.classes = adict()
        cls._setup_once_tables()
        cls._setup_once_classes()
        cls._setup_once_mappers()
        cls._setup_once_inserts()
        yield
        cls._teardown_once_class()
        cls._teardown_once_metadata_bind()
    @config.fixture(autouse=True, scope="function")
    def _setup_tables_test_instance(self):
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/testing/fixtures/__init__.py =====
from .base import FutureEngineMixin as FutureEngineMixin
from .base import TestBase as TestBase
from .mypy import MypyTest as MypyTest
from .orm import after_test as after_test
from .orm import close_all_sessions as close_all_sessions
from .orm import DeclarativeMappedTest as DeclarativeMappedTest
from .orm import fixture_session as fixture_session
from .orm import MappedTest as MappedTest
from .orm import ORMTest as ORMTest
from .orm import RemoveORMEventsGlobally as RemoveORMEventsGlobally
from .orm import (
    stop_test_class_inside_fixtures as stop_test_class_inside_fixtures,
)
from .sql import CacheKeyFixture as CacheKeyFixture
from .sql import (
    ComputedReflectionFixtureTest as ComputedReflectionFixtureTest,
)
from .sql import insertmanyvalues_fixture as insertmanyvalues_fixture
from .sql import NoCache as NoCache
from .sql import RemovesEvents as RemovesEvents
from .sql import TablesTest as TablesTest
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/testing/fixtures/mypy.py =====
from __future__ import annotations
import inspect
import os
from pathlib import Path
import re
import shutil
import sys
import tempfile
from .base import TestBase
from .. import config
from ..assertions import eq_
from ... import util
@config.add_to_marker.mypy
class MypyTest(TestBase):
    __requires__ = ("no_sqlalchemy2_stubs",)
    @config.fixture(scope="function")
    def per_func_cachedir(self):
        yield from self._cachedir()
    @config.fixture(scope="class")
    def cachedir(self):
        yield from self._cachedir()
    def _cachedir(self):
        # as of mypy 0.971 i think we need to keep mypy_path empty
        mypy_path = ""
        with tempfile.TemporaryDirectory() as cachedir:
            with open(
                Path(cachedir) / "sqla_mypy_config.cfg", "w"
            ) as config_file:
                config_file.write(
                    f"""
                    [mypy]\n
                    plugins = sqlalchemy.ext.mypy.plugin\n
                    show_error_codes = True\n
                    {mypy_path}
                    disable_error_code = no-untyped-call
                    [mypy-sqlalchemy.*]
                    ignore_errors = True
                    """
                )
            with open(
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/testing/fixtures/sql.py =====
from __future__ import annotations
import itertools
import random
import re
import sys
import sqlalchemy as sa
from .base import TestBase
from .. import config
from .. import mock
from ..assertions import eq_
from ..assertions import ne_
from ..util import adict
from ..util import drop_all_tables_from_metadata
from ... import event
from ... import util
from ...schema import sort_tables_and_constraints
from ...sql import visitors
from ...sql.elements import ClauseElement
class TablesTest(TestBase):
    # 'once', None
    run_setup_bind = "once"
    # 'once', 'each', None
    run_define_tables = "once"
    # 'once', 'each', None
    run_create_tables = "once"
    # 'once', 'each', None
    run_inserts = "each"
    # 'each', None
    run_deletes = "each"
    # 'once', None
    run_dispose_bind = None
    bind = None
    _tables_metadata = None
    tables = None
    other = None
    sequences = None
    @config.fixture(autouse=True, scope="class")
    def _setup_tables_test_class(self):
        cls = self.__class__
        cls._init_class()
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/testing/fixtures/base.py =====
from __future__ import annotations
import sqlalchemy as sa
from .. import assertions
from .. import config
from ..assertions import eq_
from ..util import drop_all_tables_from_metadata
from ..util import picklers
from ... import Column
from ... import func
from ... import Integer
from ... import select
from ... import Table
from ...orm import DeclarativeBase
from ...orm import MappedAsDataclass
from ...orm import registry
@config.mark_base_test_class()
class TestBase:
    # A sequence of requirement names matching testing.requires decorators
    __requires__ = ()
    # A sequence of dialect names to exclude from the test class.
    __unsupported_on__ = ()
    # If present, test class is only runnable for the *single* specified
    # dialect.  If you need multiple, use __unsupported_on__ and invert.
    __only_on__ = None
    # A sequence of no-arg callables. If any are True, the entire testcase is
    # skipped.
    __skip_if__ = None
    # if True, the testing reaper will not attempt to touch connection
    # state after a test is completed and before the outer teardown
    # starts
    __leave_connections_for_teardown__ = False
    def assert_(self, val, msg=None):
        assert val, msg
    @config.fixture()
    def nocache(self):
        _cache = config.db._compiled_cache
        config.db._compiled_cache = None
        yield
        config.db._compiled_cache = _cache
    @config.fixture()
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/testing/entities.py =====
from __future__ import annotations
import sqlalchemy as sa
from .. import exc as sa_exc
from ..orm.writeonly import WriteOnlyCollection
_repr_stack = set()
class BasicEntity:
    def __init__(self, **kw):
        for key, value in kw.items():
            setattr(self, key, value)
    def __repr__(self):
        if id(self) in _repr_stack:
            return object.__repr__(self)
        _repr_stack.add(id(self))
        try:
            return "%s(%s)" % (
                (self.__class__.__name__),
                ", ".join(
                    [
                        "%s=%r" % (key, getattr(self, key))
                        for key in sorted(self.__dict__.keys())
                        if not key.startswith("_")
                    ]
                ),
            )
        finally:
            _repr_stack.remove(id(self))
_recursion_stack = set()
class ComparableMixin:
    def __ne__(self, other):
        return not self.__eq__(other)
    def __eq__(self, other):
        """'Deep, sparse compare.
        Deeply compare two entities, following the non-None attributes of the
        non-persisted object, if possible.
        """
        if other is self:
            return True
        elif not self.__class__ == other.__class__:
            return False
        if id(self) in _recursion_stack:
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/testing/suite/test_sequence.py =====
from .. import config
from .. import fixtures
from ..assertions import eq_
from ..assertions import is_true
from ..config import requirements
from ..provision import normalize_sequence
from ..schema import Column
from ..schema import Table
from ... import inspect
from ... import Integer
from ... import MetaData
from ... import Sequence
from ... import String
from ... import testing
class SequenceTest(fixtures.TablesTest):
    __requires__ = ("sequences",)
    __backend__ = True
    run_create_tables = "each"
    @classmethod
    def define_tables(cls, metadata):
        Table(
            "seq_pk",
            metadata,
            Column(
                "id",
                Integer,
                normalize_sequence(config, Sequence("tab_id_seq")),
                primary_key=True,
            ),
            Column("data", String(50)),
        )
        Table(
            "seq_opt_pk",
            metadata,
            Column(
                "id",
                Integer,
                normalize_sequence(
                    config,
                    Sequence("tab_id_seq", data_type=Integer, optional=True),
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/testing/suite/test_results.py =====
import datetime
import re
from .. import engines
from .. import fixtures
from ..assertions import eq_
from ..config import requirements
from ..schema import Column
from ..schema import Table
from ... import DateTime
from ... import func
from ... import Integer
from ... import select
from ... import sql
from ... import String
from ... import testing
from ... import text
class RowFetchTest(fixtures.TablesTest):
    __backend__ = True
    @classmethod
    def define_tables(cls, metadata):
        Table(
            "plain_pk",
            metadata,
            Column("id", Integer, primary_key=True),
            Column("data", String(50)),
        )
        Table(
            "has_dates",
            metadata,
            Column("id", Integer, primary_key=True),
            Column("today", DateTime),
        )
    @classmethod
    def insert_data(cls, connection):
        connection.execute(
            cls.tables.plain_pk.insert(),
            [
                {"id": 1, "data": "d1"},
                {"id": 2, "data": "d2"},
                {"id": 3, "data": "d3"},
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/testing/suite/test_insert.py =====
from decimal import Decimal
import uuid
from . import testing
from .. import fixtures
from ..assertions import eq_
from ..config import requirements
from ..schema import Column
from ..schema import Table
from ... import Double
from ... import Float
from ... import Identity
from ... import Integer
from ... import literal
from ... import literal_column
from ... import Numeric
from ... import select
from ... import String
from ...types import LargeBinary
from ...types import UUID
from ...types import Uuid
class LastrowidTest(fixtures.TablesTest):
    run_deletes = "each"
    __backend__ = True
    __requires__ = "implements_get_lastrowid", "autoincrement_insert"
    @classmethod
    def define_tables(cls, metadata):
        Table(
            "autoinc_pk",
            metadata,
            Column(
                "id", Integer, primary_key=True, test_needs_autoincrement=True
            ),
            Column("data", String(50)),
            implicit_returning=False,
        )
        Table(
            "manual_pk",
            metadata,
            Column("id", Integer, primary_key=True, autoincrement=False),
            Column("data", String(50)),
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/testing/suite/test_select.py =====
import collections.abc as collections_abc
import itertools
from .. import AssertsCompiledSQL
from .. import AssertsExecutionResults
from .. import config
from .. import fixtures
from ..assertions import assert_raises
from ..assertions import eq_
from ..assertions import in_
from ..assertsql import CursorSQL
from ..schema import Column
from ..schema import Table
from ... import bindparam
from ... import case
from ... import column
from ... import Computed
from ... import exists
from ... import false
from ... import ForeignKey
from ... import func
from ... import Identity
from ... import Integer
from ... import literal
from ... import literal_column
from ... import null
from ... import select
from ... import String
from ... import table
from ... import testing
from ... import text
from ... import true
from ... import tuple_
from ... import TupleType
from ... import union
from ... import values
from ...exc import DatabaseError
from ...exc import ProgrammingError
class CollateTest(fixtures.TablesTest):
    __backend__ = True
    @classmethod
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/testing/suite/test_deprecations.py =====
from .. import fixtures
from ..assertions import eq_
from ..schema import Column
from ..schema import Table
from ... import Integer
from ... import select
from ... import testing
from ... import union
class DeprecatedCompoundSelectTest(fixtures.TablesTest):
    __backend__ = True
    @classmethod
    def define_tables(cls, metadata):
        Table(
            "some_table",
            metadata,
            Column("id", Integer, primary_key=True),
            Column("x", Integer),
            Column("y", Integer),
        )
    @classmethod
    def insert_data(cls, connection):
        connection.execute(
            cls.tables.some_table.insert(),
            [
                {"id": 1, "x": 1, "y": 2},
                {"id": 2, "x": 2, "y": 3},
                {"id": 3, "x": 3, "y": 4},
                {"id": 4, "x": 4, "y": 5},
            ],
        )
    def _assert_result(self, conn, select, result, params=()):
        eq_(conn.execute(select, params).fetchall(), result)
    def test_plain_union(self, connection):
        table = self.tables.some_table
        s1 = select(table).where(table.c.id == 2)
        s2 = select(table).where(table.c.id == 3)
        u1 = union(s1, s2)
        with testing.expect_deprecated(
            "The SelectBase.c and SelectBase.columns "
            "attributes are deprecated"
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/testing/suite/test_ddl.py =====
import random
from . import testing
from .. import config
from .. import fixtures
from .. import util
from ..assertions import eq_
from ..assertions import is_false
from ..assertions import is_true
from ..config import requirements
from ..schema import Table
from ... import CheckConstraint
from ... import Column
from ... import ForeignKeyConstraint
from ... import Index
from ... import inspect
from ... import Integer
from ... import schema
from ... import String
from ... import UniqueConstraint
class TableDDLTest(fixtures.TestBase):
    __backend__ = True
    def _simple_fixture(self, schema=None):
        return Table(
            "test_table",
            self.metadata,
            Column("id", Integer, primary_key=True, autoincrement=False),
            Column("data", String(50)),
            schema=schema,
        )
    def _underscore_fixture(self):
        return Table(
            "_test_table",
            self.metadata,
            Column("id", Integer, primary_key=True, autoincrement=False),
            Column("_data", String(50)),
        )
    def _table_index_fixture(self, schema=None):
        table = self._simple_fixture(schema=schema)
        idx = Index("test_index", table.c.data)
        return table, idx
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/testing/suite/test_dialect.py =====
import importlib
from . import testing
from .. import assert_raises
from .. import config
from .. import engines
from .. import eq_
from .. import fixtures
from .. import is_not_none
from .. import is_true
from .. import mock
from .. import ne_
from .. import provide_metadata
from ..assertions import expect_raises
from ..assertions import expect_raises_message
from ..config import requirements
from ..provision import set_default_schema_on_connection
from ..schema import Column
from ..schema import Table
from ... import bindparam
from ... import dialects
from ... import event
from ... import exc
from ... import Integer
from ... import literal_column
from ... import select
from ... import String
from ...sql.compiler import Compiled
from ...util import inspect_getfullargspec
class PingTest(fixtures.TestBase):
    __backend__ = True
    def test_do_ping(self):
        with testing.db.connect() as conn:
            is_true(
                testing.db.dialect.do_ping(conn.connection.dbapi_connection)
            )
class ArgSignatureTest(fixtures.TestBase):
    """test that all visit_XYZ() in :class:`_sql.Compiler` subclasses have
    ``**kw``, for #8988.
    This test uses runtime code inspection.   Does not need to be a
    ``__backend__`` test as it only needs to run once provided all target
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/testing/suite/__init__.py =====
from .test_cte import *  # noqa
from .test_ddl import *  # noqa
from .test_deprecations import *  # noqa
from .test_dialect import *  # noqa
from .test_insert import *  # noqa
from .test_reflection import *  # noqa
from .test_results import *  # noqa
from .test_rowcount import *  # noqa
from .test_select import *  # noqa
from .test_sequence import *  # noqa
from .test_types import *  # noqa
from .test_unicode_ddl import *  # noqa
from .test_update_delete import *  # noqa
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/testing/suite/test_update_delete.py =====
from .. import fixtures
from ..assertions import eq_
from ..schema import Column
from ..schema import Table
from ... import Integer
from ... import String
from ... import testing
class SimpleUpdateDeleteTest(fixtures.TablesTest):
    run_deletes = "each"
    __requires__ = ("sane_rowcount",)
    __backend__ = True
    @classmethod
    def define_tables(cls, metadata):
        Table(
            "plain_pk",
            metadata,
            Column("id", Integer, primary_key=True),
            Column("data", String(50)),
        )
    @classmethod
    def insert_data(cls, connection):
        connection.execute(
            cls.tables.plain_pk.insert(),
            [
                {"id": 1, "data": "d1"},
                {"id": 2, "data": "d2"},
                {"id": 3, "data": "d3"},
            ],
        )
    def test_update(self, connection):
        t = self.tables.plain_pk
        r = connection.execute(
            t.update().where(t.c.id == 2), dict(data="d2_new")
        )
        assert not r.is_insert
        assert not r.returns_rows
        assert r.rowcount == 1
        eq_(
            connection.execute(t.select().order_by(t.c.id)).fetchall(),
            [(1, "d1"), (2, "d2_new"), (3, "d3")],
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/testing/suite/test_reflection.py =====
import contextlib
import operator
import re
import sqlalchemy as sa
from .. import config
from .. import engines
from .. import eq_
from .. import eq_regex
from .. import expect_raises
from .. import expect_raises_message
from .. import expect_warnings
from .. import fixtures
from .. import is_
from ..provision import get_temp_table_name
from ..provision import temp_table_keyword_args
from ..schema import Column
from ..schema import Table
from ... import Boolean
from ... import DateTime
from ... import event
from ... import ForeignKey
from ... import func
from ... import Identity
from ... import inspect
from ... import Integer
from ... import MetaData
from ... import String
from ... import testing
from ... import types as sql_types
from ...engine import Inspector
from ...engine import ObjectKind
from ...engine import ObjectScope
from ...exc import NoSuchTableError
from ...exc import UnreflectableTableError
from ...schema import DDL
from ...schema import Index
from ...sql.elements import quoted_name
from ...sql.schema import BLANK_SCHEMA
from ...testing import ComparesIndexes
from ...testing import ComparesTables
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/testing/suite/test_rowcount.py =====
from sqlalchemy import bindparam
from sqlalchemy import Column
from sqlalchemy import Integer
from sqlalchemy import MetaData
from sqlalchemy import select
from sqlalchemy import String
from sqlalchemy import Table
from sqlalchemy import testing
from sqlalchemy import text
from sqlalchemy.testing import eq_
from sqlalchemy.testing import fixtures
class RowCountTest(fixtures.TablesTest):
    """test rowcount functionality"""
    __requires__ = ("sane_rowcount",)
    __backend__ = True
    @classmethod
    def define_tables(cls, metadata):
        Table(
            "employees",
            metadata,
            Column(
                "employee_id",
                Integer,
                autoincrement=False,
                primary_key=True,
            ),
            Column("name", String(50)),
            Column("department", String(1)),
        )
    @classmethod
    def insert_data(cls, connection):
        cls.data = data = [
            ("Angela", "A"),
            ("Andrew", "A"),
            ("Anand", "A"),
            ("Bob", "B"),
            ("Bobette", "B"),
            ("Buffy", "B"),
            ("Charlie", "C"),
            ("Cynthia", "C"),
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/testing/suite/test_cte.py =====
from .. import fixtures
from ..assertions import eq_
from ..schema import Column
from ..schema import Table
from ... import column
from ... import ForeignKey
from ... import Integer
from ... import select
from ... import String
from ... import testing
from ... import values
class CTETest(fixtures.TablesTest):
    __backend__ = True
    __requires__ = ("ctes",)
    run_inserts = "each"
    run_deletes = "each"
    @classmethod
    def define_tables(cls, metadata):
        Table(
            "some_table",
            metadata,
            Column("id", Integer, primary_key=True),
            Column("data", String(50)),
            Column("parent_id", ForeignKey("some_table.id")),
        )
        Table(
            "some_other_table",
            metadata,
            Column("id", Integer, primary_key=True),
            Column("data", String(50)),
            Column("parent_id", Integer),
        )
    @classmethod
    def insert_data(cls, connection):
        connection.execute(
            cls.tables.some_table.insert(),
            [
                {"id": 1, "data": "d1", "parent_id": None},
                {"id": 2, "data": "d2", "parent_id": 1},
                {"id": 3, "data": "d3", "parent_id": 1},
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/testing/suite/test_types.py =====
import datetime
import decimal
import json
import re
import uuid
from .. import config
from .. import engines
from .. import fixtures
from .. import mock
from ..assertions import eq_
from ..assertions import is_
from ..assertions import ne_
from ..config import requirements
from ..schema import Column
from ..schema import Table
from ... import and_
from ... import ARRAY
from ... import BigInteger
from ... import bindparam
from ... import Boolean
from ... import case
from ... import cast
from ... import Date
from ... import DateTime
from ... import Enum
from ... import Float
from ... import Integer
from ... import Interval
from ... import JSON
from ... import literal
from ... import literal_column
from ... import MetaData
from ... import null
from ... import Numeric
from ... import select
from ... import String
from ... import testing
from ... import Text
from ... import Time
from ... import TIMESTAMP
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/testing/suite/test_unicode_ddl.py =====
from sqlalchemy import desc
from sqlalchemy import ForeignKey
from sqlalchemy import Integer
from sqlalchemy import MetaData
from sqlalchemy import testing
from sqlalchemy.testing import eq_
from sqlalchemy.testing import fixtures
from sqlalchemy.testing.schema import Column
from sqlalchemy.testing.schema import Table
class UnicodeSchemaTest(fixtures.TablesTest):
    __requires__ = ("unicode_ddl",)
    __backend__ = True
    @classmethod
    def define_tables(cls, metadata):
        global t1, t2, t3
        t1 = Table(
            "unitable1",
            metadata,
            Column("méil", Integer, primary_key=True),
            Column("\u6e2c\u8a66", Integer),
            test_needs_fk=True,
        )
        t2 = Table(
            "Unitéble2",
            metadata,
            Column("méil", Integer, primary_key=True, key="a"),
            Column(
                "\u6e2c\u8a66",
                Integer,
                ForeignKey("unitable1.méil"),
                key="b",
            ),
            test_needs_fk=True,
        )
        # Few DBs support Unicode foreign keys
        if testing.against("sqlite"):
            t3 = Table(
                "\u6e2c\u8a66",
                metadata,
                Column(
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/testing/profiling.py =====
"""Profiling support for unit and performance tests.
These are special purpose profiling methods which operate
in a more fine-grained way than nose's profiling plugin.
"""
from __future__ import annotations
import collections
import contextlib
import os
import platform
import pstats
import re
import sys
from . import config
from .util import gc_collect
from ..util import has_compiled_ext
try:
    import cProfile
except ImportError:
    cProfile = None
_profile_stats = None
"""global ProfileStatsFileInstance.
plugin_base assigns this at the start of all tests.
"""
_current_test = None
"""String id of current test.
plugin_base assigns this at the start of each test using
_start_current_test.
"""
def _start_current_test(id_):
    global _current_test
    _current_test = id_
    if _profile_stats.force_write:
        _profile_stats.reset_count()
class ProfileStatsFile:
    """Store per-platform/fn profiling results in a file.
    There was no json module available when this was written, but now
    the file format which is very deterministically line oriented is kind of
    handy in any case for diffs and merges.
    """
    def __init__(self, filename, sort="cumulative", dump=None):
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/testing/schema.py =====
from __future__ import annotations
import sys
from . import config
from . import exclusions
from .. import event
from .. import schema
from .. import types as sqltypes
from ..orm import mapped_column as _orm_mapped_column
from ..util import OrderedDict
__all__ = ["Table", "Column"]
table_options = {}
def Table(*args, **kw) -> schema.Table:
    """A schema.Table wrapper/hook for dialect-specific tweaks."""
    test_opts = {k: kw.pop(k) for k in list(kw) if k.startswith("test_")}
    kw.update(table_options)
    if exclusions.against(config._current, "mysql"):
        if (
            "mysql_engine" not in kw
            and "mysql_type" not in kw
            and "autoload_with" not in kw
        ):
            if "test_needs_fk" in test_opts or "test_needs_acid" in test_opts:
                kw["mysql_engine"] = "InnoDB"
            else:
                # there are in fact test fixtures that rely upon MyISAM,
                # due to MySQL / MariaDB having poor FK behavior under innodb,
                # such as a self-referential table can't be deleted from at
                # once without attending to per-row dependencies.  We'd need to
                # add special steps to some fixtures if we want to not
                # explicitly state MyISAM here
                kw["mysql_engine"] = "MyISAM"
    elif exclusions.against(config._current, "mariadb"):
        if (
            "mariadb_engine" not in kw
            and "mariadb_type" not in kw
            and "autoload_with" not in kw
        ):
            if "test_needs_fk" in test_opts or "test_needs_acid" in test_opts:
                kw["mariadb_engine"] = "InnoDB"
            else:
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/cyextension/__init__.py =====
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/exc.py =====
"""Exceptions used with SQLAlchemy.
The base exception class is :exc:`.SQLAlchemyError`.  Exceptions which are
raised as a result of DBAPI exceptions are all subclasses of
:exc:`.DBAPIError`.
"""
from __future__ import annotations
import typing
from typing import Any
from typing import List
from typing import Optional
from typing import overload
from typing import Tuple
from typing import Type
from typing import Union
from .util import compat
from .util import preloaded as _preloaded
if typing.TYPE_CHECKING:
    from .engine.interfaces import _AnyExecuteParams
    from .engine.interfaces import Dialect
    from .sql.compiler import Compiled
    from .sql.compiler import TypeCompiler
    from .sql.elements import ClauseElement
if typing.TYPE_CHECKING:
    _version_token: str
else:
    # set by __init__.py
    _version_token = None
class HasDescriptionCode:
    """helper which adds 'code' as an attribute and '_code_str' as a method"""
    code: Optional[str] = None
    def __init__(self, *arg: Any, **kw: Any):
        code = kw.pop("code", None)
        if code is not None:
            self.code = code
        super().__init__(*arg, **kw)
    _what_are_we = "error"
    def _code_str(self) -> str:
        if not self.code:
            return ""
        else:
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/dialects/postgresql/pg_catalog.py =====
from __future__ import annotations
from typing import Any
from typing import Optional
from typing import Sequence
from typing import TYPE_CHECKING
from .array import ARRAY
from .types import OID
from .types import REGCLASS
from ... import Column
from ... import func
from ... import MetaData
from ... import Table
from ...types import BigInteger
from ...types import Boolean
from ...types import CHAR
from ...types import Float
from ...types import Integer
from ...types import SmallInteger
from ...types import String
from ...types import Text
from ...types import TypeDecorator
if TYPE_CHECKING:
    from ...engine.interfaces import Dialect
    from ...sql.type_api import _ResultProcessorType
class NAME(TypeDecorator[str]):
    impl = String(64, collation="C")
    cache_ok = True
class PG_NODE_TREE(TypeDecorator[str]):
    impl = Text(collation="C")
    cache_ok = True
class INT2VECTOR(TypeDecorator[Sequence[int]]):
    impl = ARRAY(SmallInteger)
    cache_ok = True
class OIDVECTOR(TypeDecorator[Sequence[int]]):
    impl = ARRAY(OID)
    cache_ok = True
class _SpaceVector:
    def result_processor(
        self, dialect: Dialect, coltype: object
    ) -> _ResultProcessorType[list[int]]:
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/dialects/postgresql/_psycopg_common.py =====
from __future__ import annotations
import decimal
from .array import ARRAY as PGARRAY
from .base import _DECIMAL_TYPES
from .base import _FLOAT_TYPES
from .base import _INT_TYPES
from .base import PGDialect
from .base import PGExecutionContext
from .hstore import HSTORE
from .pg_catalog import _SpaceVector
from .pg_catalog import INT2VECTOR
from .pg_catalog import OIDVECTOR
from ... import exc
from ... import types as sqltypes
from ... import util
from ...engine import processors
_server_side_id = util.counter()
class _PsycopgNumeric(sqltypes.Numeric):
    def bind_processor(self, dialect):
        return None
    def result_processor(self, dialect, coltype):
        if self.asdecimal:
            if coltype in _FLOAT_TYPES:
                return processors.to_decimal_processor_factory(
                    decimal.Decimal, self._effective_decimal_return_scale
                )
            elif coltype in _DECIMAL_TYPES or coltype in _INT_TYPES:
                # psycopg returns Decimal natively for 1700
                return None
            else:
                raise exc.InvalidRequestError(
                    "Unknown PG numeric type: %d" % coltype
                )
        else:
            if coltype in _FLOAT_TYPES:
                # psycopg returns float natively for 701
                return None
            elif coltype in _DECIMAL_TYPES or coltype in _INT_TYPES:
                return processors.to_float
            else:
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py =====
r"""
.. dialect:: postgresql+asyncpg
    :name: asyncpg
    :dbapi: asyncpg
    :connectstring: postgresql+asyncpg://user:password@host:port/dbname[?key=value&key=value...]
    :url: https://magicstack.github.io/asyncpg/
The asyncpg dialect is SQLAlchemy's first Python asyncio dialect.
Using a special asyncio mediation layer, the asyncpg dialect is usable
as the backend for the :ref:`SQLAlchemy asyncio <asyncio_toplevel>`
extension package.
This dialect should normally be used only with the
:func:`_asyncio.create_async_engine` engine creation function::
    from sqlalchemy.ext.asyncio import create_async_engine
    engine = create_async_engine(
        "postgresql+asyncpg://user:pass@hostname/dbname"
    )
.. versionadded:: 1.4
.. note::
    By default asyncpg does not decode the ``json`` and ``jsonb`` types and
    returns them as strings. SQLAlchemy sets default type decoder for ``json``
    and ``jsonb`` types using the python builtin ``json.loads`` function.
    The json implementation used can be changed by setting the attribute
    ``json_deserializer`` when creating the engine with
    :func:`create_engine` or :func:`create_async_engine`.
.. _asyncpg_multihost:
Multihost Connections
--------------------------
The asyncpg dialect features support for multiple fallback hosts in the
same way as that of the psycopg2 and psycopg dialects.  The
syntax is the same,
using ``host=<host>:<port>`` combinations as additional query string arguments;
however, there is no default port, so all hosts must have a complete port number
present, otherwise an exception is raised::
    engine = create_async_engine(
        "postgresql+asyncpg://user:password@/dbname?host=HostA:5432&host=HostB:5432&host=HostC:5432"
    )
For complete background on this syntax, see :ref:`psycopg2_multi_host`.
.. versionadded:: 2.0.18
.. seealso::
    :ref:`psycopg2_multi_host`
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/dialects/postgresql/psycopg2cffi.py =====
r"""
.. dialect:: postgresql+psycopg2cffi
    :name: psycopg2cffi
    :dbapi: psycopg2cffi
    :connectstring: postgresql+psycopg2cffi://user:password@host:port/dbname[?key=value&key=value...]
    :url: https://pypi.org/project/psycopg2cffi/
``psycopg2cffi`` is an adaptation of ``psycopg2``, using CFFI for the C
layer. This makes it suitable for use in e.g. PyPy. Documentation
is as per ``psycopg2``.
.. seealso::
    :mod:`sqlalchemy.dialects.postgresql.psycopg2`
"""  # noqa
from .psycopg2 import PGDialect_psycopg2
from ... import util
class PGDialect_psycopg2cffi(PGDialect_psycopg2):
    driver = "psycopg2cffi"
    supports_unicode_statements = True
    supports_statement_cache = True
    # psycopg2cffi's first release is 2.5.0, but reports
    # __version__ as 2.4.4.  Subsequent releases seem to have
    # fixed this.
    FEATURE_VERSION_MAP = dict(
        native_json=(2, 4, 4),
        native_jsonb=(2, 7, 1),
        sane_multi_rowcount=(2, 4, 4),
        array_oid=(2, 4, 4),
        hstore_adapter=(2, 4, 4),
    )
    @classmethod
    def import_dbapi(cls):
        return __import__("psycopg2cffi")
    @util.memoized_property
    def _psycopg2_extensions(cls):
        root = __import__("psycopg2cffi", fromlist=["extensions"])
        return root.extensions
    @util.memoized_property
    def _psycopg2_extras(cls):
        root = __import__("psycopg2cffi", fromlist=["extras"])
        return root.extras
dialect = PGDialect_psycopg2cffi
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/dialects/postgresql/__init__.py =====
from types import ModuleType
from . import array as arraylib  # noqa # keep above base and other dialects
from . import asyncpg  # noqa
from . import base
from . import pg8000  # noqa
from . import psycopg  # noqa
from . import psycopg2  # noqa
from . import psycopg2cffi  # noqa
from .array import All
from .array import Any
from .array import ARRAY
from .array import array
from .base import BIGINT
from .base import BOOLEAN
from .base import CHAR
from .base import DATE
from .base import DOMAIN
from .base import DOUBLE_PRECISION
from .base import FLOAT
from .base import INTEGER
from .base import NUMERIC
from .base import REAL
from .base import SMALLINT
from .base import TEXT
from .base import UUID
from .base import VARCHAR
from .dml import Insert
from .dml import insert
from .ext import aggregate_order_by
from .ext import array_agg
from .ext import ExcludeConstraint
from .ext import phraseto_tsquery
from .ext import plainto_tsquery
from .ext import to_tsquery
from .ext import to_tsvector
from .ext import ts_headline
from .ext import websearch_to_tsquery
from .hstore import HSTORE
from .hstore import hstore
from .json import JSON
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/dialects/postgresql/psycopg.py =====
r"""
.. dialect:: postgresql+psycopg
    :name: psycopg (a.k.a. psycopg 3)
    :dbapi: psycopg
    :connectstring: postgresql+psycopg://user:password@host:port/dbname[?key=value&key=value...]
    :url: https://pypi.org/project/psycopg/
``psycopg`` is the package and module name for version 3 of the ``psycopg``
database driver, formerly known as ``psycopg2``.  This driver is different
enough from its ``psycopg2`` predecessor that SQLAlchemy supports it
via a totally separate dialect; support for ``psycopg2`` is expected to remain
for as long as that package continues to function for modern Python versions,
and also remains the default dialect for the ``postgresql://`` dialect
series.
The SQLAlchemy ``psycopg`` dialect provides both a sync and an async
implementation under the same dialect name. The proper version is
selected depending on how the engine is created:
* calling :func:`_sa.create_engine` with ``postgresql+psycopg://...`` will
  automatically select the sync version, e.g.::
    from sqlalchemy import create_engine
    sync_engine = create_engine(
        "postgresql+psycopg://scott:tiger@localhost/test"
    )
* calling :func:`_asyncio.create_async_engine` with
  ``postgresql+psycopg://...`` will automatically select the async version,
  e.g.::
    from sqlalchemy.ext.asyncio import create_async_engine
    asyncio_engine = create_async_engine(
        "postgresql+psycopg://scott:tiger@localhost/test"
    )
The asyncio version of the dialect may also be specified explicitly using the
``psycopg_async`` suffix, as::
    from sqlalchemy.ext.asyncio import create_async_engine
    asyncio_engine = create_async_engine(
        "postgresql+psycopg_async://scott:tiger@localhost/test"
    )
.. seealso::
    :ref:`postgresql_psycopg2` - The SQLAlchemy ``psycopg``
    dialect shares most of its behavior with the ``psycopg2`` dialect.
    Further documentation is available there.
Using a different Cursor class
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/dialects/postgresql/types.py =====
from __future__ import annotations
import datetime as dt
from typing import Any
from typing import Optional
from typing import overload
from typing import Type
from typing import TYPE_CHECKING
from uuid import UUID as _python_UUID
from ...sql import sqltypes
from ...sql import type_api
from ...util.typing import Literal
if TYPE_CHECKING:
    from ...engine.interfaces import Dialect
    from ...sql.operators import OperatorType
    from ...sql.type_api import _LiteralProcessorType
    from ...sql.type_api import TypeEngine
_DECIMAL_TYPES = (1231, 1700)
_FLOAT_TYPES = (700, 701, 1021, 1022)
_INT_TYPES = (20, 21, 23, 26, 1005, 1007, 1016)
class PGUuid(sqltypes.UUID[sqltypes._UUID_RETURN]):
    render_bind_cast = True
    render_literal_cast = True
    if TYPE_CHECKING:
        @overload
        def __init__(
            self: PGUuid[_python_UUID], as_uuid: Literal[True] = ...
        ) -> None: ...
        @overload
        def __init__(
            self: PGUuid[str], as_uuid: Literal[False] = ...
        ) -> None: ...
        def __init__(self, as_uuid: bool = True) -> None: ...
class BYTEA(sqltypes.LargeBinary):
    __visit_name__ = "BYTEA"
class _NetworkAddressTypeMixin:
    def coerce_compared_value(
        self, op: Optional[OperatorType], value: Any
    ) -> TypeEngine[Any]:
        if TYPE_CHECKING:
            assert isinstance(self, TypeEngine)
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/dialects/postgresql/ranges.py =====
from __future__ import annotations
import dataclasses
from datetime import date
from datetime import datetime
from datetime import timedelta
from decimal import Decimal
from typing import Any
from typing import cast
from typing import Generic
from typing import List
from typing import Optional
from typing import overload
from typing import Sequence
from typing import Tuple
from typing import Type
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union
from .operators import ADJACENT_TO
from .operators import CONTAINED_BY
from .operators import CONTAINS
from .operators import NOT_EXTEND_LEFT_OF
from .operators import NOT_EXTEND_RIGHT_OF
from .operators import OVERLAP
from .operators import STRICTLY_LEFT_OF
from .operators import STRICTLY_RIGHT_OF
from ... import types as sqltypes
from ...sql import operators
from ...sql.type_api import TypeEngine
from ...util import py310
from ...util.typing import Literal
if TYPE_CHECKING:
    from ...sql.elements import ColumnElement
    from ...sql.type_api import _TE
    from ...sql.type_api import TypeEngineMixin
_T = TypeVar("_T", bound=Any)
_BoundsType = Literal["()", "[)", "(]", "[]"]
if py310:
    dc_slots = {"slots": True}
    dc_kwonly = {"kw_only": True}
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/dialects/postgresql/psycopg2.py =====
r"""
.. dialect:: postgresql+psycopg2
    :name: psycopg2
    :dbapi: psycopg2
    :connectstring: postgresql+psycopg2://user:password@host:port/dbname[?key=value&key=value...]
    :url: https://pypi.org/project/psycopg2/
.. _psycopg2_toplevel:
psycopg2 Connect Arguments
--------------------------
Keyword arguments that are specific to the SQLAlchemy psycopg2 dialect
may be passed to :func:`_sa.create_engine()`, and include the following:
* ``isolation_level``: This option, available for all PostgreSQL dialects,
  includes the ``AUTOCOMMIT`` isolation level when using the psycopg2
  dialect.   This option sets the **default** isolation level for the
  connection that is set immediately upon connection to the database before
  the connection is pooled.  This option is generally superseded by the more
  modern :paramref:`_engine.Connection.execution_options.isolation_level`
  execution option, detailed at :ref:`dbapi_autocommit`.
  .. seealso::
    :ref:`psycopg2_isolation_level`
    :ref:`dbapi_autocommit`
* ``client_encoding``: sets the client encoding in a libpq-agnostic way,
  using psycopg2's ``set_client_encoding()`` method.
  .. seealso::
    :ref:`psycopg2_unicode`
* ``executemany_mode``, ``executemany_batch_page_size``,
  ``executemany_values_page_size``: Allows use of psycopg2
  extensions for optimizing "executemany"-style queries.  See the referenced
  section below for details.
  .. seealso::
    :ref:`psycopg2_executemany_mode`
.. tip::
    The above keyword arguments are **dialect** keyword arguments, meaning
    that they are passed as explicit keyword arguments to :func:`_sa.create_engine()`::
        engine = create_engine(
            "postgresql+psycopg2://scott:tiger@localhost/test",
            isolation_level="SERIALIZABLE",
        )
    These should not be confused with **DBAPI** connect arguments, which
    are passed as part of the :paramref:`_sa.create_engine.connect_args`
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/dialects/postgresql/provision.py =====
import time
from ... import exc
from ... import inspect
from ... import text
from ...testing import warn_test_suite
from ...testing.provision import create_db
from ...testing.provision import drop_all_schema_objects_post_tables
from ...testing.provision import drop_all_schema_objects_pre_tables
from ...testing.provision import drop_db
from ...testing.provision import log
from ...testing.provision import post_configure_engine
from ...testing.provision import prepare_for_drop_tables
from ...testing.provision import set_default_schema_on_connection
from ...testing.provision import temp_table_keyword_args
from ...testing.provision import upsert
@create_db.for_db("postgresql")
def _pg_create_db(cfg, eng, ident):
    template_db = cfg.options.postgresql_templatedb
    with eng.execution_options(isolation_level="AUTOCOMMIT").begin() as conn:
        if not template_db:
            template_db = conn.exec_driver_sql(
                "select current_database()"
            ).scalar()
        attempt = 0
        while True:
            try:
                conn.exec_driver_sql(
                    "CREATE DATABASE %s TEMPLATE %s" % (ident, template_db)
                )
            except exc.OperationalError as err:
                attempt += 1
                if attempt >= 3:
                    raise
                if "accessed by other users" in str(err):
                    log.info(
                        "Waiting to create %s, URI %r, "
                        "template DB %s is in use sleeping for .5",
                        ident,
                        eng.url,
                        template_db,
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/dialects/postgresql/pg8000.py =====
r"""
.. dialect:: postgresql+pg8000
    :name: pg8000
    :dbapi: pg8000
    :connectstring: postgresql+pg8000://user:password@host:port/dbname[?key=value&key=value...]
    :url: https://pypi.org/project/pg8000/
.. versionchanged:: 1.4  The pg8000 dialect has been updated for version
   1.16.6 and higher, and is again part of SQLAlchemy's continuous integration
   with full feature support.
.. _pg8000_unicode:
Unicode
-------
pg8000 will encode / decode string values between it and the server using the
PostgreSQL ``client_encoding`` parameter; by default this is the value in
the ``postgresql.conf`` file, which often defaults to ``SQL_ASCII``.
Typically, this can be changed to ``utf-8``, as a more useful default::
    # client_encoding = sql_ascii # actually, defaults to database encoding
    client_encoding = utf8
The ``client_encoding`` can be overridden for a session by executing the SQL:
.. sourcecode:: sql
    SET CLIENT_ENCODING TO 'utf8';
SQLAlchemy will execute this SQL on all new connections based on the value
passed to :func:`_sa.create_engine` using the ``client_encoding`` parameter::
    engine = create_engine(
        "postgresql+pg8000://user:pass@host/dbname", client_encoding="utf8"
    )
.. _pg8000_ssl:
SSL Connections
---------------
pg8000 accepts a Python ``SSLContext`` object which may be specified using the
:paramref:`_sa.create_engine.connect_args` dictionary::
    import ssl
    ssl_context = ssl.create_default_context()
    engine = sa.create_engine(
        "postgresql+pg8000://scott:tiger@192.168.0.199/test",
        connect_args={"ssl_context": ssl_context},
    )
If the server uses an automatically-generated certificate that is self-signed
or does not match the host name (as seen from the client), it may also be
necessary to disable hostname checking::
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/dialects/postgresql/operators.py =====
from ...sql import operators
_getitem_precedence = operators._PRECEDENCE[operators.json_getitem_op]
_eq_precedence = operators._PRECEDENCE[operators.eq]
ASTEXT = operators.custom_op(
    "->>",
    precedence=_getitem_precedence,
    natural_self_precedent=True,
    eager_grouping=True,
)
JSONPATH_ASTEXT = operators.custom_op(
    "#>>",
    precedence=_getitem_precedence,
    natural_self_precedent=True,
    eager_grouping=True,
)
HAS_KEY = operators.custom_op(
    "?",
    precedence=_eq_precedence,
    natural_self_precedent=True,
    eager_grouping=True,
    is_comparison=True,
)
HAS_ALL = operators.custom_op(
    "?&",
    precedence=_eq_precedence,
    natural_self_precedent=True,
    eager_grouping=True,
    is_comparison=True,
)
HAS_ANY = operators.custom_op(
    "?|",
    precedence=_eq_precedence,
    natural_self_precedent=True,
    eager_grouping=True,
    is_comparison=True,
)
DELETE_PATH = operators.custom_op(
    "#-",
    precedence=_getitem_precedence,
    natural_self_precedent=True,
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/dialects/postgresql/array.py =====
from __future__ import annotations
import re
from typing import Any as typing_Any
from typing import Iterable
from typing import Optional
from typing import Sequence
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union
from .operators import CONTAINED_BY
from .operators import CONTAINS
from .operators import OVERLAP
from ... import types as sqltypes
from ... import util
from ...sql import expression
from ...sql import operators
from ...sql.visitors import InternalTraversal
if TYPE_CHECKING:
    from ...engine.interfaces import Dialect
    from ...sql._typing import _ColumnExpressionArgument
    from ...sql._typing import _TypeEngineArgument
    from ...sql.elements import ColumnElement
    from ...sql.elements import Grouping
    from ...sql.expression import BindParameter
    from ...sql.operators import OperatorType
    from ...sql.selectable import _SelectIterable
    from ...sql.type_api import _BindProcessorType
    from ...sql.type_api import _LiteralProcessorType
    from ...sql.type_api import _ResultProcessorType
    from ...sql.type_api import TypeEngine
    from ...sql.visitors import _TraverseInternalsType
    from ...util.typing import Self
_T = TypeVar("_T", bound=typing_Any)
def Any(
    other: typing_Any,
    arrexpr: _ColumnExpressionArgument[_T],
    operator: OperatorType = operators.eq,
) -> ColumnElement[bool]:
    """A synonym for the ARRAY-level :meth:`.ARRAY.Comparator.any` method.
    See that method for details.
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/dialects/postgresql/dml.py =====
from __future__ import annotations
from typing import Any
from typing import List
from typing import Optional
from typing import Tuple
from typing import Union
from . import ext
from .._typing import _OnConflictConstraintT
from .._typing import _OnConflictIndexElementsT
from .._typing import _OnConflictIndexWhereT
from .._typing import _OnConflictSetT
from .._typing import _OnConflictWhereT
from ... import util
from ...sql import coercions
from ...sql import roles
from ...sql import schema
from ...sql._typing import _DMLTableArgument
from ...sql.base import _exclusive_against
from ...sql.base import _generative
from ...sql.base import ColumnCollection
from ...sql.base import ReadOnlyColumnCollection
from ...sql.dml import Insert as StandardInsert
from ...sql.elements import ClauseElement
from ...sql.elements import ColumnElement
from ...sql.elements import KeyedColumnElement
from ...sql.elements import TextClause
from ...sql.expression import alias
from ...util.typing import Self
__all__ = ("Insert", "insert")
def insert(table: _DMLTableArgument) -> Insert:
    """Construct a PostgreSQL-specific variant :class:`_postgresql.Insert`
    construct.
    .. container:: inherited_member
        The :func:`sqlalchemy.dialects.postgresql.insert` function creates
        a :class:`sqlalchemy.dialects.postgresql.Insert`.  This class is based
        on the dialect-agnostic :class:`_sql.Insert` construct which may
        be constructed using the :func:`_sql.insert` function in
        SQLAlchemy Core.
    The :class:`_postgresql.Insert` construct includes additional methods
    :meth:`_postgresql.Insert.on_conflict_do_update`,
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/dialects/postgresql/json.py =====
from __future__ import annotations
from typing import Any
from typing import Callable
from typing import List
from typing import Optional
from typing import TYPE_CHECKING
from typing import Union
from .array import ARRAY
from .array import array as _pg_array
from .operators import ASTEXT
from .operators import CONTAINED_BY
from .operators import CONTAINS
from .operators import DELETE_PATH
from .operators import HAS_ALL
from .operators import HAS_ANY
from .operators import HAS_KEY
from .operators import JSONPATH_ASTEXT
from .operators import PATH_EXISTS
from .operators import PATH_MATCH
from ... import types as sqltypes
from ...sql import cast
from ...sql._typing import _T
if TYPE_CHECKING:
    from ...engine.interfaces import Dialect
    from ...sql.elements import ColumnElement
    from ...sql.type_api import _BindProcessorType
    from ...sql.type_api import _LiteralProcessorType
    from ...sql.type_api import TypeEngine
__all__ = ("JSON", "JSONB")
class JSONPathType(sqltypes.JSON.JSONPathType):
    def _processor(
        self, dialect: Dialect, super_proc: Optional[Callable[[Any], Any]]
    ) -> Callable[[Any], Any]:
        def process(value: Any) -> Any:
            if isinstance(value, str):
                # If it's already a string assume that it's in json path
                # format. This allows using cast with json paths literals
                return value
            elif value:
                # If it's already a string assume that it's in json path
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/dialects/postgresql/named_types.py =====
from __future__ import annotations
from types import ModuleType
from typing import Any
from typing import Dict
from typing import Optional
from typing import Type
from typing import TYPE_CHECKING
from typing import Union
from ... import schema
from ... import util
from ...sql import coercions
from ...sql import elements
from ...sql import roles
from ...sql import sqltypes
from ...sql import type_api
from ...sql.base import _NoArg
from ...sql.ddl import InvokeCreateDDLBase
from ...sql.ddl import InvokeDropDDLBase
if TYPE_CHECKING:
    from ...sql._typing import _CreateDropBind
    from ...sql._typing import _TypeEngineArgument
class NamedType(schema.SchemaVisitable, sqltypes.TypeEngine):
    """Base for named types."""
    __abstract__ = True
    DDLGenerator: Type[NamedTypeGenerator]
    DDLDropper: Type[NamedTypeDropper]
    create_type: bool
    def create(
        self, bind: _CreateDropBind, checkfirst: bool = True, **kw: Any
    ) -> None:
        """Emit ``CREATE`` DDL for this type.
        :param bind: a connectable :class:`_engine.Engine`,
         :class:`_engine.Connection`, or similar object to emit
         SQL.
        :param checkfirst: if ``True``, a query against
         the PG catalog will be first performed to see
         if the type does not exist already before
         creating.
        """
        bind._run_ddl_visitor(self.DDLGenerator, self, checkfirst=checkfirst)
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/dialects/postgresql/base.py =====
r"""
.. dialect:: postgresql
    :name: PostgreSQL
    :normal_support: 9.6+
    :best_effort: 9+
.. _postgresql_sequences:
Sequences/SERIAL/IDENTITY
-------------------------
PostgreSQL supports sequences, and SQLAlchemy uses these as the default means
of creating new primary key values for integer-based primary key columns. When
creating tables, SQLAlchemy will issue the ``SERIAL`` datatype for
integer-based primary key columns, which generates a sequence and server side
default corresponding to the column.
To specify a specific named sequence to be used for primary key generation,
use the :func:`~sqlalchemy.schema.Sequence` construct::
    Table(
        "sometable",
        metadata,
        Column(
            "id", Integer, Sequence("some_id_seq", start=1), primary_key=True
        ),
    )
When SQLAlchemy issues a single INSERT statement, to fulfill the contract of
having the "last insert identifier" available, a RETURNING clause is added to
the INSERT statement which specifies the primary key columns should be
returned after the statement completes. The RETURNING functionality only takes
place if PostgreSQL 8.2 or later is in use. As a fallback approach, the
sequence, whether specified explicitly or implicitly via ``SERIAL``, is
executed independently beforehand, the returned value to be used in the
subsequent insert. Note that when an
:func:`~sqlalchemy.sql.expression.insert()` construct is executed using
"executemany" semantics, the "last inserted identifier" functionality does not
apply; no RETURNING clause is emitted nor is the sequence pre-executed in this
case.
PostgreSQL 10 and above IDENTITY columns
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
PostgreSQL 10 and above have a new IDENTITY feature that supersedes the use
of SERIAL. The :class:`_schema.Identity` construct in a
:class:`_schema.Column` can be used to control its behavior::
    from sqlalchemy import Table, Column, MetaData, Integer, Computed
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/dialects/postgresql/ext.py =====
from __future__ import annotations
from typing import Any
from typing import Iterable
from typing import List
from typing import Optional
from typing import overload
from typing import TYPE_CHECKING
from typing import TypeVar
from . import types
from .array import ARRAY
from ...sql import coercions
from ...sql import elements
from ...sql import expression
from ...sql import functions
from ...sql import roles
from ...sql import schema
from ...sql.schema import ColumnCollectionConstraint
from ...sql.sqltypes import TEXT
from ...sql.visitors import InternalTraversal
if TYPE_CHECKING:
    from ...sql._typing import _ColumnExpressionArgument
    from ...sql.elements import ClauseElement
    from ...sql.elements import ColumnElement
    from ...sql.operators import OperatorType
    from ...sql.selectable import FromClause
    from ...sql.visitors import _CloneCallableType
    from ...sql.visitors import _TraverseInternalsType
_T = TypeVar("_T", bound=Any)
class aggregate_order_by(expression.ColumnElement[_T]):
    """Represent a PostgreSQL aggregate order by expression.
    E.g.::
        from sqlalchemy.dialects.postgresql import aggregate_order_by
        expr = func.array_agg(aggregate_order_by(table.c.a, table.c.b.desc()))
        stmt = select(expr)
    would represent the expression:
    .. sourcecode:: sql
        SELECT array_agg(a ORDER BY b DESC) FROM table;
    Similarly::
        expr = func.string_agg(
            table.c.a, aggregate_order_by(literal_column("','"), table.c.a)
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/dialects/postgresql/hstore.py =====
import re
from .array import ARRAY
from .operators import CONTAINED_BY
from .operators import CONTAINS
from .operators import GETITEM
from .operators import HAS_ALL
from .operators import HAS_ANY
from .operators import HAS_KEY
from ... import types as sqltypes
from ...sql import functions as sqlfunc
__all__ = ("HSTORE", "hstore")
class HSTORE(sqltypes.Indexable, sqltypes.Concatenable, sqltypes.TypeEngine):
    """Represent the PostgreSQL HSTORE type.
    The :class:`.HSTORE` type stores dictionaries containing strings, e.g.::
        data_table = Table(
            "data_table",
            metadata,
            Column("id", Integer, primary_key=True),
            Column("data", HSTORE),
        )
        with engine.connect() as conn:
            conn.execute(
                data_table.insert(), data={"key1": "value1", "key2": "value2"}
            )
    :class:`.HSTORE` provides for a wide range of operations, including:
    * Index operations::
        data_table.c.data["some key"] == "some value"
    * Containment operations::
        data_table.c.data.has_key("some key")
        data_table.c.data.has_all(["one", "two", "three"])
    * Concatenation::
        data_table.c.data + {"k1": "v1"}
    For a full list of special methods see
    :class:`.HSTORE.comparator_factory`.
    .. container:: topic
        **Detecting Changes in HSTORE columns when using the ORM**
        For usage with the SQLAlchemy ORM, it may be desirable to combine the
        usage of :class:`.HSTORE` with :class:`.MutableDict` dictionary now
        part of the :mod:`sqlalchemy.ext.mutable` extension. This extension
        will allow "in-place" changes to the dictionary, e.g. addition of new
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/dialects/_typing.py =====
from __future__ import annotations
from typing import Any
from typing import Iterable
from typing import Mapping
from typing import Optional
from typing import Union
from ..sql import roles
from ..sql.base import ColumnCollection
from ..sql.schema import Column
from ..sql.schema import ColumnCollectionConstraint
from ..sql.schema import Index
_OnConflictConstraintT = Union[str, ColumnCollectionConstraint, Index, None]
_OnConflictIndexElementsT = Optional[
    Iterable[Union[Column[Any], str, roles.DDLConstraintColumnRole]]
]
_OnConflictIndexWhereT = Optional[roles.WhereHavingRole]
_OnConflictSetT = Optional[
    Union[Mapping[Any, Any], ColumnCollection[Any, Any]]
]
_OnConflictWhereT = Optional[roles.WhereHavingRole]
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/dialects/oracle/vector.py =====
from __future__ import annotations
import array
from dataclasses import dataclass
from enum import Enum
from typing import Optional
from typing import Union
import sqlalchemy.types as types
from sqlalchemy.types import Float
class VectorIndexType(Enum):
    """Enum representing different types of VECTOR index structures.
    See :ref:`oracle_vector_datatype` for background.
    .. versionadded:: 2.0.41
    """
    HNSW = "HNSW"
    """
    The HNSW (Hierarchical Navigable Small World) index type.
    """
    IVF = "IVF"
    """
    The IVF (Inverted File Index) index type
    """
class VectorDistanceType(Enum):
    """Enum representing different types of vector distance metrics.
    See :ref:`oracle_vector_datatype` for background.
    .. versionadded:: 2.0.41
    """
    EUCLIDEAN = "EUCLIDEAN"
    """Euclidean distance (L2 norm).
    Measures the straight-line distance between two vectors in space.
    """
    DOT = "DOT"
    """Dot product similarity.
    Measures the algebraic similarity between two vectors.
    """
    COSINE = "COSINE"
    """Cosine similarity.
    Measures the cosine of the angle between two vectors.
    """
    MANHATTAN = "MANHATTAN"
    """Manhattan distance (L1 norm).
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/dialects/oracle/__init__.py =====
from types import ModuleType
from . import base  # noqa
from . import cx_oracle  # noqa
from . import oracledb  # noqa
from .base import BFILE
from .base import BINARY_DOUBLE
from .base import BINARY_FLOAT
from .base import BLOB
from .base import CHAR
from .base import CLOB
from .base import DATE
from .base import DOUBLE_PRECISION
from .base import FLOAT
from .base import INTERVAL
from .base import LONG
from .base import NCHAR
from .base import NCLOB
from .base import NUMBER
from .base import NVARCHAR
from .base import NVARCHAR2
from .base import RAW
from .base import REAL
from .base import ROWID
from .base import TIMESTAMP
from .base import VARCHAR
from .base import VARCHAR2
from .base import VECTOR
from .base import VectorIndexConfig
from .base import VectorIndexType
from .vector import SparseVector
from .vector import VectorDistanceType
from .vector import VectorStorageFormat
from .vector import VectorStorageType
oracledb_async = type(
    "oracledb_async", (ModuleType,), {"dialect": oracledb.dialect_async}
)
base.dialect = dialect = cx_oracle.dialect
__all__ = (
    "VARCHAR",
    "NVARCHAR",
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/dialects/oracle/types.py =====
from __future__ import annotations
import datetime as dt
from typing import Optional
from typing import Type
from typing import TYPE_CHECKING
from ... import exc
from ...sql import sqltypes
from ...types import NVARCHAR
from ...types import VARCHAR
if TYPE_CHECKING:
    from ...engine.interfaces import Dialect
    from ...sql.type_api import _LiteralProcessorType
class RAW(sqltypes._Binary):
    __visit_name__ = "RAW"
OracleRaw = RAW
class NCLOB(sqltypes.Text):
    __visit_name__ = "NCLOB"
class VARCHAR2(VARCHAR):
    __visit_name__ = "VARCHAR2"
NVARCHAR2 = NVARCHAR
class NUMBER(sqltypes.Numeric, sqltypes.Integer):
    __visit_name__ = "NUMBER"
    def __init__(self, precision=None, scale=None, asdecimal=None):
        if asdecimal is None:
            asdecimal = bool(scale and scale > 0)
        super().__init__(precision=precision, scale=scale, asdecimal=asdecimal)
    def adapt(self, impltype):
        ret = super().adapt(impltype)
        # leave a hint for the DBAPI handler
        ret._is_oracle_number = True
        return ret
    @property
    def _type_affinity(self):
        if bool(self.scale and self.scale > 0):
            return sqltypes.Numeric
        else:
            return sqltypes.Integer
class FLOAT(sqltypes.FLOAT):
    """Oracle Database FLOAT.
    This is the same as :class:`_sqltypes.FLOAT` except that
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/dialects/oracle/oracledb.py =====
r""".. dialect:: oracle+oracledb
    :name: python-oracledb
    :dbapi: oracledb
    :connectstring: oracle+oracledb://user:pass@hostname:port[/dbname][?service_name=<service>[&key=value&key=value...]]
    :url: https://oracle.github.io/python-oracledb/
Description
-----------
Python-oracledb is the Oracle Database driver for Python. It features a default
"thin" client mode that requires no dependencies, and an optional "thick" mode
that uses Oracle Client libraries.  It supports SQLAlchemy features including
two phase transactions and Asyncio.
Python-oracle is the renamed, updated cx_Oracle driver. Oracle is no longer
doing any releases in the cx_Oracle namespace.
The SQLAlchemy ``oracledb`` dialect provides both a sync and an async
implementation under the same dialect name. The proper version is
selected depending on how the engine is created:
* calling :func:`_sa.create_engine` with ``oracle+oracledb://...`` will
  automatically select the sync version::
    from sqlalchemy import create_engine
    sync_engine = create_engine(
        "oracle+oracledb://scott:tiger@localhost?service_name=FREEPDB1"
    )
* calling :func:`_asyncio.create_async_engine` with ``oracle+oracledb://...``
  will automatically select the async version::
    from sqlalchemy.ext.asyncio import create_async_engine
    asyncio_engine = create_async_engine(
        "oracle+oracledb://scott:tiger@localhost?service_name=FREEPDB1"
    )
  The asyncio version of the dialect may also be specified explicitly using the
  ``oracledb_async`` suffix::
      from sqlalchemy.ext.asyncio import create_async_engine
      asyncio_engine = create_async_engine(
          "oracle+oracledb_async://scott:tiger@localhost?service_name=FREEPDB1"
      )
.. versionadded:: 2.0.25 added support for the async version of oracledb.
Thick mode support
------------------
By default, the python-oracledb driver runs in a "thin" mode that does not
require Oracle Client libraries to be installed. The driver also supports a
"thick" mode that uses Oracle Client libraries to get functionality such as
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/dialects/oracle/provision.py =====
from ... import create_engine
from ... import exc
from ... import inspect
from ...engine import url as sa_url
from ...testing.provision import configure_follower
from ...testing.provision import create_db
from ...testing.provision import drop_all_schema_objects_post_tables
from ...testing.provision import drop_all_schema_objects_pre_tables
from ...testing.provision import drop_db
from ...testing.provision import follower_url_from_main
from ...testing.provision import log
from ...testing.provision import post_configure_engine
from ...testing.provision import run_reap_dbs
from ...testing.provision import set_default_schema_on_connection
from ...testing.provision import stop_test_class_outside_fixtures
from ...testing.provision import temp_table_keyword_args
from ...testing.provision import update_db_opts
@create_db.for_db("oracle")
def _oracle_create_db(cfg, eng, ident):
    # NOTE: make sure you've run "ALTER DATABASE default tablespace users" or
    # similar, so that the default tablespace is not "system"; reflection will
    # fail otherwise
    with eng.begin() as conn:
        conn.exec_driver_sql("create user %s identified by xe" % ident)
        conn.exec_driver_sql("create user %s_ts1 identified by xe" % ident)
        conn.exec_driver_sql("create user %s_ts2 identified by xe" % ident)
        conn.exec_driver_sql("grant dba to %s" % (ident,))
        conn.exec_driver_sql("grant unlimited tablespace to %s" % ident)
        conn.exec_driver_sql("grant unlimited tablespace to %s_ts1" % ident)
        conn.exec_driver_sql("grant unlimited tablespace to %s_ts2" % ident)
        # these are needed to create materialized views
        conn.exec_driver_sql("grant create table to %s" % ident)
        conn.exec_driver_sql("grant create table to %s_ts1" % ident)
        conn.exec_driver_sql("grant create table to %s_ts2" % ident)
@configure_follower.for_db("oracle")
def _oracle_configure_follower(config, ident):
    config.test_schema = "%s_ts1" % ident
    config.test_schema_2 = "%s_ts2" % ident
def _ora_drop_ignore(conn, dbname):
    try:
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/dialects/oracle/cx_oracle.py =====
r""".. dialect:: oracle+cx_oracle
    :name: cx-Oracle
    :dbapi: cx_oracle
    :connectstring: oracle+cx_oracle://user:pass@hostname:port[/dbname][?service_name=<service>[&key=value&key=value...]]
    :url: https://oracle.github.io/python-cx_Oracle/
Description
-----------
cx_Oracle was the original driver for Oracle Database. It was superseded by
python-oracledb which should be used instead.
DSN vs. Hostname connections
-----------------------------
cx_Oracle provides several methods of indicating the target database.  The
dialect translates from a series of different URL forms.
Hostname Connections with Easy Connect Syntax
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Given a hostname, port and service name of the target database, for example
from Oracle Database's Easy Connect syntax then connect in SQLAlchemy using the
``service_name`` query string parameter::
    engine = create_engine(
        "oracle+cx_oracle://scott:tiger@hostname:port?service_name=myservice&encoding=UTF-8&nencoding=UTF-8"
    )
Note that the default driver value for encoding and nencoding was changed to
“UTF-8” in cx_Oracle 8.0 so these parameters can be omitted when using that
version, or later.
To use a full Easy Connect string, pass it as the ``dsn`` key value in a
:paramref:`_sa.create_engine.connect_args` dictionary::
    import cx_Oracle
    e = create_engine(
        "oracle+cx_oracle://@",
        connect_args={
            "user": "scott",
            "password": "tiger",
            "dsn": "hostname:port/myservice?transport_connect_timeout=30&expire_time=60",
        },
    )
Connections with tnsnames.ora or to Oracle Autonomous Database
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Alternatively, if no port, database name, or service name is provided, the
dialect will use an Oracle Database DSN "connection string".  This takes the
"hostname" portion of the URL as the data source name.  For example, if the
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/dialects/oracle/dictionary.py =====
from .types import DATE
from .types import LONG
from .types import NUMBER
from .types import RAW
from .types import VARCHAR2
from ... import Column
from ... import MetaData
from ... import Table
from ... import table
from ...sql.sqltypes import CHAR
DB_LINK_PLACEHOLDER = "__$sa_dblink$__"
dual = table("dual")
dictionary_meta = MetaData()
all_tables = Table(
    "all_tables" + DB_LINK_PLACEHOLDER,
    dictionary_meta,
    Column("owner", VARCHAR2(128), nullable=False),
    Column("table_name", VARCHAR2(128), nullable=False),
    Column("tablespace_name", VARCHAR2(30)),
    Column("cluster_name", VARCHAR2(128)),
    Column("iot_name", VARCHAR2(128)),
    Column("status", VARCHAR2(8)),
    Column("pct_free", NUMBER),
    Column("pct_used", NUMBER),
    Column("ini_trans", NUMBER),
    Column("max_trans", NUMBER),
    Column("initial_extent", NUMBER),
    Column("next_extent", NUMBER),
    Column("min_extents", NUMBER),
    Column("max_extents", NUMBER),
    Column("pct_increase", NUMBER),
    Column("freelists", NUMBER),
    Column("freelist_groups", NUMBER),
    Column("logging", VARCHAR2(3)),
    Column("backed_up", VARCHAR2(1)),
    Column("num_rows", NUMBER),
    Column("blocks", NUMBER),
    Column("empty_blocks", NUMBER),
    Column("avg_space", NUMBER),
    Column("chain_cnt", NUMBER),
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/dialects/oracle/base.py =====
r"""
.. dialect:: oracle
    :name: Oracle Database
    :normal_support: 11+
    :best_effort: 9+
Auto Increment Behavior
-----------------------
SQLAlchemy Table objects which include integer primary keys are usually assumed
to have "autoincrementing" behavior, meaning they can generate their own
primary key values upon INSERT. For use within Oracle Database, two options are
available, which are the use of IDENTITY columns (Oracle Database 12 and above
only) or the association of a SEQUENCE with the column.
Specifying GENERATED AS IDENTITY (Oracle Database 12 and above)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Starting from version 12, Oracle Database can make use of identity columns
using the :class:`_sql.Identity` to specify the autoincrementing behavior::
    t = Table(
        "mytable",
        metadata,
        Column("id", Integer, Identity(start=3), primary_key=True),
        Column(...),
        ...,
    )
The CREATE TABLE for the above :class:`_schema.Table` object would be:
.. sourcecode:: sql
    CREATE TABLE mytable (
        id INTEGER GENERATED BY DEFAULT AS IDENTITY (START WITH 3),
        ...,
        PRIMARY KEY (id)
    )
The :class:`_schema.Identity` object support many options to control the
"autoincrementing" behavior of the column, like the starting value, the
incrementing value, etc.  In addition to the standard options, Oracle Database
supports setting :paramref:`_schema.Identity.always` to ``None`` to use the
default generated mode, rendering GENERATED AS IDENTITY in the DDL. It also supports
setting :paramref:`_schema.Identity.on_null` to ``True`` to specify ON NULL
in conjunction with a 'BY DEFAULT' identity column.
Using a SEQUENCE (all Oracle Database versions)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Older version of Oracle Database had no "autoincrement" feature: SQLAlchemy
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/dialects/__init__.py =====
from __future__ import annotations
from typing import Any
from typing import Callable
from typing import Optional
from typing import Type
from typing import TYPE_CHECKING
from .. import util
if TYPE_CHECKING:
    from ..engine.interfaces import Dialect
__all__ = ("mssql", "mysql", "oracle", "postgresql", "sqlite")
def _auto_fn(name: str) -> Optional[Callable[[], Type[Dialect]]]:
    """default dialect importer.
    plugs into the :class:`.PluginLoader`
    as a first-hit system.
    """
    if "." in name:
        dialect, driver = name.split(".")
    else:
        dialect = name
        driver = "base"
    try:
        if dialect == "mariadb":
            # it's "OK" for us to hardcode here since _auto_fn is already
            # hardcoded.   if mysql / mariadb etc were third party dialects
            # they would just publish all the entrypoints, which would actually
            # look much nicer.
            module: Any = __import__(
                "sqlalchemy.dialects.mysql.mariadb"
            ).dialects.mysql.mariadb
            return module.loader(driver)  # type: ignore
        else:
            module = __import__("sqlalchemy.dialects.%s" % (dialect,)).dialects
            module = getattr(module, dialect)
    except ImportError:
        return None
    if hasattr(module, driver):
        module = getattr(module, driver)
        return lambda: module.dialect
    else:
        return None
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/dialects/sqlite/aiosqlite.py =====
r"""
.. dialect:: sqlite+aiosqlite
    :name: aiosqlite
    :dbapi: aiosqlite
    :connectstring: sqlite+aiosqlite:///file_path
    :url: https://pypi.org/project/aiosqlite/
The aiosqlite dialect provides support for the SQLAlchemy asyncio interface
running on top of pysqlite.
aiosqlite is a wrapper around pysqlite that uses a background thread for
each connection.   It does not actually use non-blocking IO, as SQLite
databases are not socket-based.  However it does provide a working asyncio
interface that's useful for testing and prototyping purposes.
Using a special asyncio mediation layer, the aiosqlite dialect is usable
as the backend for the :ref:`SQLAlchemy asyncio <asyncio_toplevel>`
extension package.
This dialect should normally be used only with the
:func:`_asyncio.create_async_engine` engine creation function::
    from sqlalchemy.ext.asyncio import create_async_engine
    engine = create_async_engine("sqlite+aiosqlite:///filename")
The URL passes through all arguments to the ``pysqlite`` driver, so all
connection arguments are the same as they are for that of :ref:`pysqlite`.
.. _aiosqlite_udfs:
User-Defined Functions
----------------------
aiosqlite extends pysqlite to support async, so we can create our own user-defined functions (UDFs)
in Python and use them directly in SQLite queries as described here: :ref:`pysqlite_udfs`.
.. _aiosqlite_serializable:
Serializable isolation / Savepoints / Transactional DDL (asyncio version)
-------------------------------------------------------------------------
A newly revised version of this important section is now available
at the top level of the SQLAlchemy SQLite documentation, in the section
:ref:`sqlite_transactions`.
.. _aiosqlite_pooling:
Pooling Behavior
----------------
The SQLAlchemy ``aiosqlite`` DBAPI establishes the connection pool differently
based on the kind of SQLite database that's requested:
* When a ``:memory:`` SQLite database is specified, the dialect by default
  will use :class:`.StaticPool`. This pool maintains a single
  connection, so that all access to the engine
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/dialects/sqlite/pysqlcipher.py =====
"""
.. dialect:: sqlite+pysqlcipher
    :name: pysqlcipher
    :dbapi: sqlcipher 3 or pysqlcipher
    :connectstring: sqlite+pysqlcipher://:passphrase@/file_path[?kdf_iter=<iter>]
    Dialect for support of DBAPIs that make use of the
    `SQLCipher <https://www.zetetic.net/sqlcipher>`_ backend.
Driver
------
Current dialect selection logic is:
* If the :paramref:`_sa.create_engine.module` parameter supplies a DBAPI module,
  that module is used.
* Otherwise for Python 3, choose https://pypi.org/project/sqlcipher3/
* If not available, fall back to https://pypi.org/project/pysqlcipher3/
* For Python 2, https://pypi.org/project/pysqlcipher/ is used.
.. warning:: The ``pysqlcipher3`` and ``pysqlcipher`` DBAPI drivers are no
   longer maintained; the ``sqlcipher3`` driver as of this writing appears
   to be current.  For future compatibility, any pysqlcipher-compatible DBAPI
   may be used as follows::
        import sqlcipher_compatible_driver
        from sqlalchemy import create_engine
        e = create_engine(
            "sqlite+pysqlcipher://:password@/dbname.db",
            module=sqlcipher_compatible_driver,
        )
These drivers make use of the SQLCipher engine. This system essentially
introduces new PRAGMA commands to SQLite which allows the setting of a
passphrase and other encryption parameters, allowing the database file to be
encrypted.
Connect Strings
---------------
The format of the connect string is in every way the same as that
of the :mod:`~sqlalchemy.dialects.sqlite.pysqlite` driver, except that the
"password" field is now accepted, which should contain a passphrase::
    e = create_engine("sqlite+pysqlcipher://:testing@/foo.db")
For an absolute file path, two leading slashes should be used for the
database name::
    e = create_engine("sqlite+pysqlcipher://:testing@//path/to/foo.db")
A selection of additional encryption-related pragmas supported by SQLCipher
as documented at https://www.zetetic.net/sqlcipher/sqlcipher-api/ can be passed
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/dialects/sqlite/__init__.py =====
from . import aiosqlite  # noqa
from . import base  # noqa
from . import pysqlcipher  # noqa
from . import pysqlite  # noqa
from .base import BLOB
from .base import BOOLEAN
from .base import CHAR
from .base import DATE
from .base import DATETIME
from .base import DECIMAL
from .base import FLOAT
from .base import INTEGER
from .base import JSON
from .base import NUMERIC
from .base import REAL
from .base import SMALLINT
from .base import TEXT
from .base import TIME
from .base import TIMESTAMP
from .base import VARCHAR
from .dml import Insert
from .dml import insert
base.dialect = dialect = pysqlite.dialect
__all__ = (
    "BLOB",
    "BOOLEAN",
    "CHAR",
    "DATE",
    "DATETIME",
    "DECIMAL",
    "FLOAT",
    "INTEGER",
    "JSON",
    "NUMERIC",
    "SMALLINT",
    "TEXT",
    "TIME",
    "TIMESTAMP",
    "VARCHAR",
    "REAL",
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/dialects/sqlite/provision.py =====
import os
import re
from ... import exc
from ...engine import url as sa_url
from ...testing.provision import create_db
from ...testing.provision import drop_db
from ...testing.provision import follower_url_from_main
from ...testing.provision import generate_driver_url
from ...testing.provision import log
from ...testing.provision import post_configure_engine
from ...testing.provision import run_reap_dbs
from ...testing.provision import stop_test_class_outside_fixtures
from ...testing.provision import temp_table_keyword_args
from ...testing.provision import upsert
_drivernames = {
    "pysqlite",
    "aiosqlite",
    "pysqlcipher",
    "pysqlite_numeric",
    "pysqlite_dollar",
}
def _format_url(url, driver, ident):
    """given a sqlite url + desired driver + ident, make a canonical
    URL out of it
    """
    url = sa_url.make_url(url)
    if driver is None:
        driver = url.get_driver_name()
    filename = url.database
    needs_enc = driver == "pysqlcipher"
    name_token = None
    if filename and filename != ":memory:":
        assert "test_schema" not in filename
        tokens = re.split(r"[_\.]", filename)
        for token in tokens:
            if token in _drivernames:
                if driver is None:
                    driver = token
                continue
            elif token in ("db", "enc"):
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/dialects/sqlite/dml.py =====
from __future__ import annotations
from typing import Any
from typing import List
from typing import Optional
from typing import Tuple
from typing import Union
from .._typing import _OnConflictIndexElementsT
from .._typing import _OnConflictIndexWhereT
from .._typing import _OnConflictSetT
from .._typing import _OnConflictWhereT
from ... import util
from ...sql import coercions
from ...sql import roles
from ...sql import schema
from ...sql._typing import _DMLTableArgument
from ...sql.base import _exclusive_against
from ...sql.base import _generative
from ...sql.base import ColumnCollection
from ...sql.base import ReadOnlyColumnCollection
from ...sql.dml import Insert as StandardInsert
from ...sql.elements import ClauseElement
from ...sql.elements import ColumnElement
from ...sql.elements import KeyedColumnElement
from ...sql.elements import TextClause
from ...sql.expression import alias
from ...util.typing import Self
__all__ = ("Insert", "insert")
def insert(table: _DMLTableArgument) -> Insert:
    """Construct a sqlite-specific variant :class:`_sqlite.Insert`
    construct.
    .. container:: inherited_member
        The :func:`sqlalchemy.dialects.sqlite.insert` function creates
        a :class:`sqlalchemy.dialects.sqlite.Insert`.  This class is based
        on the dialect-agnostic :class:`_sql.Insert` construct which may
        be constructed using the :func:`_sql.insert` function in
        SQLAlchemy Core.
    The :class:`_sqlite.Insert` construct includes additional methods
    :meth:`_sqlite.Insert.on_conflict_do_update`,
    :meth:`_sqlite.Insert.on_conflict_do_nothing`.
    """
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/dialects/sqlite/json.py =====
from ... import types as sqltypes
class JSON(sqltypes.JSON):
    """SQLite JSON type.
    SQLite supports JSON as of version 3.9 through its JSON1_ extension. Note
    that JSON1_ is a
    `loadable extension <https://www.sqlite.org/loadext.html>`_ and as such
    may not be available, or may require run-time loading.
    :class:`_sqlite.JSON` is used automatically whenever the base
    :class:`_types.JSON` datatype is used against a SQLite backend.
    .. seealso::
        :class:`_types.JSON` - main documentation for the generic
        cross-platform JSON datatype.
    The :class:`_sqlite.JSON` type supports persistence of JSON values
    as well as the core index operations provided by :class:`_types.JSON`
    datatype, by adapting the operations to render the ``JSON_EXTRACT``
    function wrapped in the ``JSON_QUOTE`` function at the database level.
    Extracted values are quoted in order to ensure that the results are
    always JSON string values.
    .. versionadded:: 1.3
    .. _JSON1: https://www.sqlite.org/json1.html
    """
class _FormatTypeMixin:
    def _format_value(self, value):
        raise NotImplementedError()
    def bind_processor(self, dialect):
        super_proc = self.string_bind_processor(dialect)
        def process(value):
            value = self._format_value(value)
            if super_proc:
                value = super_proc(value)
            return value
        return process
    def literal_processor(self, dialect):
        super_proc = self.string_literal_processor(dialect)
        def process(value):
            value = self._format_value(value)
            if super_proc:
                value = super_proc(value)
            return value
        return process
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/dialects/sqlite/base.py =====
r'''
.. dialect:: sqlite
    :name: SQLite
    :normal_support: 3.12+
    :best_effort: 3.7.16+
.. _sqlite_datetime:
Date and Time Types
-------------------
SQLite does not have built-in DATE, TIME, or DATETIME types, and pysqlite does
not provide out of the box functionality for translating values between Python
`datetime` objects and a SQLite-supported format. SQLAlchemy's own
:class:`~sqlalchemy.types.DateTime` and related types provide date formatting
and parsing functionality when SQLite is used. The implementation classes are
:class:`_sqlite.DATETIME`, :class:`_sqlite.DATE` and :class:`_sqlite.TIME`.
These types represent dates and times as ISO formatted strings, which also
nicely support ordering. There's no reliance on typical "libc" internals for
these functions so historical dates are fully supported.
Ensuring Text affinity
^^^^^^^^^^^^^^^^^^^^^^
The DDL rendered for these types is the standard ``DATE``, ``TIME``
and ``DATETIME`` indicators.    However, custom storage formats can also be
applied to these types.   When the
storage format is detected as containing no alpha characters, the DDL for
these types is rendered as ``DATE_CHAR``, ``TIME_CHAR``, and ``DATETIME_CHAR``,
so that the column continues to have textual affinity.
.. seealso::
    `Type Affinity <https://www.sqlite.org/datatype3.html#affinity>`_ -
    in the SQLite documentation
.. _sqlite_autoincrement:
SQLite Auto Incrementing Behavior
----------------------------------
Background on SQLite's autoincrement is at: https://sqlite.org/autoinc.html
Key concepts:
* SQLite has an implicit "auto increment" feature that takes place for any
  non-composite primary-key column that is specifically created using
  "INTEGER PRIMARY KEY" for the type + primary key.
* SQLite also has an explicit "AUTOINCREMENT" keyword, that is **not**
  equivalent to the implicit autoincrement feature; this keyword is not
  recommended for general use.  SQLAlchemy does not render this keyword
  unless a special SQLite-specific directive is used (see below).  However,
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/dialects/sqlite/pysqlite.py =====
r"""
.. dialect:: sqlite+pysqlite
    :name: pysqlite
    :dbapi: sqlite3
    :connectstring: sqlite+pysqlite:///file_path
    :url: https://docs.python.org/library/sqlite3.html
    Note that ``pysqlite`` is the same driver as the ``sqlite3``
    module included with the Python distribution.
Driver
------
The ``sqlite3`` Python DBAPI is standard on all modern Python versions;
for cPython and Pypy, no additional installation is necessary.
Connect Strings
---------------
The file specification for the SQLite database is taken as the "database"
portion of the URL.  Note that the format of a SQLAlchemy url is:
.. sourcecode:: text
    driver://user:pass@host/database
This means that the actual filename to be used starts with the characters to
the **right** of the third slash.   So connecting to a relative filepath
looks like::
    # relative path
    e = create_engine("sqlite:///path/to/database.db")
An absolute path, which is denoted by starting with a slash, means you
need **four** slashes::
    # absolute path
    e = create_engine("sqlite:////path/to/database.db")
To use a Windows path, regular drive specifications and backslashes can be
used. Double backslashes are probably needed::
    # absolute path on Windows
    e = create_engine("sqlite:///C:\\path\\to\\database.db")
To use sqlite ``:memory:`` database specify it as the filename using
``sqlite:///:memory:``. It's also the default if no filepath is
present, specifying only ``sqlite://`` and nothing else::
    # in-memory database (note three slashes)
    e = create_engine("sqlite:///:memory:")
    # also in-memory database
    e2 = create_engine("sqlite://")
.. _pysqlite_uri_connections:
URI Connections
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/dialects/mysql/enumerated.py =====
from __future__ import annotations
import enum
import re
from typing import Any
from typing import Dict
from typing import Optional
from typing import Set
from typing import Type
from typing import TYPE_CHECKING
from typing import Union
from .types import _StringType
from ... import exc
from ... import sql
from ... import util
from ...sql import sqltypes
from ...sql import type_api
if TYPE_CHECKING:
    from ...engine.interfaces import Dialect
    from ...sql.elements import ColumnElement
    from ...sql.type_api import _BindProcessorType
    from ...sql.type_api import _ResultProcessorType
    from ...sql.type_api import TypeEngine
    from ...sql.type_api import TypeEngineMixin
class ENUM(type_api.NativeForEmulated, sqltypes.Enum, _StringType):
    """MySQL ENUM type."""
    __visit_name__ = "ENUM"
    native_enum = True
    def __init__(self, *enums: Union[str, Type[enum.Enum]], **kw: Any) -> None:
        """Construct an ENUM.
        E.g.::
          Column("myenum", ENUM("foo", "bar", "baz"))
        :param enums: The range of valid values for this ENUM.  Values in
          enums are not quoted, they will be escaped and surrounded by single
          quotes when generating the schema.  This object may also be a
          PEP-435-compliant enumerated type.
          .. versionadded: 1.1 added support for PEP-435-compliant enumerated
             types.
        :param strict: This flag has no effect.
         .. versionchanged:: The MySQL ENUM type as well as the base Enum
            type now validates all Python data values.
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/dialects/mysql/mysqlconnector.py =====
r"""
.. dialect:: mysql+mysqlconnector
    :name: MySQL Connector/Python
    :dbapi: myconnpy
    :connectstring: mysql+mysqlconnector://<user>:<password>@<host>[:<port>]/<dbname>
    :url: https://pypi.org/project/mysql-connector-python/
Driver Status
-------------
MySQL Connector/Python is supported as of SQLAlchemy 2.0.39 to the
degree which the driver is functional.   There are still ongoing issues
with features such as server side cursors which remain disabled until
upstream issues are repaired.
.. warning:: The MySQL Connector/Python driver published by Oracle is subject
   to frequent, major regressions of essential functionality such as being able
   to correctly persist simple binary strings which indicate it is not well
   tested.  The SQLAlchemy project is not able to maintain this dialect fully as
   regressions in the driver prevent it from being included in continuous
   integration.
.. versionchanged:: 2.0.39
    The MySQL Connector/Python dialect has been updated to support the
    latest version of this DBAPI.   Previously, MySQL Connector/Python
    was not fully supported.  However, support remains limited due to ongoing
    regressions introduced in this driver.
Connecting to MariaDB with MySQL Connector/Python
--------------------------------------------------
MySQL Connector/Python may attempt to pass an incompatible collation to the
database when connecting to MariaDB.  Experimentation has shown that using
``?charset=utf8mb4&collation=utfmb4_general_ci`` or similar MariaDB-compatible
charset/collation will allow connectivity.
"""  # noqa
from __future__ import annotations
import re
from typing import Any
from typing import cast
from typing import Optional
from typing import Sequence
from typing import Tuple
from typing import TYPE_CHECKING
from typing import Union
from .base import MariaDBIdentifierPreparer
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/dialects/mysql/asyncmy.py =====
r"""
.. dialect:: mysql+asyncmy
    :name: asyncmy
    :dbapi: asyncmy
    :connectstring: mysql+asyncmy://user:password@host:port/dbname[?key=value&key=value...]
    :url: https://github.com/long2ice/asyncmy
Using a special asyncio mediation layer, the asyncmy dialect is usable
as the backend for the :ref:`SQLAlchemy asyncio <asyncio_toplevel>`
extension package.
This dialect should normally be used only with the
:func:`_asyncio.create_async_engine` engine creation function::
    from sqlalchemy.ext.asyncio import create_async_engine
    engine = create_async_engine(
        "mysql+asyncmy://user:pass@hostname/dbname?charset=utf8mb4"
    )
"""  # noqa
from __future__ import annotations
from types import ModuleType
from typing import Any
from typing import NoReturn
from typing import Optional
from typing import TYPE_CHECKING
from typing import Union
from .pymysql import MySQLDialect_pymysql
from ... import pool
from ... import util
from ...connectors.asyncio import AsyncAdapt_dbapi_connection
from ...connectors.asyncio import AsyncAdapt_dbapi_cursor
from ...connectors.asyncio import AsyncAdapt_dbapi_module
from ...connectors.asyncio import AsyncAdapt_dbapi_ss_cursor
from ...util.concurrency import await_fallback
from ...util.concurrency import await_only
if TYPE_CHECKING:
    from ...connectors.asyncio import AsyncIODBAPIConnection
    from ...connectors.asyncio import AsyncIODBAPICursor
    from ...engine.interfaces import ConnectArgsType
    from ...engine.interfaces import DBAPIConnection
    from ...engine.interfaces import DBAPICursor
    from ...engine.interfaces import DBAPIModule
    from ...engine.interfaces import PoolProxiedConnection
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/dialects/mysql/aiomysql.py =====
r"""
.. dialect:: mysql+aiomysql
    :name: aiomysql
    :dbapi: aiomysql
    :connectstring: mysql+aiomysql://user:password@host:port/dbname[?key=value&key=value...]
    :url: https://github.com/aio-libs/aiomysql
The aiomysql dialect is SQLAlchemy's second Python asyncio dialect.
Using a special asyncio mediation layer, the aiomysql dialect is usable
as the backend for the :ref:`SQLAlchemy asyncio <asyncio_toplevel>`
extension package.
This dialect should normally be used only with the
:func:`_asyncio.create_async_engine` engine creation function::
    from sqlalchemy.ext.asyncio import create_async_engine
    engine = create_async_engine(
        "mysql+aiomysql://user:pass@hostname/dbname?charset=utf8mb4"
    )
"""  # noqa
from __future__ import annotations
from types import ModuleType
from typing import Any
from typing import Dict
from typing import Optional
from typing import Tuple
from typing import TYPE_CHECKING
from typing import Union
from .pymysql import MySQLDialect_pymysql
from ... import pool
from ... import util
from ...connectors.asyncio import AsyncAdapt_dbapi_connection
from ...connectors.asyncio import AsyncAdapt_dbapi_cursor
from ...connectors.asyncio import AsyncAdapt_dbapi_module
from ...connectors.asyncio import AsyncAdapt_dbapi_ss_cursor
from ...util.concurrency import await_fallback
from ...util.concurrency import await_only
if TYPE_CHECKING:
    from ...connectors.asyncio import AsyncIODBAPIConnection
    from ...connectors.asyncio import AsyncIODBAPICursor
    from ...engine.interfaces import ConnectArgsType
    from ...engine.interfaces import DBAPIConnection
    from ...engine.interfaces import DBAPICursor
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/dialects/mysql/reserved_words.py =====
RESERVED_WORDS_MARIADB = {
    "accessible",
    "add",
    "all",
    "alter",
    "analyze",
    "and",
    "as",
    "asc",
    "asensitive",
    "before",
    "between",
    "bigint",
    "binary",
    "blob",
    "both",
    "by",
    "call",
    "cascade",
    "case",
    "change",
    "char",
    "character",
    "check",
    "collate",
    "column",
    "condition",
    "constraint",
    "continue",
    "convert",
    "create",
    "cross",
    "current_date",
    "current_role",
    "current_time",
    "current_timestamp",
    "current_user",
    "cursor",
    "database",
    "databases",
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/dialects/mysql/reflection.py =====
from __future__ import annotations
import re
from typing import Any
from typing import Callable
from typing import Dict
from typing import List
from typing import Optional
from typing import overload
from typing import Sequence
from typing import Tuple
from typing import TYPE_CHECKING
from typing import Union
from .enumerated import ENUM
from .enumerated import SET
from .types import DATETIME
from .types import TIME
from .types import TIMESTAMP
from ... import types as sqltypes
from ... import util
from ...util.typing import Literal
if TYPE_CHECKING:
    from .base import MySQLDialect
    from .base import MySQLIdentifierPreparer
    from ...engine.interfaces import ReflectedColumn
class ReflectedState:
    """Stores raw information about a SHOW CREATE TABLE statement."""
    charset: Optional[str]
    def __init__(self) -> None:
        self.columns: List[ReflectedColumn] = []
        self.table_options: Dict[str, str] = {}
        self.table_name: Optional[str] = None
        self.keys: List[Dict[str, Any]] = []
        self.fk_constraints: List[Dict[str, Any]] = []
        self.ck_constraints: List[Dict[str, Any]] = []
class MySQLTableDefinitionParser:
    """Parses the results of a SHOW CREATE TABLE statement."""
    def __init__(
        self, dialect: MySQLDialect, preparer: MySQLIdentifierPreparer
    ):
        self.dialect = dialect
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/dialects/mysql/mariadbconnector.py =====
"""
.. dialect:: mysql+mariadbconnector
    :name: MariaDB Connector/Python
    :dbapi: mariadb
    :connectstring: mariadb+mariadbconnector://<user>:<password>@<host>[:<port>]/<dbname>
    :url: https://pypi.org/project/mariadb/
Driver Status
-------------
MariaDB Connector/Python enables Python programs to access MariaDB and MySQL
databases using an API which is compliant with the Python DB API 2.0 (PEP-249).
It is written in C and uses MariaDB Connector/C client library for client server
communication.
Note that the default driver for a ``mariadb://`` connection URI continues to
be ``mysqldb``. ``mariadb+mariadbconnector://`` is required to use this driver.
.. mariadb: https://github.com/mariadb-corporation/mariadb-connector-python
"""  # noqa
from __future__ import annotations
import re
from typing import Any
from typing import Optional
from typing import Sequence
from typing import Tuple
from typing import TYPE_CHECKING
from typing import Union
from uuid import UUID as _python_UUID
from .base import MySQLCompiler
from .base import MySQLDialect
from .base import MySQLExecutionContext
from ... import sql
from ... import util
from ...sql import sqltypes
if TYPE_CHECKING:
    from ...engine.base import Connection
    from ...engine.interfaces import ConnectArgsType
    from ...engine.interfaces import DBAPIConnection
    from ...engine.interfaces import DBAPICursor
    from ...engine.interfaces import DBAPIModule
    from ...engine.interfaces import Dialect
    from ...engine.interfaces import IsolationLevel
    from ...engine.interfaces import PoolProxiedConnection
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/dialects/mysql/__init__.py =====
from . import aiomysql  # noqa
from . import asyncmy  # noqa
from . import base  # noqa
from . import cymysql  # noqa
from . import mariadbconnector  # noqa
from . import mysqlconnector  # noqa
from . import mysqldb  # noqa
from . import pymysql  # noqa
from . import pyodbc  # noqa
from .base import BIGINT
from .base import BINARY
from .base import BIT
from .base import BLOB
from .base import BOOLEAN
from .base import CHAR
from .base import DATE
from .base import DATETIME
from .base import DECIMAL
from .base import DOUBLE
from .base import ENUM
from .base import FLOAT
from .base import INTEGER
from .base import JSON
from .base import LONGBLOB
from .base import LONGTEXT
from .base import MEDIUMBLOB
from .base import MEDIUMINT
from .base import MEDIUMTEXT
from .base import NCHAR
from .base import NUMERIC
from .base import NVARCHAR
from .base import REAL
from .base import SET
from .base import SMALLINT
from .base import TEXT
from .base import TIME
from .base import TIMESTAMP
from .base import TINYBLOB
from .base import TINYINT
from .base import TINYTEXT
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/dialects/mysql/types.py =====
from __future__ import annotations
import datetime
import decimal
from typing import Any
from typing import Iterable
from typing import Optional
from typing import TYPE_CHECKING
from typing import Union
from ... import exc
from ... import util
from ...sql import sqltypes
if TYPE_CHECKING:
    from .base import MySQLDialect
    from ...engine.interfaces import Dialect
    from ...sql.type_api import _BindProcessorType
    from ...sql.type_api import _ResultProcessorType
    from ...sql.type_api import TypeEngine
class _NumericType:
    """Base for MySQL numeric types.
    This is the base both for NUMERIC as well as INTEGER, hence
    it's a mixin.
    """
    def __init__(
        self, unsigned: bool = False, zerofill: bool = False, **kw: Any
    ):
        self.unsigned = unsigned
        self.zerofill = zerofill
        super().__init__(**kw)
    def __repr__(self) -> str:
        return util.generic_repr(
            self, to_inspect=[_NumericType, sqltypes.Numeric]
        )
class _FloatType(_NumericType, sqltypes.Float[Union[decimal.Decimal, float]]):
    def __init__(
        self,
        precision: Optional[int] = None,
        scale: Optional[int] = None,
        asdecimal: bool = True,
        **kw: Any,
    ):
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/dialects/mysql/mariadb.py =====
from __future__ import annotations
from typing import Any
from typing import Callable
from .base import MariaDBIdentifierPreparer
from .base import MySQLDialect
from .base import MySQLIdentifierPreparer
from .base import MySQLTypeCompiler
from ...sql import sqltypes
class INET4(sqltypes.TypeEngine[str]):
    """INET4 column type for MariaDB
    .. versionadded:: 2.0.37
    """
    __visit_name__ = "INET4"
class INET6(sqltypes.TypeEngine[str]):
    """INET6 column type for MariaDB
    .. versionadded:: 2.0.37
    """
    __visit_name__ = "INET6"
class MariaDBTypeCompiler(MySQLTypeCompiler):
    def visit_INET4(self, type_: INET4, **kwargs: Any) -> str:
        return "INET4"
    def visit_INET6(self, type_: INET6, **kwargs: Any) -> str:
        return "INET6"
class MariaDBDialect(MySQLDialect):
    is_mariadb = True
    supports_statement_cache = True
    name = "mariadb"
    preparer: type[MySQLIdentifierPreparer] = MariaDBIdentifierPreparer
    type_compiler_cls = MariaDBTypeCompiler
def loader(driver: str) -> Callable[[], type[MariaDBDialect]]:
    dialect_mod = __import__(
        "sqlalchemy.dialects.mysql.%s" % driver
    ).dialects.mysql
    driver_mod = getattr(dialect_mod, driver)
    if hasattr(driver_mod, "mariadb_dialect"):
        driver_cls = driver_mod.mariadb_dialect
        return driver_cls  # type: ignore[no-any-return]
    else:
        driver_cls = driver_mod.dialect
        return type(
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/dialects/mysql/provision.py =====
from ... import exc
from ...testing.provision import configure_follower
from ...testing.provision import create_db
from ...testing.provision import drop_db
from ...testing.provision import generate_driver_url
from ...testing.provision import temp_table_keyword_args
from ...testing.provision import upsert
@generate_driver_url.for_db("mysql", "mariadb")
def generate_driver_url(url, driver, query_str):
    backend = url.get_backend_name()
    # NOTE: at the moment, tests are running mariadbconnector
    # against both mariadb and mysql backends.   if we want this to be
    # limited, do the decision making here to reject a "mysql+mariadbconnector"
    # URL.  Optionally also re-enable the module level
    # MySQLDialect_mariadbconnector.is_mysql flag as well, which must include
    # a unit and/or functional test.
    # all the Jenkins tests have been running mysqlclient Python library
    # built against mariadb client drivers for years against all MySQL /
    # MariaDB versions going back to MySQL 5.6, currently they can talk
    # to MySQL databases without problems.
    if backend == "mysql":
        dialect_cls = url.get_dialect()
        if dialect_cls._is_mariadb_from_url(url):
            backend = "mariadb"
    new_url = url.set(
        drivername="%s+%s" % (backend, driver)
    ).update_query_string(query_str)
    if driver == "mariadbconnector":
        new_url = new_url.difference_update_query(["charset"])
    elif driver == "mysqlconnector":
        new_url = new_url.update_query_pairs(
            [("collation", "utf8mb4_general_ci")]
        )
    try:
        new_url.get_dialect()
    except exc.NoSuchModuleError:
        return None
    else:
        return new_url
@create_db.for_db("mysql", "mariadb")
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/dialects/mysql/mysqldb.py =====
"""
.. dialect:: mysql+mysqldb
    :name: mysqlclient (maintained fork of MySQL-Python)
    :dbapi: mysqldb
    :connectstring: mysql+mysqldb://<user>:<password>@<host>[:<port>]/<dbname>
    :url: https://pypi.org/project/mysqlclient/
Driver Status
-------------
The mysqlclient DBAPI is a maintained fork of the
`MySQL-Python <https://sourceforge.net/projects/mysql-python>`_ DBAPI
that is no longer maintained.  `mysqlclient`_ supports Python 2 and Python 3
and is very stable.
.. _mysqlclient: https://github.com/PyMySQL/mysqlclient-python
.. _mysqldb_unicode:
Unicode
-------
Please see :ref:`mysql_unicode` for current recommendations on unicode
handling.
.. _mysqldb_ssl:
SSL Connections
----------------
The mysqlclient and PyMySQL DBAPIs accept an additional dictionary under the
key "ssl", which may be specified using the
:paramref:`_sa.create_engine.connect_args` dictionary::
    engine = create_engine(
        "mysql+mysqldb://scott:tiger@192.168.0.134/test",
        connect_args={
            "ssl": {
                "ca": "/home/gord/client-ssl/ca.pem",
                "cert": "/home/gord/client-ssl/client-cert.pem",
                "key": "/home/gord/client-ssl/client-key.pem",
            }
        },
    )
For convenience, the following keys may also be specified inline within the URL
where they will be interpreted into the "ssl" dictionary automatically:
"ssl_ca", "ssl_cert", "ssl_key", "ssl_capath", "ssl_cipher",
"ssl_check_hostname". An example is as follows::
    connection_uri = (
        "mysql+mysqldb://scott:tiger@192.168.0.134/test"
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/dialects/mysql/pymysql.py =====
r"""
.. dialect:: mysql+pymysql
    :name: PyMySQL
    :dbapi: pymysql
    :connectstring: mysql+pymysql://<username>:<password>@<host>/<dbname>[?<options>]
    :url: https://pymysql.readthedocs.io/
Unicode
-------
Please see :ref:`mysql_unicode` for current recommendations on unicode
handling.
.. _pymysql_ssl:
SSL Connections
------------------
The PyMySQL DBAPI accepts the same SSL arguments as that of MySQLdb,
described at :ref:`mysqldb_ssl`.   See that section for additional examples.
If the server uses an automatically-generated certificate that is self-signed
or does not match the host name (as seen from the client), it may also be
necessary to indicate ``ssl_check_hostname=false`` in PyMySQL::
    connection_uri = (
        "mysql+pymysql://scott:tiger@192.168.0.134/test"
        "?ssl_ca=/home/gord/client-ssl/ca.pem"
        "&ssl_cert=/home/gord/client-ssl/client-cert.pem"
        "&ssl_key=/home/gord/client-ssl/client-key.pem"
        "&ssl_check_hostname=false"
    )
MySQL-Python Compatibility
--------------------------
The pymysql DBAPI is a pure Python port of the MySQL-python (MySQLdb) driver,
and targets 100% compatibility.   Most behavioral notes for MySQL-python apply
to the pymysql driver as well.
"""  # noqa
from __future__ import annotations
from typing import Any
from typing import Dict
from typing import Optional
from typing import TYPE_CHECKING
from typing import Union
from .mysqldb import MySQLDialect_mysqldb
from ...util import langhelpers
from ...util.typing import Literal
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/dialects/mysql/dml.py =====
from __future__ import annotations
from typing import Any
from typing import Dict
from typing import List
from typing import Mapping
from typing import Optional
from typing import Tuple
from typing import Union
from ... import exc
from ... import util
from ...sql._typing import _DMLTableArgument
from ...sql.base import _exclusive_against
from ...sql.base import _generative
from ...sql.base import ColumnCollection
from ...sql.base import ReadOnlyColumnCollection
from ...sql.dml import Insert as StandardInsert
from ...sql.elements import ClauseElement
from ...sql.elements import KeyedColumnElement
from ...sql.expression import alias
from ...sql.selectable import NamedFromClause
from ...util.typing import Self
__all__ = ("Insert", "insert")
def insert(table: _DMLTableArgument) -> Insert:
    """Construct a MySQL/MariaDB-specific variant :class:`_mysql.Insert`
    construct.
    .. container:: inherited_member
        The :func:`sqlalchemy.dialects.mysql.insert` function creates
        a :class:`sqlalchemy.dialects.mysql.Insert`.  This class is based
        on the dialect-agnostic :class:`_sql.Insert` construct which may
        be constructed using the :func:`_sql.insert` function in
        SQLAlchemy Core.
    The :class:`_mysql.Insert` construct includes additional methods
    :meth:`_mysql.Insert.on_duplicate_key_update`.
    """
    return Insert(table)
class Insert(StandardInsert):
    """MySQL-specific implementation of INSERT.
    Adds methods for MySQL-specific syntaxes such as ON DUPLICATE KEY UPDATE.
    The :class:`~.mysql.Insert` object is created using the
    :func:`sqlalchemy.dialects.mysql.insert` function.
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/dialects/mysql/expression.py =====
from __future__ import annotations
from typing import Any
from ... import exc
from ... import util
from ...sql import coercions
from ...sql import elements
from ...sql import operators
from ...sql import roles
from ...sql.base import _generative
from ...sql.base import Generative
from ...util.typing import Self
class match(Generative, elements.BinaryExpression[Any]):
    """Produce a ``MATCH (X, Y) AGAINST ('TEXT')`` clause.
    E.g.::
        from sqlalchemy import desc
        from sqlalchemy.dialects.mysql import match
        match_expr = match(
            users_table.c.firstname,
            users_table.c.lastname,
            against="Firstname Lastname",
        )
        stmt = (
            select(users_table)
            .where(match_expr.in_boolean_mode())
            .order_by(desc(match_expr))
        )
    Would produce SQL resembling:
    .. sourcecode:: sql
        SELECT id, firstname, lastname
        FROM user
        WHERE MATCH(firstname, lastname) AGAINST (:param_1 IN BOOLEAN MODE)
        ORDER BY MATCH(firstname, lastname) AGAINST (:param_2) DESC
    The :func:`_mysql.match` function is a standalone version of the
    :meth:`_sql.ColumnElement.match` method available on all
    SQL expressions, as when :meth:`_expression.ColumnElement.match` is
    used, but allows to pass multiple columns
    :param cols: column expressions to match against
    :param against: expression to be compared towards
    :param in_boolean_mode: boolean, set "boolean mode" to true
    :param in_natural_language_mode: boolean , set "natural language" to true
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/dialects/mysql/json.py =====
from __future__ import annotations
from typing import Any
from typing import TYPE_CHECKING
from ... import types as sqltypes
if TYPE_CHECKING:
    from ...engine.interfaces import Dialect
    from ...sql.type_api import _BindProcessorType
    from ...sql.type_api import _LiteralProcessorType
class JSON(sqltypes.JSON):
    """MySQL JSON type.
    MySQL supports JSON as of version 5.7.
    MariaDB supports JSON (as an alias for LONGTEXT) as of version 10.2.
    :class:`_mysql.JSON` is used automatically whenever the base
    :class:`_types.JSON` datatype is used against a MySQL or MariaDB backend.
    .. seealso::
        :class:`_types.JSON` - main documentation for the generic
        cross-platform JSON datatype.
    The :class:`.mysql.JSON` type supports persistence of JSON values
    as well as the core index operations provided by :class:`_types.JSON`
    datatype, by adapting the operations to render the ``JSON_EXTRACT``
    function at the database level.
    """
    pass
class _FormatTypeMixin:
    def _format_value(self, value: Any) -> str:
        raise NotImplementedError()
    def bind_processor(self, dialect: Dialect) -> _BindProcessorType[Any]:
        super_proc = self.string_bind_processor(dialect)  # type: ignore[attr-defined]  # noqa: E501
        def process(value: Any) -> Any:
            value = self._format_value(value)
            if super_proc:
                value = super_proc(value)
            return value
        return process
    def literal_processor(
        self, dialect: Dialect
    ) -> _LiteralProcessorType[Any]:
        super_proc = self.string_literal_processor(dialect)  # type: ignore[attr-defined]  # noqa: E501
        def process(value: Any) -> str:
            value = self._format_value(value)
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/dialects/mysql/pyodbc.py =====
r"""
.. dialect:: mysql+pyodbc
    :name: PyODBC
    :dbapi: pyodbc
    :connectstring: mysql+pyodbc://<username>:<password>@<dsnname>
    :url: https://pypi.org/project/pyodbc/
.. note::
    The PyODBC for MySQL dialect is **not tested as part of
    SQLAlchemy's continuous integration**.
    The recommended MySQL dialects are mysqlclient and PyMySQL.
    However, if you want to use the mysql+pyodbc dialect and require
    full support for ``utf8mb4`` characters (including supplementary
    characters like emoji) be sure to use a current release of
    MySQL Connector/ODBC and specify the "ANSI" (**not** "Unicode")
    version of the driver in your DSN or connection string.
Pass through exact pyodbc connection string::
    import urllib
    connection_string = (
        "DRIVER=MySQL ODBC 8.0 ANSI Driver;"
        "SERVER=localhost;"
        "PORT=3307;"
        "DATABASE=mydb;"
        "UID=root;"
        "PWD=(whatever);"
        "charset=utf8mb4;"
    )
    params = urllib.parse.quote_plus(connection_string)
    connection_uri = "mysql+pyodbc:///?odbc_connect=%s" % params
"""  # noqa
from __future__ import annotations
import datetime
import re
from typing import Any
from typing import Callable
from typing import Optional
from typing import Tuple
from typing import TYPE_CHECKING
from typing import Union
from .base import MySQLDialect
from .base import MySQLExecutionContext
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/dialects/mysql/base.py =====
r"""
.. dialect:: mysql
    :name: MySQL / MariaDB
    :normal_support: 5.6+ / 10+
    :best_effort: 5.0.2+ / 5.0.2+
Supported Versions and Features
-------------------------------
SQLAlchemy supports MySQL starting with version 5.0.2 through modern releases,
as well as all modern versions of MariaDB.   See the official MySQL
documentation for detailed information about features supported in any given
server release.
.. versionchanged:: 1.4  minimum MySQL version supported is now 5.0.2.
MariaDB Support
~~~~~~~~~~~~~~~
The MariaDB variant of MySQL retains fundamental compatibility with MySQL's
protocols however the development of these two products continues to diverge.
Within the realm of SQLAlchemy, the two databases have a small number of
syntactical and behavioral differences that SQLAlchemy accommodates automatically.
To connect to a MariaDB database, no changes to the database URL are required::
    engine = create_engine(
        "mysql+pymysql://user:pass@some_mariadb/dbname?charset=utf8mb4"
    )
Upon first connect, the SQLAlchemy dialect employs a
server version detection scheme that determines if the
backing database reports as MariaDB.  Based on this flag, the dialect
can make different choices in those of areas where its behavior
must be different.
.. _mysql_mariadb_only_mode:
MariaDB-Only Mode
~~~~~~~~~~~~~~~~~
The dialect also supports an **optional** "MariaDB-only" mode of connection, which may be
useful for the case where an application makes use of MariaDB-specific features
and is not compatible with a MySQL database.    To use this mode of operation,
replace the "mysql" token in the above URL with "mariadb"::
    engine = create_engine(
        "mariadb+pymysql://user:pass@some_mariadb/dbname?charset=utf8mb4"
    )
The above engine, upon first connect, will raise an error if the server version
detection detects that the backing database is not MariaDB.
When using an engine with ``"mariadb"`` as the dialect name, **all mysql-specific options
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/dialects/mysql/cymysql.py =====
r"""
.. dialect:: mysql+cymysql
    :name: CyMySQL
    :dbapi: cymysql
    :connectstring: mysql+cymysql://<username>:<password>@<host>/<dbname>[?<options>]
    :url: https://github.com/nakagami/CyMySQL
.. note::
    The CyMySQL dialect is **not tested as part of SQLAlchemy's continuous
    integration** and may have unresolved issues.  The recommended MySQL
    dialects are mysqlclient and PyMySQL.
"""  # noqa
from __future__ import annotations
from typing import Any
from typing import Iterable
from typing import Optional
from typing import TYPE_CHECKING
from typing import Union
from .base import MySQLDialect
from .mysqldb import MySQLDialect_mysqldb
from .types import BIT
from ... import util
if TYPE_CHECKING:
    from ...engine.base import Connection
    from ...engine.interfaces import DBAPIConnection
    from ...engine.interfaces import DBAPICursor
    from ...engine.interfaces import DBAPIModule
    from ...engine.interfaces import Dialect
    from ...engine.interfaces import PoolProxiedConnection
    from ...sql.type_api import _ResultProcessorType
class _cymysqlBIT(BIT):
    def result_processor(
        self, dialect: Dialect, coltype: object
    ) -> Optional[_ResultProcessorType[Any]]:
        """Convert MySQL's 64 bit, variable length binary string to a long."""
        def process(value: Optional[Iterable[int]]) -> Optional[int]:
            if value is not None:
                v = 0
                for i in iter(value):
                    v = v << 8 | i
                return v
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/dialects/mssql/__init__.py =====
from . import aioodbc  # noqa
from . import base  # noqa
from . import pymssql  # noqa
from . import pyodbc  # noqa
from .base import BIGINT
from .base import BINARY
from .base import BIT
from .base import CHAR
from .base import DATE
from .base import DATETIME
from .base import DATETIME2
from .base import DATETIMEOFFSET
from .base import DECIMAL
from .base import DOUBLE_PRECISION
from .base import FLOAT
from .base import IMAGE
from .base import INTEGER
from .base import JSON
from .base import MONEY
from .base import NCHAR
from .base import NTEXT
from .base import NUMERIC
from .base import NVARCHAR
from .base import REAL
from .base import ROWVERSION
from .base import SMALLDATETIME
from .base import SMALLINT
from .base import SMALLMONEY
from .base import SQL_VARIANT
from .base import TEXT
from .base import TIME
from .base import TIMESTAMP
from .base import TINYINT
from .base import UNIQUEIDENTIFIER
from .base import VARBINARY
from .base import VARCHAR
from .base import XML
from ...sql import try_cast
base.dialect = dialect = pyodbc.dialect
__all__ = (
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/dialects/mssql/pymssql.py =====
"""
.. dialect:: mssql+pymssql
    :name: pymssql
    :dbapi: pymssql
    :connectstring: mssql+pymssql://<username>:<password>@<freetds_name>/?charset=utf8
pymssql is a Python module that provides a Python DBAPI interface around
`FreeTDS <https://www.freetds.org/>`_.
.. versionchanged:: 2.0.5
    pymssql was restored to SQLAlchemy's continuous integration testing
"""  # noqa
import re
from .base import MSDialect
from .base import MSIdentifierPreparer
from ... import types as sqltypes
from ... import util
from ...engine import processors
class _MSNumeric_pymssql(sqltypes.Numeric):
    def result_processor(self, dialect, type_):
        if not self.asdecimal:
            return processors.to_float
        else:
            return sqltypes.Numeric.result_processor(self, dialect, type_)
class MSIdentifierPreparer_pymssql(MSIdentifierPreparer):
    def __init__(self, dialect):
        super().__init__(dialect)
        # pymssql has the very unusual behavior that it uses pyformat
        # yet does not require that percent signs be doubled
        self._double_percents = False
class MSDialect_pymssql(MSDialect):
    supports_statement_cache = True
    supports_native_decimal = True
    supports_native_uuid = True
    driver = "pymssql"
    preparer = MSIdentifierPreparer_pymssql
    colspecs = util.update_copy(
        MSDialect.colspecs,
        {sqltypes.Numeric: _MSNumeric_pymssql, sqltypes.Float: sqltypes.Float},
    )
    @classmethod
    def import_dbapi(cls):
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/dialects/mssql/provision.py =====
from sqlalchemy import inspect
from sqlalchemy import Integer
from ... import create_engine
from ... import exc
from ...schema import Column
from ...schema import DropConstraint
from ...schema import ForeignKeyConstraint
from ...schema import MetaData
from ...schema import Table
from ...testing.provision import create_db
from ...testing.provision import drop_all_schema_objects_pre_tables
from ...testing.provision import drop_db
from ...testing.provision import generate_driver_url
from ...testing.provision import get_temp_table_name
from ...testing.provision import log
from ...testing.provision import normalize_sequence
from ...testing.provision import post_configure_engine
from ...testing.provision import run_reap_dbs
from ...testing.provision import temp_table_keyword_args
@post_configure_engine.for_db("mssql")
def post_configure_engine(url, engine, follower_ident):
    if engine.driver == "pyodbc":
        engine.dialect.dbapi.pooling = False
@generate_driver_url.for_db("mssql")
def generate_driver_url(url, driver, query_str):
    backend = url.get_backend_name()
    new_url = url.set(drivername="%s+%s" % (backend, driver))
    if driver not in ("pyodbc", "aioodbc"):
        new_url = new_url.set(query="")
    if driver == "aioodbc":
        new_url = new_url.update_query_dict({"MARS_Connection": "Yes"})
    if query_str:
        new_url = new_url.update_query_string(query_str)
    try:
        new_url.get_dialect()
    except exc.NoSuchModuleError:
        return None
    else:
        return new_url
@create_db.for_db("mssql")
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/dialects/mssql/aioodbc.py =====
r"""
.. dialect:: mssql+aioodbc
    :name: aioodbc
    :dbapi: aioodbc
    :connectstring: mssql+aioodbc://<username>:<password>@<dsnname>
    :url: https://pypi.org/project/aioodbc/
Support for the SQL Server database in asyncio style, using the aioodbc
driver which itself is a thread-wrapper around pyodbc.
.. versionadded:: 2.0.23  Added the mssql+aioodbc dialect which builds
   on top of the pyodbc and general aio* dialect architecture.
Using a special asyncio mediation layer, the aioodbc dialect is usable
as the backend for the :ref:`SQLAlchemy asyncio <asyncio_toplevel>`
extension package.
Most behaviors and caveats for this driver are the same as that of the
pyodbc dialect used on SQL Server; see :ref:`mssql_pyodbc` for general
background.
This dialect should normally be used only with the
:func:`_asyncio.create_async_engine` engine creation function; connection
styles are otherwise equivalent to those documented in the pyodbc section::
    from sqlalchemy.ext.asyncio import create_async_engine
    engine = create_async_engine(
        "mssql+aioodbc://scott:tiger@mssql2017:1433/test?"
        "driver=ODBC+Driver+18+for+SQL+Server&TrustServerCertificate=yes"
    )
"""
from __future__ import annotations
from .pyodbc import MSDialect_pyodbc
from .pyodbc import MSExecutionContext_pyodbc
from ...connectors.aioodbc import aiodbcConnector
class MSExecutionContext_aioodbc(MSExecutionContext_pyodbc):
    def create_server_side_cursor(self):
        return self._dbapi_connection.cursor(server_side=True)
class MSDialectAsync_aioodbc(aiodbcConnector, MSDialect_pyodbc):
    driver = "aioodbc"
    supports_statement_cache = True
    execution_ctx_cls = MSExecutionContext_aioodbc
dialect = MSDialectAsync_aioodbc
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/dialects/mssql/information_schema.py =====
from ... import cast
from ... import Column
from ... import MetaData
from ... import Table
from ...ext.compiler import compiles
from ...sql import expression
from ...types import Boolean
from ...types import Integer
from ...types import Numeric
from ...types import NVARCHAR
from ...types import String
from ...types import TypeDecorator
from ...types import Unicode
ischema = MetaData()
class CoerceUnicode(TypeDecorator):
    impl = Unicode
    cache_ok = True
    def bind_expression(self, bindvalue):
        return _cast_on_2005(bindvalue)
class _cast_on_2005(expression.ColumnElement):
    def __init__(self, bindvalue):
        self.bindvalue = bindvalue
@compiles(_cast_on_2005)
def _compile(element, compiler, **kw):
    from . import base
    if (
        compiler.dialect.server_version_info is None
        or compiler.dialect.server_version_info < base.MS_2005_VERSION
    ):
        return compiler.process(element.bindvalue, **kw)
    else:
        return compiler.process(cast(element.bindvalue, Unicode), **kw)
schemata = Table(
    "SCHEMATA",
    ischema,
    Column("CATALOG_NAME", CoerceUnicode, key="catalog_name"),
    Column("SCHEMA_NAME", CoerceUnicode, key="schema_name"),
    Column("SCHEMA_OWNER", CoerceUnicode, key="schema_owner"),
    schema="INFORMATION_SCHEMA",
)
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/dialects/mssql/json.py =====
from ... import types as sqltypes
class JSON(sqltypes.JSON):
    """MSSQL JSON type.
    MSSQL supports JSON-formatted data as of SQL Server 2016.
    The :class:`_mssql.JSON` datatype at the DDL level will represent the
    datatype as ``NVARCHAR(max)``, but provides for JSON-level comparison
    functions as well as Python coercion behavior.
    :class:`_mssql.JSON` is used automatically whenever the base
    :class:`_types.JSON` datatype is used against a SQL Server backend.
    .. seealso::
        :class:`_types.JSON` - main documentation for the generic
        cross-platform JSON datatype.
    The :class:`_mssql.JSON` type supports persistence of JSON values
    as well as the core index operations provided by :class:`_types.JSON`
    datatype, by adapting the operations to render the ``JSON_VALUE``
    or ``JSON_QUERY`` functions at the database level.
    The SQL Server :class:`_mssql.JSON` type necessarily makes use of the
    ``JSON_QUERY`` and ``JSON_VALUE`` functions when querying for elements
    of a JSON object.   These two functions have a major restriction in that
    they are **mutually exclusive** based on the type of object to be returned.
    The ``JSON_QUERY`` function **only** returns a JSON dictionary or list,
    but not an individual string, numeric, or boolean element; the
    ``JSON_VALUE`` function **only** returns an individual string, numeric,
    or boolean element.   **both functions either return NULL or raise
    an error if they are not used against the correct expected value**.
    To handle this awkward requirement, indexed access rules are as follows:
    1. When extracting a sub element from a JSON that is itself a JSON
       dictionary or list, the :meth:`_types.JSON.Comparator.as_json` accessor
       should be used::
            stmt = select(data_table.c.data["some key"].as_json()).where(
                data_table.c.data["some key"].as_json() == {"sub": "structure"}
            )
    2. When extracting a sub element from a JSON that is a plain boolean,
       string, integer, or float, use the appropriate method among
       :meth:`_types.JSON.Comparator.as_boolean`,
       :meth:`_types.JSON.Comparator.as_string`,
       :meth:`_types.JSON.Comparator.as_integer`,
       :meth:`_types.JSON.Comparator.as_float`::
            stmt = select(data_table.c.data["some key"].as_string()).where(
                data_table.c.data["some key"].as_string() == "some string"
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/dialects/mssql/pyodbc.py =====
r"""
.. dialect:: mssql+pyodbc
    :name: PyODBC
    :dbapi: pyodbc
    :connectstring: mssql+pyodbc://<username>:<password>@<dsnname>
    :url: https://pypi.org/project/pyodbc/
Connecting to PyODBC
--------------------
The URL here is to be translated to PyODBC connection strings, as
detailed in `ConnectionStrings <https://code.google.com/p/pyodbc/wiki/ConnectionStrings>`_.
DSN Connections
^^^^^^^^^^^^^^^
A DSN connection in ODBC means that a pre-existing ODBC datasource is
configured on the client machine.   The application then specifies the name
of this datasource, which encompasses details such as the specific ODBC driver
in use as well as the network address of the database.   Assuming a datasource
is configured on the client, a basic DSN-based connection looks like::
    engine = create_engine("mssql+pyodbc://scott:tiger@some_dsn")
Which above, will pass the following connection string to PyODBC:
.. sourcecode:: text
    DSN=some_dsn;UID=scott;PWD=tiger
If the username and password are omitted, the DSN form will also add
the ``Trusted_Connection=yes`` directive to the ODBC string.
Hostname Connections
^^^^^^^^^^^^^^^^^^^^
Hostname-based connections are also supported by pyodbc.  These are often
easier to use than a DSN and have the additional advantage that the specific
database name to connect towards may be specified locally in the URL, rather
than it being fixed as part of a datasource configuration.
When using a hostname connection, the driver name must also be specified in the
query parameters of the URL.  As these names usually have spaces in them, the
name must be URL encoded which means using plus signs for spaces::
    engine = create_engine(
        "mssql+pyodbc://scott:tiger@myhost:port/databasename?driver=ODBC+Driver+17+for+SQL+Server"
    )
The ``driver`` keyword is significant to the pyodbc dialect and must be
specified in lowercase.
Any other names passed in the query string are passed through in the pyodbc
connect string, such as ``authentication``, ``TrustServerCertificate``, etc.
Multiple keyword arguments must be separated by an ampersand (``&``); these
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/dialects/mssql/base.py =====
"""
.. dialect:: mssql
    :name: Microsoft SQL Server
    :normal_support: 2012+
    :best_effort: 2005+
.. _mssql_external_dialects:
External Dialects
-----------------
In addition to the above DBAPI layers with native SQLAlchemy support, there
are third-party dialects for other DBAPI layers that are compatible
with SQL Server. See the "External Dialects" list on the
:ref:`dialect_toplevel` page.
.. _mssql_identity:
Auto Increment Behavior / IDENTITY Columns
------------------------------------------
SQL Server provides so-called "auto incrementing" behavior using the
``IDENTITY`` construct, which can be placed on any single integer column in a
table. SQLAlchemy considers ``IDENTITY`` within its default "autoincrement"
behavior for an integer primary key column, described at
:paramref:`_schema.Column.autoincrement`.  This means that by default,
the first integer primary key column in a :class:`_schema.Table` will be
considered to be the identity column - unless it is associated with a
:class:`.Sequence` - and will generate DDL as such::
    from sqlalchemy import Table, MetaData, Column, Integer
    m = MetaData()
    t = Table(
        "t",
        m,
        Column("id", Integer, primary_key=True),
        Column("x", Integer),
    )
    m.create_all(engine)
The above example will generate DDL as:
.. sourcecode:: sql
    CREATE TABLE t (
        id INTEGER NOT NULL IDENTITY,
        x INTEGER NULL,
        PRIMARY KEY (id)
    )
For the case where this default generation of ``IDENTITY`` is not desired,
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/orm/sync.py =====
"""private module containing functions used for copying data
between instances based on join conditions.
"""
from __future__ import annotations
from . import exc
from . import util as orm_util
from .base import PassiveFlag
def populate(
    source,
    source_mapper,
    dest,
    dest_mapper,
    synchronize_pairs,
    uowcommit,
    flag_cascaded_pks,
):
    source_dict = source.dict
    dest_dict = dest.dict
    for l, r in synchronize_pairs:
        try:
            # inline of source_mapper._get_state_attr_by_column
            prop = source_mapper._columntoproperty[l]
            value = source.manager[prop.key].impl.get(
                source, source_dict, PassiveFlag.PASSIVE_OFF
            )
        except exc.UnmappedColumnError as err:
            _raise_col_to_prop(False, source_mapper, l, dest_mapper, r, err)
        try:
            # inline of dest_mapper._set_state_attr_by_column
            prop = dest_mapper._columntoproperty[r]
            dest.manager[prop.key].impl.set(dest, dest_dict, value, None)
        except exc.UnmappedColumnError as err:
            _raise_col_to_prop(True, source_mapper, l, dest_mapper, r, err)
        # technically the "r.primary_key" check isn't
        # needed here, but we check for this condition to limit
        # how often this logic is invoked for memory/performance
        # reasons, since we only need this info for a primary key
        # destination.
        if (
            flag_cascaded_pks
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/orm/interfaces.py =====
"""
Contains various base classes used throughout the ORM.
Defines some key base classes prominent within the internals.
This module and the classes within are mostly private, though some attributes
are exposed when inspecting mappings.
"""
from __future__ import annotations
import collections
import dataclasses
import typing
from typing import Any
from typing import Callable
from typing import cast
from typing import ClassVar
from typing import Dict
from typing import Generic
from typing import Iterator
from typing import List
from typing import Mapping
from typing import NamedTuple
from typing import NoReturn
from typing import Optional
from typing import Sequence
from typing import Set
from typing import Tuple
from typing import Type
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union
from . import exc as orm_exc
from . import path_registry
from .base import _MappedAttribute as _MappedAttribute
from .base import EXT_CONTINUE as EXT_CONTINUE  # noqa: F401
from .base import EXT_SKIP as EXT_SKIP  # noqa: F401
from .base import EXT_STOP as EXT_STOP  # noqa: F401
from .base import InspectionAttr as InspectionAttr  # noqa: F401
from .base import InspectionAttrInfo as InspectionAttrInfo
from .base import MANYTOMANY as MANYTOMANY  # noqa: F401
from .base import MANYTOONE as MANYTOONE  # noqa: F401
from .base import NO_KEY as NO_KEY  # noqa: F401
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/orm/decl_base.py =====
"""Internal implementation for declarative."""
from __future__ import annotations
import collections
import dataclasses
import re
from typing import Any
from typing import Callable
from typing import cast
from typing import Dict
from typing import Iterable
from typing import List
from typing import Mapping
from typing import NamedTuple
from typing import NoReturn
from typing import Optional
from typing import Sequence
from typing import Tuple
from typing import Type
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union
import weakref
from . import attributes
from . import clsregistry
from . import exc as orm_exc
from . import instrumentation
from . import mapperlib
from ._typing import _O
from ._typing import attr_is_internal_proxy
from .attributes import InstrumentedAttribute
from .attributes import QueryableAttribute
from .base import _is_mapped_class
from .base import InspectionAttr
from .descriptor_props import CompositeProperty
from .descriptor_props import SynonymProperty
from .interfaces import _AttributeOptions
from .interfaces import _DCAttributeOptions
from .interfaces import _IntrospectsAnnotations
from .interfaces import _MappedAttribute
from .interfaces import _MapsColumns
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/orm/instrumentation.py =====
"""Defines SQLAlchemy's system of class instrumentation.
This module is usually not directly visible to user applications, but
defines a large part of the ORM's interactivity.
instrumentation.py deals with registration of end-user classes
for state tracking.   It interacts closely with state.py
and attributes.py which establish per-instance and per-class-attribute
instrumentation, respectively.
The class instrumentation system can be customized on a per-class
or global basis using the :mod:`sqlalchemy.ext.instrumentation`
module, which provides the means to build and specify
alternate instrumentation forms.
.. versionchanged: 0.8
   The instrumentation extension system was moved out of the
   ORM and into the external :mod:`sqlalchemy.ext.instrumentation`
   package.  When that package is imported, it installs
   itself within sqlalchemy.orm so that its more comprehensive
   resolution mechanics take effect.
"""
from __future__ import annotations
from typing import Any
from typing import Callable
from typing import cast
from typing import Collection
from typing import Dict
from typing import Generic
from typing import Iterable
from typing import List
from typing import Optional
from typing import Set
from typing import Tuple
from typing import Type
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union
import weakref
from . import base
from . import collections
from . import exc
from . import interfaces
from . import state
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/orm/loading.py =====
"""private module containing functions used to convert database
rows into object instances and associated state.
the functions here are called primarily by Query, Mapper,
as well as some of the attribute loading strategies.
"""
from __future__ import annotations
from typing import Any
from typing import Dict
from typing import Iterable
from typing import List
from typing import Mapping
from typing import Optional
from typing import Sequence
from typing import Tuple
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union
from . import attributes
from . import exc as orm_exc
from . import path_registry
from .base import _DEFER_FOR_STATE
from .base import _RAISE_FOR_STATE
from .base import _SET_DEFERRED_EXPIRED
from .base import PassiveFlag
from .context import FromStatement
from .context import ORMCompileState
from .context import QueryContext
from .strategies import SelectInLoader
from .util import _none_set
from .util import state_str
from .. import exc as sa_exc
from .. import util
from ..engine import result_tuple
from ..engine.result import ChunkedIteratorResult
from ..engine.result import FrozenResult
from ..engine.result import SimpleResultMetaData
from ..sql import select
from ..sql import util as sql_util
from ..sql.selectable import ForUpdateArg
from ..sql.selectable import LABEL_STYLE_TABLENAME_PLUS_COL
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/orm/persistence.py =====
"""private module containing functions used to emit INSERT, UPDATE
and DELETE statements on behalf of a :class:`_orm.Mapper` and its descending
mappers.
The functions here are called only by the unit of work functions
in unitofwork.py.
"""
from __future__ import annotations
from itertools import chain
from itertools import groupby
from itertools import zip_longest
import operator
from . import attributes
from . import exc as orm_exc
from . import loading
from . import sync
from .base import state_str
from .. import exc as sa_exc
from .. import future
from .. import sql
from .. import util
from ..engine import cursor as _cursor
from ..sql import operators
from ..sql.elements import BooleanClauseList
from ..sql.selectable import LABEL_STYLE_TABLENAME_PLUS_COL
def save_obj(base_mapper, states, uowtransaction, single=False):
    """Issue ``INSERT`` and/or ``UPDATE`` statements for a list
    of objects.
    This is called within the context of a UOWTransaction during a
    flush operation, given a list of states to be flushed.  The
    base mapper in an inheritance hierarchy handles the inserts/
    updates for all descendant mappers.
    """
    # if batch=false, call _save_obj separately for each object
    if not single and not base_mapper.batch:
        for state in _sort_states(base_mapper, states):
            save_obj(base_mapper, [state], uowtransaction, single=True)
        return
    states_to_update = []
    states_to_insert = []
    for (
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/orm/_typing.py =====
from __future__ import annotations
import operator
from typing import Any
from typing import Dict
from typing import Mapping
from typing import Optional
from typing import Tuple
from typing import Type
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union
from ..engine.interfaces import _CoreKnownExecutionOptions
from ..sql import roles
from ..sql._orm_types import DMLStrategyArgument as DMLStrategyArgument
from ..sql._orm_types import (
    SynchronizeSessionArgument as SynchronizeSessionArgument,
)
from ..sql._typing import _HasClauseElement
from ..sql.elements import ColumnElement
from ..util.typing import Protocol
from ..util.typing import TypeGuard
if TYPE_CHECKING:
    from .attributes import AttributeImpl
    from .attributes import CollectionAttributeImpl
    from .attributes import HasCollectionAdapter
    from .attributes import QueryableAttribute
    from .base import PassiveFlag
    from .decl_api import registry as _registry_type
    from .interfaces import InspectionAttr
    from .interfaces import MapperProperty
    from .interfaces import ORMOption
    from .interfaces import UserDefinedOption
    from .mapper import Mapper
    from .relationships import RelationshipProperty
    from .state import InstanceState
    from .util import AliasedClass
    from .util import AliasedInsp
    from ..sql._typing import _CE
    from ..sql.base import ExecutableOption
_T = TypeVar("_T", bound=Any)
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/orm/path_registry.py =====
"""Path tracking utilities, representing mapper graph traversals."""
from __future__ import annotations
from functools import reduce
from itertools import chain
import logging
import operator
from typing import Any
from typing import cast
from typing import Dict
from typing import Iterator
from typing import List
from typing import Optional
from typing import overload
from typing import Sequence
from typing import Tuple
from typing import TYPE_CHECKING
from typing import Union
from . import base as orm_base
from ._typing import insp_is_mapper_property
from .. import exc
from .. import util
from ..sql import visitors
from ..sql.cache_key import HasCacheKey
if TYPE_CHECKING:
    from ._typing import _InternalEntityType
    from .interfaces import StrategizedProperty
    from .mapper import Mapper
    from .relationships import RelationshipProperty
    from .util import AliasedInsp
    from ..sql.cache_key import _CacheKeyTraversalType
    from ..sql.elements import BindParameter
    from ..sql.visitors import anon_map
    from ..util.typing import _LiteralStar
    from ..util.typing import TypeGuard
    def is_root(path: PathRegistry) -> TypeGuard[RootRegistry]: ...
    def is_entity(path: PathRegistry) -> TypeGuard[AbstractEntityRegistry]: ...
else:
    is_root = operator.attrgetter("is_root")
    is_entity = operator.attrgetter("is_entity")
_SerializedPath = List[Any]
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/orm/query.py =====
"""The Query class and support.
Defines the :class:`_query.Query` class, the central
construct used by the ORM to construct database queries.
The :class:`_query.Query` class should not be confused with the
:class:`_expression.Select` class, which defines database
SELECT operations at the SQL (non-ORM) level.  ``Query`` differs from
``Select`` in that it returns ORM-mapped objects and interacts with an
ORM session, whereas the ``Select`` construct interacts directly with the
database to return iterable result sets.
"""
from __future__ import annotations
import collections.abc as collections_abc
import operator
from typing import Any
from typing import Callable
from typing import cast
from typing import Dict
from typing import Generic
from typing import Iterable
from typing import Iterator
from typing import List
from typing import Mapping
from typing import Optional
from typing import overload
from typing import Sequence
from typing import Tuple
from typing import Type
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union
from . import attributes
from . import interfaces
from . import loading
from . import util as orm_util
from ._typing import _O
from .base import _assertions
from .context import _column_descriptions
from .context import _determine_last_joined_entity
from .context import _legacy_filter_by_entity_zero
from .context import FromStatement
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/orm/attributes.py =====
"""Defines instrumentation for class attributes and their interaction
with instances.
This module is usually not directly visible to user applications, but
defines a large part of the ORM's interactivity.
"""
from __future__ import annotations
import dataclasses
import operator
from typing import Any
from typing import Callable
from typing import cast
from typing import ClassVar
from typing import Dict
from typing import Iterable
from typing import List
from typing import NamedTuple
from typing import Optional
from typing import overload
from typing import Sequence
from typing import Tuple
from typing import Type
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union
from . import collections
from . import exc as orm_exc
from . import interfaces
from ._typing import insp_is_aliased_class
from .base import _DeclarativeMapped
from .base import ATTR_EMPTY
from .base import ATTR_WAS_SET
from .base import CALLABLES_OK
from .base import DEFERRED_HISTORY_LOAD
from .base import INCLUDE_PENDING_MUTATIONS  # noqa
from .base import INIT_OK
from .base import instance_dict as instance_dict
from .base import instance_state as instance_state
from .base import instance_str
from .base import LOAD_AGAINST_COMMITTED
from .base import LoaderCallableStatus
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/orm/strategies.py =====
"""sqlalchemy.orm.interfaces.LoaderStrategy
implementations, and related MapperOptions."""
from __future__ import annotations
import collections
import itertools
from typing import Any
from typing import Dict
from typing import Optional
from typing import Tuple
from typing import TYPE_CHECKING
from typing import Union
from . import attributes
from . import exc as orm_exc
from . import interfaces
from . import loading
from . import path_registry
from . import properties
from . import query
from . import relationships
from . import unitofwork
from . import util as orm_util
from .base import _DEFER_FOR_STATE
from .base import _RAISE_FOR_STATE
from .base import _SET_DEFERRED_EXPIRED
from .base import ATTR_WAS_SET
from .base import LoaderCallableStatus
from .base import PASSIVE_OFF
from .base import PassiveFlag
from .context import _column_descriptions
from .context import ORMCompileState
from .context import ORMSelectCompileState
from .context import QueryContext
from .interfaces import LoaderStrategy
from .interfaces import StrategizedProperty
from .session import _state_session
from .state import InstanceState
from .strategy_options import Load
from .util import _none_only_set
from .util import AliasedClass
from .. import event
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/orm/strategy_options.py =====
""" """
from __future__ import annotations
import typing
from typing import Any
from typing import Callable
from typing import cast
from typing import Dict
from typing import Iterable
from typing import Optional
from typing import overload
from typing import Sequence
from typing import Tuple
from typing import Type
from typing import TypeVar
from typing import Union
from . import util as orm_util
from ._typing import insp_is_aliased_class
from ._typing import insp_is_attribute
from ._typing import insp_is_mapper
from ._typing import insp_is_mapper_property
from .attributes import QueryableAttribute
from .base import InspectionAttr
from .interfaces import LoaderOption
from .path_registry import _DEFAULT_TOKEN
from .path_registry import _StrPathToken
from .path_registry import _WILDCARD_TOKEN
from .path_registry import AbstractEntityRegistry
from .path_registry import path_is_property
from .path_registry import PathRegistry
from .path_registry import TokenRegistry
from .util import _orm_full_deannotate
from .util import AliasedInsp
from .. import exc as sa_exc
from .. import inspect
from .. import util
from ..sql import and_
from ..sql import cache_key
from ..sql import coercions
from ..sql import roles
from ..sql import traversals
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/orm/properties.py =====
"""MapperProperty implementations.
This is a private module which defines the behavior of individual ORM-
mapped attributes.
"""
from __future__ import annotations
from typing import Any
from typing import cast
from typing import Dict
from typing import List
from typing import Optional
from typing import Sequence
from typing import Set
from typing import Tuple
from typing import Type
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union
from . import attributes
from . import exc as orm_exc
from . import strategy_options
from .base import _DeclarativeMapped
from .base import class_mapper
from .descriptor_props import CompositeProperty
from .descriptor_props import ConcreteInheritedProperty
from .descriptor_props import SynonymProperty
from .interfaces import _AttributeOptions
from .interfaces import _DEFAULT_ATTRIBUTE_OPTIONS
from .interfaces import _IntrospectsAnnotations
from .interfaces import _MapsColumns
from .interfaces import MapperProperty
from .interfaces import PropComparator
from .interfaces import StrategizedProperty
from .relationships import RelationshipProperty
from .util import de_stringify_annotation
from .. import exc as sa_exc
from .. import ForeignKey
from .. import log
from .. import util
from ..sql import coercions
from ..sql import roles
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/orm/util.py =====
from __future__ import annotations
import enum
import functools
import re
import types
import typing
from typing import AbstractSet
from typing import Any
from typing import Callable
from typing import cast
from typing import Dict
from typing import FrozenSet
from typing import Generic
from typing import Iterable
from typing import Iterator
from typing import List
from typing import Match
from typing import Optional
from typing import Sequence
from typing import Tuple
from typing import Type
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union
import weakref
from . import attributes  # noqa
from . import exc
from . import exc as orm_exc
from ._typing import _O
from ._typing import insp_is_aliased_class
from ._typing import insp_is_mapper
from ._typing import prop_is_relationship
from .base import _class_to_mapper as _class_to_mapper
from .base import _MappedAnnotationBase
from .base import _never_set as _never_set  # noqa: F401
from .base import _none_only_set as _none_only_set  # noqa: F401
from .base import _none_set as _none_set  # noqa: F401
from .base import attribute_str as attribute_str  # noqa: F401
from .base import class_mapper as class_mapper
from .base import DynamicMapped
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/orm/events.py =====
"""ORM event interfaces."""
from __future__ import annotations
from typing import Any
from typing import Callable
from typing import Collection
from typing import Dict
from typing import Generic
from typing import Iterable
from typing import Optional
from typing import Sequence
from typing import Set
from typing import Type
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union
import weakref
from . import instrumentation
from . import interfaces
from . import mapperlib
from .attributes import QueryableAttribute
from .base import _mapper_or_none
from .base import NO_KEY
from .instrumentation import ClassManager
from .instrumentation import InstrumentationFactory
from .query import BulkDelete
from .query import BulkUpdate
from .query import Query
from .scoping import scoped_session
from .session import Session
from .session import sessionmaker
from .. import event
from .. import exc
from .. import util
from ..event import EventTarget
from ..event.registry import _ET
from ..util.compat import inspect_getfullargspec
if TYPE_CHECKING:
    from weakref import ReferenceType
    from ._typing import _InstanceDict
    from ._typing import _InternalEntityType
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/orm/mapper.py =====
"""Logic to map Python classes to and from selectables.
Defines the :class:`~sqlalchemy.orm.mapper.Mapper` class, the central
configurational unit which associates a class with a database table.
This is a semi-private module; the main configurational API of the ORM is
available in :class:`~sqlalchemy.orm.`.
"""
from __future__ import annotations
from collections import deque
from functools import reduce
from itertools import chain
import sys
import threading
from typing import Any
from typing import Callable
from typing import cast
from typing import Collection
from typing import Deque
from typing import Dict
from typing import FrozenSet
from typing import Generic
from typing import Iterable
from typing import Iterator
from typing import List
from typing import Mapping
from typing import Optional
from typing import Sequence
from typing import Set
from typing import Tuple
from typing import Type
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union
import weakref
from . import attributes
from . import exc as orm_exc
from . import instrumentation
from . import loading
from . import properties
from . import util as orm_util
from ._typing import _O
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/orm/mapped_collection.py =====
from __future__ import annotations
import operator
from typing import Any
from typing import Callable
from typing import Dict
from typing import Generic
from typing import List
from typing import Optional
from typing import Sequence
from typing import Tuple
from typing import Type
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union
from . import base
from .collections import collection
from .collections import collection_adapter
from .. import exc as sa_exc
from .. import util
from ..sql import coercions
from ..sql import expression
from ..sql import roles
from ..util.langhelpers import Missing
from ..util.langhelpers import MissingOr
from ..util.typing import Literal
if TYPE_CHECKING:
    from . import AttributeEventToken
    from . import Mapper
    from .collections import CollectionAdapter
    from ..sql.elements import ColumnElement
_KT = TypeVar("_KT", bound=Any)
_VT = TypeVar("_VT", bound=Any)
class _PlainColumnGetter(Generic[_KT]):
    """Plain column getter, stores collection of Column objects
    directly.
    Serializes to a :class:`._SerializableColumnGetterV2`
    which has more expensive __call__() performance
    and some rare caveats.
    """
    __slots__ = ("cols", "composite")
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/orm/scoping.py =====
from __future__ import annotations
from typing import Any
from typing import Callable
from typing import Dict
from typing import Generic
from typing import Iterable
from typing import Iterator
from typing import Optional
from typing import overload
from typing import Sequence
from typing import Tuple
from typing import Type
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union
from .session import _S
from .session import Session
from .. import exc as sa_exc
from .. import util
from ..util import create_proxy_methods
from ..util import ScopedRegistry
from ..util import ThreadLocalRegistry
from ..util import warn
from ..util import warn_deprecated
from ..util.typing import Protocol
if TYPE_CHECKING:
    from ._typing import _EntityType
    from ._typing import _IdentityKeyType
    from ._typing import OrmExecuteOptionsParameter
    from .identity import IdentityMap
    from .interfaces import ORMOption
    from .mapper import Mapper
    from .query import Query
    from .query import RowReturningQuery
    from .session import _BindArguments
    from .session import _EntityBindKey
    from .session import _PKIdentityArgument
    from .session import _SessionBind
    from .session import sessionmaker
    from .session import SessionTransaction
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/orm/clsregistry.py =====
"""Routines to handle the string class registry used by declarative.
This system allows specification of classes and expressions used in
:func:`_orm.relationship` using strings.
"""
from __future__ import annotations
import re
from typing import Any
from typing import Callable
from typing import cast
from typing import Dict
from typing import Generator
from typing import Iterable
from typing import List
from typing import Mapping
from typing import MutableMapping
from typing import NoReturn
from typing import Optional
from typing import Set
from typing import Tuple
from typing import Type
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union
import weakref
from . import attributes
from . import interfaces
from .descriptor_props import SynonymProperty
from .properties import ColumnProperty
from .util import class_mapper
from .. import exc
from .. import inspection
from .. import util
from ..sql.schema import _get_table_key
from ..util.typing import CallableReference
if TYPE_CHECKING:
    from .relationships import RelationshipProperty
    from ..sql.schema import MetaData
    from ..sql.schema import Table
_T = TypeVar("_T", bound=Any)
_ClsRegistryType = MutableMapping[str, Union[type, "ClsRegistryToken"]]
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/orm/session.py =====
"""Provides the Session class and related utilities."""
from __future__ import annotations
import contextlib
from enum import Enum
import itertools
import sys
import typing
from typing import Any
from typing import Callable
from typing import cast
from typing import Dict
from typing import Generic
from typing import Iterable
from typing import Iterator
from typing import List
from typing import NoReturn
from typing import Optional
from typing import overload
from typing import Sequence
from typing import Set
from typing import Tuple
from typing import Type
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union
import weakref
from . import attributes
from . import bulk_persistence
from . import context
from . import descriptor_props
from . import exc
from . import identity
from . import loading
from . import query
from . import state as statelib
from ._typing import _O
from ._typing import insp_is_mapper
from ._typing import is_composite_class
from ._typing import is_orm_option
from ._typing import is_user_defined_option
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/orm/__init__.py =====
"""
Functional constructs for ORM configuration.
See the SQLAlchemy object relational tutorial and mapper configuration
documentation for an overview of how this module is used.
"""
from __future__ import annotations
from typing import Any
from . import exc as exc
from . import mapper as mapperlib
from . import strategy_options as strategy_options
from ._orm_constructors import _mapper_fn as mapper
from ._orm_constructors import aliased as aliased
from ._orm_constructors import backref as backref
from ._orm_constructors import clear_mappers as clear_mappers
from ._orm_constructors import column_property as column_property
from ._orm_constructors import composite as composite
from ._orm_constructors import contains_alias as contains_alias
from ._orm_constructors import create_session as create_session
from ._orm_constructors import deferred as deferred
from ._orm_constructors import dynamic_loader as dynamic_loader
from ._orm_constructors import join as join
from ._orm_constructors import mapped_column as mapped_column
from ._orm_constructors import orm_insert_sentinel as orm_insert_sentinel
from ._orm_constructors import outerjoin as outerjoin
from ._orm_constructors import query_expression as query_expression
from ._orm_constructors import relationship as relationship
from ._orm_constructors import synonym as synonym
from ._orm_constructors import with_loader_criteria as with_loader_criteria
from ._orm_constructors import with_polymorphic as with_polymorphic
from .attributes import AttributeEventToken as AttributeEventToken
from .attributes import InstrumentedAttribute as InstrumentedAttribute
from .attributes import QueryableAttribute as QueryableAttribute
from .base import class_mapper as class_mapper
from .base import DynamicMapped as DynamicMapped
from .base import InspectionAttrExtensionType as InspectionAttrExtensionType
from .base import LoaderCallableStatus as LoaderCallableStatus
from .base import Mapped as Mapped
from .base import NotExtension as NotExtension
from .base import ORMDescriptor as ORMDescriptor
from .base import PassiveFlag as PassiveFlag
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/orm/writeonly.py =====
"""Write-only collection API.
This is an alternate mapped attribute style that only supports single-item
collection mutation operations.   To read the collection, a select()
object must be executed each time.
.. versionadded:: 2.0
"""
from __future__ import annotations
from typing import Any
from typing import Collection
from typing import Dict
from typing import Generic
from typing import Iterable
from typing import Iterator
from typing import List
from typing import NoReturn
from typing import Optional
from typing import overload
from typing import Tuple
from typing import Type
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union
from sqlalchemy.sql import bindparam
from . import attributes
from . import interfaces
from . import relationships
from . import strategies
from .base import NEVER_SET
from .base import object_mapper
from .base import PassiveFlag
from .base import RelationshipDirection
from .. import exc
from .. import inspect
from .. import log
from .. import util
from ..sql import delete
from ..sql import insert
from ..sql import select
from ..sql import update
from ..sql.dml import Delete
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/orm/dynamic.py =====
"""Dynamic collection API.
Dynamic collections act like Query() objects for read operations and support
basic add/delete mutation.
.. legacy:: the "dynamic" loader is a legacy feature, superseded by the
 "write_only" loader.
"""
from __future__ import annotations
from typing import Any
from typing import Iterable
from typing import Iterator
from typing import List
from typing import Optional
from typing import Tuple
from typing import Type
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union
from . import attributes
from . import exc as orm_exc
from . import relationships
from . import util as orm_util
from .base import PassiveFlag
from .query import Query
from .session import object_session
from .writeonly import AbstractCollectionWriter
from .writeonly import WriteOnlyAttributeImpl
from .writeonly import WriteOnlyHistory
from .writeonly import WriteOnlyLoader
from .. import util
from ..engine import result
if TYPE_CHECKING:
    from . import QueryableAttribute
    from .mapper import Mapper
    from .relationships import _RelationshipOrderByArg
    from .session import Session
    from .state import InstanceState
    from .util import AliasedClass
    from ..event import _Dispatch
    from ..sql.elements import ColumnElement
_T = TypeVar("_T", bound=Any)
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/orm/context.py =====
from __future__ import annotations
import itertools
from typing import Any
from typing import cast
from typing import Dict
from typing import Iterable
from typing import List
from typing import Optional
from typing import Set
from typing import Tuple
from typing import Type
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union
from . import attributes
from . import interfaces
from . import loading
from .base import _is_aliased_class
from .interfaces import ORMColumnDescription
from .interfaces import ORMColumnsClauseRole
from .path_registry import PathRegistry
from .util import _entity_corresponds_to
from .util import _ORMJoin
from .util import _TraceAdaptRole
from .util import AliasedClass
from .util import Bundle
from .util import ORMAdapter
from .util import ORMStatementAdapter
from .. import exc as sa_exc
from .. import future
from .. import inspect
from .. import sql
from .. import util
from ..sql import coercions
from ..sql import expression
from ..sql import roles
from ..sql import util as sql_util
from ..sql import visitors
from ..sql._typing import _TP
from ..sql._typing import is_dml
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/orm/exc.py =====
"""SQLAlchemy ORM exceptions."""
from __future__ import annotations
from typing import Any
from typing import Optional
from typing import Tuple
from typing import Type
from typing import TYPE_CHECKING
from typing import TypeVar
from .util import _mapper_property_as_plain_name
from .. import exc as sa_exc
from .. import util
from ..exc import MultipleResultsFound  # noqa
from ..exc import NoResultFound  # noqa
if TYPE_CHECKING:
    from .interfaces import LoaderStrategy
    from .interfaces import MapperProperty
    from .state import InstanceState
_T = TypeVar("_T", bound=Any)
NO_STATE = (AttributeError, KeyError)
"""Exception types that may be raised by instrumentation implementations."""
class StaleDataError(sa_exc.SQLAlchemyError):
    """An operation encountered database state that is unaccounted for.
    Conditions which cause this to happen include:
    * A flush may have attempted to update or delete rows
      and an unexpected number of rows were matched during
      the UPDATE or DELETE statement.   Note that when
      version_id_col is used, rows in UPDATE or DELETE statements
      are also matched against the current known version
      identifier.
    * A mapped object with version_id_col was refreshed,
      and the version number coming back from the database does
      not match that of the object itself.
    * A object is detached from its parent object, however
      the object was previously attached to a different parent
      identity which was garbage collected, and a decision
      cannot be made if the new parent was really the most
      recent "parent".
    """
ConcurrentModificationError = StaleDataError
class FlushError(sa_exc.SQLAlchemyError):
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/orm/collections.py =====
"""Support for collections of mapped entities.
The collections package supplies the machinery used to inform the ORM of
collection membership changes.  An instrumentation via decoration approach is
used, allowing arbitrary types (including built-ins) to be used as entity
collections without requiring inheritance from a base class.
Instrumentation decoration relays membership change events to the
:class:`.CollectionAttributeImpl` that is currently managing the collection.
The decorators observe function call arguments and return values, tracking
entities entering or leaving the collection.  Two decorator approaches are
provided.  One is a bundle of generic decorators that map function arguments
and return values to events::
  from sqlalchemy.orm.collections import collection
  class MyClass:
      # ...
      @collection.adds(1)
      def store(self, item):
          self.data.append(item)
      @collection.removes_return()
      def pop(self):
          return self.data.pop()
The second approach is a bundle of targeted decorators that wrap appropriate
append and remove notifiers around the mutation methods present in the
standard Python ``list``, ``set`` and ``dict`` interfaces.  These could be
specified in terms of generic decorator recipes, but are instead hand-tooled
for increased efficiency.  The targeted decorators occasionally implement
adapter-like behavior, such as mapping bulk-set methods (``extend``,
``update``, ``__setslice__``, etc.) into the series of atomic mutation events
that the ORM requires.
The targeted decorators are used internally for automatic instrumentation of
entity collection classes.  Every collection class goes through a
transformation process roughly like so:
1. If the class is a built-in, substitute a trivial sub-class
2. Is this class already instrumented?
3. Add in generic decorators
4. Sniff out the collection interface through duck-typing
5. Add targeted decoration to any undecorated interface method
This process modifies the class at runtime, decorating methods and adding some
bookkeeping properties.  This isn't possible (or desirable) for built-in
classes like ``list``, so trivial sub-classes are substituted to hold
decoration::
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/orm/_orm_constructors.py =====
from __future__ import annotations
import typing
from typing import Any
from typing import Callable
from typing import Collection
from typing import Iterable
from typing import Mapping
from typing import NoReturn
from typing import Optional
from typing import overload
from typing import Type
from typing import TYPE_CHECKING
from typing import Union
from . import mapperlib as mapperlib
from ._typing import _O
from .descriptor_props import Composite
from .descriptor_props import Synonym
from .interfaces import _AttributeOptions
from .properties import MappedColumn
from .properties import MappedSQLExpression
from .query import AliasOption
from .relationships import _RelationshipArgumentType
from .relationships import _RelationshipDeclared
from .relationships import _RelationshipSecondaryArgument
from .relationships import RelationshipProperty
from .session import Session
from .util import _ORMJoin
from .util import AliasedClass
from .util import AliasedInsp
from .util import LoaderCriteriaOption
from .. import sql
from .. import util
from ..exc import InvalidRequestError
from ..sql._typing import _no_kw
from ..sql.base import _NoArg
from ..sql.base import SchemaEventTarget
from ..sql.schema import _InsertSentinelColumnDefault
from ..sql.schema import SchemaConst
from ..sql.selectable import FromClause
from ..util.typing import Annotated
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/orm/dependency.py =====
"""Relationship dependencies."""
from __future__ import annotations
from . import attributes
from . import exc
from . import sync
from . import unitofwork
from . import util as mapperutil
from .interfaces import MANYTOMANY
from .interfaces import MANYTOONE
from .interfaces import ONETOMANY
from .. import exc as sa_exc
from .. import sql
from .. import util
class DependencyProcessor:
    def __init__(self, prop):
        self.prop = prop
        self.cascade = prop.cascade
        self.mapper = prop.mapper
        self.parent = prop.parent
        self.secondary = prop.secondary
        self.direction = prop.direction
        self.post_update = prop.post_update
        self.passive_deletes = prop.passive_deletes
        self.passive_updates = prop.passive_updates
        self.enable_typechecks = prop.enable_typechecks
        if self.passive_deletes:
            self._passive_delete_flag = attributes.PASSIVE_NO_INITIALIZE
        else:
            self._passive_delete_flag = attributes.PASSIVE_OFF
        if self.passive_updates:
            self._passive_update_flag = attributes.PASSIVE_NO_INITIALIZE
        else:
            self._passive_update_flag = attributes.PASSIVE_OFF
        self.sort_key = "%s_%s" % (self.parent._sort_key, prop.key)
        self.key = prop.key
        if not self.prop.synchronize_pairs:
            raise sa_exc.ArgumentError(
                "Can't build a DependencyProcessor for relationship %s. "
                "No target attributes to populate between parent and "
                "child are present" % self.prop
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/orm/descriptor_props.py =====
"""Descriptor properties are more "auxiliary" properties
that exist as configurational elements, but don't participate
as actively in the load/persist ORM loop.
"""
from __future__ import annotations
from dataclasses import is_dataclass
import inspect
import itertools
import operator
import typing
from typing import Any
from typing import Callable
from typing import Dict
from typing import List
from typing import NoReturn
from typing import Optional
from typing import Sequence
from typing import Tuple
from typing import Type
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union
import weakref
from . import attributes
from . import util as orm_util
from .base import _DeclarativeMapped
from .base import LoaderCallableStatus
from .base import Mapped
from .base import PassiveFlag
from .base import SQLORMOperations
from .interfaces import _AttributeOptions
from .interfaces import _IntrospectsAnnotations
from .interfaces import _MapsColumns
from .interfaces import MapperProperty
from .interfaces import PropComparator
from .util import _none_set
from .util import de_stringify_annotation
from .. import event
from .. import exc as sa_exc
from .. import schema
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/orm/decl_api.py =====
"""Public API functions and helpers for declarative."""
from __future__ import annotations
import itertools
import re
import typing
from typing import Any
from typing import Callable
from typing import ClassVar
from typing import Dict
from typing import FrozenSet
from typing import Generic
from typing import Iterable
from typing import Iterator
from typing import Mapping
from typing import Optional
from typing import overload
from typing import Set
from typing import Tuple
from typing import Type
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union
import weakref
from . import attributes
from . import clsregistry
from . import instrumentation
from . import interfaces
from . import mapperlib
from ._orm_constructors import composite
from ._orm_constructors import deferred
from ._orm_constructors import mapped_column
from ._orm_constructors import relationship
from ._orm_constructors import synonym
from .attributes import InstrumentedAttribute
from .base import _inspect_mapped_class
from .base import _is_mapped_class
from .base import Mapped
from .base import ORMDescriptor
from .decl_base import _add_attribute
from .decl_base import _as_declarative
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/orm/bulk_persistence.py =====
"""additional ORM persistence classes related to "bulk" operations,
specifically outside of the flush() process.
"""
from __future__ import annotations
from typing import Any
from typing import cast
from typing import Dict
from typing import Iterable
from typing import Optional
from typing import overload
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union
from . import attributes
from . import context
from . import evaluator
from . import exc as orm_exc
from . import loading
from . import persistence
from .base import NO_VALUE
from .context import AbstractORMCompileState
from .context import FromStatement
from .context import ORMFromStatementCompileState
from .context import QueryContext
from .. import exc as sa_exc
from .. import util
from ..engine import Dialect
from ..engine import result as _result
from ..sql import coercions
from ..sql import dml
from ..sql import expression
from ..sql import roles
from ..sql import select
from ..sql import sqltypes
from ..sql.base import _entity_namespace_key
from ..sql.base import CompileState
from ..sql.base import Options
from ..sql.dml import DeleteDMLState
from ..sql.dml import InsertDMLState
from ..sql.dml import UpdateDMLState
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/orm/identity.py =====
from __future__ import annotations
from typing import Any
from typing import cast
from typing import Dict
from typing import Iterable
from typing import Iterator
from typing import List
from typing import NoReturn
from typing import Optional
from typing import Set
from typing import Tuple
from typing import TYPE_CHECKING
from typing import TypeVar
import weakref
from . import util as orm_util
from .. import exc as sa_exc
if TYPE_CHECKING:
    from ._typing import _IdentityKeyType
    from .state import InstanceState
_T = TypeVar("_T", bound=Any)
_O = TypeVar("_O", bound=object)
class IdentityMap:
    _wr: weakref.ref[IdentityMap]
    _dict: Dict[_IdentityKeyType[Any], Any]
    _modified: Set[InstanceState[Any]]
    def __init__(self) -> None:
        self._dict = {}
        self._modified = set()
        self._wr = weakref.ref(self)
    def _kill(self) -> None:
        self._add_unpresent = _killed  # type: ignore
    def all_states(self) -> List[InstanceState[Any]]:
        raise NotImplementedError()
    def contains_state(self, state: InstanceState[Any]) -> bool:
        raise NotImplementedError()
    def __contains__(self, key: _IdentityKeyType[Any]) -> bool:
        raise NotImplementedError()
    def safe_discard(self, state: InstanceState[Any]) -> None:
        raise NotImplementedError()
    def __getitem__(self, key: _IdentityKeyType[_O]) -> _O:
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/orm/state_changes.py =====
"""State tracking utilities used by :class:`_orm.Session`."""
from __future__ import annotations
import contextlib
from enum import Enum
from typing import Any
from typing import Callable
from typing import cast
from typing import Iterator
from typing import NoReturn
from typing import Optional
from typing import Tuple
from typing import TypeVar
from typing import Union
from .. import exc as sa_exc
from .. import util
from ..util.typing import Literal
_F = TypeVar("_F", bound=Callable[..., Any])
class _StateChangeState(Enum):
    pass
class _StateChangeStates(_StateChangeState):
    ANY = 1
    NO_CHANGE = 2
    CHANGE_IN_PROGRESS = 3
class _StateChange:
    """Supplies state assertion decorators.
    The current use case is for the :class:`_orm.SessionTransaction` class. The
    :class:`_StateChange` class itself is agnostic of the
    :class:`_orm.SessionTransaction` class so could in theory be generalized
    for other systems as well.
    """
    _next_state: _StateChangeState = _StateChangeStates.ANY
    _state: _StateChangeState = _StateChangeStates.NO_CHANGE
    _current_fn: Optional[Callable[..., Any]] = None
    def _raise_for_prerequisite_state(
        self, operation_name: str, state: _StateChangeState
    ) -> NoReturn:
        raise sa_exc.IllegalStateChangeError(
            f"Can't run operation '{operation_name}()' when Session "
            f"is in state {state!r}",
            code="isce",
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/orm/evaluator.py =====
"""Evaluation functions used **INTERNALLY** by ORM DML use cases.
This module is **private, for internal use by SQLAlchemy**.
.. versionchanged:: 2.0.4 renamed ``EvaluatorCompiler`` to
   ``_EvaluatorCompiler``.
"""
from __future__ import annotations
from typing import Type
from . import exc as orm_exc
from .base import LoaderCallableStatus
from .base import PassiveFlag
from .. import exc
from .. import inspect
from ..sql import and_
from ..sql import operators
from ..sql.sqltypes import Concatenable
from ..sql.sqltypes import Integer
from ..sql.sqltypes import Numeric
from ..util import warn_deprecated
class UnevaluatableError(exc.InvalidRequestError):
    pass
class _NoObject(operators.ColumnOperators):
    def operate(self, *arg, **kw):
        return None
    def reverse_operate(self, *arg, **kw):
        return None
class _ExpiredObject(operators.ColumnOperators):
    def operate(self, *arg, **kw):
        return self
    def reverse_operate(self, *arg, **kw):
        return self
_NO_OBJECT = _NoObject()
_EXPIRED_OBJECT = _ExpiredObject()
class _EvaluatorCompiler:
    def __init__(self, target_cls=None):
        self.target_cls = target_cls
    def process(self, clause, *clauses):
        if clauses:
            clause = and_(clause, *clauses)
        meth = getattr(self, f"visit_{clause.__visit_name__}", None)
        if not meth:
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/orm/unitofwork.py =====
"""The internals for the unit of work system.
The session's flush() process passes objects to a contextual object
here, which assembles flush tasks based on mappers and their properties,
organizes them in order of dependency, and executes.
"""
from __future__ import annotations
from typing import Any
from typing import Dict
from typing import Optional
from typing import Set
from typing import TYPE_CHECKING
from . import attributes
from . import exc as orm_exc
from . import util as orm_util
from .. import event
from .. import util
from ..util import topological
if TYPE_CHECKING:
    from .dependency import DependencyProcessor
    from .interfaces import MapperProperty
    from .mapper import Mapper
    from .session import Session
    from .session import SessionTransaction
    from .state import InstanceState
def track_cascade_events(descriptor, prop):
    """Establish event listeners on object attributes which handle
    cascade-on-set/append.
    """
    key = prop.key
    def append(state, item, initiator, **kw):
        # process "save_update" cascade rules for when
        # an instance is appended to the list of another instance
        if item is None:
            return
        sess = state.session
        if sess:
            if sess._warn_on_events:
                sess._flush_warning("collection append")
            prop = state.manager.mapper._props[key]
            item_state = attributes.instance_state(item)
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/orm/base.py =====
"""Constants and rudimental functions used throughout the ORM."""
from __future__ import annotations
from enum import Enum
import operator
import typing
from typing import Any
from typing import Callable
from typing import Dict
from typing import Generic
from typing import no_type_check
from typing import Optional
from typing import overload
from typing import Tuple
from typing import Type
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union
from . import exc
from ._typing import insp_is_mapper
from .. import exc as sa_exc
from .. import inspection
from .. import util
from ..sql import roles
from ..sql.elements import SQLColumnExpression
from ..sql.elements import SQLCoreOperations
from ..util import FastIntFlag
from ..util.langhelpers import TypingOnly
from ..util.typing import Literal
if typing.TYPE_CHECKING:
    from ._typing import _EntityType
    from ._typing import _ExternalEntityType
    from ._typing import _InternalEntityType
    from .attributes import InstrumentedAttribute
    from .dynamic import AppenderQuery
    from .instrumentation import ClassManager
    from .interfaces import PropComparator
    from .mapper import Mapper
    from .state import InstanceState
    from .util import AliasedClass
    from .writeonly import WriteOnlyCollection
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/orm/relationships.py =====
"""Heuristics related to join conditions as used in
:func:`_orm.relationship`.
Provides the :class:`.JoinCondition` object, which encapsulates
SQL annotation and aliasing behavior focused on the `primaryjoin`
and `secondaryjoin` aspects of :func:`_orm.relationship`.
"""
from __future__ import annotations
import collections
from collections import abc
import dataclasses
import inspect as _py_inspect
import itertools
import re
import typing
from typing import Any
from typing import Callable
from typing import cast
from typing import Collection
from typing import Dict
from typing import FrozenSet
from typing import Generic
from typing import Iterable
from typing import Iterator
from typing import List
from typing import NamedTuple
from typing import NoReturn
from typing import Optional
from typing import Sequence
from typing import Set
from typing import Tuple
from typing import Type
from typing import TypeVar
from typing import Union
import weakref
from . import attributes
from . import strategy_options
from ._typing import insp_is_aliased_class
from ._typing import is_has_collection_adapter
from .base import _DeclarativeMapped
from .base import _is_mapped_class
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/orm/state.py =====
"""Defines instrumentation of instances.
This module is usually not directly visible to user applications, but
defines a large part of the ORM's interactivity.
"""
from __future__ import annotations
from typing import Any
from typing import Callable
from typing import Dict
from typing import Generic
from typing import Iterable
from typing import Optional
from typing import Set
from typing import Tuple
from typing import TYPE_CHECKING
from typing import Union
import weakref
from . import base
from . import exc as orm_exc
from . import interfaces
from ._typing import _O
from ._typing import is_collection_impl
from .base import ATTR_WAS_SET
from .base import INIT_OK
from .base import LoaderCallableStatus
from .base import NEVER_SET
from .base import NO_VALUE
from .base import PASSIVE_NO_INITIALIZE
from .base import PASSIVE_NO_RESULT
from .base import PASSIVE_OFF
from .base import SQL_OK
from .path_registry import PathRegistry
from .. import exc as sa_exc
from .. import inspection
from .. import util
from ..util.typing import Literal
from ..util.typing import Protocol
if TYPE_CHECKING:
    from ._typing import _IdentityKeyType
    from ._typing import _InstanceDict
    from ._typing import _LoaderCallable
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/engine/interfaces.py =====
"""Define core interfaces used by the engine system."""
from __future__ import annotations
from enum import Enum
from typing import Any
from typing import Awaitable
from typing import Callable
from typing import ClassVar
from typing import Collection
from typing import Dict
from typing import Iterable
from typing import Iterator
from typing import List
from typing import Mapping
from typing import MutableMapping
from typing import Optional
from typing import Sequence
from typing import Set
from typing import Tuple
from typing import Type
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union
from .. import util
from ..event import EventTarget
from ..pool import Pool
from ..pool import PoolProxiedConnection as PoolProxiedConnection
from ..sql.compiler import Compiled as Compiled
from ..sql.compiler import Compiled  # noqa
from ..sql.compiler import TypeCompiler as TypeCompiler
from ..sql.compiler import TypeCompiler  # noqa
from ..util import immutabledict
from ..util.concurrency import await_only
from ..util.typing import Literal
from ..util.typing import NotRequired
from ..util.typing import Protocol
from ..util.typing import TypedDict
if TYPE_CHECKING:
    from .base import Connection
    from .base import Engine
    from .cursor import CursorResult
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/engine/_py_row.py =====
from __future__ import annotations
import operator
import typing
from typing import Any
from typing import Callable
from typing import Dict
from typing import Iterator
from typing import List
from typing import Mapping
from typing import Optional
from typing import Tuple
from typing import Type
if typing.TYPE_CHECKING:
    from .result import _KeyType
    from .result import _ProcessorsType
    from .result import _RawRowType
    from .result import _TupleGetterType
    from .result import ResultMetaData
MD_INDEX = 0  # integer index in cursor.description
class BaseRow:
    __slots__ = ("_parent", "_data", "_key_to_index")
    _parent: ResultMetaData
    _key_to_index: Mapping[_KeyType, int]
    _data: _RawRowType
    def __init__(
        self,
        parent: ResultMetaData,
        processors: Optional[_ProcessorsType],
        key_to_index: Mapping[_KeyType, int],
        data: _RawRowType,
    ):
        """Row objects are constructed by CursorResult objects."""
        object.__setattr__(self, "_parent", parent)
        object.__setattr__(self, "_key_to_index", key_to_index)
        if processors:
            object.__setattr__(
                self,
                "_data",
                tuple(
                    [
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/engine/characteristics.py =====
from __future__ import annotations
import abc
import typing
from typing import Any
from typing import ClassVar
if typing.TYPE_CHECKING:
    from .base import Connection
    from .interfaces import DBAPIConnection
    from .interfaces import Dialect
class ConnectionCharacteristic(abc.ABC):
    """An abstract base for an object that can set, get and reset a
    per-connection characteristic, typically one that gets reset when the
    connection is returned to the connection pool.
    transaction isolation is the canonical example, and the
    ``IsolationLevelCharacteristic`` implementation provides this for the
    ``DefaultDialect``.
    The ``ConnectionCharacteristic`` class should call upon the ``Dialect`` for
    the implementation of each method.   The object exists strictly to serve as
    a dialect visitor that can be placed into the
    ``DefaultDialect.connection_characteristics`` dictionary where it will take
    effect for calls to :meth:`_engine.Connection.execution_options` and
    related APIs.
    .. versionadded:: 1.4
    """
    __slots__ = ()
    transactional: ClassVar[bool] = False
    @abc.abstractmethod
    def reset_characteristic(
        self, dialect: Dialect, dbapi_conn: DBAPIConnection
    ) -> None:
        """Reset the characteristic on the DBAPI connection to its default
        value."""
    @abc.abstractmethod
    def set_characteristic(
        self, dialect: Dialect, dbapi_conn: DBAPIConnection, value: Any
    ) -> None:
        """set characteristic on the DBAPI connection to a given value."""
    def set_connection_characteristic(
        self,
        dialect: Dialect,
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/engine/create.py =====
from __future__ import annotations
import inspect
import typing
from typing import Any
from typing import Callable
from typing import cast
from typing import Dict
from typing import List
from typing import Optional
from typing import overload
from typing import Type
from typing import Union
from . import base
from . import url as _url
from .interfaces import DBAPIConnection
from .mock import create_mock_engine
from .. import event
from .. import exc
from .. import util
from ..pool import _AdhocProxiedConnection
from ..pool import ConnectionPoolEntry
from ..sql import compiler
from ..util import immutabledict
if typing.TYPE_CHECKING:
    from .base import Engine
    from .interfaces import _ExecuteOptions
    from .interfaces import _ParamStyle
    from .interfaces import IsolationLevel
    from .url import URL
    from ..log import _EchoFlagType
    from ..pool import _CreatorFnType
    from ..pool import _CreatorWRecFnType
    from ..pool import _ResetStyleArgType
    from ..pool import Pool
    from ..util.typing import Literal
@overload
def create_engine(
    url: Union[str, URL],
    *,
    connect_args: Dict[Any, Any] = ...,
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/engine/strategies.py =====
"""Deprecated mock engine strategy used by Alembic."""
from __future__ import annotations
from .mock import MockConnection  # noqa
class MockEngineStrategy:
    MockConnection = MockConnection
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/engine/util.py =====
from __future__ import annotations
import typing
from typing import Any
from typing import Callable
from typing import Optional
from typing import TypeVar
from .. import exc
from .. import util
from ..util._has_cy import HAS_CYEXTENSION
from ..util.typing import Protocol
from ..util.typing import Self
if typing.TYPE_CHECKING or not HAS_CYEXTENSION:
    from ._py_util import _distill_params_20 as _distill_params_20
    from ._py_util import _distill_raw_params as _distill_raw_params
else:
    from sqlalchemy.cyextension.util import (  # noqa: F401
        _distill_params_20 as _distill_params_20,
    )
    from sqlalchemy.cyextension.util import (  # noqa: F401
        _distill_raw_params as _distill_raw_params,
    )
_C = TypeVar("_C", bound=Callable[[], Any])
def connection_memoize(key: str) -> Callable[[_C], _C]:
    """Decorator, memoize a function in a connection.info stash.
    Only applicable to functions which take no arguments other than a
    connection.  The memo will be stored in ``connection.info[key]``.
    """
    @util.decorator
    def decorated(fn, self, connection):  # type: ignore
        connection = connection.connect()
        try:
            return connection.info[key]
        except KeyError:
            connection.info[key] = val = fn(self, connection)
            return val
    return decorated
class _TConsSubject(Protocol):
    _trans_context_manager: Optional[TransactionalContext]
class TransactionalContext:
    """Apply Python context manager behavior to transaction objects.
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/engine/events.py =====
from __future__ import annotations
import typing
from typing import Any
from typing import Dict
from typing import Optional
from typing import Tuple
from typing import Type
from typing import Union
from .base import Connection
from .base import Engine
from .interfaces import ConnectionEventsTarget
from .interfaces import DBAPIConnection
from .interfaces import DBAPICursor
from .interfaces import Dialect
from .. import event
from .. import exc
from ..util.typing import Literal
if typing.TYPE_CHECKING:
    from .interfaces import _CoreMultiExecuteParams
    from .interfaces import _CoreSingleExecuteParams
    from .interfaces import _DBAPIAnyExecuteParams
    from .interfaces import _DBAPIMultiExecuteParams
    from .interfaces import _DBAPISingleExecuteParams
    from .interfaces import _ExecuteOptions
    from .interfaces import ExceptionContext
    from .interfaces import ExecutionContext
    from .result import Result
    from ..pool import ConnectionPoolEntry
    from ..sql import Executable
    from ..sql.elements import BindParameter
class ConnectionEvents(event.Events[ConnectionEventsTarget]):
    """Available events for
    :class:`_engine.Connection` and :class:`_engine.Engine`.
    The methods here define the name of an event as well as the names of
    members that are passed to listener functions.
    An event listener can be associated with any
    :class:`_engine.Connection` or :class:`_engine.Engine`
    class or instance, such as an :class:`_engine.Engine`, e.g.::
        from sqlalchemy import event, create_engine
        def before_cursor_execute(
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/engine/reflection.py =====
"""Provides an abstraction for obtaining database schema information.
Usage Notes:
Here are some general conventions when accessing the low level inspector
methods such as get_table_names, get_columns, etc.
1. Inspector methods return lists of dicts in most cases for the following
   reasons:
   * They're both standard types that can be serialized.
   * Using a dict instead of a tuple allows easy expansion of attributes.
   * Using a list for the outer structure maintains order and is easy to work
     with (e.g. list comprehension [d['name'] for d in cols]).
2. Records that contain a name, such as the column name in a column record
   use the key 'name'. So for most return values, each record will have a
   'name' attribute..
"""
from __future__ import annotations
import contextlib
from dataclasses import dataclass
from enum import auto
from enum import Flag
from enum import unique
from typing import Any
from typing import Callable
from typing import Collection
from typing import Dict
from typing import Generator
from typing import Iterable
from typing import List
from typing import Optional
from typing import Sequence
from typing import Set
from typing import Tuple
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union
from .base import Connection
from .base import Engine
from .. import exc
from .. import inspection
from .. import sql
from .. import util
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/engine/__init__.py =====
"""SQL connections, SQL execution and high-level DB-API interface.
The engine package defines the basic components used to interface
DB-API modules with higher-level statement construction,
connection-management, execution and result contexts.  The primary
"entry point" class into this package is the Engine and its public
constructor ``create_engine()``.
"""
from . import events as events
from . import util as util
from .base import Connection as Connection
from .base import Engine as Engine
from .base import NestedTransaction as NestedTransaction
from .base import RootTransaction as RootTransaction
from .base import Transaction as Transaction
from .base import TwoPhaseTransaction as TwoPhaseTransaction
from .create import create_engine as create_engine
from .create import create_pool_from_url as create_pool_from_url
from .create import engine_from_config as engine_from_config
from .cursor import CursorResult as CursorResult
from .cursor import ResultProxy as ResultProxy
from .interfaces import AdaptedConnection as AdaptedConnection
from .interfaces import BindTyping as BindTyping
from .interfaces import Compiled as Compiled
from .interfaces import Connectable as Connectable
from .interfaces import ConnectArgsType as ConnectArgsType
from .interfaces import ConnectionEventsTarget as ConnectionEventsTarget
from .interfaces import CreateEnginePlugin as CreateEnginePlugin
from .interfaces import Dialect as Dialect
from .interfaces import ExceptionContext as ExceptionContext
from .interfaces import ExecutionContext as ExecutionContext
from .interfaces import TypeCompiler as TypeCompiler
from .mock import create_mock_engine as create_mock_engine
from .reflection import Inspector as Inspector
from .reflection import ObjectKind as ObjectKind
from .reflection import ObjectScope as ObjectScope
from .result import ChunkedIteratorResult as ChunkedIteratorResult
from .result import FilterResult as FilterResult
from .result import FrozenResult as FrozenResult
from .result import IteratorResult as IteratorResult
from .result import MappingResult as MappingResult
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/engine/url.py =====
"""Provides the :class:`~sqlalchemy.engine.url.URL` class which encapsulates
information about a database connection specification.
The URL object is created automatically when
:func:`~sqlalchemy.engine.create_engine` is called with a string
argument; alternatively, the URL is a public-facing construct which can
be used directly and is also accepted directly by ``create_engine()``.
"""
from __future__ import annotations
import collections.abc as collections_abc
import re
from typing import Any
from typing import cast
from typing import Dict
from typing import Iterable
from typing import List
from typing import Mapping
from typing import NamedTuple
from typing import Optional
from typing import overload
from typing import Sequence
from typing import Tuple
from typing import Type
from typing import Union
from urllib.parse import parse_qsl
from urllib.parse import quote
from urllib.parse import quote_plus
from urllib.parse import unquote
from .interfaces import Dialect
from .. import exc
from .. import util
from ..dialects import plugins
from ..dialects import registry
class URL(NamedTuple):
    """
    Represent the components of a URL used to connect to a database.
    URLs are typically constructed from a fully formatted URL string, where the
    :func:`.make_url` function is used internally by the
    :func:`_sa.create_engine` function in order to parse the URL string into
    its individual components, which are then used to construct a new
    :class:`.URL` object. When parsing from a formatted URL string, the parsing
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/engine/result.py =====
"""Define generic result set constructs."""
from __future__ import annotations
from enum import Enum
import functools
import itertools
import operator
import typing
from typing import Any
from typing import Callable
from typing import cast
from typing import Dict
from typing import Generic
from typing import Iterable
from typing import Iterator
from typing import List
from typing import Mapping
from typing import NoReturn
from typing import Optional
from typing import overload
from typing import Sequence
from typing import Set
from typing import Tuple
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union
from .row import Row
from .row import RowMapping
from .. import exc
from .. import util
from ..sql.base import _generative
from ..sql.base import HasMemoized
from ..sql.base import InPlaceGenerative
from ..util import HasMemoized_ro_memoized_attribute
from ..util import NONE_SET
from ..util._has_cy import HAS_CYEXTENSION
from ..util.typing import Literal
from ..util.typing import Self
if typing.TYPE_CHECKING or not HAS_CYEXTENSION:
    from ._py_row import tuplegetter as tuplegetter
else:
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/engine/default.py =====
"""Default implementations of per-dialect sqlalchemy.engine classes.
These are semi-private implementation classes which are only of importance
to database dialect authors; dialects will usually use the classes here
as the base class for their own corresponding classes.
"""
from __future__ import annotations
import functools
import operator
import random
import re
from time import perf_counter
import typing
from typing import Any
from typing import Callable
from typing import cast
from typing import Dict
from typing import List
from typing import Mapping
from typing import MutableMapping
from typing import MutableSequence
from typing import Optional
from typing import Sequence
from typing import Set
from typing import Tuple
from typing import Type
from typing import TYPE_CHECKING
from typing import Union
import weakref
from . import characteristics
from . import cursor as _cursor
from . import interfaces
from .base import Connection
from .interfaces import CacheStats
from .interfaces import DBAPICursor
from .interfaces import Dialect
from .interfaces import ExecuteStyle
from .interfaces import ExecutionContext
from .reflection import ObjectKind
from .reflection import ObjectScope
from .. import event
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/engine/_py_processors.py =====
"""defines generic type conversion functions, as used in bind and result
processors.
They all share one common characteristic: None is passed through unchanged.
"""
from __future__ import annotations
import datetime
from datetime import date as date_cls
from datetime import datetime as datetime_cls
from datetime import time as time_cls
from decimal import Decimal
import typing
from typing import Any
from typing import Callable
from typing import Optional
from typing import Type
from typing import TypeVar
from typing import Union
_DT = TypeVar(
    "_DT", bound=Union[datetime.datetime, datetime.time, datetime.date]
)
def str_to_datetime_processor_factory(
    regexp: typing.Pattern[str], type_: Callable[..., _DT]
) -> Callable[[Optional[str]], Optional[_DT]]:
    rmatch = regexp.match
    # Even on python2.6 datetime.strptime is both slower than this code
    # and it does not support microseconds.
    has_named_groups = bool(regexp.groupindex)
    def process(value: Optional[str]) -> Optional[_DT]:
        if value is None:
            return None
        else:
            try:
                m = rmatch(value)
            except TypeError as err:
                raise ValueError(
                    "Couldn't parse %s string '%r' "
                    "- value is not a string." % (type_.__name__, value)
                ) from err
            if m is None:
                raise ValueError(
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/engine/processors.py =====
"""defines generic type conversion functions, as used in bind and result
processors.
They all share one common characteristic: None is passed through unchanged.
"""
from __future__ import annotations
import typing
from ._py_processors import str_to_datetime_processor_factory  # noqa
from ..util._has_cy import HAS_CYEXTENSION
if typing.TYPE_CHECKING or not HAS_CYEXTENSION:
    from ._py_processors import int_to_boolean as int_to_boolean
    from ._py_processors import str_to_date as str_to_date
    from ._py_processors import str_to_datetime as str_to_datetime
    from ._py_processors import str_to_time as str_to_time
    from ._py_processors import (
        to_decimal_processor_factory as to_decimal_processor_factory,
    )
    from ._py_processors import to_float as to_float
    from ._py_processors import to_str as to_str
else:
    from sqlalchemy.cyextension.processors import (
        DecimalResultProcessor,
    )
    from sqlalchemy.cyextension.processors import (  # noqa: F401
        int_to_boolean as int_to_boolean,
    )
    from sqlalchemy.cyextension.processors import (  # noqa: F401,E501
        str_to_date as str_to_date,
    )
    from sqlalchemy.cyextension.processors import (  # noqa: F401
        str_to_datetime as str_to_datetime,
    )
    from sqlalchemy.cyextension.processors import (  # noqa: F401,E501
        str_to_time as str_to_time,
    )
    from sqlalchemy.cyextension.processors import (  # noqa: F401,E501
        to_float as to_float,
    )
    from sqlalchemy.cyextension.processors import (  # noqa: F401,E501
        to_str as to_str,
    )
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/engine/row.py =====
"""Define row constructs including :class:`.Row`."""
from __future__ import annotations
from abc import ABC
import collections.abc as collections_abc
import operator
import typing
from typing import Any
from typing import Callable
from typing import Dict
from typing import Generic
from typing import Iterator
from typing import List
from typing import Mapping
from typing import NoReturn
from typing import Optional
from typing import overload
from typing import Sequence
from typing import Tuple
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union
from ..sql import util as sql_util
from ..util import deprecated
from ..util._has_cy import HAS_CYEXTENSION
if TYPE_CHECKING or not HAS_CYEXTENSION:
    from ._py_row import BaseRow as BaseRow
else:
    from sqlalchemy.cyextension.resultproxy import BaseRow as BaseRow
if TYPE_CHECKING:
    from .result import _KeyType
    from .result import _ProcessorsType
    from .result import RMKeyView
_T = TypeVar("_T", bound=Any)
_TP = TypeVar("_TP", bound=Tuple[Any, ...])
class Row(BaseRow, Sequence[Any], Generic[_TP]):
    """Represent a single result row.
    The :class:`.Row` object represents a row of a database result.  It is
    typically associated in the 1.x series of SQLAlchemy with the
    :class:`_engine.CursorResult` object, however is also used by the ORM for
    tuple-like results as of SQLAlchemy 1.4.
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/engine/base.py =====
"""Defines :class:`_engine.Connection` and :class:`_engine.Engine`."""
from __future__ import annotations
import contextlib
import sys
import typing
from typing import Any
from typing import Callable
from typing import cast
from typing import Iterable
from typing import Iterator
from typing import List
from typing import Mapping
from typing import NoReturn
from typing import Optional
from typing import overload
from typing import Tuple
from typing import Type
from typing import TypeVar
from typing import Union
from .interfaces import BindTyping
from .interfaces import ConnectionEventsTarget
from .interfaces import DBAPICursor
from .interfaces import ExceptionContext
from .interfaces import ExecuteStyle
from .interfaces import ExecutionContext
from .interfaces import IsolationLevel
from .util import _distill_params_20
from .util import _distill_raw_params
from .util import TransactionalContext
from .. import exc
from .. import inspection
from .. import log
from .. import util
from ..sql import compiler
from ..sql import util as sql_util
if typing.TYPE_CHECKING:
    from . import CursorResult
    from . import ScalarResult
    from .interfaces import _AnyExecuteParams
    from .interfaces import _AnyMultiExecuteParams
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/engine/cursor.py =====
"""Define cursor-specific result set constructs including
:class:`.CursorResult`."""
from __future__ import annotations
import collections
import functools
import operator
import typing
from typing import Any
from typing import cast
from typing import ClassVar
from typing import Dict
from typing import Iterable
from typing import Iterator
from typing import List
from typing import Mapping
from typing import NoReturn
from typing import Optional
from typing import Sequence
from typing import Tuple
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union
from .result import IteratorResult
from .result import MergedResult
from .result import Result
from .result import ResultMetaData
from .result import SimpleResultMetaData
from .result import tuplegetter
from .row import Row
from .. import exc
from .. import util
from ..sql import elements
from ..sql import sqltypes
from ..sql import util as sql_util
from ..sql.base import _generative
from ..sql.compiler import ResultColumnsEntry
from ..sql.compiler import RM_NAME
from ..sql.compiler import RM_OBJECTS
from ..sql.compiler import RM_RENDERED_NAME
from ..sql.compiler import RM_TYPE
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/engine/mock.py =====
from __future__ import annotations
from operator import attrgetter
import typing
from typing import Any
from typing import Callable
from typing import cast
from typing import Optional
from typing import Type
from typing import Union
from . import url as _url
from .. import util
if typing.TYPE_CHECKING:
    from .base import Engine
    from .interfaces import _CoreAnyExecuteParams
    from .interfaces import CoreExecuteOptionsParameter
    from .interfaces import Dialect
    from .url import URL
    from ..sql.base import Executable
    from ..sql.ddl import InvokeDDLBase
    from ..sql.schema import HasSchemaAttr
    from ..sql.visitors import Visitable
class MockConnection:
    def __init__(self, dialect: Dialect, execute: Callable[..., Any]):
        self._dialect = dialect
        self._execute_impl = execute
    engine: Engine = cast(Any, property(lambda s: s))
    dialect: Dialect = cast(Any, property(attrgetter("_dialect")))
    name: str = cast(Any, property(lambda s: s._dialect.name))
    def connect(self, **kwargs: Any) -> MockConnection:
        return self
    def schema_for_object(self, obj: HasSchemaAttr) -> Optional[str]:
        return obj.schema
    def execution_options(self, **kw: Any) -> MockConnection:
        return self
    def _run_ddl_visitor(
        self,
        visitorcallable: Type[InvokeDDLBase],
        element: Visitable,
        **kwargs: Any,
    ) -> None:
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/engine/_py_util.py =====
from __future__ import annotations
import typing
from typing import Any
from typing import Mapping
from typing import Optional
from typing import Tuple
from .. import exc
if typing.TYPE_CHECKING:
    from .interfaces import _CoreAnyExecuteParams
    from .interfaces import _CoreMultiExecuteParams
    from .interfaces import _DBAPIAnyExecuteParams
    from .interfaces import _DBAPIMultiExecuteParams
_no_tuple: Tuple[Any, ...] = ()
def _distill_params_20(
    params: Optional[_CoreAnyExecuteParams],
) -> _CoreMultiExecuteParams:
    if params is None:
        return _no_tuple
    # Assume list is more likely than tuple
    elif isinstance(params, list) or isinstance(params, tuple):
        # collections_abc.MutableSequence): # avoid abc.__instancecheck__
        if params and not isinstance(params[0], Mapping):
            raise exc.ArgumentError(
                "List argument must consist only of dictionaries"
            )
        return params
    elif isinstance(params, dict) or isinstance(
        # only do immutabledict or abc.__instancecheck__ for Mapping after
        # we've checked for plain dictionaries and would otherwise raise
        params,
        Mapping,
    ):
        return [params]
    else:
        raise exc.ArgumentError("mapping or list expected for parameters")
def _distill_raw_params(
    params: Optional[_DBAPIAnyExecuteParams],
) -> _DBAPIMultiExecuteParams:
    if params is None:
        return _no_tuple
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/pool/events.py =====
from __future__ import annotations
import typing
from typing import Any
from typing import Optional
from typing import Type
from typing import Union
from .base import ConnectionPoolEntry
from .base import Pool
from .base import PoolProxiedConnection
from .base import PoolResetState
from .. import event
from .. import util
if typing.TYPE_CHECKING:
    from ..engine import Engine
    from ..engine.interfaces import DBAPIConnection
class PoolEvents(event.Events[Pool]):
    """Available events for :class:`_pool.Pool`.
    The methods here define the name of an event as well
    as the names of members that are passed to listener
    functions.
    e.g.::
        from sqlalchemy import event
        def my_on_checkout(dbapi_conn, connection_rec, connection_proxy):
            "handle an on checkout event"
        event.listen(Pool, "checkout", my_on_checkout)
    In addition to accepting the :class:`_pool.Pool` class and
    :class:`_pool.Pool` instances, :class:`_events.PoolEvents` also accepts
    :class:`_engine.Engine` objects and the :class:`_engine.Engine` class as
    targets, which will be resolved to the ``.pool`` attribute of the
    given engine or the :class:`_pool.Pool` class::
        engine = create_engine("postgresql+psycopg2://scott:tiger@localhost/test")
        # will associate with engine.pool
        event.listen(engine, "checkout", my_on_checkout)
    """  # noqa: E501
    _target_class_doc = "SomeEngineOrPool"
    _dispatch_target = Pool
    @util.preload_module("sqlalchemy.engine")
    @classmethod
    def _accept_with(
        cls,
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/pool/__init__.py =====
"""Connection pooling for DB-API connections.
Provides a number of connection pool implementations for a variety of
usage scenarios and thread behavior requirements imposed by the
application, DB-API or database itself.
Also provides a DB-API 2.0 connection proxying mechanism allowing
regular DB-API connect() methods to be transparently managed by a
SQLAlchemy connection pool.
"""
from . import events
from .base import _AdhocProxiedConnection as _AdhocProxiedConnection
from .base import _ConnectionFairy as _ConnectionFairy
from .base import _ConnectionRecord
from .base import _CreatorFnType as _CreatorFnType
from .base import _CreatorWRecFnType as _CreatorWRecFnType
from .base import _finalize_fairy
from .base import _ResetStyleArgType as _ResetStyleArgType
from .base import ConnectionPoolEntry as ConnectionPoolEntry
from .base import ManagesConnection as ManagesConnection
from .base import Pool as Pool
from .base import PoolProxiedConnection as PoolProxiedConnection
from .base import PoolResetState as PoolResetState
from .base import reset_commit as reset_commit
from .base import reset_none as reset_none
from .base import reset_rollback as reset_rollback
from .impl import AssertionPool as AssertionPool
from .impl import AsyncAdaptedQueuePool as AsyncAdaptedQueuePool
from .impl import (
    FallbackAsyncAdaptedQueuePool as FallbackAsyncAdaptedQueuePool,
)
from .impl import NullPool as NullPool
from .impl import QueuePool as QueuePool
from .impl import SingletonThreadPool as SingletonThreadPool
from .impl import StaticPool as StaticPool
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/pool/impl.py =====
"""Pool implementation classes."""
from __future__ import annotations
import threading
import traceback
import typing
from typing import Any
from typing import cast
from typing import List
from typing import Optional
from typing import Set
from typing import Type
from typing import TYPE_CHECKING
from typing import Union
import weakref
from .base import _AsyncConnDialect
from .base import _ConnectionFairy
from .base import _ConnectionRecord
from .base import _CreatorFnType
from .base import _CreatorWRecFnType
from .base import ConnectionPoolEntry
from .base import Pool
from .base import PoolProxiedConnection
from .. import exc
from .. import util
from ..util import chop_traceback
from ..util import queue as sqla_queue
from ..util.typing import Literal
if typing.TYPE_CHECKING:
    from ..engine.interfaces import DBAPIConnection
class QueuePool(Pool):
    """A :class:`_pool.Pool`
    that imposes a limit on the number of open connections.
    :class:`.QueuePool` is the default pooling implementation used for
    all :class:`_engine.Engine` objects other than SQLite with a ``:memory:``
    database.
    The :class:`.QueuePool` class **is not compatible** with asyncio and
    :func:`_asyncio.create_async_engine`.  The
    :class:`.AsyncAdaptedQueuePool` class is used automatically when
    using :func:`_asyncio.create_async_engine`, if no other kind of pool
    is specified.
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/pool/base.py =====
"""Base constructs for connection pools."""
from __future__ import annotations
from collections import deque
import dataclasses
from enum import Enum
import threading
import time
import typing
from typing import Any
from typing import Callable
from typing import cast
from typing import Deque
from typing import Dict
from typing import List
from typing import Optional
from typing import Tuple
from typing import TYPE_CHECKING
from typing import Union
import weakref
from .. import event
from .. import exc
from .. import log
from .. import util
from ..util.typing import Literal
from ..util.typing import Protocol
if TYPE_CHECKING:
    from ..engine.interfaces import DBAPIConnection
    from ..engine.interfaces import DBAPICursor
    from ..engine.interfaces import Dialect
    from ..event import _DispatchCommon
    from ..event import _ListenerFnType
    from ..event import dispatcher
    from ..sql._typing import _InfoType
@dataclasses.dataclass(frozen=True)
class PoolResetState:
    """describes the state of a DBAPI connection as it is being passed to
    the :meth:`.PoolEvents.reset` connection pool event.
    .. versionadded:: 2.0.0b3
    """
    __slots__ = ("transaction_was_reset", "terminate_only", "asyncio_safe")
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/event/legacy.py =====
"""Routines to handle adaption of legacy call signatures,
generation of deprecation notes and docstrings.
"""
from __future__ import annotations
import typing
from typing import Any
from typing import Callable
from typing import List
from typing import Optional
from typing import Tuple
from typing import Type
from .registry import _ET
from .registry import _ListenerFnType
from .. import util
from ..util.compat import FullArgSpec
if typing.TYPE_CHECKING:
    from .attr import _ClsLevelDispatch
    from .base import _HasEventsDispatch
_LegacySignatureType = Tuple[str, List[str], Optional[Callable[..., Any]]]
def _legacy_signature(
    since: str,
    argnames: List[str],
    converter: Optional[Callable[..., Any]] = None,
) -> Callable[[Callable[..., Any]], Callable[..., Any]]:
    """legacy sig decorator
    :param since: string version for deprecation warning
    :param argnames: list of strings, which is *all* arguments that the legacy
     version accepted, including arguments that are still there
    :param converter: lambda that will accept tuple of this full arg signature
     and return tuple of new arg signature.
    """
    def leg(fn: Callable[..., Any]) -> Callable[..., Any]:
        if not hasattr(fn, "_legacy_signatures"):
            fn._legacy_signatures = []  # type: ignore[attr-defined]
        fn._legacy_signatures.append((since, argnames, converter))  # type: ignore[attr-defined] # noqa: E501
        return fn
    return leg
def _wrap_fn_for_legacy(
    dispatch_collection: _ClsLevelDispatch[_ET],
    fn: _ListenerFnType,
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/event/registry.py =====
"""Provides managed registration services on behalf of :func:`.listen`
arguments.
By "managed registration", we mean that event listening functions and
other objects can be added to various collections in such a way that their
membership in all those collections can be revoked at once, based on
an equivalent :class:`._EventKey`.
"""
from __future__ import annotations
import collections
import types
import typing
from typing import Any
from typing import Callable
from typing import cast
from typing import Deque
from typing import Dict
from typing import Generic
from typing import Iterable
from typing import Optional
from typing import Tuple
from typing import TypeVar
from typing import Union
import weakref
from .. import exc
from .. import util
if typing.TYPE_CHECKING:
    from .attr import RefCollection
    from .base import dispatcher
_ListenerFnType = Callable[..., Any]
_ListenerFnKeyType = Union[int, Tuple[int, int]]
_EventKeyTupleType = Tuple[int, str, _ListenerFnKeyType]
_ET = TypeVar("_ET", bound="EventTarget")
class EventTarget:
    """represents an event target, that is, something we can listen on
    either with that target as a class or as an instance.
    Examples include:  Connection, Mapper, Table, Session,
    InstrumentedAttribute, Engine, Pool, Dialect.
    """
    __slots__ = ()
    dispatch: dispatcher[Any]
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/event/__init__.py =====
from __future__ import annotations
from .api import CANCEL as CANCEL
from .api import contains as contains
from .api import listen as listen
from .api import listens_for as listens_for
from .api import NO_RETVAL as NO_RETVAL
from .api import remove as remove
from .attr import _InstanceLevelDispatch as _InstanceLevelDispatch
from .attr import RefCollection as RefCollection
from .base import _Dispatch as _Dispatch
from .base import _DispatchCommon as _DispatchCommon
from .base import dispatcher as dispatcher
from .base import Events as Events
from .legacy import _legacy_signature as _legacy_signature
from .registry import _EventKey as _EventKey
from .registry import _ListenerFnType as _ListenerFnType
from .registry import EventTarget as EventTarget
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/event/api.py =====
"""Public API functions for the event system."""
from __future__ import annotations
from typing import Any
from typing import Callable
from .base import _registrars
from .registry import _ET
from .registry import _EventKey
from .registry import _ListenerFnType
from .. import exc
from .. import util
CANCEL = util.symbol("CANCEL")
NO_RETVAL = util.symbol("NO_RETVAL")
def _event_key(
    target: _ET, identifier: str, fn: _ListenerFnType
) -> _EventKey[_ET]:
    for evt_cls in _registrars[identifier]:
        tgt = evt_cls._accept_with(target, identifier)
        if tgt is not None:
            return _EventKey(target, identifier, fn, tgt)
    else:
        raise exc.InvalidRequestError(
            "No such event '%s' for target '%s'" % (identifier, target)
        )
def listen(
    target: Any, identifier: str, fn: Callable[..., Any], *args: Any, **kw: Any
) -> None:
    """Register a listener function for the given target.
    The :func:`.listen` function is part of the primary interface for the
    SQLAlchemy event system, documented at :ref:`event_toplevel`.
    e.g.::
        from sqlalchemy import event
        from sqlalchemy.schema import UniqueConstraint
        def unique_constraint_name(const, table):
            const.name = "uq_%s_%s" % (table.name, list(const.columns)[0].name)
        event.listen(
            UniqueConstraint, "after_parent_attach", unique_constraint_name
        )
    :param bool insert: The default behavior for event handlers is to append
      the decorated user defined function to an internal list of registered
      event listeners upon discovery. If a user registers a function with
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/event/attr.py =====
"""Attribute implementation for _Dispatch classes.
The various listener targets for a particular event class are represented
as attributes, which refer to collections of listeners to be fired off.
These collections can exist at the class level as well as at the instance
level.  An event is fired off using code like this::
    some_object.dispatch.first_connect(arg1, arg2)
Above, ``some_object.dispatch`` would be an instance of ``_Dispatch`` and
``first_connect`` is typically an instance of ``_ListenerCollection``
if event listeners are present, or ``_EmptyListener`` if none are present.
The attribute mechanics here spend effort trying to ensure listener functions
are available with a minimum of function call overhead, that unnecessary
objects aren't created (i.e. many empty per-instance listener collections),
as well as that everything is garbage collectable when owning references are
lost.  Other features such as "propagation" of listener functions across
many ``_Dispatch`` instances, "joining" of multiple ``_Dispatch`` instances,
as well as support for subclass propagation (e.g. events assigned to
``Pool`` vs. ``QueuePool``) are all implemented here.
"""
from __future__ import annotations
import collections
from itertools import chain
import threading
from types import TracebackType
import typing
from typing import Any
from typing import cast
from typing import Collection
from typing import Deque
from typing import FrozenSet
from typing import Generic
from typing import Iterator
from typing import MutableMapping
from typing import MutableSequence
from typing import NoReturn
from typing import Optional
from typing import Sequence
from typing import Set
from typing import Tuple
from typing import Type
from typing import TypeVar
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/event/base.py =====
"""Base implementation classes.
The public-facing ``Events`` serves as the base class for an event interface;
its public attributes represent different kinds of events.   These attributes
are mirrored onto a ``_Dispatch`` class, which serves as a container for
collections of listener functions.   These collections are represented both
at the class level of a particular ``_Dispatch`` class as well as within
instances of ``_Dispatch``.
"""
from __future__ import annotations
import typing
from typing import Any
from typing import cast
from typing import Dict
from typing import Generic
from typing import Iterator
from typing import List
from typing import Mapping
from typing import MutableMapping
from typing import Optional
from typing import overload
from typing import Tuple
from typing import Type
from typing import Union
import weakref
from .attr import _ClsLevelDispatch
from .attr import _EmptyListener
from .attr import _InstanceLevelDispatch
from .attr import _JoinedListener
from .registry import _ET
from .registry import _EventKey
from .. import util
from ..util.typing import Literal
_registrars: MutableMapping[str, List[Type[_HasEventsDispatch[Any]]]] = (
    util.defaultdict(list)
)
def _is_event_name(name: str) -> bool:
    # _sa_event prefix is special to support internal-only event names.
    # most event names are just plain method names that aren't
    # underscored.
    return (
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/future/__init__.py =====
"""2.0 API features.
this module is legacy as 2.0 APIs are now standard.
"""
from .engine import Connection as Connection
from .engine import create_engine as create_engine
from .engine import Engine as Engine
from ..sql._selectable_constructors import select as select
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/future/engine.py =====
"""2.0 API features.
this module is legacy as 2.0 APIs are now standard.
"""
from ..engine import Connection as Connection  # noqa: F401
from ..engine import create_engine as create_engine  # noqa: F401
from ..engine import Engine as Engine  # noqa: F401
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/schema.py =====
"""Compatibility namespace for sqlalchemy.sql.schema and related."""
from __future__ import annotations
from .sql.base import SchemaVisitor as SchemaVisitor
from .sql.ddl import _CreateDropBase as _CreateDropBase
from .sql.ddl import _DropView as _DropView
from .sql.ddl import AddConstraint as AddConstraint
from .sql.ddl import BaseDDLElement as BaseDDLElement
from .sql.ddl import CreateColumn as CreateColumn
from .sql.ddl import CreateIndex as CreateIndex
from .sql.ddl import CreateSchema as CreateSchema
from .sql.ddl import CreateSequence as CreateSequence
from .sql.ddl import CreateTable as CreateTable
from .sql.ddl import DDL as DDL
from .sql.ddl import DDLElement as DDLElement
from .sql.ddl import DropColumnComment as DropColumnComment
from .sql.ddl import DropConstraint as DropConstraint
from .sql.ddl import DropConstraintComment as DropConstraintComment
from .sql.ddl import DropIndex as DropIndex
from .sql.ddl import DropSchema as DropSchema
from .sql.ddl import DropSequence as DropSequence
from .sql.ddl import DropTable as DropTable
from .sql.ddl import DropTableComment as DropTableComment
from .sql.ddl import ExecutableDDLElement as ExecutableDDLElement
from .sql.ddl import InvokeDDLBase as InvokeDDLBase
from .sql.ddl import SetColumnComment as SetColumnComment
from .sql.ddl import SetConstraintComment as SetConstraintComment
from .sql.ddl import SetTableComment as SetTableComment
from .sql.ddl import sort_tables as sort_tables
from .sql.ddl import (
    sort_tables_and_constraints as sort_tables_and_constraints,
)
from .sql.naming import conv as conv
from .sql.schema import _get_table_key as _get_table_key
from .sql.schema import BLANK_SCHEMA as BLANK_SCHEMA
from .sql.schema import CheckConstraint as CheckConstraint
from .sql.schema import Column as Column
from .sql.schema import (
    ColumnCollectionConstraint as ColumnCollectionConstraint,
)
from .sql.schema import ColumnCollectionMixin as ColumnCollectionMixin
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/sql/functions.py =====
"""SQL function API, factories, and built-in functions."""
from __future__ import annotations
import datetime
import decimal
from typing import Any
from typing import cast
from typing import Dict
from typing import List
from typing import Mapping
from typing import Optional
from typing import overload
from typing import Sequence
from typing import Tuple
from typing import Type
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union
from . import annotation
from . import coercions
from . import operators
from . import roles
from . import schema
from . import sqltypes
from . import type_api
from . import util as sqlutil
from ._typing import is_table_value_type
from .base import _entity_namespace
from .base import ColumnCollection
from .base import Executable
from .base import Generative
from .base import HasMemoized
from .elements import _type_from_args
from .elements import BinaryExpression
from .elements import BindParameter
from .elements import Cast
from .elements import ClauseList
from .elements import ColumnElement
from .elements import Extract
from .elements import FunctionFilter
from .elements import Grouping
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/sql/annotation.py =====
"""The :class:`.Annotated` class and related routines; creates hash-equivalent
copies of SQL constructs which contain context-specific markers and
associations.
Note that the :class:`.Annotated` concept as implemented in this module is not
related in any way to the pep-593 concept of "Annotated".
"""
from __future__ import annotations
import typing
from typing import Any
from typing import Callable
from typing import cast
from typing import Dict
from typing import FrozenSet
from typing import Mapping
from typing import Optional
from typing import overload
from typing import Sequence
from typing import Tuple
from typing import Type
from typing import TYPE_CHECKING
from typing import TypeVar
from . import operators
from .cache_key import HasCacheKey
from .visitors import anon_map
from .visitors import ExternallyTraversible
from .visitors import InternalTraversal
from .. import util
from ..util.typing import Literal
from ..util.typing import Self
if TYPE_CHECKING:
    from .base import _EntityNamespace
    from .visitors import _TraverseInternalsType
_AnnotationDict = Mapping[str, Any]
EMPTY_ANNOTATIONS: util.immutabledict[str, Any] = util.EMPTY_DICT
class SupportsAnnotations(ExternallyTraversible):
    __slots__ = ()
    _annotations: util.immutabledict[str, Any] = EMPTY_ANNOTATIONS
    proxy_set: util.generic_fn_descriptor[FrozenSet[Any]]
    _is_immutable: bool
    def _annotate(self, values: _AnnotationDict) -> Self:
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/sql/ddl.py =====
"""
Provides the hierarchy of DDL-defining schema items as well as routines
to invoke them for a create/drop call.
"""
from __future__ import annotations
import contextlib
import typing
from typing import Any
from typing import Callable
from typing import Generic
from typing import Iterable
from typing import List
from typing import Optional
from typing import Sequence as typing_Sequence
from typing import Tuple
from typing import TypeVar
from typing import Union
from . import roles
from .base import _generative
from .base import Executable
from .base import SchemaVisitor
from .elements import ClauseElement
from .. import exc
from .. import util
from ..util import topological
from ..util.typing import Protocol
from ..util.typing import Self
if typing.TYPE_CHECKING:
    from .compiler import Compiled
    from .compiler import DDLCompiler
    from .elements import BindParameter
    from .schema import Column
    from .schema import Constraint
    from .schema import ForeignKeyConstraint
    from .schema import Index
    from .schema import SchemaItem
    from .schema import Sequence as Sequence  # noqa: F401
    from .schema import Table
    from .selectable import TableClause
    from ..engine.base import Connection
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/sql/_selectable_constructors.py =====
from __future__ import annotations
from typing import Any
from typing import Optional
from typing import overload
from typing import Tuple
from typing import TYPE_CHECKING
from typing import Union
from . import coercions
from . import roles
from ._typing import _ColumnsClauseArgument
from ._typing import _no_kw
from .elements import ColumnClause
from .selectable import Alias
from .selectable import CompoundSelect
from .selectable import Exists
from .selectable import FromClause
from .selectable import Join
from .selectable import Lateral
from .selectable import LateralFromClause
from .selectable import NamedFromClause
from .selectable import Select
from .selectable import TableClause
from .selectable import TableSample
from .selectable import Values
if TYPE_CHECKING:
    from ._typing import _FromClauseArgument
    from ._typing import _OnClauseArgument
    from ._typing import _SelectStatementForCompoundArgument
    from ._typing import _T0
    from ._typing import _T1
    from ._typing import _T2
    from ._typing import _T3
    from ._typing import _T4
    from ._typing import _T5
    from ._typing import _T6
    from ._typing import _T7
    from ._typing import _T8
    from ._typing import _T9
    from ._typing import _TP
    from ._typing import _TypedColumnClauseArgument as _TCCA
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/sql/compiler.py =====
"""Base SQL and DDL compiler implementations.
Classes provided include:
:class:`.compiler.SQLCompiler` - renders SQL
strings
:class:`.compiler.DDLCompiler` - renders DDL
(data definition language) strings
:class:`.compiler.GenericTypeCompiler` - renders
type specification strings.
To generate user-defined SQL strings, see
:doc:`/ext/compiler`.
"""
from __future__ import annotations
import collections
import collections.abc as collections_abc
import contextlib
from enum import IntEnum
import functools
import itertools
import operator
import re
from time import perf_counter
import typing
from typing import Any
from typing import Callable
from typing import cast
from typing import ClassVar
from typing import Dict
from typing import FrozenSet
from typing import Iterable
from typing import Iterator
from typing import List
from typing import Mapping
from typing import MutableMapping
from typing import NamedTuple
from typing import NoReturn
from typing import Optional
from typing import Pattern
from typing import Sequence
from typing import Set
from typing import Tuple
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/sql/_typing.py =====
from __future__ import annotations
import operator
from typing import Any
from typing import Callable
from typing import Dict
from typing import Generic
from typing import Iterable
from typing import Mapping
from typing import NoReturn
from typing import Optional
from typing import overload
from typing import Set
from typing import Tuple
from typing import Type
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union
from . import roles
from .. import exc
from .. import util
from ..inspection import Inspectable
from ..util.typing import Literal
from ..util.typing import Protocol
from ..util.typing import TypeAlias
if TYPE_CHECKING:
    from datetime import date
    from datetime import datetime
    from datetime import time
    from datetime import timedelta
    from decimal import Decimal
    from uuid import UUID
    from .base import Executable
    from .compiler import Compiled
    from .compiler import DDLCompiler
    from .compiler import SQLCompiler
    from .dml import UpdateBase
    from .dml import ValuesBase
    from .elements import ClauseElement
    from .elements import ColumnElement
    from .elements import KeyedColumnElement
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/sql/traversals.py =====
from __future__ import annotations
from collections import deque
import collections.abc as collections_abc
import itertools
from itertools import zip_longest
import operator
import typing
from typing import Any
from typing import Callable
from typing import Deque
from typing import Dict
from typing import Iterable
from typing import Optional
from typing import Set
from typing import Tuple
from typing import Type
from . import operators
from .cache_key import HasCacheKey
from .visitors import _TraverseInternalsType
from .visitors import anon_map
from .visitors import ExternallyTraversible
from .visitors import HasTraversalDispatch
from .visitors import HasTraverseInternals
from .. import util
from ..util import langhelpers
from ..util.typing import Self
SKIP_TRAVERSE = util.symbol("skip_traverse")
COMPARE_FAILED = False
COMPARE_SUCCEEDED = True
def compare(obj1: Any, obj2: Any, **kw: Any) -> bool:
    strategy: TraversalComparatorStrategy
    if kw.get("use_proxies", False):
        strategy = ColIdentityComparatorStrategy()
    else:
        strategy = TraversalComparatorStrategy()
    return strategy.compare(obj1, obj2, **kw)
def _preconfigure_traversals(target_hierarchy: Type[Any]) -> None:
    for cls in util.walk_subclasses(target_hierarchy):
        if hasattr(cls, "_generate_cache_attrs") and hasattr(
            cls, "_traverse_internals"
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/sql/cache_key.py =====
from __future__ import annotations
import enum
from itertools import zip_longest
import typing
from typing import Any
from typing import Callable
from typing import Dict
from typing import Iterable
from typing import Iterator
from typing import List
from typing import MutableMapping
from typing import NamedTuple
from typing import Optional
from typing import Sequence
from typing import Tuple
from typing import Union
from .visitors import anon_map
from .visitors import HasTraversalDispatch
from .visitors import HasTraverseInternals
from .visitors import InternalTraversal
from .visitors import prefix_anon_map
from .. import util
from ..inspection import inspect
from ..util import HasMemoized
from ..util.typing import Literal
from ..util.typing import Protocol
if typing.TYPE_CHECKING:
    from .elements import BindParameter
    from .elements import ClauseElement
    from .elements import ColumnElement
    from .visitors import _TraverseInternalsType
    from ..engine.interfaces import _CoreSingleExecuteParams
class _CacheKeyTraversalDispatchType(Protocol):
    def __call__(
        s, self: HasCacheKey, visitor: _CacheKeyTraversal
    ) -> _CacheKeyTraversalDispatchTypeReturn: ...
class CacheConst(enum.Enum):
    NO_CACHE = 0
NO_CACHE = CacheConst.NO_CACHE
_CacheKeyTraversalType = Union[
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/sql/roles.py =====
from __future__ import annotations
from typing import Any
from typing import Generic
from typing import Optional
from typing import TYPE_CHECKING
from typing import TypeVar
from .. import util
from ..util.typing import Literal
if TYPE_CHECKING:
    from ._typing import _PropagateAttrsType
    from .elements import Label
    from .selectable import _SelectIterable
    from .selectable import FromClause
    from .selectable import Subquery
_T = TypeVar("_T", bound=Any)
_T_co = TypeVar("_T_co", bound=Any, covariant=True)
class SQLRole:
    """Define a "role" within a SQL statement structure.
    Classes within SQL Core participate within SQLRole hierarchies in order
    to more accurately indicate where they may be used within SQL statements
    of all types.
    .. versionadded:: 1.4
    """
    __slots__ = ()
    allows_lambda = False
    uses_inspection = False
class UsesInspection:
    __slots__ = ()
    _post_inspect: Literal[None] = None
    uses_inspection = True
class AllowsLambdaRole:
    __slots__ = ()
    allows_lambda = True
class HasCacheKeyRole(SQLRole):
    __slots__ = ()
    _role_name = "Cacheable Core or ORM object"
class ExecutableOptionRole(SQLRole):
    __slots__ = ()
    _role_name = "ExecutionOption Core or ORM object"
class LiteralValueRole(SQLRole):
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/sql/naming.py =====
"""Establish constraint and index naming conventions."""
from __future__ import annotations
import re
from . import events  # noqa
from .base import _NONE_NAME
from .elements import conv as conv
from .schema import CheckConstraint
from .schema import Column
from .schema import Constraint
from .schema import ForeignKeyConstraint
from .schema import Index
from .schema import PrimaryKeyConstraint
from .schema import Table
from .schema import UniqueConstraint
from .. import event
from .. import exc
class ConventionDict:
    def __init__(self, const, table, convention):
        self.const = const
        self._is_fk = isinstance(const, ForeignKeyConstraint)
        self.table = table
        self.convention = convention
        self._const_name = const.name
    def _key_table_name(self):
        return self.table.name
    def _column_X(self, idx, attrname):
        if self._is_fk:
            try:
                fk = self.const.elements[idx]
            except IndexError:
                return ""
            else:
                return getattr(fk.parent, attrname)
        else:
            cols = list(self.const.columns)
            try:
                col = cols[idx]
            except IndexError:
                return ""
            else:
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/sql/util.py =====
"""High level utilities which build upon other modules here."""
from __future__ import annotations
from collections import deque
import copy
from itertools import chain
import typing
from typing import AbstractSet
from typing import Any
from typing import Callable
from typing import cast
from typing import Collection
from typing import Dict
from typing import Iterable
from typing import Iterator
from typing import List
from typing import Optional
from typing import overload
from typing import Sequence
from typing import Tuple
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union
from . import coercions
from . import operators
from . import roles
from . import visitors
from ._typing import is_text_clause
from .annotation import _deep_annotate as _deep_annotate  # noqa: F401
from .annotation import _deep_deannotate as _deep_deannotate  # noqa: F401
from .annotation import _shallow_annotate as _shallow_annotate  # noqa: F401
from .base import _expand_cloned
from .base import _from_objects
from .cache_key import HasCacheKey as HasCacheKey  # noqa: F401
from .ddl import sort_tables as sort_tables  # noqa: F401
from .elements import _find_columns as _find_columns
from .elements import _label_reference
from .elements import _textual_label_reference
from .elements import BindParameter
from .elements import ClauseElement
from .elements import ColumnClause
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/sql/visitors.py =====
"""Visitor/traversal interface and library functions."""
from __future__ import annotations
from collections import deque
from enum import Enum
import itertools
import operator
import typing
from typing import Any
from typing import Callable
from typing import cast
from typing import ClassVar
from typing import Dict
from typing import Iterable
from typing import Iterator
from typing import List
from typing import Mapping
from typing import Optional
from typing import overload
from typing import Tuple
from typing import Type
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union
from .. import exc
from .. import util
from ..util import langhelpers
from ..util._has_cy import HAS_CYEXTENSION
from ..util.typing import Literal
from ..util.typing import Protocol
from ..util.typing import Self
if TYPE_CHECKING:
    from .annotation import _AnnotationDict
    from .elements import ColumnElement
if typing.TYPE_CHECKING or not HAS_CYEXTENSION:
    from ._py_util import prefix_anon_map as prefix_anon_map
    from ._py_util import cache_anon_map as anon_map
else:
    from sqlalchemy.cyextension.util import (  # noqa: F401,E501
        prefix_anon_map as prefix_anon_map,
    )
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/sql/events.py =====
from __future__ import annotations
from typing import Any
from typing import TYPE_CHECKING
from .base import SchemaEventTarget
from .. import event
if TYPE_CHECKING:
    from .schema import Column
    from .schema import Constraint
    from .schema import SchemaItem
    from .schema import Table
    from ..engine.base import Connection
    from ..engine.interfaces import ReflectedColumn
    from ..engine.reflection import Inspector
class DDLEvents(event.Events[SchemaEventTarget]):
    """
    Define event listeners for schema objects,
    that is, :class:`.SchemaItem` and other :class:`.SchemaEventTarget`
    subclasses, including :class:`_schema.MetaData`, :class:`_schema.Table`,
    :class:`_schema.Column`, etc.
    **Create / Drop Events**
    Events emitted when CREATE and DROP commands are emitted to the database.
    The event hooks in this category include :meth:`.DDLEvents.before_create`,
    :meth:`.DDLEvents.after_create`, :meth:`.DDLEvents.before_drop`, and
    :meth:`.DDLEvents.after_drop`.
    These events are emitted when using schema-level methods such as
    :meth:`.MetaData.create_all` and :meth:`.MetaData.drop_all`. Per-object
    create/drop methods such as :meth:`.Table.create`, :meth:`.Table.drop`,
    :meth:`.Index.create` are also included, as well as dialect-specific
    methods such as :meth:`_postgresql.ENUM.create`.
    .. versionadded:: 2.0 :class:`.DDLEvents` event hooks now take place
       for non-table objects including constraints, indexes, and
       dialect-specific schema types.
    Event hooks may be attached directly to a :class:`_schema.Table` object or
    to a :class:`_schema.MetaData` collection, as well as to any
    :class:`.SchemaItem` class or object that can be individually created and
    dropped using a distinct SQL command. Such classes include :class:`.Index`,
    :class:`.Sequence`, and dialect-specific classes such as
    :class:`_postgresql.ENUM`.
    Example using the :meth:`.DDLEvents.after_create` event, where a custom
    event hook will emit an ``ALTER TABLE`` command on the current connection,
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/sql/default_comparator.py =====
"""Default implementation of SQL comparison operations."""
from __future__ import annotations
import typing
from typing import Any
from typing import Callable
from typing import Dict
from typing import NoReturn
from typing import Optional
from typing import Tuple
from typing import Type
from typing import Union
from . import coercions
from . import operators
from . import roles
from . import type_api
from .elements import and_
from .elements import BinaryExpression
from .elements import ClauseElement
from .elements import CollationClause
from .elements import CollectionAggregate
from .elements import ExpressionClauseList
from .elements import False_
from .elements import Null
from .elements import OperatorExpression
from .elements import or_
from .elements import True_
from .elements import UnaryExpression
from .operators import OperatorType
from .. import exc
from .. import util
_T = typing.TypeVar("_T", bound=Any)
if typing.TYPE_CHECKING:
    from .elements import ColumnElement
    from .operators import custom_op
    from .type_api import TypeEngine
def _boolean_compare(
    expr: ColumnElement[Any],
    op: OperatorType,
    obj: Any,
    *,
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/sql/elements.py =====
"""Core SQL expression elements, including :class:`_expression.ClauseElement`,
:class:`_expression.ColumnElement`, and derived classes.
"""
from __future__ import annotations
from decimal import Decimal
from enum import Enum
import itertools
import operator
import re
import typing
from typing import AbstractSet
from typing import Any
from typing import Callable
from typing import cast
from typing import Dict
from typing import FrozenSet
from typing import Generic
from typing import Iterable
from typing import Iterator
from typing import List
from typing import Mapping
from typing import Optional
from typing import overload
from typing import Sequence
from typing import Set
from typing import Tuple as typing_Tuple
from typing import Type
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union
from . import coercions
from . import operators
from . import roles
from . import traversals
from . import type_api
from ._typing import has_schema_attr
from ._typing import is_named_from_clause
from ._typing import is_quoted_name
from ._typing import is_tuple_type
from .annotation import Annotated
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/sql/_dml_constructors.py =====
from __future__ import annotations
from typing import TYPE_CHECKING
from .dml import Delete
from .dml import Insert
from .dml import Update
if TYPE_CHECKING:
    from ._typing import _DMLTableArgument
def insert(table: _DMLTableArgument) -> Insert:
    """Construct an :class:`_expression.Insert` object.
    E.g.::
        from sqlalchemy import insert
        stmt = insert(user_table).values(name="username", fullname="Full Username")
    Similar functionality is available via the
    :meth:`_expression.TableClause.insert` method on
    :class:`_schema.Table`.
    .. seealso::
        :ref:`tutorial_core_insert` - in the :ref:`unified_tutorial`
    :param table: :class:`_expression.TableClause`
     which is the subject of the
     insert.
    :param values: collection of values to be inserted; see
     :meth:`_expression.Insert.values`
     for a description of allowed formats here.
     Can be omitted entirely; a :class:`_expression.Insert` construct
     will also dynamically render the VALUES clause at execution time
     based on the parameters passed to :meth:`_engine.Connection.execute`.
    :param inline: if True, no attempt will be made to retrieve the
     SQL-generated default values to be provided within the statement;
     in particular,
     this allows SQL expressions to be rendered 'inline' within the
     statement without the need to pre-execute them beforehand; for
     backends that support "returning", this turns off the "implicit
     returning" feature for the statement.
    If both :paramref:`_expression.insert.values` and compile-time bind
    parameters are present, the compile-time bind parameters override the
    information specified within :paramref:`_expression.insert.values` on a
    per-key basis.
    The keys within :paramref:`_expression.Insert.values` can be either
    :class:`~sqlalchemy.schema.Column` objects or their string
    identifiers. Each key may reference one of:
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/sql/__init__.py =====
from typing import Any
from typing import TYPE_CHECKING
from ._typing import ColumnExpressionArgument as ColumnExpressionArgument
from ._typing import NotNullable as NotNullable
from ._typing import Nullable as Nullable
from .base import Executable as Executable
from .compiler import COLLECT_CARTESIAN_PRODUCTS as COLLECT_CARTESIAN_PRODUCTS
from .compiler import FROM_LINTING as FROM_LINTING
from .compiler import NO_LINTING as NO_LINTING
from .compiler import WARN_LINTING as WARN_LINTING
from .ddl import BaseDDLElement as BaseDDLElement
from .ddl import DDL as DDL
from .ddl import DDLElement as DDLElement
from .ddl import ExecutableDDLElement as ExecutableDDLElement
from .expression import Alias as Alias
from .expression import alias as alias
from .expression import all_ as all_
from .expression import and_ as and_
from .expression import any_ as any_
from .expression import asc as asc
from .expression import between as between
from .expression import bindparam as bindparam
from .expression import case as case
from .expression import cast as cast
from .expression import ClauseElement as ClauseElement
from .expression import collate as collate
from .expression import column as column
from .expression import ColumnCollection as ColumnCollection
from .expression import ColumnElement as ColumnElement
from .expression import CompoundSelect as CompoundSelect
from .expression import cte as cte
from .expression import Delete as Delete
from .expression import delete as delete
from .expression import desc as desc
from .expression import distinct as distinct
from .expression import except_ as except_
from .expression import except_all as except_all
from .expression import exists as exists
from .expression import extract as extract
from .expression import false as false
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/sql/_elements_constructors.py =====
from __future__ import annotations
import typing
from typing import Any
from typing import Callable
from typing import Mapping
from typing import Optional
from typing import overload
from typing import Sequence
from typing import Tuple as typing_Tuple
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union
from . import coercions
from . import roles
from .base import _NoArg
from .coercions import _document_text_coercion
from .elements import BindParameter
from .elements import BooleanClauseList
from .elements import Case
from .elements import Cast
from .elements import CollationClause
from .elements import CollectionAggregate
from .elements import ColumnClause
from .elements import ColumnElement
from .elements import Extract
from .elements import False_
from .elements import FunctionFilter
from .elements import Label
from .elements import Null
from .elements import Over
from .elements import TextClause
from .elements import True_
from .elements import TryCast
from .elements import Tuple
from .elements import TypeCoerce
from .elements import UnaryExpression
from .elements import WithinGroup
from .functions import FunctionElement
from ..util.typing import Literal
if typing.TYPE_CHECKING:
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/sql/sqltypes.py =====
"""SQL specific types."""
from __future__ import annotations
import collections.abc as collections_abc
import datetime as dt
import decimal
import enum
import json
import pickle
from typing import Any
from typing import Callable
from typing import cast
from typing import Dict
from typing import Iterable
from typing import List
from typing import Mapping
from typing import Optional
from typing import overload
from typing import Sequence
from typing import Tuple
from typing import Type
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union
from uuid import UUID as _python_UUID
from . import coercions
from . import elements
from . import operators
from . import roles
from . import type_api
from .base import _NONE_NAME
from .base import NO_ARG
from .base import SchemaEventTarget
from .cache_key import HasCacheKey
from .elements import quoted_name
from .elements import Slice
from .elements import TypeCoerce as type_coerce  # noqa
from .type_api import Emulated
from .type_api import NativeForEmulated  # noqa
from .type_api import to_instance as to_instance
from .type_api import TypeDecorator as TypeDecorator
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/sql/operators.py =====
"""Defines operators used in SQL expressions."""
from __future__ import annotations
from enum import IntEnum
from operator import add as _uncast_add
from operator import and_ as _uncast_and_
from operator import contains as _uncast_contains
from operator import eq as _uncast_eq
from operator import floordiv as _uncast_floordiv
from operator import ge as _uncast_ge
from operator import getitem as _uncast_getitem
from operator import gt as _uncast_gt
from operator import inv as _uncast_inv
from operator import le as _uncast_le
from operator import lshift as _uncast_lshift
from operator import lt as _uncast_lt
from operator import mod as _uncast_mod
from operator import mul as _uncast_mul
from operator import ne as _uncast_ne
from operator import neg as _uncast_neg
from operator import or_ as _uncast_or_
from operator import rshift as _uncast_rshift
from operator import sub as _uncast_sub
from operator import truediv as _uncast_truediv
import typing
from typing import Any
from typing import Callable
from typing import cast
from typing import Dict
from typing import Generic
from typing import Optional
from typing import overload
from typing import Set
from typing import Tuple
from typing import Type
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union
from .. import exc
from .. import util
from ..util.typing import Literal
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/sql/selectable.py =====
"""The :class:`_expression.FromClause` class of SQL expression elements,
representing
SQL tables and derived rowsets.
"""
from __future__ import annotations
import collections
from enum import Enum
import itertools
from typing import AbstractSet
from typing import Any as TODO_Any
from typing import Any
from typing import Callable
from typing import cast
from typing import Dict
from typing import Generic
from typing import Iterable
from typing import Iterator
from typing import List
from typing import NamedTuple
from typing import NoReturn
from typing import Optional
from typing import overload
from typing import Sequence
from typing import Set
from typing import Tuple
from typing import Type
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union
from . import cache_key
from . import coercions
from . import operators
from . import roles
from . import traversals
from . import type_api
from . import visitors
from ._typing import _ColumnsClauseArgument
from ._typing import _no_kw
from ._typing import _T
from ._typing import _TP
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/sql/dml.py =====
"""
Provide :class:`_expression.Insert`, :class:`_expression.Update` and
:class:`_expression.Delete`.
"""
from __future__ import annotations
import collections.abc as collections_abc
import operator
from typing import Any
from typing import cast
from typing import Dict
from typing import Iterable
from typing import List
from typing import MutableMapping
from typing import NoReturn
from typing import Optional
from typing import overload
from typing import Sequence
from typing import Set
from typing import Tuple
from typing import Type
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union
from . import coercions
from . import roles
from . import util as sql_util
from ._typing import _TP
from ._typing import _unexpected_kw
from ._typing import is_column_element
from ._typing import is_named_from_clause
from .base import _entity_namespace_key
from .base import _exclusive_against
from .base import _from_objects
from .base import _generative
from .base import _select_iterables
from .base import ColumnCollection
from .base import ColumnSet
from .base import CompileState
from .base import DialectKWArgs
from .base import Executable
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/sql/coercions.py =====
from __future__ import annotations
import collections.abc as collections_abc
import numbers
import re
import typing
from typing import Any
from typing import Callable
from typing import cast
from typing import Dict
from typing import Iterable
from typing import Iterator
from typing import List
from typing import NoReturn
from typing import Optional
from typing import overload
from typing import Sequence
from typing import Tuple
from typing import Type
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union
from . import roles
from . import visitors
from ._typing import is_from_clause
from .base import ExecutableOption
from .base import Options
from .cache_key import HasCacheKey
from .visitors import Visitable
from .. import exc
from .. import inspection
from .. import util
from ..util.typing import Literal
if typing.TYPE_CHECKING:
    # elements lambdas schema selectable are set by __init__
    from . import elements
    from . import lambdas
    from . import schema
    from . import selectable
    from ._typing import _ColumnExpressionArgument
    from ._typing import _ColumnsClauseArgument
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/sql/expression.py =====
"""Defines the public namespace for SQL expression constructs."""
from __future__ import annotations
from ._dml_constructors import delete as delete
from ._dml_constructors import insert as insert
from ._dml_constructors import update as update
from ._elements_constructors import all_ as all_
from ._elements_constructors import and_ as and_
from ._elements_constructors import any_ as any_
from ._elements_constructors import asc as asc
from ._elements_constructors import between as between
from ._elements_constructors import bindparam as bindparam
from ._elements_constructors import bitwise_not as bitwise_not
from ._elements_constructors import case as case
from ._elements_constructors import cast as cast
from ._elements_constructors import collate as collate
from ._elements_constructors import column as column
from ._elements_constructors import desc as desc
from ._elements_constructors import distinct as distinct
from ._elements_constructors import extract as extract
from ._elements_constructors import false as false
from ._elements_constructors import funcfilter as funcfilter
from ._elements_constructors import label as label
from ._elements_constructors import not_ as not_
from ._elements_constructors import null as null
from ._elements_constructors import nulls_first as nulls_first
from ._elements_constructors import nulls_last as nulls_last
from ._elements_constructors import or_ as or_
from ._elements_constructors import outparam as outparam
from ._elements_constructors import over as over
from ._elements_constructors import text as text
from ._elements_constructors import true as true
from ._elements_constructors import try_cast as try_cast
from ._elements_constructors import tuple_ as tuple_
from ._elements_constructors import type_coerce as type_coerce
from ._elements_constructors import within_group as within_group
from ._selectable_constructors import alias as alias
from ._selectable_constructors import cte as cte
from ._selectable_constructors import except_ as except_
from ._selectable_constructors import except_all as except_all
from ._selectable_constructors import exists as exists
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/sql/base.py =====
"""Foundational utilities common to many sql modules."""
from __future__ import annotations
import collections
from enum import Enum
import itertools
from itertools import zip_longest
import operator
import re
from typing import Any
from typing import Callable
from typing import cast
from typing import Dict
from typing import FrozenSet
from typing import Generator
from typing import Generic
from typing import Iterable
from typing import Iterator
from typing import List
from typing import Mapping
from typing import MutableMapping
from typing import NamedTuple
from typing import NoReturn
from typing import Optional
from typing import overload
from typing import Sequence
from typing import Set
from typing import Tuple
from typing import Type
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union
from . import roles
from . import visitors
from .cache_key import HasCacheKey  # noqa
from .cache_key import MemoizedHasCacheKey  # noqa
from .traversals import HasCopyInternals  # noqa
from .visitors import ClauseVisitor
from .visitors import ExtendedInternalTraversal
from .visitors import ExternallyTraversible
from .visitors import InternalTraversal
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/sql/type_api.py =====
"""Base types API."""
from __future__ import annotations
from enum import Enum
import typing
from typing import Any
from typing import Callable
from typing import cast
from typing import Dict
from typing import Generic
from typing import Mapping
from typing import NewType
from typing import Optional
from typing import overload
from typing import Sequence
from typing import Tuple
from typing import Type
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union
from .base import SchemaEventTarget
from .cache_key import CacheConst
from .cache_key import NO_CACHE
from .operators import ColumnOperators
from .visitors import Visitable
from .. import exc
from .. import util
from ..util.typing import Protocol
from ..util.typing import Self
from ..util.typing import TypeAliasType
from ..util.typing import TypedDict
from ..util.typing import TypeGuard
if typing.TYPE_CHECKING:
    from ._typing import _TypeEngineArgument
    from .elements import BindParameter
    from .elements import ColumnElement
    from .operators import OperatorType
    from .sqltypes import _resolve_value_to_type as _resolve_value_to_type
    from .sqltypes import BOOLEANTYPE as BOOLEANTYPE  # noqa: F401
    from .sqltypes import INDEXABLE as INDEXABLE  # noqa: F401
    from .sqltypes import INTEGERTYPE as INTEGERTYPE  # noqa: F401
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/sql/crud.py =====
"""Functions used by compiler.py to determine the parameters rendered
within INSERT and UPDATE statements.
"""
from __future__ import annotations
import functools
import operator
from typing import Any
from typing import Callable
from typing import cast
from typing import Dict
from typing import Iterable
from typing import List
from typing import MutableMapping
from typing import NamedTuple
from typing import Optional
from typing import overload
from typing import Sequence
from typing import Set
from typing import Tuple
from typing import TYPE_CHECKING
from typing import Union
from . import coercions
from . import dml
from . import elements
from . import roles
from .base import _DefaultDescriptionTuple
from .dml import isinsert as _compile_state_isinsert
from .elements import ColumnClause
from .schema import default_is_clause_element
from .schema import default_is_sequence
from .selectable import Select
from .selectable import TableClause
from .. import exc
from .. import util
from ..util.typing import Literal
if TYPE_CHECKING:
    from .compiler import _BindNameForColProtocol
    from .compiler import SQLCompiler
    from .dml import _DMLColumnElement
    from .dml import DMLState
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/sql/lambdas.py =====
from __future__ import annotations
import collections.abc as collections_abc
import inspect
import itertools
import operator
import threading
import types
from types import CodeType
from typing import Any
from typing import Callable
from typing import cast
from typing import List
from typing import MutableMapping
from typing import Optional
from typing import Tuple
from typing import Type
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union
import weakref
from . import cache_key as _cache_key
from . import coercions
from . import elements
from . import roles
from . import schema
from . import visitors
from .base import _clone
from .base import Executable
from .base import Options
from .cache_key import CacheConst
from .operators import ColumnOperators
from .. import exc
from .. import inspection
from .. import util
from ..util.typing import Literal
if TYPE_CHECKING:
    from .elements import BindParameter
    from .elements import ClauseElement
    from .roles import SQLRole
    from .visitors import _CloneCallableType
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/sql/schema.py =====
"""The schema module provides the building blocks for database metadata.
Each element within this module describes a database entity which can be
created and dropped, or is otherwise part of such an entity.  Examples include
tables, columns, sequences, and indexes.
All entities are subclasses of :class:`~sqlalchemy.schema.SchemaItem`, and as
defined in this module they are intended to be agnostic of any vendor-specific
constructs.
A collection of entities are grouped into a unit called
:class:`~sqlalchemy.schema.MetaData`. MetaData serves as a logical grouping of
schema elements, and can also be associated with an actual database connection
such that operations involving the contained elements can contact the database
as needed.
Two of the elements here also build upon their "syntactic" counterparts, which
are defined in :class:`~sqlalchemy.sql.expression.`, specifically
:class:`~sqlalchemy.schema.Table` and :class:`~sqlalchemy.schema.Column`.
Since these objects are part of the SQL expression language, they are usable
as components in SQL expressions.
"""
from __future__ import annotations
from abc import ABC
import collections
from enum import Enum
import operator
import typing
from typing import Any
from typing import Callable
from typing import cast
from typing import Collection
from typing import Dict
from typing import Iterable
from typing import Iterator
from typing import List
from typing import Mapping
from typing import NoReturn
from typing import Optional
from typing import overload
from typing import Sequence as _typing_Sequence
from typing import Set
from typing import Tuple
from typing import TYPE_CHECKING
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/sql/_orm_types.py =====
"""ORM types that need to present specifically for **documentation only** of
the Executable.execution_options() method, which includes options that
are meaningful to the ORM.
"""
from __future__ import annotations
from ..util.typing import Literal
SynchronizeSessionArgument = Literal[False, "auto", "evaluate", "fetch"]
DMLStrategyArgument = Literal["bulk", "raw", "orm", "auto"]
...(truncado)

===== ./venv/lib/python3.13/site-packages/sqlalchemy/sql/_py_util.py =====
from __future__ import annotations
import typing
from typing import Any
from typing import Dict
from typing import Tuple
from typing import Union
from ..util.typing import Literal
if typing.TYPE_CHECKING:
    from .cache_key import CacheConst
class prefix_anon_map(Dict[str, str]):
    """A map that creates new keys for missing key access.
    Considers keys of the form "<ident> <name>" to produce
    new symbols "<name>_<index>", where "index" is an incrementing integer
    corresponding to <name>.
    Inlines the approach taken by :class:`sqlalchemy.util.PopulateDict` which
    is otherwise usually used for this type of operation.
    """
    def __missing__(self, key: str) -> str:
        (ident, derived) = key.split(" ", 1)
        anonymous_counter = self.get(derived, 1)
        self[derived] = anonymous_counter + 1  # type: ignore
        value = f"{derived}_{anonymous_counter}"
        self[key] = value
        return value
class cache_anon_map(
    Dict[Union[int, "Literal[CacheConst.NO_CACHE]"], Union[Literal[True], str]]
):
    """A map that creates new keys for missing key access.
    Produces an incrementing sequence given a series of unique keys.
    This is similar to the compiler prefix_anon_map class although simpler.
    Inlines the approach taken by :class:`sqlalchemy.util.PopulateDict` which
    is otherwise usually used for this type of operation.
    """
    _index = 0
    def get_anon(self, object_: Any) -> Tuple[str, bool]:
        idself = id(object_)
        if idself in self:
            s_val = self[idself]
            assert s_val is not True
            return s_val, True
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/configuration.py =====
"""Configuration management setup
Some terminology:
- name
  As written in config files.
- value
  Value associated with a name
- key
  Name combined with it's section (section.name)
- variant
  A single word describing where the configuration key-value pair came from
"""
from __future__ import annotations
import configparser
import locale
import os
import sys
from collections.abc import Iterable
from typing import Any, NewType
from pip._internal.exceptions import (
    ConfigurationError,
    ConfigurationFileCouldNotBeLoaded,
)
from pip._internal.utils import appdirs
from pip._internal.utils.compat import WINDOWS
from pip._internal.utils.logging import getLogger
from pip._internal.utils.misc import ensure_dir, enum
RawConfigParser = configparser.RawConfigParser  # Shorthand
Kind = NewType("Kind", str)
CONFIG_BASENAME = "pip.ini" if WINDOWS else "pip.conf"
ENV_NAMES_IGNORED = "version", "help"
kinds = enum(
    USER="user",  # User Specific
    GLOBAL="global",  # System Wide
    SITE="site",  # [Virtual] Environment Specific
    ENV="env",  # from PIP_CONFIG_FILE
    ENV_VAR="env-var",  # from Environment Variables
)
OVERRIDE_ORDER = kinds.GLOBAL, kinds.USER, kinds.SITE, kinds.ENV, kinds.ENV_VAR
VALID_LOAD_ONLY = kinds.USER, kinds.GLOBAL, kinds.SITE
logger = getLogger(__name__)
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/pyproject.py =====
from __future__ import annotations
import importlib.util
import os
from collections import namedtuple
from typing import Any
from pip._vendor.packaging.requirements import InvalidRequirement
from pip._internal.exceptions import (
    InstallationError,
    InvalidPyProjectBuildRequires,
    MissingPyProjectBuildRequires,
)
from pip._internal.utils.compat import tomllib
from pip._internal.utils.packaging import get_requirement
def _is_list_of_str(obj: Any) -> bool:
    return isinstance(obj, list) and all(isinstance(item, str) for item in obj)
def make_pyproject_path(unpacked_source_directory: str) -> str:
    return os.path.join(unpacked_source_directory, "pyproject.toml")
BuildSystemDetails = namedtuple(
    "BuildSystemDetails", ["requires", "backend", "check", "backend_path"]
)
def load_pyproject_toml(
    use_pep517: bool | None, pyproject_toml: str, setup_py: str, req_name: str
) -> BuildSystemDetails | None:
    """Load the pyproject.toml file.
    Parameters:
        use_pep517 - Has the user requested PEP 517 processing? None
                     means the user hasn't explicitly specified.
        pyproject_toml - Location of the project's pyproject.toml file
        setup_py - Location of the project's setup.py file
        req_name - The name of the requirement we're processing (for
                   error reporting)
    Returns:
        None if we should use the legacy code path, otherwise a tuple
        (
            requirements from pyproject.toml,
            name of PEP 517 backend,
            requirements we should check are installed after setting
                up the build environment
            directory paths to import the backend from (backend-path),
                relative to the project root.
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/network/auth.py =====
"""Network Authentication Helpers
Contains interface (MultiDomainBasicAuth) and associated glue code for
providing credentials in the context of network requests.
"""
from __future__ import annotations
import logging
import os
import shutil
import subprocess
import sysconfig
import typing
import urllib.parse
from abc import ABC, abstractmethod
from functools import cache
from os.path import commonprefix
from pathlib import Path
from typing import Any, NamedTuple
from pip._vendor.requests.auth import AuthBase, HTTPBasicAuth
from pip._vendor.requests.models import Request, Response
from pip._vendor.requests.utils import get_netrc_auth
from pip._internal.utils.logging import getLogger
from pip._internal.utils.misc import (
    ask,
    ask_input,
    ask_password,
    remove_auth_from_url,
    split_auth_netloc_from_url,
)
from pip._internal.vcs.versioncontrol import AuthInfo
logger = getLogger(__name__)
KEYRING_DISABLED = False
class Credentials(NamedTuple):
    url: str
    username: str
    password: str
class KeyRingBaseProvider(ABC):
    """Keyring base provider interface"""
    has_keyring: bool
    @abstractmethod
    def get_auth_info(self, url: str, username: str | None) -> AuthInfo | None: ...
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/network/xmlrpc.py =====
"""xmlrpclib.Transport implementation"""
import logging
import urllib.parse
import xmlrpc.client
from typing import TYPE_CHECKING
from pip._internal.exceptions import NetworkConnectionError
from pip._internal.network.session import PipSession
from pip._internal.network.utils import raise_for_status
if TYPE_CHECKING:
    from xmlrpc.client import _HostType, _Marshallable
    from _typeshed import SizedBuffer
logger = logging.getLogger(__name__)
class PipXmlrpcTransport(xmlrpc.client.Transport):
    """Provide a `xmlrpclib.Transport` implementation via a `PipSession`
    object.
    """
    def __init__(
        self, index_url: str, session: PipSession, use_datetime: bool = False
    ) -> None:
        super().__init__(use_datetime)
        index_parts = urllib.parse.urlparse(index_url)
        self._scheme = index_parts.scheme
        self._session = session
    def request(
        self,
        host: "_HostType",
        handler: str,
        request_body: "SizedBuffer",
        verbose: bool = False,
    ) -> tuple["_Marshallable", ...]:
        assert isinstance(host, str)
        parts = (self._scheme, host, handler, None, None, None)
        url = urllib.parse.urlunparse(parts)
        try:
            headers = {"Content-Type": "text/xml"}
            response = self._session.post(
                url,
                data=request_body,
                headers=headers,
                stream=True,
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/network/download.py =====
"""Download files with progress indicators."""
from __future__ import annotations
import email.message
import logging
import mimetypes
import os
from collections.abc import Iterable, Mapping
from dataclasses import dataclass
from http import HTTPStatus
from typing import BinaryIO
from pip._vendor.requests import PreparedRequest
from pip._vendor.requests.models import Response
from pip._vendor.urllib3 import HTTPResponse as URLlib3Response
from pip._vendor.urllib3._collections import HTTPHeaderDict
from pip._vendor.urllib3.exceptions import ReadTimeoutError
from pip._internal.cli.progress_bars import BarType, get_download_progress_renderer
from pip._internal.exceptions import IncompleteDownloadError, NetworkConnectionError
from pip._internal.models.index import PyPI
from pip._internal.models.link import Link
from pip._internal.network.cache import SafeFileCache, is_from_cache
from pip._internal.network.session import CacheControlAdapter, PipSession
from pip._internal.network.utils import HEADERS, raise_for_status, response_chunks
from pip._internal.utils.misc import format_size, redact_auth_from_url, splitext
logger = logging.getLogger(__name__)
def _get_http_response_size(resp: Response) -> int | None:
    try:
        return int(resp.headers["content-length"])
    except (ValueError, KeyError, TypeError):
        return None
def _get_http_response_etag_or_last_modified(resp: Response) -> str | None:
    """
    Return either the ETag or Last-Modified header (or None if neither exists).
    The return value can be used in an If-Range header.
    """
    return resp.headers.get("etag", resp.headers.get("last-modified"))
def _log_download(
    resp: Response,
    link: Link,
    progress_bar: BarType,
    total_length: int | None,
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/network/session.py =====
"""PipSession and supporting code, containing all pip-specific
network request configuration and behavior.
"""
from __future__ import annotations
import email.utils
import functools
import io
import ipaddress
import json
import logging
import mimetypes
import os
import platform
import shutil
import subprocess
import sys
import urllib.parse
import warnings
from collections.abc import Generator, Mapping, Sequence
from typing import (
    TYPE_CHECKING,
    Any,
    Optional,
    Union,
)
from pip._vendor import requests, urllib3
from pip._vendor.cachecontrol import CacheControlAdapter as _BaseCacheControlAdapter
from pip._vendor.requests.adapters import DEFAULT_POOLBLOCK, BaseAdapter
from pip._vendor.requests.adapters import HTTPAdapter as _BaseHTTPAdapter
from pip._vendor.requests.models import PreparedRequest, Response
from pip._vendor.requests.structures import CaseInsensitiveDict
from pip._vendor.urllib3.connectionpool import ConnectionPool
from pip._vendor.urllib3.exceptions import InsecureRequestWarning
from pip import __version__
from pip._internal.metadata import get_default_environment
from pip._internal.models.link import Link
from pip._internal.network.auth import MultiDomainBasicAuth
from pip._internal.network.cache import SafeFileCache
from pip._internal.utils.compat import has_tls
from pip._internal.utils.glibc import libc_ver
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/network/cache.py =====
"""HTTP cache implementation."""
from __future__ import annotations
import os
import shutil
from collections.abc import Generator
from contextlib import contextmanager
from datetime import datetime
from typing import Any, BinaryIO, Callable
from pip._vendor.cachecontrol.cache import SeparateBodyBaseCache
from pip._vendor.cachecontrol.caches import SeparateBodyFileCache
from pip._vendor.requests.models import Response
from pip._internal.utils.filesystem import adjacent_tmp_file, replace
from pip._internal.utils.misc import ensure_dir
def is_from_cache(response: Response) -> bool:
    return getattr(response, "from_cache", False)
@contextmanager
def suppressed_cache_errors() -> Generator[None, None, None]:
    """If we can't access the cache then we can just skip caching and process
    requests as if caching wasn't enabled.
    """
    try:
        yield
    except OSError:
        pass
class SafeFileCache(SeparateBodyBaseCache):
    """
    A file based cache which is safe to use even when the target directory may
    not be accessible or writable.
    There is a race condition when two processes try to write and/or read the
    same entry at the same time, since each entry consists of two separate
    files (https://github.com/psf/cachecontrol/issues/324).  We therefore have
    additional logic that makes sure that both files to be present before
    returning an entry; this fixes the read side of the race condition.
    For the write side, we assume that the server will only ever return the
    same data for the same URL, which ought to be the case for files pip is
    downloading.  PyPI does not have a mechanism to swap out a wheel for
    another wheel, for example.  If this assumption is not true, the
    CacheControl issue will need to be fixed.
    """
    def __init__(self, directory: str) -> None:
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/network/__init__.py =====
"""Contains purely network-related utilities."""
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/network/utils.py =====
from collections.abc import Generator
from pip._vendor.requests.models import Response
from pip._internal.exceptions import NetworkConnectionError
HEADERS: dict[str, str] = {"Accept-Encoding": "identity"}
DOWNLOAD_CHUNK_SIZE = 256 * 1024
def raise_for_status(resp: Response) -> None:
    http_error_msg = ""
    if isinstance(resp.reason, bytes):
        # We attempt to decode utf-8 first because some servers
        # choose to localize their reason strings. If the string
        # isn't utf-8, we fall back to iso-8859-1 for all other
        # encodings.
        try:
            reason = resp.reason.decode("utf-8")
        except UnicodeDecodeError:
            reason = resp.reason.decode("iso-8859-1")
    else:
        reason = resp.reason
    if 400 <= resp.status_code < 500:
        http_error_msg = (
            f"{resp.status_code} Client Error: {reason} for url: {resp.url}"
        )
    elif 500 <= resp.status_code < 600:
        http_error_msg = (
            f"{resp.status_code} Server Error: {reason} for url: {resp.url}"
        )
    if http_error_msg:
        raise NetworkConnectionError(http_error_msg, response=resp)
def response_chunks(
    response: Response, chunk_size: int = DOWNLOAD_CHUNK_SIZE
) -> Generator[bytes, None, None]:
    """Given a requests Response, provide the data chunks."""
    try:
        # Special case for urllib3.
        for chunk in response.raw.stream(
            chunk_size,
            # We use decode_content=False here because we don't
            # want urllib3 to mess with the raw bytes we get
            # from the server. If we decompress inside of
            # urllib3 then we cannot verify the checksum
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/network/lazy_wheel.py =====
"""Lazy ZIP over HTTP"""
from __future__ import annotations
__all__ = ["HTTPRangeRequestUnsupported", "dist_from_wheel_url"]
from bisect import bisect_left, bisect_right
from collections.abc import Generator
from contextlib import contextmanager
from tempfile import NamedTemporaryFile
from typing import Any
from zipfile import BadZipFile, ZipFile
from pip._vendor.packaging.utils import canonicalize_name
from pip._vendor.requests.models import CONTENT_CHUNK_SIZE, Response
from pip._internal.metadata import BaseDistribution, MemoryWheel, get_wheel_distribution
from pip._internal.network.session import PipSession
from pip._internal.network.utils import HEADERS, raise_for_status, response_chunks
class HTTPRangeRequestUnsupported(Exception):
    pass
def dist_from_wheel_url(name: str, url: str, session: PipSession) -> BaseDistribution:
    """Return a distribution object from the given wheel URL.
    This uses HTTP range requests to only fetch the portion of the wheel
    containing metadata, just enough for the object to be constructed.
    If such requests are not supported, HTTPRangeRequestUnsupported
    is raised.
    """
    with LazyZipOverHTTP(url, session) as zf:
        # For read-only ZIP files, ZipFile only needs methods read,
        # seek, seekable and tell, not the whole IO protocol.
        wheel = MemoryWheel(zf.name, zf)  # type: ignore
        # After context manager exit, wheel.name
        # is an invalid file by intention.
        return get_wheel_distribution(wheel, canonicalize_name(name))
class LazyZipOverHTTP:
    """File-like object mapped to a ZIP file over HTTP.
    This uses HTTP range requests to lazily fetch the file's content,
    which is supposed to be fed to ZipFile.  If such requests are not
    supported by the server, raise HTTPRangeRequestUnsupported
    during initialization.
    """
    def __init__(
        self, url: str, session: PipSession, chunk_size: int = CONTENT_CHUNK_SIZE
    ) -> None:
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/cache.py =====
"""Cache Management"""
from __future__ import annotations
import hashlib
import json
import logging
import os
from pathlib import Path
from typing import Any
from pip._vendor.packaging.tags import Tag, interpreter_name, interpreter_version
from pip._vendor.packaging.utils import canonicalize_name
from pip._internal.exceptions import InvalidWheelFilename
from pip._internal.models.direct_url import DirectUrl
from pip._internal.models.link import Link
from pip._internal.models.wheel import Wheel
from pip._internal.utils.temp_dir import TempDirectory, tempdir_kinds
from pip._internal.utils.urls import path_to_url
logger = logging.getLogger(__name__)
ORIGIN_JSON_NAME = "origin.json"
def _hash_dict(d: dict[str, str]) -> str:
    """Return a stable sha224 of a dictionary."""
    s = json.dumps(d, sort_keys=True, separators=(",", ":"), ensure_ascii=True)
    return hashlib.sha224(s.encode("ascii")).hexdigest()
class Cache:
    """An abstract class - provides cache directories for data from links
    :param cache_dir: The root of the cache.
    """
    def __init__(self, cache_dir: str) -> None:
        super().__init__()
        assert not cache_dir or os.path.isabs(cache_dir)
        self.cache_dir = cache_dir or None
    def _get_cache_path_parts(self, link: Link) -> list[str]:
        """Get parts of part that must be os.path.joined with cache_dir"""
        # We want to generate an url to use as our cache key, we don't want to
        # just reuse the URL because it might have other items in the fragment
        # and we don't care about those.
        key_parts = {"url": link.url_without_fragment}
        if link.hash_name is not None and link.hash is not None:
            key_parts[link.hash_name] = link.hash
        if link.subdirectory_fragment:
            key_parts["subdirectory"] = link.subdirectory_fragment
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/__init__.py =====
from __future__ import annotations
from pip._internal.utils import _log
_log.init_logging()
def main(args: list[str] | None = None) -> int:
    """This is preserved for old console scripts that may still be referencing
    it.
    For additional details, see https://github.com/pypa/pip/issues/7498.
    """
    from pip._internal.utils.entrypoints import _wrapper
    return _wrapper(args)
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/utils/logging.py =====
from __future__ import annotations
import contextlib
import errno
import logging
import logging.handlers
import os
import sys
import threading
from collections.abc import Generator
from dataclasses import dataclass
from io import TextIOWrapper
from logging import Filter
from typing import Any, ClassVar
from pip._vendor.rich.console import (
    Console,
    ConsoleOptions,
    ConsoleRenderable,
    RenderableType,
    RenderResult,
    RichCast,
)
from pip._vendor.rich.highlighter import NullHighlighter
from pip._vendor.rich.logging import RichHandler
from pip._vendor.rich.segment import Segment
from pip._vendor.rich.style import Style
from pip._internal.utils._log import VERBOSE, getLogger
from pip._internal.utils.compat import WINDOWS
from pip._internal.utils.deprecation import DEPRECATION_MSG_PREFIX
from pip._internal.utils.misc import ensure_dir
_log_state = threading.local()
_stdout_console = None
_stderr_console = None
subprocess_logger = getLogger("pip.subprocessor")
class BrokenStdoutLoggingError(Exception):
    """
    Raised if BrokenPipeError occurs for the stdout stream while logging.
    """
def _is_broken_pipe_error(exc_class: type[BaseException], exc: BaseException) -> bool:
    if exc_class is BrokenPipeError:
        return True
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/utils/misc.py =====
from __future__ import annotations
import errno
import getpass
import hashlib
import logging
import os
import posixpath
import shutil
import stat
import sys
import sysconfig
import urllib.parse
from collections.abc import Generator, Iterable, Iterator, Mapping, Sequence
from dataclasses import dataclass
from functools import partial
from io import StringIO
from itertools import filterfalse, tee, zip_longest
from pathlib import Path
from types import FunctionType, TracebackType
from typing import (
    Any,
    BinaryIO,
    Callable,
    Optional,
    TextIO,
    TypeVar,
    cast,
)
from pip._vendor.packaging.requirements import Requirement
from pip._vendor.pyproject_hooks import BuildBackendHookCaller
from pip import __version__
from pip._internal.exceptions import CommandError, ExternallyManagedEnvironment
from pip._internal.locations import get_major_minor_version
from pip._internal.utils.compat import WINDOWS
from pip._internal.utils.retry import retry
from pip._internal.utils.virtualenv import running_under_virtualenv
__all__ = [
    "rmtree",
    "display_path",
    "backup_dir",
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/utils/egg_link.py =====
from __future__ import annotations
import os
import re
import sys
from pip._internal.locations import site_packages, user_site
from pip._internal.utils.virtualenv import (
    running_under_virtualenv,
    virtualenv_no_global,
)
__all__ = [
    "egg_link_path_from_sys_path",
    "egg_link_path_from_location",
]
def _egg_link_names(raw_name: str) -> list[str]:
    """
    Convert a Name metadata value to a .egg-link name, by applying
    the same substitution as pkg_resources's safe_name function.
    Note: we cannot use canonicalize_name because it has a different logic.
    We also look for the raw name (without normalization) as setuptools 69 changed
    the way it names .egg-link files (https://github.com/pypa/setuptools/issues/4167).
    """
    return [
        re.sub("[^A-Za-z0-9.]+", "-", raw_name) + ".egg-link",
        f"{raw_name}.egg-link",
    ]
def egg_link_path_from_sys_path(raw_name: str) -> str | None:
    """
    Look for a .egg-link file for project name, by walking sys.path.
    """
    egg_link_names = _egg_link_names(raw_name)
    for path_item in sys.path:
        for egg_link_name in egg_link_names:
            egg_link = os.path.join(path_item, egg_link_name)
            if os.path.isfile(egg_link):
                return egg_link
    return None
def egg_link_path_from_location(raw_name: str) -> str | None:
    """
    Return the path for the .egg-link file if it exists, otherwise, None.
    There's 3 scenarios:
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/utils/compat.py =====
"""Stuff that differs in different Python versions and platform
distributions."""
import importlib.resources
import logging
import os
import sys
from typing import IO
__all__ = ["get_path_uid", "stdlib_pkgs", "tomllib", "WINDOWS"]
logger = logging.getLogger(__name__)
def has_tls() -> bool:
    try:
        import _ssl  # noqa: F401  # ignore unused
        return True
    except ImportError:
        pass
    from pip._vendor.urllib3.util import IS_PYOPENSSL
    return IS_PYOPENSSL
def get_path_uid(path: str) -> int:
    """
    Return path's uid.
    Does not follow symlinks:
        https://github.com/pypa/pip/pull/935#discussion_r5307003
    Placed this function in compat due to differences on AIX and
    Jython, that should eventually go away.
    :raises OSError: When path is a symlink or can't be read.
    """
    if hasattr(os, "O_NOFOLLOW"):
        fd = os.open(path, os.O_RDONLY | os.O_NOFOLLOW)
        file_uid = os.fstat(fd).st_uid
        os.close(fd)
    else:  # AIX and Jython
        # WARNING: time of check vulnerability, but best we can do w/o NOFOLLOW
        if not os.path.islink(path):
            # older versions of Jython don't have `os.fstat`
            file_uid = os.stat(path).st_uid
        else:
            # raise OSError for parity with os.O_NOFOLLOW above
            raise OSError(f"{path} is a symlink; Will not return uid for symlinks")
    return file_uid
if sys.version_info < (3, 11):
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/utils/deprecation.py =====
"""
A module that implements tooling to enable easy warnings about deprecations.
"""
from __future__ import annotations
import logging
import warnings
from typing import Any, TextIO
from pip._vendor.packaging.version import parse
from pip import __version__ as current_version  # NOTE: tests patch this name.
DEPRECATION_MSG_PREFIX = "DEPRECATION: "
class PipDeprecationWarning(Warning):
    pass
_original_showwarning: Any = None
def _showwarning(
    message: Warning | str,
    category: type[Warning],
    filename: str,
    lineno: int,
    file: TextIO | None = None,
    line: str | None = None,
) -> None:
    if file is not None:
        if _original_showwarning is not None:
            _original_showwarning(message, category, filename, lineno, file, line)
    elif issubclass(category, PipDeprecationWarning):
        # We use a specially named logger which will handle all of the
        # deprecation messages for pip.
        logger = logging.getLogger("pip._internal.deprecations")
        logger.warning(message)
    else:
        _original_showwarning(message, category, filename, lineno, file, line)
def install_warning_logger() -> None:
    # Enable our Deprecation Warnings
    warnings.simplefilter("default", PipDeprecationWarning, append=True)
    global _original_showwarning
    if _original_showwarning is None:
        _original_showwarning = warnings.showwarning
        warnings.showwarning = _showwarning
def deprecated(
    *,
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/utils/subprocess.py =====
from __future__ import annotations
import logging
import os
import shlex
import subprocess
from collections.abc import Iterable, Mapping
from typing import Any, Callable, Literal, Union
from pip._vendor.rich.markup import escape
from pip._internal.cli.spinners import SpinnerInterface, open_spinner
from pip._internal.exceptions import InstallationSubprocessError
from pip._internal.utils.logging import VERBOSE, subprocess_logger
from pip._internal.utils.misc import HiddenText
CommandArgs = list[Union[str, HiddenText]]
def make_command(*args: str | HiddenText | CommandArgs) -> CommandArgs:
    """
    Create a CommandArgs object.
    """
    command_args: CommandArgs = []
    for arg in args:
        # Check for list instead of CommandArgs since CommandArgs is
        # only known during type-checking.
        if isinstance(arg, list):
            command_args.extend(arg)
        else:
            # Otherwise, arg is str or HiddenText.
            command_args.append(arg)
    return command_args
def format_command_args(args: list[str] | CommandArgs) -> str:
    """
    Format command arguments for display.
    """
    # For HiddenText arguments, display the redacted form by calling str().
    # Also, we don't apply str() to arguments that aren't HiddenText since
    # this can trigger a UnicodeDecodeError in Python 2 if the argument
    # has type unicode and includes a non-ascii character.  (The type
    # checker doesn't ensure the annotations are correct in all cases.)
    return " ".join(
        shlex.quote(str(arg)) if isinstance(arg, HiddenText) else shlex.quote(arg)
        for arg in args
    )
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/utils/filesystem.py =====
from __future__ import annotations
import fnmatch
import os
import os.path
import random
import sys
from collections.abc import Generator
from contextlib import contextmanager
from tempfile import NamedTemporaryFile
from typing import Any, BinaryIO, cast
from pip._internal.utils.compat import get_path_uid
from pip._internal.utils.misc import format_size
from pip._internal.utils.retry import retry
def check_path_owner(path: str) -> bool:
    # If we don't have a way to check the effective uid of this process, then
    # we'll just assume that we own the directory.
    if sys.platform == "win32" or not hasattr(os, "geteuid"):
        return True
    assert os.path.isabs(path)
    previous = None
    while path != previous:
        if os.path.lexists(path):
            # Check if path is writable by current user.
            if os.geteuid() == 0:
                # Special handling for root user in order to handle properly
                # cases where users use sudo without -H flag.
                try:
                    path_uid = get_path_uid(path)
                except OSError:
                    return False
                return path_uid == 0
            else:
                return os.access(path, os.W_OK)
        else:
            previous, path = path, os.path.dirname(path)
    return False  # assume we don't own the path
@contextmanager
def adjacent_tmp_file(path: str, **kwargs: Any) -> Generator[BinaryIO, None, None]:
    """Return a file-like object pointing to a tmp file next to path.
    The file is created securely and is ensured to be written to disk
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/utils/direct_url_helpers.py =====
from __future__ import annotations
from pip._internal.models.direct_url import ArchiveInfo, DirectUrl, DirInfo, VcsInfo
from pip._internal.models.link import Link
from pip._internal.utils.urls import path_to_url
from pip._internal.vcs import vcs
def direct_url_as_pep440_direct_reference(direct_url: DirectUrl, name: str) -> str:
    """Convert a DirectUrl to a pip requirement string."""
    direct_url.validate()  # if invalid, this is a pip bug
    requirement = name + " @ "
    fragments = []
    if isinstance(direct_url.info, VcsInfo):
        requirement += (
            f"{direct_url.info.vcs}+{direct_url.url}@{direct_url.info.commit_id}"
        )
    elif isinstance(direct_url.info, ArchiveInfo):
        requirement += direct_url.url
        if direct_url.info.hash:
            fragments.append(direct_url.info.hash)
    else:
        assert isinstance(direct_url.info, DirInfo)
        requirement += direct_url.url
    if direct_url.subdirectory:
        fragments.append("subdirectory=" + direct_url.subdirectory)
    if fragments:
        requirement += "#" + "&".join(fragments)
    return requirement
def direct_url_for_editable(source_dir: str) -> DirectUrl:
    return DirectUrl(
        url=path_to_url(source_dir),
        info=DirInfo(editable=True),
    )
def direct_url_from_link(
    link: Link, source_dir: str | None = None, link_is_in_wheel_cache: bool = False
) -> DirectUrl:
    if link.is_vcs:
        vcs_backend = vcs.get_backend_for_scheme(link.scheme)
        assert vcs_backend
        url, requested_revision, _ = vcs_backend.get_url_rev_and_auth(
            link.url_without_fragment
        )
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/utils/__init__.py =====
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/utils/_jaraco_text.py =====
"""Functions brought over from jaraco.text.
These functions are not supposed to be used within `pip._internal`. These are
helper functions brought over from `jaraco.text` to enable vendoring newer
copies of `pkg_resources` without having to vendor `jaraco.text` and its entire
dependency cone; something that our vendoring setup is not currently capable of
handling.
License reproduced from original source below:
Copyright Jason R. Coombs
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to
deal in the Software without restriction, including without limitation the
rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
sell copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
IN THE SOFTWARE.
"""
import functools
import itertools
def _nonblank(str):
    return str and not str.startswith("#")
@functools.singledispatch
def yield_lines(iterable):
    r"""
    Yield valid lines of a string or iterable.
    >>> list(yield_lines(''))
    []
    >>> list(yield_lines(['foo', 'bar']))
    ['foo', 'bar']
    >>> list(yield_lines('foo\nbar'))
    ['foo', 'bar']
    >>> list(yield_lines('\nfoo\n#bar\nbaz #comment'))
    ['foo', 'baz #comment']
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/utils/temp_dir.py =====
from __future__ import annotations
import errno
import itertools
import logging
import os.path
import tempfile
import traceback
from collections.abc import Generator
from contextlib import ExitStack, contextmanager
from pathlib import Path
from typing import (
    Any,
    Callable,
    TypeVar,
)
from pip._internal.utils.misc import enum, rmtree
logger = logging.getLogger(__name__)
_T = TypeVar("_T", bound="TempDirectory")
tempdir_kinds = enum(
    BUILD_ENV="build-env",
    EPHEM_WHEEL_CACHE="ephem-wheel-cache",
    REQ_BUILD="req-build",
)
_tempdir_manager: ExitStack | None = None
@contextmanager
def global_tempdir_manager() -> Generator[None, None, None]:
    global _tempdir_manager
    with ExitStack() as stack:
        old_tempdir_manager, _tempdir_manager = _tempdir_manager, stack
        try:
            yield
        finally:
            _tempdir_manager = old_tempdir_manager
class TempDirectoryTypeRegistry:
    """Manages temp directory behavior"""
    def __init__(self) -> None:
        self._should_delete: dict[str, bool] = {}
    def set_delete(self, kind: str, value: bool) -> None:
        """Indicate whether a TempDirectory of the given kind should be
        auto-deleted.
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/utils/retry.py =====
from __future__ import annotations
import functools
from time import perf_counter, sleep
from typing import TYPE_CHECKING, Callable, TypeVar
if TYPE_CHECKING:
    from typing_extensions import ParamSpec
    T = TypeVar("T")
    P = ParamSpec("P")
def retry(
    wait: float, stop_after_delay: float
) -> Callable[[Callable[P, T]], Callable[P, T]]:
    """Decorator to automatically retry a function on error.
    If the function raises, the function is recalled with the same arguments
    until it returns or the time limit is reached. When the time limit is
    surpassed, the last exception raised is reraised.
    :param wait: The time to wait after an error before retrying, in seconds.
    :param stop_after_delay: The time limit after which retries will cease,
        in seconds.
    """
    def wrapper(func: Callable[P, T]) -> Callable[P, T]:
        @functools.wraps(func)
        def retry_wrapped(*args: P.args, **kwargs: P.kwargs) -> T:
            # The performance counter is monotonic on all platforms we care
            # about and has much better resolution than time.monotonic().
            start_time = perf_counter()
            while True:
                try:
                    return func(*args, **kwargs)
                except Exception:
                    if perf_counter() - start_time > stop_after_delay:
                        raise
                    sleep(wait)
        return retry_wrapped
    return wrapper
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/utils/appdirs.py =====
"""
This code wraps the vendored appdirs module to so the return values are
compatible for the current pip code base.
The intention is to rewrite current usages gradually, keeping the tests pass,
and eventually drop this after all usages are changed.
"""
import os
import sys
from pip._vendor import platformdirs as _appdirs
def user_cache_dir(appname: str) -> str:
    return _appdirs.user_cache_dir(appname, appauthor=False)
def _macos_user_config_dir(appname: str, roaming: bool = True) -> str:
    # Use ~/Application Support/pip, if the directory exists.
    path = _appdirs.user_data_dir(appname, appauthor=False, roaming=roaming)
    if os.path.isdir(path):
        return path
    # Use a Linux-like ~/.config/pip, by default.
    linux_like_path = "~/.config/"
    if appname:
        linux_like_path = os.path.join(linux_like_path, appname)
    return os.path.expanduser(linux_like_path)
def user_config_dir(appname: str, roaming: bool = True) -> str:
    if sys.platform == "darwin":
        return _macos_user_config_dir(appname, roaming)
    return _appdirs.user_config_dir(appname, appauthor=False, roaming=roaming)
def site_config_dirs(appname: str) -> list[str]:
    if sys.platform == "darwin":
        dirval = _appdirs.site_data_dir(appname, appauthor=False, multipath=True)
        return dirval.split(os.pathsep)
    dirval = _appdirs.site_config_dir(appname, appauthor=False, multipath=True)
    if sys.platform == "win32":
        return [dirval]
    # Unix-y system. Look in /etc as well.
    return dirval.split(os.pathsep) + ["/etc"]
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/utils/setuptools_build.py =====
from __future__ import annotations
import sys
import textwrap
from collections.abc import Sequence
_SETUPTOOLS_SHIM = textwrap.dedent(
    """
    exec(compile('''
    # This is <pip-setuptools-caller> -- a caller that pip uses to run setup.py
    #
    # - It imports setuptools before invoking setup.py, to enable projects that directly
    #   import from `distutils.core` to work with newer packaging standards.
    # - It provides a clear error message when setuptools is not installed.
    # - It sets `sys.argv[0]` to the underlying `setup.py`, when invoking `setup.py` so
    #   setuptools doesn't think the script is `-c`. This avoids the following warning:
    #     manifest_maker: standard file '-c' not found".
    # - It generates a shim setup.py, for handling setup.cfg-only projects.
    import os, sys, tokenize, traceback
    try:
        import setuptools
    except ImportError:
        print(
            "ERROR: Can not execute `setup.py` since setuptools failed to import in "
            "the build environment with exception:",
            file=sys.stderr,
        )
        traceback.print_exc()
        sys.exit(1)
    __file__ = %r
    sys.argv[0] = __file__
    if os.path.exists(__file__):
        filename = __file__
        with tokenize.open(__file__) as f:
            setup_py_code = f.read()
    else:
        filename = "<auto-generated setuptools caller>"
        setup_py_code = "from setuptools import setup; setup()"
    exec(compile(setup_py_code, filename, "exec"))
    ''' % ({!r},), "<pip-setuptools-caller>", "exec"))
    """
).rstrip()
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/utils/packaging.py =====
from __future__ import annotations
import functools
import logging
from pip._vendor.packaging import specifiers, version
from pip._vendor.packaging.requirements import Requirement
logger = logging.getLogger(__name__)
@functools.lru_cache(maxsize=32)
def check_requires_python(
    requires_python: str | None, version_info: tuple[int, ...]
) -> bool:
    """
    Check if the given Python version matches a "Requires-Python" specifier.
    :param version_info: A 3-tuple of ints representing a Python
        major-minor-micro version to check (e.g. `sys.version_info[:3]`).
    :return: `True` if the given Python version satisfies the requirement.
        Otherwise, return `False`.
    :raises InvalidSpecifier: If `requires_python` has an invalid format.
    """
    if requires_python is None:
        # The package provides no information
        return True
    requires_python_specifier = specifiers.SpecifierSet(requires_python)
    python_version = version.parse(".".join(map(str, version_info)))
    return python_version in requires_python_specifier
@functools.lru_cache(maxsize=10000)
def get_requirement(req_string: str) -> Requirement:
    """Construct a packaging.Requirement object with caching"""
    # Parsing requirement strings is expensive, and is also expected to happen
    # with a low diversity of different arguments (at least relative the number
    # constructed). This method adds a cache to requirement object creation to
    # minimize repeated parsing of the same string to construct equivalent
    # Requirement objects.
    return Requirement(req_string)
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/utils/entrypoints.py =====
from __future__ import annotations
import itertools
import os
import shutil
import sys
from pip._internal.cli.main import main
from pip._internal.utils.compat import WINDOWS
_EXECUTABLE_NAMES = [
    "pip",
    f"pip{sys.version_info.major}",
    f"pip{sys.version_info.major}.{sys.version_info.minor}",
]
if WINDOWS:
    _allowed_extensions = {"", ".exe"}
    _EXECUTABLE_NAMES = [
        "".join(parts)
        for parts in itertools.product(_EXECUTABLE_NAMES, _allowed_extensions)
    ]
def _wrapper(args: list[str] | None = None) -> int:
    """Central wrapper for all old entrypoints.
    Historically pip has had several entrypoints defined. Because of issues
    arising from PATH, sys.path, multiple Pythons, their interactions, and most
    of them having a pip installed, users suffer every time an entrypoint gets
    moved.
    To alleviate this pain, and provide a mechanism for warning users and
    directing them to an appropriate place for help, we now define all of
    our old entrypoints as wrappers for the current one.
    """
    sys.stderr.write(
        "WARNING: pip is being invoked by an old script wrapper. This will "
        "fail in a future version of pip.\n"
        "Please see https://github.com/pypa/pip/issues/5599 for advice on "
        "fixing the underlying issue.\n"
        "To avoid this problem you can invoke Python with '-m pip' instead of "
        "running pip directly.\n"
    )
    return main(args)
def get_best_invocation_for_this_pip() -> str:
    """Try to figure out the best way to invoke pip in the current environment."""
    binary_directory = "Scripts" if WINDOWS else "bin"
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/utils/filetypes.py =====
"""Filetype information."""
from pip._internal.utils.misc import splitext
WHEEL_EXTENSION = ".whl"
BZ2_EXTENSIONS: tuple[str, ...] = (".tar.bz2", ".tbz")
XZ_EXTENSIONS: tuple[str, ...] = (
    ".tar.xz",
    ".txz",
    ".tlz",
    ".tar.lz",
    ".tar.lzma",
)
ZIP_EXTENSIONS: tuple[str, ...] = (".zip", WHEEL_EXTENSION)
TAR_EXTENSIONS: tuple[str, ...] = (".tar.gz", ".tgz", ".tar")
ARCHIVE_EXTENSIONS = ZIP_EXTENSIONS + BZ2_EXTENSIONS + TAR_EXTENSIONS + XZ_EXTENSIONS
def is_archive_file(name: str) -> bool:
    """Return True if `name` is a considered as an archive file."""
    ext = splitext(name)[1].lower()
    if ext in ARCHIVE_EXTENSIONS:
        return True
    return False
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/utils/compatibility_tags.py =====
"""Generate and work with PEP 425 Compatibility Tags."""
from __future__ import annotations
import re
from pip._vendor.packaging.tags import (
    PythonVersion,
    Tag,
    android_platforms,
    compatible_tags,
    cpython_tags,
    generic_tags,
    interpreter_name,
    interpreter_version,
    ios_platforms,
    mac_platforms,
)
_apple_arch_pat = re.compile(r"(.+)_(\d+)_(\d+)_(.+)")
def version_info_to_nodot(version_info: tuple[int, ...]) -> str:
    # Only use up to the first two numbers.
    return "".join(map(str, version_info[:2]))
def _mac_platforms(arch: str) -> list[str]:
    match = _apple_arch_pat.match(arch)
    if match:
        name, major, minor, actual_arch = match.groups()
        mac_version = (int(major), int(minor))
        arches = [
            # Since we have always only checked that the platform starts
            # with "macosx", for backwards-compatibility we extract the
            # actual prefix provided by the user in case they provided
            # something like "macosxcustom_". It may be good to remove
            # this as undocumented or deprecate it in the future.
            "{}_{}".format(name, arch[len("macosx_") :])
            for arch in mac_platforms(mac_version, actual_arch)
        ]
    else:
        # arch pattern didn't match (?!)
        arches = [arch]
    return arches
def _ios_platforms(arch: str) -> list[str]:
    match = _apple_arch_pat.match(arch)
    if match:
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/utils/datetime.py =====
"""For when pip wants to check the date or time."""
import datetime
def today_is_later_than(year: int, month: int, day: int) -> bool:
    today = datetime.date.today()
    given = datetime.date(year, month, day)
    return today > given
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/utils/urls.py =====
import os
import string
import urllib.parse
import urllib.request
from .compat import WINDOWS
def path_to_url(path: str) -> str:
    """
    Convert a path to a file: URL.  The path will be made absolute and have
    quoted path parts.
    """
    path = os.path.normpath(os.path.abspath(path))
    url = urllib.parse.urljoin("file://", urllib.request.pathname2url(path))
    return url
def url_to_path(url: str) -> str:
    """
    Convert a file: URL to a path.
    """
    assert url.startswith(
        "file:"
    ), f"You can only turn file: urls into filenames (not {url!r})"
    _, netloc, path, _, _ = urllib.parse.urlsplit(url)
    if not netloc or netloc == "localhost":
        # According to RFC 8089, same as empty authority.
        netloc = ""
    elif WINDOWS:
        # If we have a UNC path, prepend UNC share notation.
        netloc = "\\\\" + netloc
    else:
        raise ValueError(
            f"non-local file URIs are not supported on this platform: {url!r}"
        )
    path = urllib.request.url2pathname(netloc + path)
    # On Windows, urlsplit parses the path as something like "/C:/Users/foo".
    # This creates issues for path-related functions like io.open(), so we try
    # to detect and strip the leading slash.
    if (
        WINDOWS
        and not netloc  # Not UNC.
        and len(path) >= 3
        and path[0] == "/"  # Leading slash to strip.
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/utils/hashes.py =====
from __future__ import annotations
import hashlib
from collections.abc import Iterable
from typing import TYPE_CHECKING, BinaryIO, NoReturn
from pip._internal.exceptions import HashMismatch, HashMissing, InstallationError
from pip._internal.utils.misc import read_chunks
if TYPE_CHECKING:
    from hashlib import _Hash
FAVORITE_HASH = "sha256"
STRONG_HASHES = ["sha256", "sha384", "sha512"]
class Hashes:
    """A wrapper that builds multiple hashes at once and checks them against
    known-good values
    """
    def __init__(self, hashes: dict[str, list[str]] | None = None) -> None:
        """
        :param hashes: A dict of algorithm names pointing to lists of allowed
            hex digests
        """
        allowed = {}
        if hashes is not None:
            for alg, keys in hashes.items():
                # Make sure values are always sorted (to ease equality checks)
                allowed[alg] = [k.lower() for k in sorted(keys)]
        self._allowed = allowed
    def __and__(self, other: Hashes) -> Hashes:
        if not isinstance(other, Hashes):
            return NotImplemented
        # If either of the Hashes object is entirely empty (i.e. no hash
        # specified at all), all hashes from the other object are allowed.
        if not other:
            return self
        if not self:
            return other
        # Otherwise only hashes that present in both objects are allowed.
        new = {}
        for alg, values in other._allowed.items():
            if alg not in self._allowed:
                continue
            new[alg] = [v for v in values if v in self._allowed[alg]]
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/utils/virtualenv.py =====
from __future__ import annotations
import logging
import os
import re
import site
import sys
logger = logging.getLogger(__name__)
_INCLUDE_SYSTEM_SITE_PACKAGES_REGEX = re.compile(
    r"include-system-site-packages\s*=\s*(?P<value>true|false)"
)
def _running_under_venv() -> bool:
    """Checks if sys.base_prefix and sys.prefix match.
    This handles PEP 405 compliant virtual environments.
    """
    return sys.prefix != getattr(sys, "base_prefix", sys.prefix)
def _running_under_legacy_virtualenv() -> bool:
    """Checks if sys.real_prefix is set.
    This handles virtual environments created with pypa's virtualenv.
    """
    # pypa/virtualenv case
    return hasattr(sys, "real_prefix")
def running_under_virtualenv() -> bool:
    """True if we're running inside a virtual environment, False otherwise."""
    return _running_under_venv() or _running_under_legacy_virtualenv()
def _get_pyvenv_cfg_lines() -> list[str] | None:
    """Reads {sys.prefix}/pyvenv.cfg and returns its contents as list of lines
    Returns None, if it could not read/access the file.
    """
    pyvenv_cfg_file = os.path.join(sys.prefix, "pyvenv.cfg")
    try:
        # Although PEP 405 does not specify, the built-in venv module always
        # writes with UTF-8. (pypa/pip#8717)
        with open(pyvenv_cfg_file, encoding="utf-8") as f:
            return f.read().splitlines()  # avoids trailing newlines
    except OSError:
        return None
def _no_global_under_venv() -> bool:
    """Check `{sys.prefix}/pyvenv.cfg` for system site-packages inclusion
    PEP 405 specifies that when system site-packages are not supposed to be
    visible from a virtual environment, `pyvenv.cfg` must contain the following
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/utils/_log.py =====
"""Customize logging
Defines custom logger class for the `logger.verbose(...)` method.
init_logging() must be called before any other modules that call logging.getLogger.
"""
import logging
from typing import Any, cast
VERBOSE = 15
class VerboseLogger(logging.Logger):
    """Custom Logger, defining a verbose log-level
    VERBOSE is between INFO and DEBUG.
    """
    def verbose(self, msg: str, *args: Any, **kwargs: Any) -> None:
        return self.log(VERBOSE, msg, *args, **kwargs)
def getLogger(name: str) -> VerboseLogger:
    """logging.getLogger, but ensures our VerboseLogger class is returned"""
    return cast(VerboseLogger, logging.getLogger(name))
def init_logging() -> None:
    """Register our VerboseLogger and VERBOSE log level.
    Should be called before any calls to getLogger(),
    i.e. in pip._internal.__init__
    """
    logging.setLoggerClass(VerboseLogger)
    logging.addLevelName(VERBOSE, "VERBOSE")
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/utils/glibc.py =====
from __future__ import annotations
import os
import sys
def glibc_version_string() -> str | None:
    "Returns glibc version string, or None if not using glibc."
    return glibc_version_string_confstr() or glibc_version_string_ctypes()
def glibc_version_string_confstr() -> str | None:
    "Primary implementation of glibc_version_string using os.confstr."
    # os.confstr is quite a bit faster than ctypes.DLL. It's also less likely
    # to be broken or missing. This strategy is used in the standard library
    # platform module:
    # https://github.com/python/cpython/blob/fcf1d003bf4f0100c9d0921ff3d70e1127ca1b71/Lib/platform.py#L175-L183
    if sys.platform == "win32":
        return None
    try:
        gnu_libc_version = os.confstr("CS_GNU_LIBC_VERSION")
        if gnu_libc_version is None:
            return None
        # os.confstr("CS_GNU_LIBC_VERSION") returns a string like "glibc 2.17":
        _, version = gnu_libc_version.split()
    except (AttributeError, OSError, ValueError):
        # os.confstr() or CS_GNU_LIBC_VERSION not available (or a bad value)...
        return None
    return version
def glibc_version_string_ctypes() -> str | None:
    "Fallback implementation of glibc_version_string using ctypes."
    try:
        import ctypes
    except ImportError:
        return None
    # ctypes.CDLL(None) internally calls dlopen(NULL), and as the dlopen
    # manpage says, "If filename is NULL, then the returned handle is for the
    # main program". This way we can let the linker do the work to figure out
    # which libc our process is actually using.
    #
    # We must also handle the special case where the executable is not a
    # dynamically linked executable. This can occur when using musl libc,
    # for example. In this situation, dlopen() will error, leading to an
    # OSError. Interestingly, at least in the case of musl, there is no
    # errno set on the OSError. The single string argument used to construct
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/utils/wheel.py =====
"""Support functions for working with wheel files."""
import logging
from email.message import Message
from email.parser import Parser
from zipfile import BadZipFile, ZipFile
from pip._vendor.packaging.utils import canonicalize_name
from pip._internal.exceptions import UnsupportedWheel
VERSION_COMPATIBLE = (1, 0)
logger = logging.getLogger(__name__)
def parse_wheel(wheel_zip: ZipFile, name: str) -> tuple[str, Message]:
    """Extract information from the provided wheel, ensuring it meets basic
    standards.
    Returns the name of the .dist-info directory and the parsed WHEEL metadata.
    """
    try:
        info_dir = wheel_dist_info_dir(wheel_zip, name)
        metadata = wheel_metadata(wheel_zip, info_dir)
        version = wheel_version(metadata)
    except UnsupportedWheel as e:
        raise UnsupportedWheel(f"{name} has an invalid wheel, {e}")
    check_compatibility(version, name)
    return info_dir, metadata
def wheel_dist_info_dir(source: ZipFile, name: str) -> str:
    """Returns the name of the contained .dist-info directory.
    Raises AssertionError or UnsupportedWheel if not found, >1 found, or
    it doesn't match the provided name.
    """
    # Zip file path separators must be /
    subdirs = {p.split("/", 1)[0] for p in source.namelist()}
    info_dirs = [s for s in subdirs if s.endswith(".dist-info")]
    if not info_dirs:
        raise UnsupportedWheel(".dist-info directory not found")
    if len(info_dirs) > 1:
        raise UnsupportedWheel(
            "multiple .dist-info directories found: {}".format(", ".join(info_dirs))
        )
    info_dir = info_dirs[0]
    info_dir_name = canonicalize_name(info_dir)
    canonical_name = canonicalize_name(name)
    if not info_dir_name.startswith(canonical_name):
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/utils/unpacking.py =====
"""Utilities related archives."""
from __future__ import annotations
import logging
import os
import shutil
import stat
import sys
import tarfile
import zipfile
from collections.abc import Iterable
from zipfile import ZipInfo
from pip._internal.exceptions import InstallationError
from pip._internal.utils.filetypes import (
    BZ2_EXTENSIONS,
    TAR_EXTENSIONS,
    XZ_EXTENSIONS,
    ZIP_EXTENSIONS,
)
from pip._internal.utils.misc import ensure_dir
logger = logging.getLogger(__name__)
SUPPORTED_EXTENSIONS = ZIP_EXTENSIONS + TAR_EXTENSIONS
try:
    import bz2  # noqa
    SUPPORTED_EXTENSIONS += BZ2_EXTENSIONS
except ImportError:
    logger.debug("bz2 module is not available")
try:
    # Only for Python 3.3+
    import lzma  # noqa
    SUPPORTED_EXTENSIONS += XZ_EXTENSIONS
except ImportError:
    logger.debug("lzma module is not available")
def current_umask() -> int:
    """Get the current umask which involves having to set it temporarily."""
    mask = os.umask(0)
    os.umask(mask)
    return mask
def split_leading_dir(path: str) -> list[str]:
    path = path.lstrip("/").lstrip("\\")
    if "/" in path and (
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/models/link.py =====
from __future__ import annotations
import functools
import itertools
import logging
import os
import posixpath
import re
import urllib.parse
from collections.abc import Mapping
from dataclasses import dataclass
from typing import (
    TYPE_CHECKING,
    Any,
    NamedTuple,
)
from pip._internal.utils.deprecation import deprecated
from pip._internal.utils.filetypes import WHEEL_EXTENSION
from pip._internal.utils.hashes import Hashes
from pip._internal.utils.misc import (
    pairwise,
    redact_auth_from_url,
    split_auth_from_netloc,
    splitext,
)
from pip._internal.utils.urls import path_to_url, url_to_path
if TYPE_CHECKING:
    from pip._internal.index.collector import IndexContent
logger = logging.getLogger(__name__)
_SUPPORTED_HASHES = ("sha512", "sha384", "sha256", "sha224", "sha1", "md5")
@dataclass(frozen=True)
class LinkHash:
    """Links to content may have embedded hash values. This class parses those.
    `name` must be any member of `_SUPPORTED_HASHES`.
    This class can be converted to and from `ArchiveInfo`. While ArchiveInfo intends to
    be JSON-serializable to conform to PEP 610, this class contains the logic for
    parsing a hash name and value for correctness, and then checking whether that hash
    conforms to a schema with `.is_hash_allowed()`."""
    name: str
    value: str
    _hash_url_fragment_re = re.compile(
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/models/selection_prefs.py =====
from __future__ import annotations
from pip._internal.models.format_control import FormatControl
class SelectionPreferences:
    """
    Encapsulates the candidate selection preferences for downloading
    and installing files.
    """
    __slots__ = [
        "allow_yanked",
        "allow_all_prereleases",
        "format_control",
        "prefer_binary",
        "ignore_requires_python",
    ]
    # Don't include an allow_yanked default value to make sure each call
    # site considers whether yanked releases are allowed. This also causes
    # that decision to be made explicit in the calling code, which helps
    # people when reading the code.
    def __init__(
        self,
        allow_yanked: bool,
        allow_all_prereleases: bool = False,
        format_control: FormatControl | None = None,
        prefer_binary: bool = False,
        ignore_requires_python: bool | None = None,
    ) -> None:
        """Create a SelectionPreferences object.
        :param allow_yanked: Whether files marked as yanked (in the sense
            of PEP 592) are permitted to be candidates for install.
        :param format_control: A FormatControl object or None. Used to control
            the selection of source packages / binary packages when consulting
            the index and links.
        :param prefer_binary: Whether to prefer an old, but valid, binary
            dist over a new source dist.
        :param ignore_requires_python: Whether to ignore incompatible
            "Requires-Python" values in links. Defaults to False.
        """
        if ignore_requires_python is None:
            ignore_requires_python = False
        self.allow_yanked = allow_yanked
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/models/direct_url.py =====
"""PEP 610"""
from __future__ import annotations
import json
import re
import urllib.parse
from collections.abc import Iterable
from dataclasses import dataclass
from typing import Any, ClassVar, TypeVar, Union
__all__ = [
    "DirectUrl",
    "DirectUrlValidationError",
    "DirInfo",
    "ArchiveInfo",
    "VcsInfo",
]
T = TypeVar("T")
DIRECT_URL_METADATA_NAME = "direct_url.json"
ENV_VAR_RE = re.compile(r"^\$\{[A-Za-z0-9-_]+\}(:\$\{[A-Za-z0-9-_]+\})?$")
class DirectUrlValidationError(Exception):
    pass
def _get(
    d: dict[str, Any], expected_type: type[T], key: str, default: T | None = None
) -> T | None:
    """Get value from dictionary and verify expected type."""
    if key not in d:
        return default
    value = d[key]
    if not isinstance(value, expected_type):
        raise DirectUrlValidationError(
            f"{value!r} has unexpected type for {key} (expected {expected_type})"
        )
    return value
def _get_required(
    d: dict[str, Any], expected_type: type[T], key: str, default: T | None = None
) -> T:
    value = _get(d, expected_type, key, default)
    if value is None:
        raise DirectUrlValidationError(f"{key} must have a value")
    return value
def _exactly_one_of(infos: Iterable[InfoType | None]) -> InfoType:
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/models/index.py =====
import urllib.parse
class PackageIndex:
    """Represents a Package Index and provides easier access to endpoints"""
    __slots__ = ["url", "netloc", "simple_url", "pypi_url", "file_storage_domain"]
    def __init__(self, url: str, file_storage_domain: str) -> None:
        super().__init__()
        self.url = url
        self.netloc = urllib.parse.urlsplit(url).netloc
        self.simple_url = self._url_for_path("simple")
        self.pypi_url = self._url_for_path("pypi")
        # This is part of a temporary hack used to block installs of PyPI
        # packages which depend on external urls only necessary until PyPI can
        # block such packages themselves
        self.file_storage_domain = file_storage_domain
    def _url_for_path(self, path: str) -> str:
        return urllib.parse.urljoin(self.url, path)
PyPI = PackageIndex("https://pypi.org/", file_storage_domain="files.pythonhosted.org")
TestPyPI = PackageIndex(
    "https://test.pypi.org/", file_storage_domain="test-files.pythonhosted.org"
)
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/models/target_python.py =====
from __future__ import annotations
import sys
from pip._vendor.packaging.tags import Tag
from pip._internal.utils.compatibility_tags import get_supported, version_info_to_nodot
from pip._internal.utils.misc import normalize_version_info
class TargetPython:
    """
    Encapsulates the properties of a Python interpreter one is targeting
    for a package install, download, etc.
    """
    __slots__ = [
        "_given_py_version_info",
        "abis",
        "implementation",
        "platforms",
        "py_version",
        "py_version_info",
        "_valid_tags",
        "_valid_tags_set",
    ]
    def __init__(
        self,
        platforms: list[str] | None = None,
        py_version_info: tuple[int, ...] | None = None,
        abis: list[str] | None = None,
        implementation: str | None = None,
    ) -> None:
        """
        :param platforms: A list of strings or None. If None, searches for
            packages that are supported by the current system. Otherwise, will
            find packages that can be built on the platforms passed in. These
            packages will only be downloaded for distribution: they will
            not be built locally.
        :param py_version_info: An optional tuple of ints representing the
            Python version information to use (e.g. `sys.version_info[:3]`).
            This can have length 1, 2, or 3 when provided.
        :param abis: A list of strings or None. This is passed to
            compatibility_tags.py's get_supported() function as is.
        :param implementation: A string or None. This is passed to
            compatibility_tags.py's get_supported() function as is.
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/models/pylock.py =====
from __future__ import annotations
import dataclasses
import re
from collections.abc import Iterable
from dataclasses import dataclass
from pathlib import Path
from typing import TYPE_CHECKING, Any
from pip._vendor import tomli_w
from pip._internal.models.direct_url import ArchiveInfo, DirInfo, VcsInfo
from pip._internal.models.link import Link
from pip._internal.req.req_install import InstallRequirement
from pip._internal.utils.urls import url_to_path
if TYPE_CHECKING:
    from typing_extensions import Self
PYLOCK_FILE_NAME_RE = re.compile(r"^pylock\.([^.]+)\.toml$")
def is_valid_pylock_file_name(path: Path) -> bool:
    return path.name == "pylock.toml" or bool(re.match(PYLOCK_FILE_NAME_RE, path.name))
def _toml_dict_factory(data: list[tuple[str, Any]]) -> dict[str, Any]:
    return {key.replace("_", "-"): value for key, value in data if value is not None}
@dataclass
class PackageVcs:
    type: str
    url: str | None
    # (not supported) path: Optional[str]
    requested_revision: str | None
    commit_id: str
    subdirectory: str | None
@dataclass
class PackageDirectory:
    path: str
    editable: bool | None
    subdirectory: str | None
@dataclass
class PackageArchive:
    url: str | None
    # (not supported) path: Optional[str]
    # (not supported) size: Optional[int]
    # (not supported) upload_time: Optional[datetime]
    hashes: dict[str, str]
    subdirectory: str | None
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/models/__init__.py =====
"""A package that contains models that represent entities."""
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/models/search_scope.py =====
import itertools
import logging
import os
import posixpath
import urllib.parse
from dataclasses import dataclass
from pip._vendor.packaging.utils import canonicalize_name
from pip._internal.models.index import PyPI
from pip._internal.utils.compat import has_tls
from pip._internal.utils.misc import normalize_path, redact_auth_from_url
logger = logging.getLogger(__name__)
@dataclass(frozen=True)
class SearchScope:
    """
    Encapsulates the locations that pip is configured to search.
    """
    __slots__ = ["find_links", "index_urls", "no_index"]
    find_links: list[str]
    index_urls: list[str]
    no_index: bool
    @classmethod
    def create(
        cls,
        find_links: list[str],
        index_urls: list[str],
        no_index: bool,
    ) -> "SearchScope":
        """
        Create a SearchScope object after normalizing the `find_links`.
        """
        # Build find_links. If an argument starts with ~, it may be
        # a local file relative to a home directory. So try normalizing
        # it and if it exists, use the normalized version.
        # This is deliberately conservative - it might be fine just to
        # blindly normalize anything starting with a ~...
        built_find_links: list[str] = []
        for link in find_links:
            if link.startswith("~"):
                new_link = normalize_path(link)
                if os.path.exists(new_link):
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/models/candidate.py =====
from dataclasses import dataclass
from pip._vendor.packaging.version import Version
from pip._vendor.packaging.version import parse as parse_version
from pip._internal.models.link import Link
@dataclass(frozen=True)
class InstallationCandidate:
    """Represents a potential "candidate" for installation."""
    __slots__ = ["name", "version", "link"]
    name: str
    version: Version
    link: Link
    def __init__(self, name: str, version: str, link: Link) -> None:
        object.__setattr__(self, "name", name)
        object.__setattr__(self, "version", parse_version(version))
        object.__setattr__(self, "link", link)
    def __str__(self) -> str:
        return f"{self.name!r} candidate (version {self.version} at {self.link})"
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/models/format_control.py =====
from __future__ import annotations
from pip._vendor.packaging.utils import canonicalize_name
from pip._internal.exceptions import CommandError
class FormatControl:
    """Helper for managing formats from which a package can be installed."""
    __slots__ = ["no_binary", "only_binary"]
    def __init__(
        self,
        no_binary: set[str] | None = None,
        only_binary: set[str] | None = None,
    ) -> None:
        if no_binary is None:
            no_binary = set()
        if only_binary is None:
            only_binary = set()
        self.no_binary = no_binary
        self.only_binary = only_binary
    def __eq__(self, other: object) -> bool:
        if not isinstance(other, self.__class__):
            return NotImplemented
        if self.__slots__ != other.__slots__:
            return False
        return all(getattr(self, k) == getattr(other, k) for k in self.__slots__)
    def __repr__(self) -> str:
        return f"{self.__class__.__name__}({self.no_binary}, {self.only_binary})"
    @staticmethod
    def handle_mutual_excludes(value: str, target: set[str], other: set[str]) -> None:
        if value.startswith("-"):
            raise CommandError(
                "--no-binary / --only-binary option requires 1 argument."
            )
        new = value.split(",")
        while ":all:" in new:
            other.clear()
            target.clear()
            target.add(":all:")
            del new[: new.index(":all:") + 1]
            # Without a none, we want to discard everything as :all: covers it
            if ":none:" not in new:
                return
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/models/installation_report.py =====
from collections.abc import Sequence
from typing import Any
from pip._vendor.packaging.markers import default_environment
from pip import __version__
from pip._internal.req.req_install import InstallRequirement
class InstallationReport:
    def __init__(self, install_requirements: Sequence[InstallRequirement]):
        self._install_requirements = install_requirements
    @classmethod
    def _install_req_to_dict(cls, ireq: InstallRequirement) -> dict[str, Any]:
        assert ireq.download_info, f"No download_info for {ireq}"
        res = {
            # PEP 610 json for the download URL. download_info.archive_info.hashes may
            # be absent when the requirement was installed from the wheel cache
            # and the cache entry was populated by an older pip version that did not
            # record origin.json.
            "download_info": ireq.download_info.to_dict(),
            # is_direct is true if the requirement was a direct URL reference (which
            # includes editable requirements), and false if the requirement was
            # downloaded from a PEP 503 index or --find-links.
            "is_direct": ireq.is_direct,
            # is_yanked is true if the requirement was yanked from the index, but
            # was still selected by pip to conform to PEP 592.
            "is_yanked": ireq.link.is_yanked if ireq.link else False,
            # requested is true if the requirement was specified by the user (aka
            # top level requirement), and false if it was installed as a dependency of a
            # requirement. https://peps.python.org/pep-0376/#requested
            "requested": ireq.user_supplied,
            # PEP 566 json encoding for metadata
            # https://www.python.org/dev/peps/pep-0566/#json-compatible-metadata
            "metadata": ireq.get_dist().metadata_dict,
        }
        if ireq.user_supplied and ireq.extras:
            # For top level requirements, the list of requested extras, if any.
            res["requested_extras"] = sorted(ireq.extras)
        return res
    def to_dict(self) -> dict[str, Any]:
        return {
            "version": "1",
            "pip_version": __version__,
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/models/scheme.py =====
"""
For types associated with installation schemes.
For a general overview of available schemes and their context, see
https://docs.python.org/3/install/index.html#alternate-installation.
"""
from dataclasses import dataclass
SCHEME_KEYS = ["platlib", "purelib", "headers", "scripts", "data"]
@dataclass(frozen=True)
class Scheme:
    """A Scheme holds paths which are used as the base directories for
    artifacts associated with a Python package.
    """
    __slots__ = SCHEME_KEYS
    platlib: str
    purelib: str
    headers: str
    scripts: str
    data: str
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/models/wheel.py =====
"""Represents a wheel file and provides access to the various parts of the
name that have meaning.
"""
from __future__ import annotations
import re
from collections.abc import Iterable
from pip._vendor.packaging.tags import Tag
from pip._vendor.packaging.utils import BuildTag, parse_wheel_filename
from pip._vendor.packaging.utils import (
    InvalidWheelFilename as _PackagingInvalidWheelFilename,
)
from pip._internal.exceptions import InvalidWheelFilename
from pip._internal.utils.deprecation import deprecated
class Wheel:
    """A wheel file"""
    legacy_wheel_file_re = re.compile(
        r"""^(?P<namever>(?P<name>[^\s-]+?)-(?P<ver>[^\s-]*?))
        ((-(?P<build>\d[^-]*?))?-(?P<pyver>[^\s-]+?)-(?P<abi>[^\s-]+?)-(?P<plat>[^\s-]+?)
        \.whl|\.dist-info)$""",
        re.VERBOSE,
    )
    def __init__(self, filename: str) -> None:
        self.filename = filename
        # To make mypy happy specify type hints that can come from either
        # parse_wheel_filename or the legacy_wheel_file_re match.
        self.name: str
        self._build_tag: BuildTag | None = None
        try:
            wheel_info = parse_wheel_filename(filename)
            self.name, _version, self._build_tag, self.file_tags = wheel_info
            self.version = str(_version)
        except _PackagingInvalidWheelFilename as e:
            # Check if the wheel filename is in the legacy format
            legacy_wheel_info = self.legacy_wheel_file_re.match(filename)
            if not legacy_wheel_info:
                raise InvalidWheelFilename(e.args[0]) from None
            deprecated(
                reason=(
                    f"Wheel filename {filename!r} is not correctly normalised. "
                    "Future versions of pip will raise the following error:\n"
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/cli/cmdoptions.py =====
"""
shared options and groups
The principle here is to define options once, but *not* instantiate them
globally. One reason being that options with action='append' can carry state
between parses. pip parses general options twice internally, and shouldn't
pass on state. To be consistent, all options will follow this design.
"""
from __future__ import annotations
import importlib.util
import logging
import os
import pathlib
import textwrap
from functools import partial
from optparse import SUPPRESS_HELP, Option, OptionGroup, OptionParser, Values
from textwrap import dedent
from typing import Any, Callable
from pip._vendor.packaging.utils import canonicalize_name
from pip._internal.cli.parser import ConfigOptionParser
from pip._internal.exceptions import CommandError
from pip._internal.locations import USER_CACHE_DIR, get_src_prefix
from pip._internal.models.format_control import FormatControl
from pip._internal.models.index import PyPI
from pip._internal.models.target_python import TargetPython
from pip._internal.utils.hashes import STRONG_HASHES
from pip._internal.utils.misc import strtobool
logger = logging.getLogger(__name__)
def raise_option_error(parser: OptionParser, option: Option, msg: str) -> None:
    """
    Raise an option parsing error using parser.error().
    Args:
      parser: an OptionParser instance.
      option: an Option instance.
      msg: the error text.
    """
    msg = f"{option} error: {msg}"
    msg = textwrap.fill(" ".join(msg.split()))
    parser.error(msg)
def make_option_group(group: dict[str, Any], parser: ConfigOptionParser) -> OptionGroup:
    """
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/cli/__init__.py =====
"""Subpackage containing all of pip's command line interface related code"""
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/cli/index_command.py =====
"""
Contains command classes which may interact with an index / the network.
Unlike its sister module, req_command, this module still uses lazy imports
so commands which don't always hit the network (e.g. list w/o --outdated or
--uptodate) don't need waste time importing PipSession and friends.
"""
from __future__ import annotations
import logging
import os
import sys
from functools import lru_cache
from optparse import Values
from typing import TYPE_CHECKING
from pip._vendor import certifi
from pip._internal.cli.base_command import Command
from pip._internal.cli.command_context import CommandContextMixIn
if TYPE_CHECKING:
    from ssl import SSLContext
    from pip._internal.network.session import PipSession
logger = logging.getLogger(__name__)
@lru_cache
def _create_truststore_ssl_context() -> SSLContext | None:
    if sys.version_info < (3, 10):
        logger.debug("Disabling truststore because Python version isn't 3.10+")
        return None
    try:
        import ssl
    except ImportError:
        logger.warning("Disabling truststore since ssl support is missing")
        return None
    try:
        from pip._vendor import truststore
    except ImportError:
        logger.warning("Disabling truststore because platform isn't supported")
        return None
    ctx = truststore.SSLContext(ssl.PROTOCOL_TLS_CLIENT)
    ctx.load_verify_locations(certifi.where())
    return ctx
class SessionCommandMixin(CommandContextMixIn):
    """
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/cli/status_codes.py =====
SUCCESS = 0
ERROR = 1
UNKNOWN_ERROR = 2
VIRTUALENV_NOT_FOUND = 3
PREVIOUS_BUILD_DIR_ERROR = 4
NO_MATCHES_FOUND = 23
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/cli/parser.py =====
"""Base option parser setup"""
from __future__ import annotations
import logging
import optparse
import shutil
import sys
import textwrap
from collections.abc import Generator
from contextlib import suppress
from typing import Any, NoReturn
from pip._internal.cli.status_codes import UNKNOWN_ERROR
from pip._internal.configuration import Configuration, ConfigurationError
from pip._internal.utils.misc import redact_auth_from_url, strtobool
logger = logging.getLogger(__name__)
class PrettyHelpFormatter(optparse.IndentedHelpFormatter):
    """A prettier/less verbose help formatter for optparse."""
    def __init__(self, *args: Any, **kwargs: Any) -> None:
        # help position must be aligned with __init__.parseopts.description
        kwargs["max_help_position"] = 30
        kwargs["indent_increment"] = 1
        kwargs["width"] = shutil.get_terminal_size()[0] - 2
        super().__init__(*args, **kwargs)
    def format_option_strings(self, option: optparse.Option) -> str:
        return self._format_option_strings(option)
    def _format_option_strings(
        self, option: optparse.Option, mvarfmt: str = " <{}>", optsep: str = ", "
    ) -> str:
        """
        Return a comma-separated list of option strings and metavars.
        :param option:  tuple of (short opt, long opt), e.g: ('-f', '--format')
        :param mvarfmt: metavar format string
        :param optsep:  separator
        """
        opts = []
        if option._short_opts:
            opts.append(option._short_opts[0])
        if option._long_opts:
            opts.append(option._long_opts[0])
        if len(opts) > 1:
            opts.insert(1, optsep)
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/cli/command_context.py =====
from collections.abc import Generator
from contextlib import AbstractContextManager, ExitStack, contextmanager
from typing import TypeVar
_T = TypeVar("_T", covariant=True)
class CommandContextMixIn:
    def __init__(self) -> None:
        super().__init__()
        self._in_main_context = False
        self._main_context = ExitStack()
    @contextmanager
    def main_context(self) -> Generator[None, None, None]:
        assert not self._in_main_context
        self._in_main_context = True
        try:
            with self._main_context:
                yield
        finally:
            self._in_main_context = False
    def enter_context(self, context_provider: AbstractContextManager[_T]) -> _T:
        assert self._in_main_context
        return self._main_context.enter_context(context_provider)
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/cli/spinners.py =====
from __future__ import annotations
import contextlib
import itertools
import logging
import sys
import time
from collections.abc import Generator
from typing import IO, Final
from pip._vendor.rich.console import (
    Console,
    ConsoleOptions,
    RenderableType,
    RenderResult,
)
from pip._vendor.rich.live import Live
from pip._vendor.rich.measure import Measurement
from pip._vendor.rich.text import Text
from pip._internal.utils.compat import WINDOWS
from pip._internal.utils.logging import get_console, get_indentation
logger = logging.getLogger(__name__)
SPINNER_CHARS: Final = r"-\|/"
SPINS_PER_SECOND: Final = 8
class SpinnerInterface:
    def spin(self) -> None:
        raise NotImplementedError()
    def finish(self, final_status: str) -> None:
        raise NotImplementedError()
class InteractiveSpinner(SpinnerInterface):
    def __init__(
        self,
        message: str,
        file: IO[str] | None = None,
        spin_chars: str = SPINNER_CHARS,
        # Empirically, 8 updates/second looks nice
        min_update_interval_seconds: float = 1 / SPINS_PER_SECOND,
    ):
        self._message = message
        if file is None:
            file = sys.stdout
        self._file = file
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/cli/autocompletion.py =====
"""Logic that powers autocompletion installed by ``pip completion``."""
from __future__ import annotations
import optparse
import os
import sys
from collections.abc import Iterable
from itertools import chain
from typing import Any
from pip._internal.cli.main_parser import create_main_parser
from pip._internal.commands import commands_dict, create_command
from pip._internal.metadata import get_default_environment
def autocomplete() -> None:
    """Entry Point for completion of main and subcommand options."""
    # Don't complete if user hasn't sourced bash_completion file.
    if "PIP_AUTO_COMPLETE" not in os.environ:
        return
    # Don't complete if autocompletion environment variables
    # are not present
    if not os.environ.get("COMP_WORDS") or not os.environ.get("COMP_CWORD"):
        return
    cwords = os.environ["COMP_WORDS"].split()[1:]
    cword = int(os.environ["COMP_CWORD"])
    try:
        current = cwords[cword - 1]
    except IndexError:
        current = ""
    parser = create_main_parser()
    subcommands = list(commands_dict)
    options = []
    # subcommand
    subcommand_name: str | None = None
    for word in cwords:
        if word in subcommands:
            subcommand_name = word
            break
    # subcommand options
    if subcommand_name is not None:
        # special case: 'help' subcommand has no options
        if subcommand_name == "help":
            sys.exit(1)
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/cli/base_command.py =====
"""Base Command class, and related routines"""
from __future__ import annotations
import logging
import logging.config
import optparse
import os
import sys
import traceback
from optparse import Values
from typing import Callable
from pip._vendor.rich import reconfigure
from pip._vendor.rich import traceback as rich_traceback
from pip._internal.cli import cmdoptions
from pip._internal.cli.command_context import CommandContextMixIn
from pip._internal.cli.parser import ConfigOptionParser, UpdatingDefaultsHelpFormatter
from pip._internal.cli.status_codes import (
    ERROR,
    PREVIOUS_BUILD_DIR_ERROR,
    UNKNOWN_ERROR,
    VIRTUALENV_NOT_FOUND,
)
from pip._internal.exceptions import (
    BadCommand,
    CommandError,
    DiagnosticPipError,
    InstallationError,
    NetworkConnectionError,
    PreviousBuildDirError,
)
from pip._internal.utils.filesystem import check_path_owner
from pip._internal.utils.logging import BrokenStdoutLoggingError, setup_logging
from pip._internal.utils.misc import get_prog, normalize_path
from pip._internal.utils.temp_dir import TempDirectoryTypeRegistry as TempDirRegistry
from pip._internal.utils.temp_dir import global_tempdir_manager, tempdir_registry
from pip._internal.utils.virtualenv import running_under_virtualenv
__all__ = ["Command"]
logger = logging.getLogger(__name__)
class Command(CommandContextMixIn):
    usage: str = ""
    ignore_require_venv: bool = False
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/cli/main_parser.py =====
"""A single place for constructing and exposing the main parser"""
from __future__ import annotations
import os
import subprocess
import sys
from pip._internal.build_env import get_runnable_pip
from pip._internal.cli import cmdoptions
from pip._internal.cli.parser import ConfigOptionParser, UpdatingDefaultsHelpFormatter
from pip._internal.commands import commands_dict, get_similar_commands
from pip._internal.exceptions import CommandError
from pip._internal.utils.misc import get_pip_version, get_prog
__all__ = ["create_main_parser", "parse_command"]
def create_main_parser() -> ConfigOptionParser:
    """Creates and returns the main parser for pip's CLI"""
    parser = ConfigOptionParser(
        usage="\n%prog <command> [options]",
        add_help_option=False,
        formatter=UpdatingDefaultsHelpFormatter(),
        name="global",
        prog=get_prog(),
    )
    parser.disable_interspersed_args()
    parser.version = get_pip_version()
    # add the general options
    gen_opts = cmdoptions.make_option_group(cmdoptions.general_group, parser)
    parser.add_option_group(gen_opts)
    # so the help formatter knows
    parser.main = True  # type: ignore
    # create command listing for description
    description = [""] + [
        f"{name:27} {command_info.summary}"
        for name, command_info in commands_dict.items()
    ]
    parser.description = "\n".join(description)
    return parser
def identify_python_interpreter(python: str) -> str | None:
    # If the named file exists, use it.
    # If it's a directory, assume it's a virtual environment and
    # look for the environment's Python executable.
    if os.path.exists(python):
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/cli/progress_bars.py =====
from __future__ import annotations
import functools
import sys
from collections.abc import Generator, Iterable, Iterator
from typing import Callable, Literal, TypeVar
from pip._vendor.rich.progress import (
    BarColumn,
    DownloadColumn,
    FileSizeColumn,
    MofNCompleteColumn,
    Progress,
    ProgressColumn,
    SpinnerColumn,
    TextColumn,
    TimeElapsedColumn,
    TimeRemainingColumn,
    TransferSpeedColumn,
)
from pip._internal.cli.spinners import RateLimiter
from pip._internal.req.req_install import InstallRequirement
from pip._internal.utils.logging import get_console, get_indentation
T = TypeVar("T")
ProgressRenderer = Callable[[Iterable[T]], Iterator[T]]
BarType = Literal["on", "off", "raw"]
def _rich_download_progress_bar(
    iterable: Iterable[bytes],
    *,
    bar_type: BarType,
    size: int | None,
    initial_progress: int | None = None,
) -> Generator[bytes, None, None]:
    assert bar_type == "on", "This should only be used in the default mode."
    if not size:
        total = float("inf")
        columns: tuple[ProgressColumn, ...] = (
            TextColumn("[progress.description]{task.description}"),
            SpinnerColumn("line", speed=1.5),
            FileSizeColumn(),
            TransferSpeedColumn(),
            TimeElapsedColumn(),
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/cli/main.py =====
"""Primary application entrypoint."""
from __future__ import annotations
import locale
import logging
import os
import sys
import warnings
from pip._internal.cli.autocompletion import autocomplete
from pip._internal.cli.main_parser import parse_command
from pip._internal.commands import create_command
from pip._internal.exceptions import PipError
from pip._internal.utils import deprecation
logger = logging.getLogger(__name__)
def main(args: list[str] | None = None) -> int:
    if args is None:
        args = sys.argv[1:]
    # Suppress the pkg_resources deprecation warning
    # Note - we use a module of .*pkg_resources to cover
    # the normal case (pip._vendor.pkg_resources) and the
    # devendored case (a bare pkg_resources)
    warnings.filterwarnings(
        action="ignore", category=DeprecationWarning, module=".*pkg_resources"
    )
    # Configure our deprecation warnings to be sent through loggers
    deprecation.install_warning_logger()
    autocomplete()
    try:
        cmd_name, cmd_args = parse_command(args)
    except PipError as exc:
        sys.stderr.write(f"ERROR: {exc}")
        sys.stderr.write(os.linesep)
        sys.exit(1)
    # Needed for locale.getpreferredencoding(False) to work
    # in pip._internal.utils.encoding.auto_decode
    try:
        locale.setlocale(locale.LC_ALL, "")
    except locale.Error as e:
        # setlocale can apparently crash if locale are uninitialized
        logger.debug("Ignoring error %s when setting locale", e)
    command = create_command(cmd_name, isolated=("--isolated" in cmd_args))
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/cli/req_command.py =====
"""Contains the RequirementCommand base class.
This class is in a separate module so the commands that do not always
need PackageFinder capability don't unnecessarily import the
PackageFinder machinery and all its vendored dependencies, etc.
"""
from __future__ import annotations
import logging
from functools import partial
from optparse import Values
from typing import Any
from pip._internal.build_env import SubprocessBuildEnvironmentInstaller
from pip._internal.cache import WheelCache
from pip._internal.cli import cmdoptions
from pip._internal.cli.index_command import IndexGroupCommand
from pip._internal.cli.index_command import SessionCommandMixin as SessionCommandMixin
from pip._internal.exceptions import CommandError, PreviousBuildDirError
from pip._internal.index.collector import LinkCollector
from pip._internal.index.package_finder import PackageFinder
from pip._internal.models.selection_prefs import SelectionPreferences
from pip._internal.models.target_python import TargetPython
from pip._internal.network.session import PipSession
from pip._internal.operations.build.build_tracker import BuildTracker
from pip._internal.operations.prepare import RequirementPreparer
from pip._internal.req.constructors import (
    install_req_from_editable,
    install_req_from_line,
    install_req_from_parsed_requirement,
    install_req_from_req_string,
)
from pip._internal.req.req_dependency_group import parse_dependency_groups
from pip._internal.req.req_file import parse_requirements
from pip._internal.req.req_install import InstallRequirement
from pip._internal.resolution.base import BaseResolver
from pip._internal.utils.temp_dir import (
    TempDirectory,
    TempDirectoryTypeRegistry,
    tempdir_kinds,
)
logger = logging.getLogger(__name__)
KEEPABLE_TEMPDIR_TYPES = [
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/operations/install/editable_legacy.py =====
"""Legacy editable installation process, i.e. `setup.py develop`."""
from __future__ import annotations
import logging
from collections.abc import Sequence
from pip._internal.build_env import BuildEnvironment
from pip._internal.utils.logging import indent_log
from pip._internal.utils.setuptools_build import make_setuptools_develop_args
from pip._internal.utils.subprocess import call_subprocess
logger = logging.getLogger(__name__)
def install_editable(
    *,
    global_options: Sequence[str],
    prefix: str | None,
    home: str | None,
    use_user_site: bool,
    name: str,
    setup_py_path: str,
    isolated: bool,
    build_env: BuildEnvironment,
    unpacked_source_directory: str,
) -> None:
    """Install a package in editable mode. Most arguments are pass-through
    to setuptools.
    """
    logger.info("Running setup.py develop for %s", name)
    args = make_setuptools_develop_args(
        setup_py_path,
        global_options=global_options,
        no_user_config=isolated,
        prefix=prefix,
        home=home,
        use_user_site=use_user_site,
    )
    with indent_log():
        with build_env:
            call_subprocess(
                args,
                command_desc="python setup.py develop",
                cwd=unpacked_source_directory,
            )
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/operations/install/__init__.py =====
"""For modules related to installing packages."""
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/operations/install/wheel.py =====
"""Support for installing and building the "wheel" binary package format."""
from __future__ import annotations
import collections
import compileall
import contextlib
import csv
import importlib
import logging
import os.path
import re
import shutil
import sys
import textwrap
import warnings
from base64 import urlsafe_b64encode
from collections.abc import Generator, Iterable, Iterator, Sequence
from email.message import Message
from itertools import chain, filterfalse, starmap
from typing import (
    IO,
    Any,
    BinaryIO,
    Callable,
    NewType,
    Protocol,
    Union,
    cast,
)
from zipfile import ZipFile, ZipInfo
from pip._vendor.distlib.scripts import ScriptMaker
from pip._vendor.distlib.util import get_export_entry
from pip._vendor.packaging.utils import canonicalize_name
from pip._internal.exceptions import InstallationError
from pip._internal.locations import get_major_minor_version
from pip._internal.metadata import (
    BaseDistribution,
    FilesystemWheel,
    get_wheel_distribution,
)
from pip._internal.models.direct_url import DIRECT_URL_METADATA_NAME, DirectUrl
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/operations/check.py =====
"""Validation of dependencies of packages"""
from __future__ import annotations
import logging
from collections.abc import Generator, Iterable
from contextlib import suppress
from email.parser import Parser
from functools import reduce
from typing import (
    Callable,
    NamedTuple,
)
from pip._vendor.packaging.requirements import Requirement
from pip._vendor.packaging.tags import Tag, parse_tag
from pip._vendor.packaging.utils import NormalizedName, canonicalize_name
from pip._vendor.packaging.version import Version
from pip._internal.distributions import make_distribution_for_install_requirement
from pip._internal.metadata import get_default_environment
from pip._internal.metadata.base import BaseDistribution
from pip._internal.req.req_install import InstallRequirement
logger = logging.getLogger(__name__)
class PackageDetails(NamedTuple):
    version: Version
    dependencies: list[Requirement]
PackageSet = dict[NormalizedName, PackageDetails]
Missing = tuple[NormalizedName, Requirement]
Conflicting = tuple[NormalizedName, Version, Requirement]
MissingDict = dict[NormalizedName, list[Missing]]
ConflictingDict = dict[NormalizedName, list[Conflicting]]
CheckResult = tuple[MissingDict, ConflictingDict]
ConflictDetails = tuple[PackageSet, CheckResult]
def create_package_set_from_installed() -> tuple[PackageSet, bool]:
    """Converts a list of distributions into a PackageSet."""
    package_set = {}
    problems = False
    env = get_default_environment()
    for dist in env.iter_installed_distributions(local_only=False, skip=()):
        name = dist.canonical_name
        try:
            dependencies = list(dist.iter_dependencies())
            package_set[name] = PackageDetails(dist.version, dependencies)
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/operations/__init__.py =====
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/operations/freeze.py =====
from __future__ import annotations
import collections
import logging
import os
from collections.abc import Container, Generator, Iterable
from dataclasses import dataclass, field
from typing import NamedTuple
from pip._vendor.packaging.utils import NormalizedName, canonicalize_name
from pip._vendor.packaging.version import InvalidVersion
from pip._internal.exceptions import BadCommand, InstallationError
from pip._internal.metadata import BaseDistribution, get_environment
from pip._internal.req.constructors import (
    install_req_from_editable,
    install_req_from_line,
)
from pip._internal.req.req_file import COMMENT_RE
from pip._internal.utils.direct_url_helpers import direct_url_as_pep440_direct_reference
logger = logging.getLogger(__name__)
class _EditableInfo(NamedTuple):
    requirement: str
    comments: list[str]
def freeze(
    requirement: list[str] | None = None,
    local_only: bool = False,
    user_only: bool = False,
    paths: list[str] | None = None,
    isolated: bool = False,
    exclude_editable: bool = False,
    skip: Container[str] = (),
) -> Generator[str, None, None]:
    installations: dict[str, FrozenRequirement] = {}
    dists = get_environment(paths).iter_installed_distributions(
        local_only=local_only,
        skip=(),
        user_only=user_only,
    )
    for dist in dists:
        req = FrozenRequirement.from_dist(dist)
        if exclude_editable and req.editable:
            continue
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/operations/build/wheel_legacy.py =====
from __future__ import annotations
import logging
import os.path
from pip._internal.cli.spinners import open_spinner
from pip._internal.utils.deprecation import deprecated
from pip._internal.utils.setuptools_build import make_setuptools_bdist_wheel_args
from pip._internal.utils.subprocess import call_subprocess, format_command_args
logger = logging.getLogger(__name__)
def format_command_result(
    command_args: list[str],
    command_output: str,
) -> str:
    """Format command information for logging."""
    command_desc = format_command_args(command_args)
    text = f"Command arguments: {command_desc}\n"
    if not command_output:
        text += "Command output: None"
    elif logger.getEffectiveLevel() > logging.DEBUG:
        text += "Command output: [use --verbose to show]"
    else:
        if not command_output.endswith("\n"):
            command_output += "\n"
        text += f"Command output:\n{command_output}"
    return text
def get_legacy_build_wheel_path(
    names: list[str],
    temp_dir: str,
    name: str,
    command_args: list[str],
    command_output: str,
) -> str | None:
    """Return the path to the wheel in the temporary build directory."""
    # Sort for determinism.
    names = sorted(names)
    if not names:
        msg = f"Legacy build of wheel for {name!r} created no files.\n"
        msg += format_command_result(command_args, command_output)
        logger.warning(msg)
        return None
    if len(names) > 1:
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/operations/build/metadata.py =====
"""Metadata generation logic for source distributions."""
import os
from pip._vendor.pyproject_hooks import BuildBackendHookCaller
from pip._internal.build_env import BuildEnvironment
from pip._internal.exceptions import (
    InstallationSubprocessError,
    MetadataGenerationFailed,
)
from pip._internal.utils.subprocess import runner_with_spinner_message
from pip._internal.utils.temp_dir import TempDirectory
def generate_metadata(
    build_env: BuildEnvironment, backend: BuildBackendHookCaller, details: str
) -> str:
    """Generate metadata using mechanisms described in PEP 517.
    Returns the generated metadata directory.
    """
    metadata_tmpdir = TempDirectory(kind="modern-metadata", globally_managed=True)
    metadata_dir = metadata_tmpdir.path
    with build_env:
        # Note that BuildBackendHookCaller implements a fallback for
        # prepare_metadata_for_build_wheel, so we don't have to
        # consider the possibility that this hook doesn't exist.
        runner = runner_with_spinner_message("Preparing metadata (pyproject.toml)")
        with backend.subprocess_runner(runner):
            try:
                distinfo_dir = backend.prepare_metadata_for_build_wheel(metadata_dir)
            except InstallationSubprocessError as error:
                raise MetadataGenerationFailed(package_details=details) from error
    return os.path.join(metadata_dir, distinfo_dir)
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/operations/build/metadata_editable.py =====
"""Metadata generation logic for source distributions."""
import os
from pip._vendor.pyproject_hooks import BuildBackendHookCaller
from pip._internal.build_env import BuildEnvironment
from pip._internal.exceptions import (
    InstallationSubprocessError,
    MetadataGenerationFailed,
)
from pip._internal.utils.subprocess import runner_with_spinner_message
from pip._internal.utils.temp_dir import TempDirectory
def generate_editable_metadata(
    build_env: BuildEnvironment, backend: BuildBackendHookCaller, details: str
) -> str:
    """Generate metadata using mechanisms described in PEP 660.
    Returns the generated metadata directory.
    """
    metadata_tmpdir = TempDirectory(kind="modern-metadata", globally_managed=True)
    metadata_dir = metadata_tmpdir.path
    with build_env:
        # Note that BuildBackendHookCaller implements a fallback for
        # prepare_metadata_for_build_wheel/editable, so we don't have to
        # consider the possibility that this hook doesn't exist.
        runner = runner_with_spinner_message(
            "Preparing editable metadata (pyproject.toml)"
        )
        with backend.subprocess_runner(runner):
            try:
                distinfo_dir = backend.prepare_metadata_for_build_editable(metadata_dir)
            except InstallationSubprocessError as error:
                raise MetadataGenerationFailed(package_details=details) from error
    assert distinfo_dir is not None
    return os.path.join(metadata_dir, distinfo_dir)
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/operations/build/wheel_editable.py =====
from __future__ import annotations
import logging
import os
from pip._vendor.pyproject_hooks import BuildBackendHookCaller, HookMissing
from pip._internal.utils.subprocess import runner_with_spinner_message
logger = logging.getLogger(__name__)
def build_wheel_editable(
    name: str,
    backend: BuildBackendHookCaller,
    metadata_directory: str,
    tempd: str,
) -> str | None:
    """Build one InstallRequirement using the PEP 660 build process.
    Returns path to wheel if successfully built. Otherwise, returns None.
    """
    assert metadata_directory is not None
    try:
        logger.debug("Destination directory: %s", tempd)
        runner = runner_with_spinner_message(
            f"Building editable for {name} (pyproject.toml)"
        )
        with backend.subprocess_runner(runner):
            try:
                wheel_name = backend.build_editable(
                    tempd,
                    metadata_directory=metadata_directory,
                )
            except HookMissing as e:
                logger.error(
                    "Cannot build editable %s because the build "
                    "backend does not have the %s hook",
                    name,
                    e,
                )
                return None
    except Exception:
        logger.error("Failed building editable for %s", name)
        return None
    return os.path.join(tempd, wheel_name)
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/operations/build/__init__.py =====
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/operations/build/metadata_legacy.py =====
"""Metadata generation logic for legacy source distributions."""
import logging
import os
from pip._internal.build_env import BuildEnvironment
from pip._internal.cli.spinners import open_spinner
from pip._internal.exceptions import (
    InstallationError,
    InstallationSubprocessError,
    MetadataGenerationFailed,
)
from pip._internal.utils.setuptools_build import make_setuptools_egg_info_args
from pip._internal.utils.subprocess import call_subprocess
from pip._internal.utils.temp_dir import TempDirectory
logger = logging.getLogger(__name__)
def _find_egg_info(directory: str) -> str:
    """Find an .egg-info subdirectory in `directory`."""
    filenames = [f for f in os.listdir(directory) if f.endswith(".egg-info")]
    if not filenames:
        raise InstallationError(f"No .egg-info directory found in {directory}")
    if len(filenames) > 1:
        raise InstallationError(
            f"More than one .egg-info directory found in {directory}"
        )
    return os.path.join(directory, filenames[0])
def generate_metadata(
    build_env: BuildEnvironment,
    setup_py_path: str,
    source_dir: str,
    isolated: bool,
    details: str,
) -> str:
    """Generate metadata using setup.py-based defacto mechanisms.
    Returns the generated metadata directory.
    """
    logger.debug(
        "Running setup.py (path:%s) egg_info for package %s",
        setup_py_path,
        details,
    )
    egg_info_dir = TempDirectory(kind="pip-egg-info", globally_managed=True).path
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/operations/build/wheel.py =====
from __future__ import annotations
import logging
import os
from pip._vendor.pyproject_hooks import BuildBackendHookCaller
from pip._internal.utils.subprocess import runner_with_spinner_message
logger = logging.getLogger(__name__)
def build_wheel_pep517(
    name: str,
    backend: BuildBackendHookCaller,
    metadata_directory: str,
    tempd: str,
) -> str | None:
    """Build one InstallRequirement using the PEP 517 build process.
    Returns path to wheel if successfully built. Otherwise, returns None.
    """
    assert metadata_directory is not None
    try:
        logger.debug("Destination directory: %s", tempd)
        runner = runner_with_spinner_message(
            f"Building wheel for {name} (pyproject.toml)"
        )
        with backend.subprocess_runner(runner):
            wheel_name = backend.build_wheel(
                tempd,
                metadata_directory=metadata_directory,
            )
    except Exception:
        logger.error("Failed building wheel for %s", name)
        return None
    return os.path.join(tempd, wheel_name)
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/operations/build/build_tracker.py =====
from __future__ import annotations
import contextlib
import hashlib
import logging
import os
from collections.abc import Generator
from types import TracebackType
from pip._internal.req.req_install import InstallRequirement
from pip._internal.utils.temp_dir import TempDirectory
logger = logging.getLogger(__name__)
@contextlib.contextmanager
def update_env_context_manager(**changes: str) -> Generator[None, None, None]:
    target = os.environ
    # Save values from the target and change them.
    non_existent_marker = object()
    saved_values: dict[str, object | str] = {}
    for name, new_value in changes.items():
        try:
            saved_values[name] = target[name]
        except KeyError:
            saved_values[name] = non_existent_marker
        target[name] = new_value
    try:
        yield
    finally:
        # Restore original values in the target.
        for name, original_value in saved_values.items():
            if original_value is non_existent_marker:
                del target[name]
            else:
                assert isinstance(original_value, str)  # for mypy
                target[name] = original_value
@contextlib.contextmanager
def get_build_tracker() -> Generator[BuildTracker, None, None]:
    root = os.environ.get("PIP_BUILD_TRACKER")
    with contextlib.ExitStack() as ctx:
        if root is None:
            root = ctx.enter_context(TempDirectory(kind="build-tracker")).path
            ctx.enter_context(update_env_context_manager(PIP_BUILD_TRACKER=root))
            logger.debug("Initialized build tracking at %s", root)
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/operations/prepare.py =====
"""Prepares a distribution for installation"""
from __future__ import annotations
import mimetypes
import os
import shutil
from collections.abc import Iterable
from dataclasses import dataclass
from pathlib import Path
from typing import TYPE_CHECKING
from pip._vendor.packaging.utils import canonicalize_name
from pip._internal.build_env import BuildEnvironmentInstaller
from pip._internal.distributions import make_distribution_for_install_requirement
from pip._internal.distributions.installed import InstalledDistribution
from pip._internal.exceptions import (
    DirectoryUrlHashUnsupported,
    HashMismatch,
    HashUnpinned,
    InstallationError,
    MetadataInconsistent,
    NetworkConnectionError,
    VcsHashUnsupported,
)
from pip._internal.index.package_finder import PackageFinder
from pip._internal.metadata import BaseDistribution, get_metadata_distribution
from pip._internal.models.direct_url import ArchiveInfo
from pip._internal.models.link import Link
from pip._internal.models.wheel import Wheel
from pip._internal.network.download import Downloader
from pip._internal.network.lazy_wheel import (
    HTTPRangeRequestUnsupported,
    dist_from_wheel_url,
)
from pip._internal.network.session import PipSession
from pip._internal.operations.build.build_tracker import BuildTracker
from pip._internal.req.req_install import InstallRequirement
from pip._internal.utils._log import getLogger
from pip._internal.utils.direct_url_helpers import (
    direct_url_for_editable,
    direct_url_from_link,
)
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/req/req_install.py =====
from __future__ import annotations
import functools
import logging
import os
import shutil
import sys
import uuid
import zipfile
from collections.abc import Collection, Iterable, Sequence
from optparse import Values
from pathlib import Path
from typing import Any
from pip._vendor.packaging.markers import Marker
from pip._vendor.packaging.requirements import Requirement
from pip._vendor.packaging.specifiers import SpecifierSet
from pip._vendor.packaging.utils import canonicalize_name
from pip._vendor.packaging.version import Version
from pip._vendor.packaging.version import parse as parse_version
from pip._vendor.pyproject_hooks import BuildBackendHookCaller
from pip._internal.build_env import BuildEnvironment, NoOpBuildEnvironment
from pip._internal.exceptions import InstallationError, PreviousBuildDirError
from pip._internal.locations import get_scheme
from pip._internal.metadata import (
    BaseDistribution,
    get_default_environment,
    get_directory_distribution,
    get_wheel_distribution,
)
from pip._internal.metadata.base import FilesystemWheel
from pip._internal.models.direct_url import DirectUrl
from pip._internal.models.link import Link
from pip._internal.operations.build.metadata import generate_metadata
from pip._internal.operations.build.metadata_editable import generate_editable_metadata
from pip._internal.operations.build.metadata_legacy import (
    generate_metadata as generate_metadata_legacy,
)
from pip._internal.operations.install.editable_legacy import (
    install_editable as install_editable_legacy,
)
from pip._internal.operations.install.wheel import install_wheel
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/req/req_set.py =====
import logging
from collections import OrderedDict
from pip._vendor.packaging.utils import canonicalize_name
from pip._internal.req.req_install import InstallRequirement
logger = logging.getLogger(__name__)
class RequirementSet:
    def __init__(self, check_supported_wheels: bool = True) -> None:
        """Create a RequirementSet."""
        self.requirements: dict[str, InstallRequirement] = OrderedDict()
        self.check_supported_wheels = check_supported_wheels
        self.unnamed_requirements: list[InstallRequirement] = []
    def __str__(self) -> str:
        requirements = sorted(
            (req for req in self.requirements.values() if not req.comes_from),
            key=lambda req: canonicalize_name(req.name or ""),
        )
        return " ".join(str(req.req) for req in requirements)
    def __repr__(self) -> str:
        requirements = sorted(
            self.requirements.values(),
            key=lambda req: canonicalize_name(req.name or ""),
        )
        format_string = "<{classname} object; {count} requirement(s): {reqs}>"
        return format_string.format(
            classname=self.__class__.__name__,
            count=len(requirements),
            reqs=", ".join(str(req.req) for req in requirements),
        )
    def add_unnamed_requirement(self, install_req: InstallRequirement) -> None:
        assert not install_req.name
        self.unnamed_requirements.append(install_req)
    def add_named_requirement(self, install_req: InstallRequirement) -> None:
        assert install_req.name
        project_name = canonicalize_name(install_req.name)
        self.requirements[project_name] = install_req
    def has_requirement(self, name: str) -> bool:
        project_name = canonicalize_name(name)
        return (
            project_name in self.requirements
            and not self.requirements[project_name].constraint
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/req/req_uninstall.py =====
from __future__ import annotations
import functools
import os
import sys
import sysconfig
from collections.abc import Generator, Iterable
from importlib.util import cache_from_source
from typing import Any, Callable
from pip._internal.exceptions import LegacyDistutilsInstall, UninstallMissingRecord
from pip._internal.locations import get_bin_prefix, get_bin_user
from pip._internal.metadata import BaseDistribution
from pip._internal.utils.compat import WINDOWS
from pip._internal.utils.egg_link import egg_link_path_from_location
from pip._internal.utils.logging import getLogger, indent_log
from pip._internal.utils.misc import ask, normalize_path, renames, rmtree
from pip._internal.utils.temp_dir import AdjacentTempDirectory, TempDirectory
from pip._internal.utils.virtualenv import running_under_virtualenv
logger = getLogger(__name__)
def _script_names(
    bin_dir: str, script_name: str, is_gui: bool
) -> Generator[str, None, None]:
    """Create the fully qualified name of the files created by
    {console,gui}_scripts for the given ``dist``.
    Returns the list of file names
    """
    exe_name = os.path.join(bin_dir, script_name)
    yield exe_name
    if not WINDOWS:
        return
    yield f"{exe_name}.exe"
    yield f"{exe_name}.exe.manifest"
    if is_gui:
        yield f"{exe_name}-script.pyw"
    else:
        yield f"{exe_name}-script.py"
def _unique(
    fn: Callable[..., Generator[Any, None, None]],
) -> Callable[..., Generator[Any, None, None]]:
    @functools.wraps(fn)
    def unique(*args: Any, **kw: Any) -> Generator[Any, None, None]:
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/req/__init__.py =====
from __future__ import annotations
import collections
import logging
from collections.abc import Generator, Sequence
from dataclasses import dataclass
from pip._internal.cli.progress_bars import BarType, get_install_progress_renderer
from pip._internal.utils.logging import indent_log
from .req_file import parse_requirements
from .req_install import InstallRequirement
from .req_set import RequirementSet
__all__ = [
    "RequirementSet",
    "InstallRequirement",
    "parse_requirements",
    "install_given_reqs",
]
logger = logging.getLogger(__name__)
@dataclass(frozen=True)
class InstallationResult:
    name: str
def _validate_requirements(
    requirements: list[InstallRequirement],
) -> Generator[tuple[str, InstallRequirement], None, None]:
    for req in requirements:
        assert req.name, f"invalid to-be-installed requirement: {req}"
        yield req.name, req
def install_given_reqs(
    requirements: list[InstallRequirement],
    global_options: Sequence[str],
    root: str | None,
    home: str | None,
    prefix: str | None,
    warn_script_location: bool,
    use_user_site: bool,
    pycompile: bool,
    progress_bar: BarType,
) -> list[InstallationResult]:
    """
    Install everything in the given list.
    (to be called after having downloaded and unpacked the packages)
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/req/req_dependency_group.py =====
from collections.abc import Iterable, Iterator
from typing import Any
from pip._vendor.dependency_groups import DependencyGroupResolver
from pip._internal.exceptions import InstallationError
from pip._internal.utils.compat import tomllib
def parse_dependency_groups(groups: list[tuple[str, str]]) -> list[str]:
    """
    Parse dependency groups data as provided via the CLI, in a `[path:]group` syntax.
    Raises InstallationErrors if anything goes wrong.
    """
    resolvers = _build_resolvers(path for (path, _) in groups)
    return list(_resolve_all_groups(resolvers, groups))
def _resolve_all_groups(
    resolvers: dict[str, DependencyGroupResolver], groups: list[tuple[str, str]]
) -> Iterator[str]:
    """
    Run all resolution, converting any error from `DependencyGroupResolver` into
    an InstallationError.
    """
    for path, groupname in groups:
        resolver = resolvers[path]
        try:
            yield from (str(req) for req in resolver.resolve(groupname))
        except (ValueError, TypeError, LookupError) as e:
            raise InstallationError(
                f"[dependency-groups] resolution failed for '{groupname}' "
                f"from '{path}': {e}"
            ) from e
def _build_resolvers(paths: Iterable[str]) -> dict[str, Any]:
    resolvers = {}
    for path in paths:
        if path in resolvers:
            continue
        pyproject = _load_pyproject(path)
        if "dependency-groups" not in pyproject:
            raise InstallationError(
                f"[dependency-groups] table was missing from '{path}'. "
                "Cannot resolve '--group' option."
            )
        raw_dependency_groups = pyproject["dependency-groups"]
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/req/req_file.py =====
"""
Requirements file parsing
"""
from __future__ import annotations
import codecs
import locale
import logging
import optparse
import os
import re
import shlex
import sys
import urllib.parse
from collections.abc import Generator, Iterable
from dataclasses import dataclass
from optparse import Values
from typing import (
    TYPE_CHECKING,
    Any,
    Callable,
    NoReturn,
)
from pip._internal.cli import cmdoptions
from pip._internal.exceptions import InstallationError, RequirementsFileParseError
from pip._internal.models.search_scope import SearchScope
if TYPE_CHECKING:
    from pip._internal.index.package_finder import PackageFinder
    from pip._internal.network.session import PipSession
__all__ = ["parse_requirements"]
ReqFileLines = Iterable[tuple[int, str]]
LineParser = Callable[[str], tuple[str, Values]]
SCHEME_RE = re.compile(r"^(http|https|file):", re.I)
COMMENT_RE = re.compile(r"(^|\s+)#.*$")
ENV_VAR_RE = re.compile(r"(?P<var>\$\{(?P<name>[A-Z0-9_]+)\})")
SUPPORTED_OPTIONS: list[Callable[..., optparse.Option]] = [
    cmdoptions.index_url,
    cmdoptions.extra_index_url,
    cmdoptions.no_index,
    cmdoptions.constraints,
    cmdoptions.requirements,
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/req/constructors.py =====
"""Backing implementation for InstallRequirement's various constructors
The idea here is that these formed a major chunk of InstallRequirement's size
so, moving them and support code dedicated to them outside of that class
helps creates for better understandability for the rest of the code.
These are meant to be used elsewhere within pip to create instances of
InstallRequirement.
"""
from __future__ import annotations
import copy
import logging
import os
import re
from collections.abc import Collection
from dataclasses import dataclass
from pip._vendor.packaging.markers import Marker
from pip._vendor.packaging.requirements import InvalidRequirement, Requirement
from pip._vendor.packaging.specifiers import Specifier
from pip._internal.exceptions import InstallationError
from pip._internal.models.index import PyPI, TestPyPI
from pip._internal.models.link import Link
from pip._internal.models.wheel import Wheel
from pip._internal.req.req_file import ParsedRequirement
from pip._internal.req.req_install import InstallRequirement
from pip._internal.utils.filetypes import is_archive_file
from pip._internal.utils.misc import is_installable_dir
from pip._internal.utils.packaging import get_requirement
from pip._internal.utils.urls import path_to_url
from pip._internal.vcs import is_url, vcs
__all__ = [
    "install_req_from_editable",
    "install_req_from_line",
    "parse_editable",
]
logger = logging.getLogger(__name__)
operators = Specifier._operators.keys()
def _strip_extras(path: str) -> tuple[str, str | None]:
    m = re.match(r"^(.+)(\[[^\]]+\])$", path)
    extras = None
    if m:
        path_no_extras = m.group(1)
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/resolution/legacy/__init__.py =====
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/resolution/legacy/resolver.py =====
"""Dependency Resolution
The dependency resolution in pip is performed as follows:
for top-level requirements:
    a. only one spec allowed per project, regardless of conflicts or not.
       otherwise a "double requirement" exception is raised
    b. they override sub-dependency requirements.
for sub-dependencies
    a. "first found, wins" (where the order is breadth first)
"""
from __future__ import annotations
import logging
import sys
from collections import defaultdict
from collections.abc import Iterable
from itertools import chain
from typing import Optional
from pip._vendor.packaging import specifiers
from pip._vendor.packaging.requirements import Requirement
from pip._internal.cache import WheelCache
from pip._internal.exceptions import (
    BestVersionAlreadyInstalled,
    DistributionNotFound,
    HashError,
    HashErrors,
    InstallationError,
    NoneMetadataError,
    UnsupportedPythonVersion,
)
from pip._internal.index.package_finder import PackageFinder
from pip._internal.metadata import BaseDistribution
from pip._internal.models.link import Link
from pip._internal.models.wheel import Wheel
from pip._internal.operations.prepare import RequirementPreparer
from pip._internal.req.req_install import (
    InstallRequirement,
    check_invalid_constraint_type,
)
from pip._internal.req.req_set import RequirementSet
from pip._internal.resolution.base import BaseResolver, InstallRequirementProvider
from pip._internal.utils import compatibility_tags
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/resolution/__init__.py =====
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/resolution/base.py =====
from typing import Callable, Optional
from pip._internal.req.req_install import InstallRequirement
from pip._internal.req.req_set import RequirementSet
InstallRequirementProvider = Callable[
    [str, Optional[InstallRequirement]], InstallRequirement
]
class BaseResolver:
    def resolve(
        self, root_reqs: list[InstallRequirement], check_supported_wheels: bool
    ) -> RequirementSet:
        raise NotImplementedError()
    def get_installation_order(
        self, req_set: RequirementSet
    ) -> list[InstallRequirement]:
        raise NotImplementedError()
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/resolution/resolvelib/provider.py =====
from __future__ import annotations
import math
from collections.abc import Iterable, Iterator, Mapping, Sequence
from functools import cache
from typing import (
    TYPE_CHECKING,
    TypeVar,
)
from pip._vendor.resolvelib.providers import AbstractProvider
from pip._internal.req.req_install import InstallRequirement
from .base import Candidate, Constraint, Requirement
from .candidates import REQUIRES_PYTHON_IDENTIFIER
from .factory import Factory
from .requirements import ExplicitRequirement
if TYPE_CHECKING:
    from pip._vendor.resolvelib.providers import Preference
    from pip._vendor.resolvelib.resolvers import RequirementInformation
    PreferenceInformation = RequirementInformation[Requirement, Candidate]
    _ProviderBase = AbstractProvider[Requirement, Candidate, str]
else:
    _ProviderBase = AbstractProvider
D = TypeVar("D")
V = TypeVar("V")
def _get_with_identifier(
    mapping: Mapping[str, V],
    identifier: str,
    default: D,
) -> D | V:
    """Get item from a package name lookup mapping with a resolver identifier.
    This extra logic is needed when the target mapping is keyed by package
    name, which cannot be directly looked up with an identifier (which may
    contain requested extras). Additional logic is added to also look up a value
    by "cleaning up" the extras from the identifier.
    """
    if identifier in mapping:
        return mapping[identifier]
    # HACK: Theoretically we should check whether this identifier is a valid
    # "NAME[EXTRAS]" format, and parse out the name part with packaging or
    # some regular expression. But since pip's resolver only spits out three
    # kinds of identifiers: normalized PEP 503 names, normalized names plus
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/resolution/resolvelib/found_candidates.py =====
"""Utilities to lazily create and visit candidates found.
Creating and visiting a candidate is a *very* costly operation. It involves
fetching, extracting, potentially building modules from source, and verifying
distribution metadata. It is therefore crucial for performance to keep
everything here lazy all the way down, so we only touch candidates that we
absolutely need, and not "download the world" when we only need one version of
something.
"""
from __future__ import annotations
import logging
from collections.abc import Iterator, Sequence
from typing import Any, Callable, Optional
from pip._vendor.packaging.version import _BaseVersion
from pip._internal.exceptions import MetadataInvalid
from .base import Candidate
logger = logging.getLogger(__name__)
IndexCandidateInfo = tuple[_BaseVersion, Callable[[], Optional[Candidate]]]
def _iter_built(infos: Iterator[IndexCandidateInfo]) -> Iterator[Candidate]:
    """Iterator for ``FoundCandidates``.
    This iterator is used when the package is not already installed. Candidates
    from index come later in their normal ordering.
    """
    versions_found: set[_BaseVersion] = set()
    for version, func in infos:
        if version in versions_found:
            continue
        try:
            candidate = func()
        except MetadataInvalid as e:
            logger.warning(
                "Ignoring version %s of %s since it has invalid metadata:\n"
                "%s\n"
                "Please use pip<24.1 if you need to use this version.",
                version,
                e.ireq.name,
                e,
            )
            # Mark version as found to avoid trying other candidates with the same
            # version, since they most likely have invalid metadata as well.
            versions_found.add(version)
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/resolution/resolvelib/reporter.py =====
from __future__ import annotations
from collections import defaultdict
from logging import getLogger
from typing import Any
from pip._vendor.resolvelib.reporters import BaseReporter
from .base import Candidate, Requirement
logger = getLogger(__name__)
class PipReporter(BaseReporter[Requirement, Candidate, str]):
    def __init__(self) -> None:
        self.reject_count_by_package: defaultdict[str, int] = defaultdict(int)
        self._messages_at_reject_count = {
            1: (
                "pip is looking at multiple versions of {package_name} to "
                "determine which version is compatible with other "
                "requirements. This could take a while."
            ),
            8: (
                "pip is still looking at multiple versions of {package_name} to "
                "determine which version is compatible with other "
                "requirements. This could take a while."
            ),
            13: (
                "This is taking longer than usual. You might need to provide "
                "the dependency resolver with stricter constraints to reduce "
                "runtime. See https://pip.pypa.io/warnings/backtracking for "
                "guidance. If you want to abort this run, press Ctrl + C."
            ),
        }
    def rejecting_candidate(self, criterion: Any, candidate: Candidate) -> None:
        self.reject_count_by_package[candidate.name] += 1
        count = self.reject_count_by_package[candidate.name]
        if count not in self._messages_at_reject_count:
            return
        message = self._messages_at_reject_count[count]
        logger.info("INFO: %s", message.format(package_name=candidate.name))
        msg = "Will try a different candidate, due to conflict:"
        for req_info in criterion.information:
            req, parent = req_info.requirement, req_info.parent
            # Inspired by Factory.get_installation_error
            msg += "\n    "
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/resolution/resolvelib/__init__.py =====
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/resolution/resolvelib/factory.py =====
from __future__ import annotations
import contextlib
import functools
import logging
from collections.abc import Iterable, Iterator, Mapping, Sequence
from typing import (
    TYPE_CHECKING,
    Callable,
    NamedTuple,
    Protocol,
    TypeVar,
    cast,
)
from pip._vendor.packaging.requirements import InvalidRequirement
from pip._vendor.packaging.specifiers import SpecifierSet
from pip._vendor.packaging.utils import NormalizedName, canonicalize_name
from pip._vendor.packaging.version import InvalidVersion, Version
from pip._vendor.resolvelib import ResolutionImpossible
from pip._internal.cache import CacheEntry, WheelCache
from pip._internal.exceptions import (
    DistributionNotFound,
    InstallationError,
    InvalidInstalledPackage,
    MetadataInconsistent,
    MetadataInvalid,
    UnsupportedPythonVersion,
    UnsupportedWheel,
)
from pip._internal.index.package_finder import PackageFinder
from pip._internal.metadata import BaseDistribution, get_default_environment
from pip._internal.models.link import Link
from pip._internal.models.wheel import Wheel
from pip._internal.operations.prepare import RequirementPreparer
from pip._internal.req.constructors import (
    install_req_drop_extras,
    install_req_from_link_and_ireq,
)
from pip._internal.req.req_install import (
    InstallRequirement,
    check_invalid_constraint_type,
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/resolution/resolvelib/requirements.py =====
from __future__ import annotations
from typing import Any
from pip._vendor.packaging.specifiers import SpecifierSet
from pip._vendor.packaging.utils import NormalizedName, canonicalize_name
from pip._internal.req.constructors import install_req_drop_extras
from pip._internal.req.req_install import InstallRequirement
from .base import Candidate, CandidateLookup, Requirement, format_name
class ExplicitRequirement(Requirement):
    def __init__(self, candidate: Candidate) -> None:
        self.candidate = candidate
    def __str__(self) -> str:
        return str(self.candidate)
    def __repr__(self) -> str:
        return f"{self.__class__.__name__}({self.candidate!r})"
    def __hash__(self) -> int:
        return hash(self.candidate)
    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ExplicitRequirement):
            return False
        return self.candidate == other.candidate
    @property
    def project_name(self) -> NormalizedName:
        # No need to canonicalize - the candidate did this
        return self.candidate.project_name
    @property
    def name(self) -> str:
        # No need to canonicalize - the candidate did this
        return self.candidate.name
    def format_for_error(self) -> str:
        return self.candidate.format_for_error()
    def get_candidate_lookup(self) -> CandidateLookup:
        return self.candidate, None
    def is_satisfied_by(self, candidate: Candidate) -> bool:
        return candidate == self.candidate
class SpecifierRequirement(Requirement):
    def __init__(self, ireq: InstallRequirement) -> None:
        assert ireq.link is None, "This is a link, not a specifier"
        self._ireq = ireq
        self._equal_cache: str | None = None
        self._hash: int | None = None
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/resolution/resolvelib/resolver.py =====
from __future__ import annotations
import contextlib
import functools
import logging
import os
from typing import TYPE_CHECKING, cast
from pip._vendor.packaging.utils import canonicalize_name
from pip._vendor.resolvelib import BaseReporter, ResolutionImpossible, ResolutionTooDeep
from pip._vendor.resolvelib import Resolver as RLResolver
from pip._vendor.resolvelib.structs import DirectedGraph
from pip._internal.cache import WheelCache
from pip._internal.exceptions import ResolutionTooDeepError
from pip._internal.index.package_finder import PackageFinder
from pip._internal.operations.prepare import RequirementPreparer
from pip._internal.req.constructors import install_req_extend_extras
from pip._internal.req.req_install import InstallRequirement
from pip._internal.req.req_set import RequirementSet
from pip._internal.resolution.base import BaseResolver, InstallRequirementProvider
from pip._internal.resolution.resolvelib.provider import PipProvider
from pip._internal.resolution.resolvelib.reporter import (
    PipDebuggingReporter,
    PipReporter,
)
from pip._internal.utils.packaging import get_requirement
from .base import Candidate, Requirement
from .factory import Factory
if TYPE_CHECKING:
    from pip._vendor.resolvelib.resolvers import Result as RLResult
    Result = RLResult[Requirement, Candidate, str]
logger = logging.getLogger(__name__)
class Resolver(BaseResolver):
    _allowed_strategies = {"eager", "only-if-needed", "to-satisfy-only"}
    def __init__(
        self,
        preparer: RequirementPreparer,
        finder: PackageFinder,
        wheel_cache: WheelCache | None,
        make_install_req: InstallRequirementProvider,
        use_user_site: bool,
        ignore_dependencies: bool,
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/resolution/resolvelib/candidates.py =====
from __future__ import annotations
import logging
import sys
from collections.abc import Iterable
from typing import TYPE_CHECKING, Any, Union, cast
from pip._vendor.packaging.requirements import InvalidRequirement
from pip._vendor.packaging.utils import NormalizedName, canonicalize_name
from pip._vendor.packaging.version import Version
from pip._internal.exceptions import (
    HashError,
    InstallationSubprocessError,
    InvalidInstalledPackage,
    MetadataInconsistent,
    MetadataInvalid,
)
from pip._internal.metadata import BaseDistribution
from pip._internal.models.link import Link, links_equivalent
from pip._internal.models.wheel import Wheel
from pip._internal.req.constructors import (
    install_req_from_editable,
    install_req_from_line,
)
from pip._internal.req.req_install import InstallRequirement
from pip._internal.utils.direct_url_helpers import direct_url_from_link
from pip._internal.utils.misc import normalize_version_info
from .base import Candidate, Requirement, format_name
if TYPE_CHECKING:
    from .factory import Factory
logger = logging.getLogger(__name__)
BaseCandidate = Union[
    "AlreadyInstalledCandidate",
    "EditableCandidate",
    "LinkCandidate",
]
REQUIRES_PYTHON_IDENTIFIER = cast(NormalizedName, "<Python from Requires-Python>")
def as_base_candidate(candidate: Candidate) -> BaseCandidate | None:
    """The runtime version of BaseCandidate."""
    base_candidate_classes = (
        AlreadyInstalledCandidate,
        EditableCandidate,
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/resolution/resolvelib/base.py =====
from __future__ import annotations
from collections.abc import Iterable
from dataclasses import dataclass
from typing import Optional
from pip._vendor.packaging.specifiers import SpecifierSet
from pip._vendor.packaging.utils import NormalizedName
from pip._vendor.packaging.version import Version
from pip._internal.models.link import Link, links_equivalent
from pip._internal.req.req_install import InstallRequirement
from pip._internal.utils.hashes import Hashes
CandidateLookup = tuple[Optional["Candidate"], Optional[InstallRequirement]]
def format_name(project: NormalizedName, extras: frozenset[NormalizedName]) -> str:
    if not extras:
        return project
    extras_expr = ",".join(sorted(extras))
    return f"{project}[{extras_expr}]"
@dataclass(frozen=True)
class Constraint:
    specifier: SpecifierSet
    hashes: Hashes
    links: frozenset[Link]
    @classmethod
    def empty(cls) -> Constraint:
        return Constraint(SpecifierSet(), Hashes(), frozenset())
    @classmethod
    def from_ireq(cls, ireq: InstallRequirement) -> Constraint:
        links = frozenset([ireq.link]) if ireq.link else frozenset()
        return Constraint(ireq.specifier, ireq.hashes(trust_internet=False), links)
    def __bool__(self) -> bool:
        return bool(self.specifier) or bool(self.hashes) or bool(self.links)
    def __and__(self, other: InstallRequirement) -> Constraint:
        if not isinstance(other, InstallRequirement):
            return NotImplemented
        specifier = self.specifier & other.specifier
        hashes = self.hashes & other.hashes(trust_internet=False)
        links = self.links
        if other.link:
            links = links.union([other.link])
        return Constraint(specifier, hashes, links)
    def is_satisfied_by(self, candidate: Candidate) -> bool:
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/vcs/git.py =====
from __future__ import annotations
import logging
import os.path
import pathlib
import re
import urllib.parse
import urllib.request
from dataclasses import replace
from typing import Any
from pip._internal.exceptions import BadCommand, InstallationError
from pip._internal.utils.misc import HiddenText, display_path, hide_url
from pip._internal.utils.subprocess import make_command
from pip._internal.vcs.versioncontrol import (
    AuthInfo,
    RemoteNotFoundError,
    RemoteNotValidError,
    RevOptions,
    VersionControl,
    find_path_to_project_root_from_repo_root,
    vcs,
)
urlsplit = urllib.parse.urlsplit
urlunsplit = urllib.parse.urlunsplit
logger = logging.getLogger(__name__)
GIT_VERSION_REGEX = re.compile(
    r"^git version "  # Prefix.
    r"(\d+)"  # Major.
    r"\.(\d+)"  # Dot, minor.
    r"(?:\.(\d+))?"  # Optional dot, patch.
    r".*$"  # Suffix, including any pre- and post-release segments we don't care about.
)
HASH_REGEX = re.compile("^[a-fA-F0-9]{40}$")
SCP_REGEX = re.compile(
    r"""^
    # Optional user, e.g. 'git@'
    (\w+@)?
    # Server, e.g. 'github.com'.
    ([^/:]+):
    # The server-side path. e.g. 'user/project.git'. Must start with an
    # alphanumeric character so as not to be confusable with a Windows paths
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/vcs/__init__.py =====
import pip._internal.vcs.bazaar
import pip._internal.vcs.git
import pip._internal.vcs.mercurial
import pip._internal.vcs.subversion  # noqa: F401
from pip._internal.vcs.versioncontrol import (  # noqa: F401
    RemoteNotFoundError,
    RemoteNotValidError,
    is_url,
    make_vcs_requirement_url,
    vcs,
)
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/vcs/mercurial.py =====
from __future__ import annotations
import configparser
import logging
import os
from pip._internal.exceptions import BadCommand, InstallationError
from pip._internal.utils.misc import HiddenText, display_path
from pip._internal.utils.subprocess import make_command
from pip._internal.utils.urls import path_to_url
from pip._internal.vcs.versioncontrol import (
    RevOptions,
    VersionControl,
    find_path_to_project_root_from_repo_root,
    vcs,
)
logger = logging.getLogger(__name__)
class Mercurial(VersionControl):
    name = "hg"
    dirname = ".hg"
    repo_name = "clone"
    schemes = (
        "hg+file",
        "hg+http",
        "hg+https",
        "hg+ssh",
        "hg+static-http",
    )
    @staticmethod
    def get_base_rev_args(rev: str) -> list[str]:
        return [f"--rev={rev}"]
    def fetch_new(
        self, dest: str, url: HiddenText, rev_options: RevOptions, verbosity: int
    ) -> None:
        rev_display = rev_options.to_display()
        logger.info(
            "Cloning hg %s%s to %s",
            url,
            rev_display,
            display_path(dest),
        )
        if verbosity <= 0:
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/vcs/bazaar.py =====
from __future__ import annotations
import logging
from pip._internal.utils.misc import HiddenText, display_path
from pip._internal.utils.subprocess import make_command
from pip._internal.utils.urls import path_to_url
from pip._internal.vcs.versioncontrol import (
    AuthInfo,
    RemoteNotFoundError,
    RevOptions,
    VersionControl,
    vcs,
)
logger = logging.getLogger(__name__)
class Bazaar(VersionControl):
    name = "bzr"
    dirname = ".bzr"
    repo_name = "branch"
    schemes = (
        "bzr+http",
        "bzr+https",
        "bzr+ssh",
        "bzr+sftp",
        "bzr+ftp",
        "bzr+lp",
        "bzr+file",
    )
    @staticmethod
    def get_base_rev_args(rev: str) -> list[str]:
        return ["-r", rev]
    def fetch_new(
        self, dest: str, url: HiddenText, rev_options: RevOptions, verbosity: int
    ) -> None:
        rev_display = rev_options.to_display()
        logger.info(
            "Checking out %s%s to %s",
            url,
            rev_display,
            display_path(dest),
        )
        if verbosity <= 0:
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/vcs/versioncontrol.py =====
"""Handles all VCS (version control) support"""
from __future__ import annotations
import logging
import os
import shutil
import sys
import urllib.parse
from collections.abc import Iterable, Iterator, Mapping
from dataclasses import dataclass, field
from typing import (
    Any,
    Literal,
    Optional,
)
from pip._internal.cli.spinners import SpinnerInterface
from pip._internal.exceptions import BadCommand, InstallationError
from pip._internal.utils.misc import (
    HiddenText,
    ask_path_exists,
    backup_dir,
    display_path,
    hide_url,
    hide_value,
    is_installable_dir,
    rmtree,
)
from pip._internal.utils.subprocess import (
    CommandArgs,
    call_subprocess,
    format_command_args,
    make_command,
)
__all__ = ["vcs"]
logger = logging.getLogger(__name__)
AuthInfo = tuple[Optional[str], Optional[str]]
def is_url(name: str) -> bool:
    """
    Return true if the name looks like a URL.
    """
    scheme = urllib.parse.urlsplit(name).scheme
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/vcs/subversion.py =====
from __future__ import annotations
import logging
import os
import re
from pip._internal.utils.misc import (
    HiddenText,
    display_path,
    is_console_interactive,
    is_installable_dir,
    split_auth_from_netloc,
)
from pip._internal.utils.subprocess import CommandArgs, make_command
from pip._internal.vcs.versioncontrol import (
    AuthInfo,
    RemoteNotFoundError,
    RevOptions,
    VersionControl,
    vcs,
)
logger = logging.getLogger(__name__)
_svn_xml_url_re = re.compile('url="([^"]+)"')
_svn_rev_re = re.compile(r'committed-rev="(\d+)"')
_svn_info_xml_rev_re = re.compile(r'\s*revision="(\d+)"')
_svn_info_xml_url_re = re.compile(r"<url>(.*)</url>")
class Subversion(VersionControl):
    name = "svn"
    dirname = ".svn"
    repo_name = "checkout"
    schemes = ("svn+ssh", "svn+http", "svn+https", "svn+svn", "svn+file")
    @classmethod
    def should_add_vcs_url_prefix(cls, remote_url: str) -> bool:
        return True
    @staticmethod
    def get_base_rev_args(rev: str) -> list[str]:
        return ["-r", rev]
    @classmethod
    def get_revision(cls, location: str) -> str:
        """
        Return the maximum revision for all files under a given location
        """
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/locations/__init__.py =====
from __future__ import annotations
import functools
import logging
import os
import pathlib
import sys
import sysconfig
from typing import Any
from pip._internal.models.scheme import SCHEME_KEYS, Scheme
from pip._internal.utils.compat import WINDOWS
from pip._internal.utils.deprecation import deprecated
from pip._internal.utils.virtualenv import running_under_virtualenv
from . import _sysconfig
from .base import (
    USER_CACHE_DIR,
    get_major_minor_version,
    get_src_prefix,
    is_osx_framework,
    site_packages,
    user_site,
)
__all__ = [
    "USER_CACHE_DIR",
    "get_bin_prefix",
    "get_bin_user",
    "get_major_minor_version",
    "get_platlib",
    "get_purelib",
    "get_scheme",
    "get_src_prefix",
    "site_packages",
    "user_site",
]
logger = logging.getLogger(__name__)
_PLATLIBDIR: str = getattr(sys, "platlibdir", "lib")
_USE_SYSCONFIG_DEFAULT = sys.version_info >= (3, 10)
def _should_use_sysconfig() -> bool:
    """This function determines the value of _USE_SYSCONFIG.
    By default, pip uses sysconfig on Python 3.10+.
    But Python distributors can override this decision by setting:
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/locations/_sysconfig.py =====
from __future__ import annotations
import logging
import os
import sys
import sysconfig
from pip._internal.exceptions import InvalidSchemeCombination, UserInstallationInvalid
from pip._internal.models.scheme import SCHEME_KEYS, Scheme
from pip._internal.utils.virtualenv import running_under_virtualenv
from .base import change_root, get_major_minor_version, is_osx_framework
logger = logging.getLogger(__name__)
_AVAILABLE_SCHEMES = set(sysconfig.get_scheme_names())
_PREFERRED_SCHEME_API = getattr(sysconfig, "get_preferred_scheme", None)
def _should_use_osx_framework_prefix() -> bool:
    """Check for Apple's ``osx_framework_library`` scheme.
    Python distributed by Apple's Command Line Tools has this special scheme
    that's used when:
    * This is a framework build.
    * We are installing into the system prefix.
    This does not account for ``pip install --prefix`` (also means we're not
    installing to the system prefix), which should use ``posix_prefix``, but
    logic here means ``_infer_prefix()`` outputs ``osx_framework_library``. But
    since ``prefix`` is not available for ``sysconfig.get_default_scheme()``,
    which is the stdlib replacement for ``_infer_prefix()``, presumably Apple
    wouldn't be able to magically switch between ``osx_framework_library`` and
    ``posix_prefix``. ``_infer_prefix()`` returning ``osx_framework_library``
    means its behavior is consistent whether we use the stdlib implementation
    or our own, and we deal with this special case in ``get_scheme()`` instead.
    """
    return (
        "osx_framework_library" in _AVAILABLE_SCHEMES
        and not running_under_virtualenv()
        and is_osx_framework()
    )
def _infer_prefix() -> str:
    """Try to find a prefix scheme for the current platform.
    This tries:
    * A special ``osx_framework_library`` for Python distributed by Apple's
      Command Line Tools, when not running in a virtual environment.
    * Implementation + OS, used by PyPy on Windows (``pypy_nt``).
    * Implementation without OS, used by PyPy on POSIX (``pypy``).
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/locations/_distutils.py =====
"""Locations where we look for configs, install stuff, etc"""
from __future__ import annotations
try:
    __import__("_distutils_hack").remove_shim()
except (ImportError, AttributeError):
    pass
import logging
import os
import sys
from distutils.cmd import Command as DistutilsCommand
from distutils.command.install import SCHEME_KEYS
from distutils.command.install import install as distutils_install_command
from distutils.sysconfig import get_python_lib
from pip._internal.models.scheme import Scheme
from pip._internal.utils.compat import WINDOWS
from pip._internal.utils.virtualenv import running_under_virtualenv
from .base import get_major_minor_version
logger = logging.getLogger(__name__)
def distutils_scheme(
    dist_name: str,
    user: bool = False,
    home: str | None = None,
    root: str | None = None,
    isolated: bool = False,
    prefix: str | None = None,
    *,
    ignore_config_files: bool = False,
) -> dict[str, str]:
    """
    Return a distutils install scheme
    """
    from distutils.dist import Distribution
    dist_args: dict[str, str | list[str]] = {"name": dist_name}
    if isolated:
        dist_args["script_args"] = ["--no-user-cfg"]
    d = Distribution(dist_args)
    if not ignore_config_files:
        try:
            d.parse_config_files()
        except UnicodeDecodeError:
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/locations/base.py =====
from __future__ import annotations
import functools
import os
import site
import sys
import sysconfig
from pip._internal.exceptions import InstallationError
from pip._internal.utils import appdirs
from pip._internal.utils.virtualenv import running_under_virtualenv
USER_CACHE_DIR = appdirs.user_cache_dir("pip")
site_packages: str = sysconfig.get_path("purelib")
def get_major_minor_version() -> str:
    """
    Return the major-minor version of the current Python as a string, e.g.
    "3.7" or "3.10".
    """
    return "{}.{}".format(*sys.version_info)
def change_root(new_root: str, pathname: str) -> str:
    """Return 'pathname' with 'new_root' prepended.
    If 'pathname' is relative, this is equivalent to os.path.join(new_root, pathname).
    Otherwise, it requires making 'pathname' relative and then joining the
    two, which is tricky on DOS/Windows and Mac OS.
    This is borrowed from Python's standard library's distutils module.
    """
    if os.name == "posix":
        if not os.path.isabs(pathname):
            return os.path.join(new_root, pathname)
        else:
            return os.path.join(new_root, pathname[1:])
    elif os.name == "nt":
        (drive, path) = os.path.splitdrive(pathname)
        if path[0] == "\\":
            path = path[1:]
        return os.path.join(new_root, path)
    else:
        raise InstallationError(
            f"Unknown platform: {os.name}\n"
            "Can not change root path prefix on unknown platform."
        )
def get_src_prefix() -> str:
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/index/collector.py =====
"""
The main purpose of this module is to expose LinkCollector.collect_sources().
"""
from __future__ import annotations
import collections
import email.message
import functools
import itertools
import json
import logging
import os
import urllib.parse
import urllib.request
from collections.abc import Iterable, MutableMapping, Sequence
from dataclasses import dataclass
from html.parser import HTMLParser
from optparse import Values
from typing import (
    Callable,
    NamedTuple,
    Protocol,
)
from pip._vendor import requests
from pip._vendor.requests import Response
from pip._vendor.requests.exceptions import RetryError, SSLError
from pip._internal.exceptions import NetworkConnectionError
from pip._internal.models.link import Link
from pip._internal.models.search_scope import SearchScope
from pip._internal.network.session import PipSession
from pip._internal.network.utils import raise_for_status
from pip._internal.utils.filetypes import is_archive_file
from pip._internal.utils.misc import redact_auth_from_url
from pip._internal.vcs import vcs
from .sources import CandidatesFromPage, LinkSource, build_source
logger = logging.getLogger(__name__)
ResponseHeaders = MutableMapping[str, str]
def _match_vcs_scheme(url: str) -> str | None:
    """Look for VCS schemes in the URL.
    Returns the matched VCS scheme, or None if there's no match.
    """
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/index/__init__.py =====
"""Index interaction code"""
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/index/sources.py =====
from __future__ import annotations
import logging
import mimetypes
import os
from collections import defaultdict
from collections.abc import Iterable
from typing import Callable
from pip._vendor.packaging.utils import (
    InvalidSdistFilename,
    InvalidWheelFilename,
    canonicalize_name,
    parse_sdist_filename,
    parse_wheel_filename,
)
from pip._internal.models.candidate import InstallationCandidate
from pip._internal.models.link import Link
from pip._internal.utils.urls import path_to_url, url_to_path
from pip._internal.vcs import is_url
logger = logging.getLogger(__name__)
FoundCandidates = Iterable[InstallationCandidate]
FoundLinks = Iterable[Link]
CandidatesFromPage = Callable[[Link], Iterable[InstallationCandidate]]
PageValidator = Callable[[Link], bool]
class LinkSource:
    @property
    def link(self) -> Link | None:
        """Returns the underlying link, if there's one."""
        raise NotImplementedError()
    def page_candidates(self) -> FoundCandidates:
        """Candidates found by parsing an archive listing HTML file."""
        raise NotImplementedError()
    def file_links(self) -> FoundLinks:
        """Links found by specifying archives directly."""
        raise NotImplementedError()
def _is_html_file(file_url: str) -> bool:
    return mimetypes.guess_type(file_url, strict=False)[0] == "text/html"
class _FlatDirectoryToUrls:
    """Scans directory and caches results"""
    def __init__(self, path: str) -> None:
        self._path = path
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/index/package_finder.py =====
"""Routines related to PyPI, indexes"""
from __future__ import annotations
import enum
import functools
import itertools
import logging
import re
from collections.abc import Iterable
from dataclasses import dataclass
from typing import (
    TYPE_CHECKING,
    Optional,
    Union,
)
from pip._vendor.packaging import specifiers
from pip._vendor.packaging.tags import Tag
from pip._vendor.packaging.utils import canonicalize_name
from pip._vendor.packaging.version import InvalidVersion, _BaseVersion
from pip._vendor.packaging.version import parse as parse_version
from pip._internal.exceptions import (
    BestVersionAlreadyInstalled,
    DistributionNotFound,
    InvalidWheelFilename,
    UnsupportedWheel,
)
from pip._internal.index.collector import LinkCollector, parse_links
from pip._internal.models.candidate import InstallationCandidate
from pip._internal.models.format_control import FormatControl
from pip._internal.models.link import Link
from pip._internal.models.search_scope import SearchScope
from pip._internal.models.selection_prefs import SelectionPreferences
from pip._internal.models.target_python import TargetPython
from pip._internal.models.wheel import Wheel
from pip._internal.req import InstallRequirement
from pip._internal.utils._log import getLogger
from pip._internal.utils.filetypes import WHEEL_EXTENSION
from pip._internal.utils.hashes import Hashes
from pip._internal.utils.logging import indent_log
from pip._internal.utils.misc import build_netloc
from pip._internal.utils.packaging import check_requires_python
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/exceptions.py =====
"""Exceptions used throughout package.
This module MUST NOT try to import from anything within `pip._internal` to
operate. This is expected to be importable from any/all files within the
subpackage and, thus, should not depend on them.
"""
from __future__ import annotations
import configparser
import contextlib
import locale
import logging
import pathlib
import re
import sys
from collections.abc import Iterator
from itertools import chain, groupby, repeat
from typing import TYPE_CHECKING, Literal
from pip._vendor.packaging.requirements import InvalidRequirement
from pip._vendor.packaging.version import InvalidVersion
from pip._vendor.rich.console import Console, ConsoleOptions, RenderResult
from pip._vendor.rich.markup import escape
from pip._vendor.rich.text import Text
if TYPE_CHECKING:
    from hashlib import _Hash
    from pip._vendor.requests.models import Request, Response
    from pip._internal.metadata import BaseDistribution
    from pip._internal.network.download import _FileDownload
    from pip._internal.req.req_install import InstallRequirement
logger = logging.getLogger(__name__)
def _is_kebab_case(s: str) -> bool:
    return re.match(r"^[a-z]+(-[a-z]+)*$", s) is not None
def _prefix_with_indent(
    s: Text | str,
    console: Console,
    *,
    prefix: str,
    indent: str,
) -> Text:
    if isinstance(s, Text):
        text = s
    else:
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/commands/configuration.py =====
from __future__ import annotations
import logging
import os
import subprocess
from optparse import Values
from typing import Any, Callable
from pip._internal.cli.base_command import Command
from pip._internal.cli.status_codes import ERROR, SUCCESS
from pip._internal.configuration import (
    Configuration,
    Kind,
    get_configuration_files,
    kinds,
)
from pip._internal.exceptions import PipError
from pip._internal.utils.logging import indent_log
from pip._internal.utils.misc import get_prog, write_output
logger = logging.getLogger(__name__)
class ConfigurationCommand(Command):
    """
    Manage local and global configuration.
    Subcommands:
    - list: List the active configuration (or from the file specified)
    - edit: Edit the configuration file in an editor
    - get: Get the value associated with command.option
    - set: Set the command.option=value
    - unset: Unset the value associated with command.option
    - debug: List the configuration files and values defined under them
    Configuration keys should be dot separated command and option name,
    with the special prefix "global" affecting any command. For example,
    "pip config set global.index-url https://example.org/" would configure
    the index url for all commands, but "pip config set download.timeout 10"
    would configure a 10 second timeout only for "pip download" commands.
    If none of --user, --global and --site are passed, a virtual
    environment configuration file is used if one is active and the file
    exists. Otherwise, all modifications happen to the user file by
    default.
    """
    ignore_require_venv = True
    usage = """
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/commands/show.py =====
from __future__ import annotations
import logging
import string
from collections.abc import Generator, Iterable, Iterator
from optparse import Values
from typing import NamedTuple
from pip._vendor.packaging.requirements import InvalidRequirement
from pip._vendor.packaging.utils import canonicalize_name
from pip._internal.cli.base_command import Command
from pip._internal.cli.status_codes import ERROR, SUCCESS
from pip._internal.metadata import BaseDistribution, get_default_environment
from pip._internal.utils.misc import write_output
logger = logging.getLogger(__name__)
def normalize_project_url_label(label: str) -> str:
    # This logic is from PEP 753 (Well-known Project URLs in Metadata).
    chars_to_remove = string.punctuation + string.whitespace
    removal_map = str.maketrans("", "", chars_to_remove)
    return label.translate(removal_map).lower()
class ShowCommand(Command):
    """
    Show information about one or more installed packages.
    The output is in RFC-compliant mail header format.
    """
    usage = """
      %prog [options] <package> ..."""
    ignore_require_venv = True
    def add_options(self) -> None:
        self.cmd_opts.add_option(
            "-f",
            "--files",
            dest="files",
            action="store_true",
            default=False,
            help="Show the full list of installed files for each package.",
        )
        self.parser.insert_option_group(0, self.cmd_opts)
    def run(self, options: Values, args: list[str]) -> int:
        if not args:
            logger.warning("ERROR: Please provide a package name or names.")
            return ERROR
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/commands/list.py =====
from __future__ import annotations
import json
import logging
from collections.abc import Generator, Sequence
from email.parser import Parser
from optparse import Values
from typing import TYPE_CHECKING, cast
from pip._vendor.packaging.utils import canonicalize_name
from pip._vendor.packaging.version import InvalidVersion, Version
from pip._internal.cli import cmdoptions
from pip._internal.cli.index_command import IndexGroupCommand
from pip._internal.cli.status_codes import SUCCESS
from pip._internal.exceptions import CommandError
from pip._internal.metadata import BaseDistribution, get_environment
from pip._internal.models.selection_prefs import SelectionPreferences
from pip._internal.utils.compat import stdlib_pkgs
from pip._internal.utils.misc import tabulate, write_output
if TYPE_CHECKING:
    from pip._internal.index.package_finder import PackageFinder
    from pip._internal.network.session import PipSession
    class _DistWithLatestInfo(BaseDistribution):
        """Give the distribution object a couple of extra fields.
        These will be populated during ``get_outdated()``. This is dirty but
        makes the rest of the code much cleaner.
        """
        latest_version: Version
        latest_filetype: str
    _ProcessedDists = Sequence[_DistWithLatestInfo]
logger = logging.getLogger(__name__)
class ListCommand(IndexGroupCommand):
    """
    List installed packages, including editables.
    Packages are listed in a case-insensitive sorted order.
    """
    ignore_require_venv = True
    usage = """
      %prog [options]"""
    def add_options(self) -> None:
        self.cmd_opts.add_option(
            "-o",
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/commands/check.py =====
import logging
from optparse import Values
from pip._internal.cli.base_command import Command
from pip._internal.cli.status_codes import ERROR, SUCCESS
from pip._internal.metadata import get_default_environment
from pip._internal.operations.check import (
    check_package_set,
    check_unsupported,
    create_package_set_from_installed,
)
from pip._internal.utils.compatibility_tags import get_supported
from pip._internal.utils.misc import write_output
logger = logging.getLogger(__name__)
class CheckCommand(Command):
    """Verify installed packages have compatible dependencies."""
    ignore_require_venv = True
    usage = """
      %prog [options]"""
    def run(self, options: Values, args: list[str]) -> int:
        package_set, parsing_probs = create_package_set_from_installed()
        missing, conflicting = check_package_set(package_set)
        unsupported = list(
            check_unsupported(
                get_default_environment().iter_installed_distributions(),
                get_supported(),
            )
        )
        for project_name in missing:
            version = package_set[project_name].version
            for dependency in missing[project_name]:
                write_output(
                    "%s %s requires %s, which is not installed.",
                    project_name,
                    version,
                    dependency[0],
                )
        for project_name in conflicting:
            version = package_set[project_name].version
            for dep_name, dep_version, req in conflicting[project_name]:
                write_output(
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/commands/index.py =====
from __future__ import annotations
import json
import logging
from collections.abc import Iterable
from optparse import Values
from typing import Any, Callable
from pip._vendor.packaging.version import Version
from pip._internal.cli import cmdoptions
from pip._internal.cli.req_command import IndexGroupCommand
from pip._internal.cli.status_codes import ERROR, SUCCESS
from pip._internal.commands.search import (
    get_installed_distribution,
    print_dist_installation_info,
)
from pip._internal.exceptions import CommandError, DistributionNotFound, PipError
from pip._internal.index.collector import LinkCollector
from pip._internal.index.package_finder import PackageFinder
from pip._internal.models.selection_prefs import SelectionPreferences
from pip._internal.models.target_python import TargetPython
from pip._internal.network.session import PipSession
from pip._internal.utils.misc import write_output
logger = logging.getLogger(__name__)
class IndexCommand(IndexGroupCommand):
    """
    Inspect information available from package indexes.
    """
    ignore_require_venv = True
    usage = """
        %prog versions <package>
    """
    def add_options(self) -> None:
        cmdoptions.add_target_python_options(self.cmd_opts)
        self.cmd_opts.add_option(cmdoptions.ignore_requires_python())
        self.cmd_opts.add_option(cmdoptions.pre())
        self.cmd_opts.add_option(cmdoptions.json())
        self.cmd_opts.add_option(cmdoptions.no_binary())
        self.cmd_opts.add_option(cmdoptions.only_binary())
        index_opts = cmdoptions.make_option_group(
            cmdoptions.index_group,
            self.parser,
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/commands/completion.py =====
import sys
import textwrap
from optparse import Values
from pip._internal.cli.base_command import Command
from pip._internal.cli.status_codes import SUCCESS
from pip._internal.utils.misc import get_prog
BASE_COMPLETION = """
"""
COMPLETION_SCRIPTS = {
    "bash": """
        _pip_completion()
        {{
            COMPREPLY=( $( COMP_WORDS="${{COMP_WORDS[*]}}" \\
                           COMP_CWORD=$COMP_CWORD \\
                           PIP_AUTO_COMPLETE=1 $1 2>/dev/null ) )
        }}
        complete -o default -F _pip_completion {prog}
    """,
    "zsh": """
        #compdef -P pip[0-9.]#
        __pip() {{
          compadd $( COMP_WORDS="$words[*]" \\
                     COMP_CWORD=$((CURRENT-1)) \\
                     PIP_AUTO_COMPLETE=1 $words[1] 2>/dev/null )
        }}
        if [[ $zsh_eval_context[-1] == loadautofunc ]]; then
          # autoload from fpath, call function directly
          __pip "$@"
        else
          # eval/source/. command, register function for later
          compdef __pip -P 'pip[0-9.]#'
        fi
    """,
    "fish": """
        function __fish_complete_pip
            set -lx COMP_WORDS \\
                (commandline --current-process --tokenize --cut-at-cursor) \\
                (commandline --current-token --cut-at-cursor)
            set -lx COMP_CWORD (math (count $COMP_WORDS) - 1)
            set -lx PIP_AUTO_COMPLETE 1
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/commands/download.py =====
import logging
import os
from optparse import Values
from pip._internal.cli import cmdoptions
from pip._internal.cli.cmdoptions import make_target_python
from pip._internal.cli.req_command import RequirementCommand, with_cleanup
from pip._internal.cli.status_codes import SUCCESS
from pip._internal.operations.build.build_tracker import get_build_tracker
from pip._internal.req.req_install import check_legacy_setup_py_options
from pip._internal.utils.misc import ensure_dir, normalize_path, write_output
from pip._internal.utils.temp_dir import TempDirectory
logger = logging.getLogger(__name__)
class DownloadCommand(RequirementCommand):
    """
    Download packages from:
    - PyPI (and other indexes) using requirement specifiers.
    - VCS project urls.
    - Local project directories.
    - Local or remote source archives.
    pip also supports downloading from "requirements files", which provide
    an easy way to specify a whole environment to be downloaded.
    """
    usage = """
      %prog [options] <requirement specifier> [package-index-options] ...
      %prog [options] -r <requirements file> [package-index-options] ...
      %prog [options] <vcs project url> ...
      %prog [options] <local project path> ...
      %prog [options] <archive url/path> ..."""
    def add_options(self) -> None:
        self.cmd_opts.add_option(cmdoptions.constraints())
        self.cmd_opts.add_option(cmdoptions.requirements())
        self.cmd_opts.add_option(cmdoptions.no_deps())
        self.cmd_opts.add_option(cmdoptions.global_options())
        self.cmd_opts.add_option(cmdoptions.no_binary())
        self.cmd_opts.add_option(cmdoptions.only_binary())
        self.cmd_opts.add_option(cmdoptions.prefer_binary())
        self.cmd_opts.add_option(cmdoptions.src())
        self.cmd_opts.add_option(cmdoptions.pre())
        self.cmd_opts.add_option(cmdoptions.require_hashes())
        self.cmd_opts.add_option(cmdoptions.progress_bar())
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/commands/cache.py =====
import os
import textwrap
from optparse import Values
from typing import Callable
from pip._internal.cli.base_command import Command
from pip._internal.cli.status_codes import ERROR, SUCCESS
from pip._internal.exceptions import CommandError, PipError
from pip._internal.utils import filesystem
from pip._internal.utils.logging import getLogger
from pip._internal.utils.misc import format_size
logger = getLogger(__name__)
class CacheCommand(Command):
    """
    Inspect and manage pip's wheel cache.
    Subcommands:
    - dir: Show the cache directory.
    - info: Show information about the cache.
    - list: List filenames of packages stored in the cache.
    - remove: Remove one or more package from the cache.
    - purge: Remove all items from the cache.
    ``<pattern>`` can be a glob expression or a package name.
    """
    ignore_require_venv = True
    usage = """
        %prog dir
        %prog info
        %prog list [<pattern>] [--format=[human, abspath]]
        %prog remove <pattern>
        %prog purge
    """
    def add_options(self) -> None:
        self.cmd_opts.add_option(
            "--format",
            action="store",
            dest="list_format",
            default="human",
            choices=("human", "abspath"),
            help="Select the output format among: human (default) or abspath",
        )
        self.parser.insert_option_group(0, self.cmd_opts)
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/commands/__init__.py =====
"""
Package containing all pip commands
"""
from __future__ import annotations
import importlib
from collections import namedtuple
from typing import Any
from pip._internal.cli.base_command import Command
CommandInfo = namedtuple("CommandInfo", "module_path, class_name, summary")
commands_dict: dict[str, CommandInfo] = {
    "install": CommandInfo(
        "pip._internal.commands.install",
        "InstallCommand",
        "Install packages.",
    ),
    "lock": CommandInfo(
        "pip._internal.commands.lock",
        "LockCommand",
        "Generate a lock file.",
    ),
    "download": CommandInfo(
        "pip._internal.commands.download",
        "DownloadCommand",
        "Download packages.",
    ),
    "uninstall": CommandInfo(
        "pip._internal.commands.uninstall",
        "UninstallCommand",
        "Uninstall packages.",
    ),
    "freeze": CommandInfo(
        "pip._internal.commands.freeze",
        "FreezeCommand",
        "Output installed packages in requirements format.",
    ),
    "inspect": CommandInfo(
        "pip._internal.commands.inspect",
        "InspectCommand",
        "Inspect the python environment.",
    ),
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/commands/hash.py =====
import hashlib
import logging
import sys
from optparse import Values
from pip._internal.cli.base_command import Command
from pip._internal.cli.status_codes import ERROR, SUCCESS
from pip._internal.utils.hashes import FAVORITE_HASH, STRONG_HASHES
from pip._internal.utils.misc import read_chunks, write_output
logger = logging.getLogger(__name__)
class HashCommand(Command):
    """
    Compute a hash of a local package archive.
    These can be used with --hash in a requirements file to do repeatable
    installs.
    """
    usage = "%prog [options] <file> ..."
    ignore_require_venv = True
    def add_options(self) -> None:
        self.cmd_opts.add_option(
            "-a",
            "--algorithm",
            dest="algorithm",
            choices=STRONG_HASHES,
            action="store",
            default=FAVORITE_HASH,
            help="The hash algorithm to use: one of {}".format(
                ", ".join(STRONG_HASHES)
            ),
        )
        self.parser.insert_option_group(0, self.cmd_opts)
    def run(self, options: Values, args: list[str]) -> int:
        if not args:
            self.parser.print_usage(sys.stderr)
            return ERROR
        algorithm = options.algorithm
        for path in args:
            write_output(
                "%s:\n--hash=%s:%s", path, algorithm, _hash_of_file(path, algorithm)
            )
        return SUCCESS
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/commands/inspect.py =====
import logging
from optparse import Values
from typing import Any
from pip._vendor.packaging.markers import default_environment
from pip._vendor.rich import print_json
from pip import __version__
from pip._internal.cli import cmdoptions
from pip._internal.cli.base_command import Command
from pip._internal.cli.status_codes import SUCCESS
from pip._internal.metadata import BaseDistribution, get_environment
from pip._internal.utils.compat import stdlib_pkgs
from pip._internal.utils.urls import path_to_url
logger = logging.getLogger(__name__)
class InspectCommand(Command):
    """
    Inspect the content of a Python environment and produce a report in JSON format.
    """
    ignore_require_venv = True
    usage = """
      %prog [options]"""
    def add_options(self) -> None:
        self.cmd_opts.add_option(
            "--local",
            action="store_true",
            default=False,
            help=(
                "If in a virtualenv that has global access, do not list "
                "globally-installed packages."
            ),
        )
        self.cmd_opts.add_option(
            "--user",
            dest="user",
            action="store_true",
            default=False,
            help="Only output packages installed in user-site.",
        )
        self.cmd_opts.add_option(cmdoptions.list_path())
        self.parser.insert_option_group(0, self.cmd_opts)
    def run(self, options: Values, args: list[str]) -> int:
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/commands/debug.py =====
from __future__ import annotations
import locale
import logging
import os
import sys
from optparse import Values
from types import ModuleType
from typing import Any
import pip._vendor
from pip._vendor.certifi import where
from pip._vendor.packaging.version import parse as parse_version
from pip._internal.cli import cmdoptions
from pip._internal.cli.base_command import Command
from pip._internal.cli.cmdoptions import make_target_python
from pip._internal.cli.status_codes import SUCCESS
from pip._internal.configuration import Configuration
from pip._internal.metadata import get_environment
from pip._internal.utils.compat import open_text_resource
from pip._internal.utils.logging import indent_log
from pip._internal.utils.misc import get_pip_version
logger = logging.getLogger(__name__)
def show_value(name: str, value: Any) -> None:
    logger.info("%s: %s", name, value)
def show_sys_implementation() -> None:
    logger.info("sys.implementation:")
    implementation_name = sys.implementation.name
    with indent_log():
        show_value("name", implementation_name)
def create_vendor_txt_map() -> dict[str, str]:
    with open_text_resource("pip._vendor", "vendor.txt") as f:
        # Purge non version specifying lines.
        # Also, remove any space prefix or suffixes (including comments).
        lines = [
            line.strip().split(" ", 1)[0] for line in f.readlines() if "==" in line
        ]
    # Transform into "module" -> version dict.
    return dict(line.split("==", 1) for line in lines)
def get_module_from_module_name(module_name: str) -> ModuleType | None:
    # Module name can be uppercase in vendor.txt for some reason...
    module_name = module_name.lower().replace("-", "_")
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/commands/uninstall.py =====
import logging
from optparse import Values
from pip._vendor.packaging.utils import canonicalize_name
from pip._internal.cli import cmdoptions
from pip._internal.cli.base_command import Command
from pip._internal.cli.index_command import SessionCommandMixin
from pip._internal.cli.status_codes import SUCCESS
from pip._internal.exceptions import InstallationError
from pip._internal.req import parse_requirements
from pip._internal.req.constructors import (
    install_req_from_line,
    install_req_from_parsed_requirement,
)
from pip._internal.utils.misc import (
    check_externally_managed,
    protect_pip_from_modification_on_windows,
    warn_if_run_as_root,
)
logger = logging.getLogger(__name__)
class UninstallCommand(Command, SessionCommandMixin):
    """
    Uninstall packages.
    pip is able to uninstall most installed packages. Known exceptions are:
    - Pure distutils packages installed with ``python setup.py install``, which
      leave behind no metadata to determine what files were installed.
    - Script wrappers installed by ``python setup.py develop``.
    """
    usage = """
      %prog [options] <package> ...
      %prog [options] -r <requirements file> ..."""
    def add_options(self) -> None:
        self.cmd_opts.add_option(
            "-r",
            "--requirement",
            dest="requirements",
            action="append",
            default=[],
            metavar="file",
            help=(
                "Uninstall all the packages listed in the given requirements "
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/commands/lock.py =====
import sys
from optparse import Values
from pathlib import Path
from pip._internal.cache import WheelCache
from pip._internal.cli import cmdoptions
from pip._internal.cli.req_command import (
    RequirementCommand,
    with_cleanup,
)
from pip._internal.cli.status_codes import SUCCESS
from pip._internal.models.pylock import Pylock, is_valid_pylock_file_name
from pip._internal.operations.build.build_tracker import get_build_tracker
from pip._internal.req.req_install import (
    check_legacy_setup_py_options,
)
from pip._internal.utils.logging import getLogger
from pip._internal.utils.misc import (
    get_pip_version,
)
from pip._internal.utils.temp_dir import TempDirectory
logger = getLogger(__name__)
class LockCommand(RequirementCommand):
    """
    EXPERIMENTAL - Lock packages and their dependencies from:
    - PyPI (and other indexes) using requirement specifiers.
    - VCS project urls.
    - Local project directories.
    - Local or remote source archives.
    pip also supports locking from "requirements files", which provide an easy
    way to specify a whole environment to be installed.
    The generated lock file is only guaranteed to be valid for the current
    python version and platform.
    """
    usage = """
      %prog [options] [-e] <local project path> ...
      %prog [options] <requirement specifier> [package-index-options] ...
      %prog [options] -r <requirements file> [package-index-options] ...
      %prog [options] <archive url/path> ..."""
    def add_options(self) -> None:
        self.cmd_opts.add_option(
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/commands/freeze.py =====
import sys
from optparse import Values
from pip._internal.cli import cmdoptions
from pip._internal.cli.base_command import Command
from pip._internal.cli.status_codes import SUCCESS
from pip._internal.operations.freeze import freeze
from pip._internal.utils.compat import stdlib_pkgs
def _should_suppress_build_backends() -> bool:
    return sys.version_info < (3, 12)
def _dev_pkgs() -> set[str]:
    pkgs = {"pip"}
    if _should_suppress_build_backends():
        pkgs |= {"setuptools", "distribute", "wheel"}
    return pkgs
class FreezeCommand(Command):
    """
    Output installed packages in requirements format.
    packages are listed in a case-insensitive sorted order.
    """
    ignore_require_venv = True
    usage = """
      %prog [options]"""
    def add_options(self) -> None:
        self.cmd_opts.add_option(
            "-r",
            "--requirement",
            dest="requirements",
            action="append",
            default=[],
            metavar="file",
            help=(
                "Use the order in the given requirements file and its "
                "comments when generating output. This option can be "
                "used multiple times."
            ),
        )
        self.cmd_opts.add_option(
            "-l",
            "--local",
            dest="local",
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/commands/search.py =====
from __future__ import annotations
import logging
import shutil
import sys
import textwrap
import xmlrpc.client
from collections import OrderedDict
from optparse import Values
from typing import TypedDict
from pip._vendor.packaging.version import parse as parse_version
from pip._internal.cli.base_command import Command
from pip._internal.cli.req_command import SessionCommandMixin
from pip._internal.cli.status_codes import NO_MATCHES_FOUND, SUCCESS
from pip._internal.exceptions import CommandError
from pip._internal.metadata import get_default_environment
from pip._internal.metadata.base import BaseDistribution
from pip._internal.models.index import PyPI
from pip._internal.network.xmlrpc import PipXmlrpcTransport
from pip._internal.utils.logging import indent_log
from pip._internal.utils.misc import write_output
class TransformedHit(TypedDict):
    name: str
    summary: str
    versions: list[str]
logger = logging.getLogger(__name__)
class SearchCommand(Command, SessionCommandMixin):
    """Search for PyPI packages whose name or summary contains <query>."""
    usage = """
      %prog [options] <query>"""
    ignore_require_venv = True
    def add_options(self) -> None:
        self.cmd_opts.add_option(
            "-i",
            "--index",
            dest="index",
            metavar="URL",
            default=PyPI.pypi_url,
            help="Base URL of Python Package Index (default %default)",
        )
        self.parser.insert_option_group(0, self.cmd_opts)
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/commands/install.py =====
from __future__ import annotations
import errno
import json
import operator
import os
import shutil
import site
from optparse import SUPPRESS_HELP, Values
from pathlib import Path
from pip._vendor.packaging.utils import canonicalize_name
from pip._vendor.requests.exceptions import InvalidProxyURL
from pip._vendor.rich import print_json
import pip._internal.self_outdated_check  # noqa: F401
from pip._internal.cache import WheelCache
from pip._internal.cli import cmdoptions
from pip._internal.cli.cmdoptions import make_target_python
from pip._internal.cli.req_command import (
    RequirementCommand,
    with_cleanup,
)
from pip._internal.cli.status_codes import ERROR, SUCCESS
from pip._internal.exceptions import (
    CommandError,
    InstallationError,
    InstallWheelBuildError,
)
from pip._internal.locations import get_scheme
from pip._internal.metadata import get_environment
from pip._internal.models.installation_report import InstallationReport
from pip._internal.operations.build.build_tracker import get_build_tracker
from pip._internal.operations.check import ConflictDetails, check_install_conflicts
from pip._internal.req import install_given_reqs
from pip._internal.req.req_install import (
    InstallRequirement,
    check_legacy_setup_py_options,
)
from pip._internal.utils.compat import WINDOWS
from pip._internal.utils.filesystem import test_writable_dir
from pip._internal.utils.logging import getLogger
from pip._internal.utils.misc import (
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/commands/help.py =====
from optparse import Values
from pip._internal.cli.base_command import Command
from pip._internal.cli.status_codes import SUCCESS
from pip._internal.exceptions import CommandError
class HelpCommand(Command):
    """Show help for commands"""
    usage = """
      %prog <command>"""
    ignore_require_venv = True
    def run(self, options: Values, args: list[str]) -> int:
        from pip._internal.commands import (
            commands_dict,
            create_command,
            get_similar_commands,
        )
        try:
            # 'pip help' with no args is handled by pip.__init__.parseopt()
            cmd_name = args[0]  # the command we need help for
        except IndexError:
            return SUCCESS
        if cmd_name not in commands_dict:
            guess = get_similar_commands(cmd_name)
            msg = [f'unknown command "{cmd_name}"']
            if guess:
                msg.append(f'maybe you meant "{guess}"')
            raise CommandError(" - ".join(msg))
        command = create_command(cmd_name)
        command.parser.print_help()
        return SUCCESS
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/commands/wheel.py =====
import logging
import os
import shutil
from optparse import Values
from pip._internal.cache import WheelCache
from pip._internal.cli import cmdoptions
from pip._internal.cli.req_command import RequirementCommand, with_cleanup
from pip._internal.cli.status_codes import SUCCESS
from pip._internal.exceptions import CommandError
from pip._internal.operations.build.build_tracker import get_build_tracker
from pip._internal.req.req_install import (
    InstallRequirement,
    check_legacy_setup_py_options,
)
from pip._internal.utils.misc import ensure_dir, normalize_path
from pip._internal.utils.temp_dir import TempDirectory
from pip._internal.wheel_builder import build
logger = logging.getLogger(__name__)
class WheelCommand(RequirementCommand):
    """
    Build Wheel archives for your requirements and dependencies.
    Wheel is a built-package format, and offers the advantage of not
    recompiling your software during every install. For more details, see the
    wheel docs: https://wheel.readthedocs.io/en/latest/
    'pip wheel' uses the build system interface as described here:
    https://pip.pypa.io/en/stable/reference/build-system/
    """
    usage = """
      %prog [options] <requirement specifier> ...
      %prog [options] -r <requirements file> ...
      %prog [options] [-e] <vcs project url> ...
      %prog [options] [-e] <local project path> ...
      %prog [options] <archive url/path> ..."""
    def add_options(self) -> None:
        self.cmd_opts.add_option(
            "-w",
            "--wheel-dir",
            dest="wheel_dir",
            metavar="dir",
            default=os.curdir,
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/main.py =====
from __future__ import annotations
def main(args: list[str] | None = None) -> int:
    """This is preserved for old console scripts that may still be referencing
    it.
    For additional details, see https://github.com/pypa/pip/issues/7498.
    """
    from pip._internal.utils.entrypoints import _wrapper
    return _wrapper(args)
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/wheel_builder.py =====
"""Orchestrator for building wheels from InstallRequirements."""
from __future__ import annotations
import logging
import os.path
import re
import shutil
from collections.abc import Iterable
from pip._vendor.packaging.utils import canonicalize_name, canonicalize_version
from pip._vendor.packaging.version import InvalidVersion, Version
from pip._internal.cache import WheelCache
from pip._internal.exceptions import InvalidWheelFilename, UnsupportedWheel
from pip._internal.metadata import FilesystemWheel, get_wheel_distribution
from pip._internal.models.link import Link
from pip._internal.models.wheel import Wheel
from pip._internal.operations.build.wheel import build_wheel_pep517
from pip._internal.operations.build.wheel_editable import build_wheel_editable
from pip._internal.operations.build.wheel_legacy import build_wheel_legacy
from pip._internal.req.req_install import InstallRequirement
from pip._internal.utils.logging import indent_log
from pip._internal.utils.misc import ensure_dir, hash_file
from pip._internal.utils.setuptools_build import make_setuptools_clean_args
from pip._internal.utils.subprocess import call_subprocess
from pip._internal.utils.temp_dir import TempDirectory
from pip._internal.utils.urls import path_to_url
from pip._internal.vcs import vcs
logger = logging.getLogger(__name__)
_egg_info_re = re.compile(r"([a-z0-9_.]+)-([a-z0-9_.!+-]+)", re.IGNORECASE)
BuildResult = tuple[list[InstallRequirement], list[InstallRequirement]]
def _contains_egg_info(s: str) -> bool:
    """Determine whether the string looks like an egg_info.
    :param s: The string to parse. E.g. foo-2.1
    """
    return bool(_egg_info_re.search(s))
def _should_build(
    req: InstallRequirement,
) -> bool:
    """Return whether an InstallRequirement should be built into a wheel."""
    assert not req.constraint
    if req.is_wheel:
        return False
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/metadata/_json.py =====
from __future__ import annotations
from email.header import Header, decode_header, make_header
from email.message import Message
from typing import Any, cast
METADATA_FIELDS = [
    # Name, Multiple-Use
    ("Metadata-Version", False),
    ("Name", False),
    ("Version", False),
    ("Dynamic", True),
    ("Platform", True),
    ("Supported-Platform", True),
    ("Summary", False),
    ("Description", False),
    ("Description-Content-Type", False),
    ("Keywords", False),
    ("Home-page", False),
    ("Download-URL", False),
    ("Author", False),
    ("Author-email", False),
    ("Maintainer", False),
    ("Maintainer-email", False),
    ("License", False),
    ("License-Expression", False),
    ("License-File", True),
    ("Classifier", True),
    ("Requires-Dist", True),
    ("Requires-Python", False),
    ("Requires-External", True),
    ("Project-URL", True),
    ("Provides-Extra", True),
    ("Provides-Dist", True),
    ("Obsoletes-Dist", True),
]
def json_name(field: str) -> str:
    return field.lower().replace("-", "_")
def msg_to_json(msg: Message) -> dict[str, Any]:
    """Convert a Message object into a JSON-compatible dictionary."""
    def sanitise_header(h: Header | str) -> str:
        if isinstance(h, Header):
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/metadata/__init__.py =====
from __future__ import annotations
import contextlib
import functools
import os
import sys
from typing import Literal, Protocol, cast
from pip._internal.utils.deprecation import deprecated
from pip._internal.utils.misc import strtobool
from .base import BaseDistribution, BaseEnvironment, FilesystemWheel, MemoryWheel, Wheel
__all__ = [
    "BaseDistribution",
    "BaseEnvironment",
    "FilesystemWheel",
    "MemoryWheel",
    "Wheel",
    "get_default_environment",
    "get_environment",
    "get_wheel_distribution",
    "select_backend",
]
def _should_use_importlib_metadata() -> bool:
    """Whether to use the ``importlib.metadata`` or ``pkg_resources`` backend.
    By default, pip uses ``importlib.metadata`` on Python 3.11+, and
    ``pkg_resources`` otherwise. Up to Python 3.13, This can be
    overridden by a couple of ways:
    * If environment variable ``_PIP_USE_IMPORTLIB_METADATA`` is set, it
      dictates whether ``importlib.metadata`` is used, for Python <3.14.
    * On Python 3.11, 3.12 and 3.13, Python distributors can patch
      ``importlib.metadata`` to add a global constant
      ``_PIP_USE_IMPORTLIB_METADATA = False``. This makes pip use
      ``pkg_resources`` (unless the user set the aforementioned environment
      variable to *True*).
    On Python 3.14+, the ``pkg_resources`` backend cannot be used.
    """
    if sys.version_info >= (3, 14):
        # On Python >=3.14 we only support importlib.metadata.
        return True
    with contextlib.suppress(KeyError, ValueError):
        # On Python <3.14, if the environment variable is set, we obey what it says.
        return bool(strtobool(os.environ["_PIP_USE_IMPORTLIB_METADATA"]))
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/metadata/pkg_resources.py =====
from __future__ import annotations
import email.message
import email.parser
import logging
import os
import zipfile
from collections.abc import Collection, Iterable, Iterator, Mapping
from typing import (
    NamedTuple,
)
from pip._vendor import pkg_resources
from pip._vendor.packaging.requirements import Requirement
from pip._vendor.packaging.utils import NormalizedName, canonicalize_name
from pip._vendor.packaging.version import Version
from pip._vendor.packaging.version import parse as parse_version
from pip._internal.exceptions import InvalidWheel, NoneMetadataError, UnsupportedWheel
from pip._internal.utils.egg_link import egg_link_path_from_location
from pip._internal.utils.misc import display_path, normalize_path
from pip._internal.utils.wheel import parse_wheel, read_wheel_metadata_file
from .base import (
    BaseDistribution,
    BaseEntryPoint,
    BaseEnvironment,
    InfoPath,
    Wheel,
)
__all__ = ["NAME", "Distribution", "Environment"]
logger = logging.getLogger(__name__)
NAME = "pkg_resources"
class EntryPoint(NamedTuple):
    name: str
    value: str
    group: str
class InMemoryMetadata:
    """IMetadataProvider that reads metadata files from a dictionary.
    This also maps metadata decoding exceptions to our internal exception type.
    """
    def __init__(self, metadata: Mapping[str, bytes], wheel_name: str) -> None:
        self._metadata = metadata
        self._wheel_name = wheel_name
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/metadata/importlib/_dists.py =====
from __future__ import annotations
import email.message
import importlib.metadata
import pathlib
import zipfile
from collections.abc import Collection, Iterable, Iterator, Mapping, Sequence
from os import PathLike
from typing import (
    cast,
)
from pip._vendor.packaging.requirements import Requirement
from pip._vendor.packaging.utils import NormalizedName, canonicalize_name
from pip._vendor.packaging.version import Version
from pip._vendor.packaging.version import parse as parse_version
from pip._internal.exceptions import InvalidWheel, UnsupportedWheel
from pip._internal.metadata.base import (
    BaseDistribution,
    BaseEntryPoint,
    InfoPath,
    Wheel,
)
from pip._internal.utils.misc import normalize_path
from pip._internal.utils.packaging import get_requirement
from pip._internal.utils.temp_dir import TempDirectory
from pip._internal.utils.wheel import parse_wheel, read_wheel_metadata_file
from ._compat import (
    BasePath,
    get_dist_canonical_name,
    parse_name_and_version_from_info_directory,
)
class WheelDistribution(importlib.metadata.Distribution):
    """An ``importlib.metadata.Distribution`` read from a wheel.
    Although ``importlib.metadata.PathDistribution`` accepts ``zipfile.Path``,
    its implementation is too "lazy" for pip's needs (we can't keep the ZipFile
    handle open for the entire lifetime of the distribution object).
    This implementation eagerly reads the entire metadata directory into the
    memory instead, and operates from that.
    """
    def __init__(
        self,
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/metadata/importlib/__init__.py =====
from ._dists import Distribution
from ._envs import Environment
__all__ = ["NAME", "Distribution", "Environment"]
NAME = "importlib"
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/metadata/importlib/_compat.py =====
from __future__ import annotations
import importlib.metadata
import os
from typing import Any, Protocol, cast
from pip._vendor.packaging.utils import NormalizedName, canonicalize_name
class BadMetadata(ValueError):
    def __init__(self, dist: importlib.metadata.Distribution, *, reason: str) -> None:
        self.dist = dist
        self.reason = reason
    def __str__(self) -> str:
        return f"Bad metadata in {self.dist} ({self.reason})"
class BasePath(Protocol):
    """A protocol that various path objects conform.
    This exists because importlib.metadata uses both ``pathlib.Path`` and
    ``zipfile.Path``, and we need a common base for type hints (Union does not
    work well since ``zipfile.Path`` is too new for our linter setup).
    This does not mean to be exhaustive, but only contains things that present
    in both classes *that we need*.
    """
    @property
    def name(self) -> str:
        raise NotImplementedError()
    @property
    def parent(self) -> BasePath:
        raise NotImplementedError()
def get_info_location(d: importlib.metadata.Distribution) -> BasePath | None:
    """Find the path to the distribution's metadata directory.
    HACK: This relies on importlib.metadata's private ``_path`` attribute. Not
    all distributions exist on disk, so importlib.metadata is correct to not
    expose the attribute as public. But pip's code base is old and not as clean,
    so we do this to avoid having to rewrite too many things. Hopefully we can
    eliminate this some day.
    """
    return getattr(d, "_path", None)
def parse_name_and_version_from_info_directory(
    dist: importlib.metadata.Distribution,
) -> tuple[str | None, str | None]:
    """Get a name and version from the metadata directory name.
    This is much faster than reading distribution metadata.
    """
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/metadata/importlib/_envs.py =====
from __future__ import annotations
import importlib.metadata
import logging
import os
import pathlib
import sys
import zipfile
from collections.abc import Iterator, Sequence
from typing import Optional
from pip._vendor.packaging.utils import (
    InvalidWheelFilename,
    NormalizedName,
    canonicalize_name,
    parse_wheel_filename,
)
from pip._internal.metadata.base import BaseDistribution, BaseEnvironment
from pip._internal.utils.filetypes import WHEEL_EXTENSION
from ._compat import BadMetadata, BasePath, get_dist_canonical_name, get_info_location
from ._dists import Distribution
logger = logging.getLogger(__name__)
def _looks_like_wheel(location: str) -> bool:
    if not location.endswith(WHEEL_EXTENSION):
        return False
    if not os.path.isfile(location):
        return False
    try:
        parse_wheel_filename(os.path.basename(location))
    except InvalidWheelFilename:
        return False
    return zipfile.is_zipfile(location)
class _DistributionFinder:
    """Finder to locate distributions.
    The main purpose of this class is to memoize found distributions' names, so
    only one distribution is returned for each package name. At lot of pip code
    assumes this (because it is setuptools's behavior), and not doing the same
    can potentially cause a distribution in lower precedence path to override a
    higher precedence one if the caller is not careful.
    Eventually we probably want to make it possible to see lower precedence
    installations as well. It's useful feature, after all.
    """
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/metadata/base.py =====
from __future__ import annotations
import csv
import email.message
import functools
import json
import logging
import pathlib
import re
import zipfile
from collections.abc import Collection, Container, Iterable, Iterator
from typing import (
    IO,
    Any,
    NamedTuple,
    Protocol,
    Union,
)
from pip._vendor.packaging.requirements import Requirement
from pip._vendor.packaging.specifiers import InvalidSpecifier, SpecifierSet
from pip._vendor.packaging.utils import NormalizedName, canonicalize_name
from pip._vendor.packaging.version import Version
from pip._internal.exceptions import NoneMetadataError
from pip._internal.locations import site_packages, user_site
from pip._internal.models.direct_url import (
    DIRECT_URL_METADATA_NAME,
    DirectUrl,
    DirectUrlValidationError,
)
from pip._internal.utils.compat import stdlib_pkgs  # TODO: Move definition here.
from pip._internal.utils.egg_link import egg_link_path_from_sys_path
from pip._internal.utils.misc import is_local, normalize_path
from pip._internal.utils.urls import url_to_path
from ._json import msg_to_json
InfoPath = Union[str, pathlib.PurePath]
logger = logging.getLogger(__name__)
class BaseEntryPoint(Protocol):
    @property
    def name(self) -> str:
        raise NotImplementedError()
    @property
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/distributions/__init__.py =====
from pip._internal.distributions.base import AbstractDistribution
from pip._internal.distributions.sdist import SourceDistribution
from pip._internal.distributions.wheel import WheelDistribution
from pip._internal.req.req_install import InstallRequirement
def make_distribution_for_install_requirement(
    install_req: InstallRequirement,
) -> AbstractDistribution:
    """Returns a Distribution for the given InstallRequirement"""
    # Editable requirements will always be source distributions. They use the
    # legacy logic until we create a modern standard for them.
    if install_req.editable:
        return SourceDistribution(install_req)
    # If it's a wheel, it's a WheelDistribution
    if install_req.is_wheel:
        return WheelDistribution(install_req)
    # Otherwise, a SourceDistribution
    return SourceDistribution(install_req)
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/distributions/sdist.py =====
from __future__ import annotations
import logging
from collections.abc import Iterable
from typing import TYPE_CHECKING
from pip._internal.build_env import BuildEnvironment
from pip._internal.distributions.base import AbstractDistribution
from pip._internal.exceptions import InstallationError
from pip._internal.metadata import BaseDistribution
from pip._internal.utils.subprocess import runner_with_spinner_message
if TYPE_CHECKING:
    from pip._internal.build_env import BuildEnvironmentInstaller
logger = logging.getLogger(__name__)
class SourceDistribution(AbstractDistribution):
    """Represents a source distribution.
    The preparation step for these needs metadata for the packages to be
    generated, either using PEP 517 or using the legacy `setup.py egg_info`.
    """
    @property
    def build_tracker_id(self) -> str | None:
        """Identify this requirement uniquely by its link."""
        assert self.req.link
        return self.req.link.url_without_fragment
    def get_metadata_distribution(self) -> BaseDistribution:
        return self.req.get_dist()
    def prepare_distribution_metadata(
        self,
        build_env_installer: BuildEnvironmentInstaller,
        build_isolation: bool,
        check_build_deps: bool,
    ) -> None:
        # Load pyproject.toml, to determine whether PEP 517 is to be used
        self.req.load_pyproject_toml()
        # Set up the build isolation, if this requirement should be isolated
        should_isolate = self.req.use_pep517 and build_isolation
        if should_isolate:
            # Setup an isolated environment and install the build backend static
            # requirements in it.
            self._prepare_build_backend(build_env_installer)
            # Check that if the requirement is editable, it either supports PEP 660 or
            # has a setup.py or a setup.cfg. This cannot be done earlier because we need
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/distributions/installed.py =====
from __future__ import annotations
from typing import TYPE_CHECKING
from pip._internal.distributions.base import AbstractDistribution
from pip._internal.metadata import BaseDistribution
if TYPE_CHECKING:
    from pip._internal.build_env import BuildEnvironmentInstaller
class InstalledDistribution(AbstractDistribution):
    """Represents an installed package.
    This does not need any preparation as the required information has already
    been computed.
    """
    @property
    def build_tracker_id(self) -> str | None:
        return None
    def get_metadata_distribution(self) -> BaseDistribution:
        assert self.req.satisfied_by is not None, "not actually installed"
        return self.req.satisfied_by
    def prepare_distribution_metadata(
        self,
        build_env_installer: BuildEnvironmentInstaller,
        build_isolation: bool,
        check_build_deps: bool,
    ) -> None:
        pass
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/distributions/base.py =====
from __future__ import annotations
import abc
from typing import TYPE_CHECKING
from pip._internal.metadata.base import BaseDistribution
from pip._internal.req import InstallRequirement
if TYPE_CHECKING:
    from pip._internal.build_env import BuildEnvironmentInstaller
class AbstractDistribution(metaclass=abc.ABCMeta):
    """A base class for handling installable artifacts.
    The requirements for anything installable are as follows:
     - we must be able to determine the requirement name
       (or we can't correctly handle the non-upgrade case).
     - for packages with setup requirements, we must also be able
       to determine their requirements without installing additional
       packages (for the same reason as run-time dependencies)
     - we must be able to create a Distribution object exposing the
       above metadata.
     - if we need to do work in the build tracker, we must be able to generate a unique
       string to identify the requirement in the build tracker.
    """
    def __init__(self, req: InstallRequirement) -> None:
        super().__init__()
        self.req = req
    @abc.abstractproperty
    def build_tracker_id(self) -> str | None:
        """A string that uniquely identifies this requirement to the build tracker.
        If None, then this dist has no work to do in the build tracker, and
        ``.prepare_distribution_metadata()`` will not be called."""
        raise NotImplementedError()
    @abc.abstractmethod
    def get_metadata_distribution(self) -> BaseDistribution:
        raise NotImplementedError()
    @abc.abstractmethod
    def prepare_distribution_metadata(
        self,
        build_env_installer: BuildEnvironmentInstaller,
        build_isolation: bool,
        check_build_deps: bool,
    ) -> None:
        raise NotImplementedError()
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/distributions/wheel.py =====
from __future__ import annotations
from typing import TYPE_CHECKING
from pip._vendor.packaging.utils import canonicalize_name
from pip._internal.distributions.base import AbstractDistribution
from pip._internal.metadata import (
    BaseDistribution,
    FilesystemWheel,
    get_wheel_distribution,
)
if TYPE_CHECKING:
    from pip._internal.build_env import BuildEnvironmentInstaller
class WheelDistribution(AbstractDistribution):
    """Represents a wheel distribution.
    This does not need any preparation as wheels can be directly unpacked.
    """
    @property
    def build_tracker_id(self) -> str | None:
        return None
    def get_metadata_distribution(self) -> BaseDistribution:
        """Loads the metadata from the wheel file into memory and returns a
        Distribution that uses it, not relying on the wheel file or
        requirement.
        """
        assert self.req.local_file_path, "Set as part of preparation during download"
        assert self.req.name, "Wheels are never unnamed"
        wheel = FilesystemWheel(self.req.local_file_path)
        return get_wheel_distribution(wheel, canonicalize_name(self.req.name))
    def prepare_distribution_metadata(
        self,
        build_env_installer: BuildEnvironmentInstaller,
        build_isolation: bool,
        check_build_deps: bool,
    ) -> None:
        pass
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/self_outdated_check.py =====
from __future__ import annotations
import datetime
import functools
import hashlib
import json
import logging
import optparse
import os.path
import sys
from dataclasses import dataclass
from typing import Any, Callable
from pip._vendor.packaging.version import Version
from pip._vendor.packaging.version import parse as parse_version
from pip._vendor.rich.console import Group
from pip._vendor.rich.markup import escape
from pip._vendor.rich.text import Text
from pip._internal.index.collector import LinkCollector
from pip._internal.index.package_finder import PackageFinder
from pip._internal.metadata import get_default_environment
from pip._internal.models.selection_prefs import SelectionPreferences
from pip._internal.network.session import PipSession
from pip._internal.utils.compat import WINDOWS
from pip._internal.utils.entrypoints import (
    get_best_invocation_for_this_pip,
    get_best_invocation_for_this_python,
)
from pip._internal.utils.filesystem import adjacent_tmp_file, check_path_owner, replace
from pip._internal.utils.misc import (
    ExternallyManagedEnvironment,
    check_externally_managed,
    ensure_dir,
)
_WEEK = datetime.timedelta(days=7)
logger = logging.getLogger(__name__)
def _get_statefile_name(key: str) -> str:
    key_bytes = key.encode()
    name = hashlib.sha224(key_bytes).hexdigest()
    return name
def _convert_date(isodate: str) -> datetime.datetime:
    """Convert an ISO format string to a date.
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_internal/build_env.py =====
"""Build Environment used for isolation during sdist building"""
from __future__ import annotations
import logging
import os
import pathlib
import site
import sys
import textwrap
from collections import OrderedDict
from collections.abc import Iterable
from types import TracebackType
from typing import TYPE_CHECKING, Protocol
from pip._vendor.packaging.version import Version
from pip import __file__ as pip_location
from pip._internal.cli.spinners import open_spinner
from pip._internal.locations import get_platlib, get_purelib, get_scheme
from pip._internal.metadata import get_default_environment, get_environment
from pip._internal.utils.logging import VERBOSE
from pip._internal.utils.packaging import get_requirement
from pip._internal.utils.subprocess import call_subprocess
from pip._internal.utils.temp_dir import TempDirectory, tempdir_kinds
if TYPE_CHECKING:
    from pip._internal.index.package_finder import PackageFinder
    from pip._internal.req.req_install import InstallRequirement
logger = logging.getLogger(__name__)
def _dedup(a: str, b: str) -> tuple[str] | tuple[str, str]:
    return (a, b) if a != b else (a,)
class _Prefix:
    def __init__(self, path: str) -> None:
        self.path = path
        self.setup = False
        scheme = get_scheme("", prefix=path)
        self.bin_dir = scheme.scripts
        self.lib_dirs = _dedup(scheme.purelib, scheme.platlib)
def get_runnable_pip() -> str:
    """Get a file to pass to a Python executable, to run the currently-running pip.
    This is used to run a pip subprocess, for installing requirements into the build
    environment.
    """
    source = pathlib.Path(pip_location).resolve().parent
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/packaging/tags.py =====
from __future__ import annotations
import logging
import platform
import re
import struct
import subprocess
import sys
import sysconfig
from importlib.machinery import EXTENSION_SUFFIXES
from typing import (
    Iterable,
    Iterator,
    Sequence,
    Tuple,
    cast,
)
from . import _manylinux, _musllinux
logger = logging.getLogger(__name__)
PythonVersion = Sequence[int]
AppleVersion = Tuple[int, int]
INTERPRETER_SHORT_NAMES: dict[str, str] = {
    "python": "py",  # Generic.
    "cpython": "cp",
    "pypy": "pp",
    "ironpython": "ip",
    "jython": "jy",
}
_32_BIT_INTERPRETER = struct.calcsize("P") == 4
class Tag:
    """
    A representation of the tag triple for a wheel.
    Instances are considered immutable and thus are hashable. Equality checking
    is also supported.
    """
    __slots__ = ["_abi", "_hash", "_interpreter", "_platform"]
    def __init__(self, interpreter: str, abi: str, platform: str) -> None:
        self._interpreter = interpreter.lower()
        self._abi = abi.lower()
        self._platform = platform.lower()
        # The __hash__ of every single element in a Set[Tag] will be evaluated each time
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/packaging/_musllinux.py =====
"""PEP 656 support.
This module implements logic to detect if the currently running Python is
linked against musl, and what musl version is used.
"""
from __future__ import annotations
import functools
import re
import subprocess
import sys
from typing import Iterator, NamedTuple, Sequence
from ._elffile import ELFFile
class _MuslVersion(NamedTuple):
    major: int
    minor: int
def _parse_musl_version(output: str) -> _MuslVersion | None:
    lines = [n for n in (n.strip() for n in output.splitlines()) if n]
    if len(lines) < 2 or lines[0][:4] != "musl":
        return None
    m = re.match(r"Version (\d+)\.(\d+)", lines[1])
    if not m:
        return None
    return _MuslVersion(major=int(m.group(1)), minor=int(m.group(2)))
@functools.lru_cache
def _get_musl_version(executable: str) -> _MuslVersion | None:
    """Detect currently-running musl runtime version.
    This is done by checking the specified executable's dynamic linking
    information, and invoking the loader to parse its output for a version
    string. If the loader is musl, the output would be something like::
        musl libc (x86_64)
        Version 1.2.2
        Dynamic Program Loader
    """
    try:
        with open(executable, "rb") as f:
            ld = ELFFile(f).interpreter
    except (OSError, TypeError, ValueError):
        return None
    if ld is None or "musl" not in ld:
        return None
    proc = subprocess.run([ld], stderr=subprocess.PIPE, text=True)
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/packaging/metadata.py =====
from __future__ import annotations
import email.feedparser
import email.header
import email.message
import email.parser
import email.policy
import pathlib
import sys
import typing
from typing import (
    Any,
    Callable,
    Generic,
    Literal,
    TypedDict,
    cast,
)
from . import licenses, requirements, specifiers, utils
from . import version as version_module
from .licenses import NormalizedLicenseExpression
T = typing.TypeVar("T")
if sys.version_info >= (3, 11):  # pragma: no cover
    ExceptionGroup = ExceptionGroup
else:  # pragma: no cover
    class ExceptionGroup(Exception):
        """A minimal implementation of :external:exc:`ExceptionGroup` from Python 3.11.
        If :external:exc:`ExceptionGroup` is already defined by Python itself,
        that version is used instead.
        """
        message: str
        exceptions: list[Exception]
        def __init__(self, message: str, exceptions: list[Exception]) -> None:
            self.message = message
            self.exceptions = exceptions
        def __repr__(self) -> str:
            return f"{self.__class__.__name__}({self.message!r}, {self.exceptions!r})"
class InvalidMetadata(ValueError):
    """A metadata field contains invalid data."""
    field: str
    """The name of the field that contains invalid data."""
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/packaging/version.py =====
"""
.. testsetup::
    from pip._vendor.packaging.version import parse, Version
"""
from __future__ import annotations
import itertools
import re
from typing import Any, Callable, NamedTuple, SupportsInt, Tuple, Union
from ._structures import Infinity, InfinityType, NegativeInfinity, NegativeInfinityType
__all__ = ["VERSION_PATTERN", "InvalidVersion", "Version", "parse"]
LocalType = Tuple[Union[int, str], ...]
CmpPrePostDevType = Union[InfinityType, NegativeInfinityType, Tuple[str, int]]
CmpLocalType = Union[
    NegativeInfinityType,
    Tuple[Union[Tuple[int, str], Tuple[NegativeInfinityType, Union[int, str]]], ...],
]
CmpKey = Tuple[
    int,
    Tuple[int, ...],
    CmpPrePostDevType,
    CmpPrePostDevType,
    CmpPrePostDevType,
    CmpLocalType,
]
VersionComparisonMethod = Callable[[CmpKey, CmpKey], bool]
class _Version(NamedTuple):
    epoch: int
    release: tuple[int, ...]
    dev: tuple[str, int] | None
    pre: tuple[str, int] | None
    post: tuple[str, int] | None
    local: LocalType | None
def parse(version: str) -> Version:
    """Parse the given version string.
    >>> parse('1.0.dev1')
    <Version('1.0.dev1')>
    :param version: The version string to parse.
    :raises InvalidVersion: When the version string is not a valid version.
    """
    return Version(version)
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/packaging/licenses/__init__.py =====
from __future__ import annotations
import re
from typing import NewType, cast
from pip._vendor.packaging.licenses._spdx import EXCEPTIONS, LICENSES
__all__ = [
    "InvalidLicenseExpression",
    "NormalizedLicenseExpression",
    "canonicalize_license_expression",
]
license_ref_allowed = re.compile("^[A-Za-z0-9.-]*$")
NormalizedLicenseExpression = NewType("NormalizedLicenseExpression", str)
class InvalidLicenseExpression(ValueError):
    """Raised when a license-expression string is invalid
    >>> canonicalize_license_expression("invalid")
    Traceback (most recent call last):
        ...
    packaging.licenses.InvalidLicenseExpression: Invalid license expression: 'invalid'
    """
def canonicalize_license_expression(
    raw_license_expression: str,
) -> NormalizedLicenseExpression:
    if not raw_license_expression:
        message = f"Invalid license expression: {raw_license_expression!r}"
        raise InvalidLicenseExpression(message)
    # Pad any parentheses so tokenization can be achieved by merely splitting on
    # whitespace.
    license_expression = raw_license_expression.replace("(", " ( ").replace(")", " ) ")
    licenseref_prefix = "LicenseRef-"
    license_refs = {
        ref.lower(): "LicenseRef-" + ref[len(licenseref_prefix) :]
        for ref in license_expression.split()
        if ref.lower().startswith(licenseref_prefix.lower())
    }
    # Normalize to lower case so we can look up licenses/exceptions
    # and so boolean operators are Python-compatible.
    license_expression = license_expression.lower()
    tokens = license_expression.split()
    # Rather than implementing boolean logic, we create an expression that Python can
    # parse. Everything that is not involved with the grammar itself is treated as
    # `False` and the expression should evaluate as such.
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/packaging/licenses/_spdx.py =====
from __future__ import annotations
from typing import TypedDict
class SPDXLicense(TypedDict):
    id: str
    deprecated: bool
class SPDXException(TypedDict):
    id: str
    deprecated: bool
VERSION = '3.25.0'
LICENSES: dict[str, SPDXLicense] = {
    '0bsd': {'id': '0BSD', 'deprecated': False},
    '3d-slicer-1.0': {'id': '3D-Slicer-1.0', 'deprecated': False},
    'aal': {'id': 'AAL', 'deprecated': False},
    'abstyles': {'id': 'Abstyles', 'deprecated': False},
    'adacore-doc': {'id': 'AdaCore-doc', 'deprecated': False},
    'adobe-2006': {'id': 'Adobe-2006', 'deprecated': False},
    'adobe-display-postscript': {'id': 'Adobe-Display-PostScript', 'deprecated': False},
    'adobe-glyph': {'id': 'Adobe-Glyph', 'deprecated': False},
    'adobe-utopia': {'id': 'Adobe-Utopia', 'deprecated': False},
    'adsl': {'id': 'ADSL', 'deprecated': False},
    'afl-1.1': {'id': 'AFL-1.1', 'deprecated': False},
    'afl-1.2': {'id': 'AFL-1.2', 'deprecated': False},
    'afl-2.0': {'id': 'AFL-2.0', 'deprecated': False},
    'afl-2.1': {'id': 'AFL-2.1', 'deprecated': False},
    'afl-3.0': {'id': 'AFL-3.0', 'deprecated': False},
    'afmparse': {'id': 'Afmparse', 'deprecated': False},
    'agpl-1.0': {'id': 'AGPL-1.0', 'deprecated': True},
    'agpl-1.0-only': {'id': 'AGPL-1.0-only', 'deprecated': False},
    'agpl-1.0-or-later': {'id': 'AGPL-1.0-or-later', 'deprecated': False},
    'agpl-3.0': {'id': 'AGPL-3.0', 'deprecated': True},
    'agpl-3.0-only': {'id': 'AGPL-3.0-only', 'deprecated': False},
    'agpl-3.0-or-later': {'id': 'AGPL-3.0-or-later', 'deprecated': False},
    'aladdin': {'id': 'Aladdin', 'deprecated': False},
    'amd-newlib': {'id': 'AMD-newlib', 'deprecated': False},
    'amdplpa': {'id': 'AMDPLPA', 'deprecated': False},
    'aml': {'id': 'AML', 'deprecated': False},
    'aml-glslang': {'id': 'AML-glslang', 'deprecated': False},
    'ampas': {'id': 'AMPAS', 'deprecated': False},
    'antlr-pd': {'id': 'ANTLR-PD', 'deprecated': False},
    'antlr-pd-fallback': {'id': 'ANTLR-PD-fallback', 'deprecated': False},
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/packaging/__init__.py =====
__title__ = "packaging"
__summary__ = "Core utilities for Python packages"
__uri__ = "https://github.com/pypa/packaging"
__version__ = "25.0"
__author__ = "Donald Stufft and individual contributors"
__email__ = "donald@stufft.io"
__license__ = "BSD-2-Clause or Apache-2.0"
__copyright__ = f"2014 {__author__}"
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/packaging/_parser.py =====
"""Handwritten parser of dependency specifiers.
The docstring for each __parse_* function contains EBNF-inspired grammar representing
the implementation.
"""
from __future__ import annotations
import ast
from typing import NamedTuple, Sequence, Tuple, Union
from ._tokenizer import DEFAULT_RULES, Tokenizer
class Node:
    def __init__(self, value: str) -> None:
        self.value = value
    def __str__(self) -> str:
        return self.value
    def __repr__(self) -> str:
        return f"<{self.__class__.__name__}('{self}')>"
    def serialize(self) -> str:
        raise NotImplementedError
class Variable(Node):
    def serialize(self) -> str:
        return str(self)
class Value(Node):
    def serialize(self) -> str:
        return f'"{self}"'
class Op(Node):
    def serialize(self) -> str:
        return str(self)
MarkerVar = Union[Variable, Value]
MarkerItem = Tuple[MarkerVar, Op, MarkerVar]
MarkerAtom = Union[MarkerItem, Sequence["MarkerAtom"]]
MarkerList = Sequence[Union["MarkerList", MarkerAtom, str]]
class ParsedRequirement(NamedTuple):
    name: str
    url: str
    extras: list[str]
    specifier: str
    marker: MarkerList | None
def parse_requirement(source: str) -> ParsedRequirement:
    return _parse_requirement(Tokenizer(source, rules=DEFAULT_RULES))
def _parse_requirement(tokenizer: Tokenizer) -> ParsedRequirement:
    """
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/packaging/utils.py =====
from __future__ import annotations
import functools
import re
from typing import NewType, Tuple, Union, cast
from .tags import Tag, parse_tag
from .version import InvalidVersion, Version, _TrimmedRelease
BuildTag = Union[Tuple[()], Tuple[int, str]]
NormalizedName = NewType("NormalizedName", str)
class InvalidName(ValueError):
    """
    An invalid distribution name; users should refer to the packaging user guide.
    """
class InvalidWheelFilename(ValueError):
    """
    An invalid wheel filename was found, users should refer to PEP 427.
    """
class InvalidSdistFilename(ValueError):
    """
    An invalid sdist filename was found, users should refer to the packaging user guide.
    """
_validate_regex = re.compile(
    r"^([A-Z0-9]|[A-Z0-9][A-Z0-9._-]*[A-Z0-9])$", re.IGNORECASE
)
_canonicalize_regex = re.compile(r"[-_.]+")
_normalized_regex = re.compile(r"^([a-z0-9]|[a-z0-9]([a-z0-9-](?!--))*[a-z0-9])$")
_build_tag_regex = re.compile(r"(\d+)(.*)")
def canonicalize_name(name: str, *, validate: bool = False) -> NormalizedName:
    if validate and not _validate_regex.match(name):
        raise InvalidName(f"name is invalid: {name!r}")
    # This is taken from PEP 503.
    value = _canonicalize_regex.sub("-", name).lower()
    return cast(NormalizedName, value)
def is_normalized_name(name: str) -> bool:
    return _normalized_regex.match(name) is not None
@functools.singledispatch
def canonicalize_version(
    version: Version | str, *, strip_trailing_zero: bool = True
) -> str:
    """
    Return a canonical form of a version as a string.
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/packaging/requirements.py =====
from __future__ import annotations
from typing import Any, Iterator
from ._parser import parse_requirement as _parse_requirement
from ._tokenizer import ParserSyntaxError
from .markers import Marker, _normalize_extra_values
from .specifiers import SpecifierSet
from .utils import canonicalize_name
class InvalidRequirement(ValueError):
    """
    An invalid requirement was found, users should refer to PEP 508.
    """
class Requirement:
    """Parse a requirement.
    Parse a given requirement string into its parts, such as name, specifier,
    URL, and extras. Raises InvalidRequirement on a badly-formed requirement
    string.
    """
    # TODO: Can we test whether something is contained within a requirement?
    #       If so how do we do that? Do we need to test against the _name_ of
    #       the thing as well as the version? What about the markers?
    # TODO: Can we normalize the name and extra name?
    def __init__(self, requirement_string: str) -> None:
        try:
            parsed = _parse_requirement(requirement_string)
        except ParserSyntaxError as e:
            raise InvalidRequirement(str(e)) from e
        self.name: str = parsed.name
        self.url: str | None = parsed.url or None
        self.extras: set[str] = set(parsed.extras or [])
        self.specifier: SpecifierSet = SpecifierSet(parsed.specifier)
        self.marker: Marker | None = None
        if parsed.marker is not None:
            self.marker = Marker.__new__(Marker)
            self.marker._markers = _normalize_extra_values(parsed.marker)
    def _iter_parts(self, name: str) -> Iterator[str]:
        yield name
        if self.extras:
            formatted_extras = ",".join(sorted(self.extras))
            yield f"[{formatted_extras}]"
        if self.specifier:
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/packaging/_structures.py =====
class InfinityType:
    def __repr__(self) -> str:
        return "Infinity"
    def __hash__(self) -> int:
        return hash(repr(self))
    def __lt__(self, other: object) -> bool:
        return False
    def __le__(self, other: object) -> bool:
        return False
    def __eq__(self, other: object) -> bool:
        return isinstance(other, self.__class__)
    def __gt__(self, other: object) -> bool:
        return True
    def __ge__(self, other: object) -> bool:
        return True
    def __neg__(self: object) -> "NegativeInfinityType":
        return NegativeInfinity
Infinity = InfinityType()
class NegativeInfinityType:
    def __repr__(self) -> str:
        return "-Infinity"
    def __hash__(self) -> int:
        return hash(repr(self))
    def __lt__(self, other: object) -> bool:
        return True
    def __le__(self, other: object) -> bool:
        return True
    def __eq__(self, other: object) -> bool:
        return isinstance(other, self.__class__)
    def __gt__(self, other: object) -> bool:
        return False
    def __ge__(self, other: object) -> bool:
        return False
    def __neg__(self: object) -> InfinityType:
        return Infinity
NegativeInfinity = NegativeInfinityType()
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/packaging/markers.py =====
from __future__ import annotations
import operator
import os
import platform
import sys
from typing import AbstractSet, Any, Callable, Literal, TypedDict, Union, cast
from ._parser import MarkerAtom, MarkerList, Op, Value, Variable
from ._parser import parse_marker as _parse_marker
from ._tokenizer import ParserSyntaxError
from .specifiers import InvalidSpecifier, Specifier
from .utils import canonicalize_name
__all__ = [
    "EvaluateContext",
    "InvalidMarker",
    "Marker",
    "UndefinedComparison",
    "UndefinedEnvironmentName",
    "default_environment",
]
Operator = Callable[[str, Union[str, AbstractSet[str]]], bool]
EvaluateContext = Literal["metadata", "lock_file", "requirement"]
MARKERS_ALLOWING_SET = {"extras", "dependency_groups"}
class InvalidMarker(ValueError):
    """
    An invalid marker was found, users should refer to PEP 508.
    """
class UndefinedComparison(ValueError):
    """
    An invalid operation was attempted on a value that doesn't support it.
    """
class UndefinedEnvironmentName(ValueError):
    """
    A name was attempted to be used that does not exist inside of the
    environment.
    """
class Environment(TypedDict):
    implementation_name: str
    """The implementation's identifier, e.g. ``'cpython'``."""
    implementation_version: str
    """
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/packaging/_manylinux.py =====
from __future__ import annotations
import collections
import contextlib
import functools
import os
import re
import sys
import warnings
from typing import Generator, Iterator, NamedTuple, Sequence
from ._elffile import EIClass, EIData, ELFFile, EMachine
EF_ARM_ABIMASK = 0xFF000000
EF_ARM_ABI_VER5 = 0x05000000
EF_ARM_ABI_FLOAT_HARD = 0x00000400
@contextlib.contextmanager
def _parse_elf(path: str) -> Generator[ELFFile | None, None, None]:
    try:
        with open(path, "rb") as f:
            yield ELFFile(f)
    except (OSError, TypeError, ValueError):
        yield None
def _is_linux_armhf(executable: str) -> bool:
    # hard-float ABI can be detected from the ELF header of the running
    # process
    # https://static.docs.arm.com/ihi0044/g/aaelf32.pdf
    with _parse_elf(executable) as f:
        return (
            f is not None
            and f.capacity == EIClass.C32
            and f.encoding == EIData.Lsb
            and f.machine == EMachine.Arm
            and f.flags & EF_ARM_ABIMASK == EF_ARM_ABI_VER5
            and f.flags & EF_ARM_ABI_FLOAT_HARD == EF_ARM_ABI_FLOAT_HARD
        )
def _is_linux_i686(executable: str) -> bool:
    with _parse_elf(executable) as f:
        return (
            f is not None
            and f.capacity == EIClass.C32
            and f.encoding == EIData.Lsb
            and f.machine == EMachine.I386
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/packaging/_tokenizer.py =====
from __future__ import annotations
import contextlib
import re
from dataclasses import dataclass
from typing import Iterator, NoReturn
from .specifiers import Specifier
@dataclass
class Token:
    name: str
    text: str
    position: int
class ParserSyntaxError(Exception):
    """The provided source text could not be parsed correctly."""
    def __init__(
        self,
        message: str,
        *,
        source: str,
        span: tuple[int, int],
    ) -> None:
        self.span = span
        self.message = message
        self.source = source
        super().__init__()
    def __str__(self) -> str:
        marker = " " * self.span[0] + "~" * (self.span[1] - self.span[0]) + "^"
        return "\n    ".join([self.message, self.source, marker])
DEFAULT_RULES: dict[str, str | re.Pattern[str]] = {
    "LEFT_PARENTHESIS": r"\(",
    "RIGHT_PARENTHESIS": r"\)",
    "LEFT_BRACKET": r"\[",
    "RIGHT_BRACKET": r"\]",
    "SEMICOLON": r";",
    "COMMA": r",",
    "QUOTED_STRING": re.compile(
        r"""
            (
                ('[^']*')
                |
                ("[^"]*")
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/packaging/specifiers.py =====
"""
.. testsetup::
    from pip._vendor.packaging.specifiers import Specifier, SpecifierSet, InvalidSpecifier
    from pip._vendor.packaging.version import Version
"""
from __future__ import annotations
import abc
import itertools
import re
from typing import Callable, Iterable, Iterator, TypeVar, Union
from .utils import canonicalize_version
from .version import Version
UnparsedVersion = Union[Version, str]
UnparsedVersionVar = TypeVar("UnparsedVersionVar", bound=UnparsedVersion)
CallableOperator = Callable[[Version, str], bool]
def _coerce_version(version: UnparsedVersion) -> Version:
    if not isinstance(version, Version):
        version = Version(version)
    return version
class InvalidSpecifier(ValueError):
    """
    Raised when attempting to create a :class:`Specifier` with a specifier
    string that is invalid.
    >>> Specifier("lolwat")
    Traceback (most recent call last):
        ...
    packaging.specifiers.InvalidSpecifier: Invalid specifier: 'lolwat'
    """
class BaseSpecifier(metaclass=abc.ABCMeta):
    @abc.abstractmethod
    def __str__(self) -> str:
        """
        Returns the str representation of this Specifier-like object. This
        should be representative of the Specifier itself.
        """
    @abc.abstractmethod
    def __hash__(self) -> int:
        """
        Returns a hash value for this Specifier-like object.
        """
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/packaging/_elffile.py =====
"""
ELF file parser.
This provides a class ``ELFFile`` that parses an ELF executable in a similar
interface to ``ZipFile``. Only the read interface is implemented.
Based on: https://gist.github.com/lyssdod/f51579ae8d93c8657a5564aefc2ffbca
ELF header: https://refspecs.linuxfoundation.org/elf/gabi4+/ch4.eheader.html
"""
from __future__ import annotations
import enum
import os
import struct
from typing import IO
class ELFInvalid(ValueError):
    pass
class EIClass(enum.IntEnum):
    C32 = 1
    C64 = 2
class EIData(enum.IntEnum):
    Lsb = 1
    Msb = 2
class EMachine(enum.IntEnum):
    I386 = 3
    S390 = 22
    Arm = 40
    X8664 = 62
    AArc64 = 183
class ELFFile:
    """
    Representation of an ELF executable.
    """
    def __init__(self, f: IO[bytes]) -> None:
        self._f = f
        try:
            ident = self._read("16B")
        except struct.error as e:
            raise ELFInvalid("unable to parse identification") from e
        magic = bytes(ident[:4])
        if magic != b"\x7fELF":
            raise ELFInvalid(f"invalid magic: {magic!r}")
        self.capacity = ident[4]  # Format for program header (bitness).
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/truststore/_openssl.py =====
import contextlib
import os
import re
import ssl
import typing
_CA_FILE_CANDIDATES = [
    # Alpine, Arch, Fedora 34+, OpenWRT, RHEL 9+, BSD
    "/etc/ssl/cert.pem",
    # Fedora <= 34, RHEL <= 9, CentOS <= 9
    "/etc/pki/tls/cert.pem",
    # Debian, Ubuntu (requires ca-certificates)
    "/etc/ssl/certs/ca-certificates.crt",
    # SUSE
    "/etc/ssl/ca-bundle.pem",
]
_HASHED_CERT_FILENAME_RE = re.compile(r"^[0-9a-fA-F]{8}\.[0-9]$")
@contextlib.contextmanager
def _configure_context(ctx: ssl.SSLContext) -> typing.Iterator[None]:
    # First, check whether the default locations from OpenSSL
    # seem like they will give us a usable set of CA certs.
    # ssl.get_default_verify_paths already takes care of:
    # - getting cafile from either the SSL_CERT_FILE env var
    #   or the path configured when OpenSSL was compiled,
    #   and verifying that that path exists
    # - getting capath from either the SSL_CERT_DIR env var
    #   or the path configured when OpenSSL was compiled,
    #   and verifying that that path exists
    # In addition we'll check whether capath appears to contain certs.
    defaults = ssl.get_default_verify_paths()
    if defaults.cafile or (defaults.capath and _capath_contains_certs(defaults.capath)):
        ctx.set_default_verify_paths()
    else:
        # cafile from OpenSSL doesn't exist
        # and capath from OpenSSL doesn't contain certs.
        # Let's search other common locations instead.
        for cafile in _CA_FILE_CANDIDATES:
            if os.path.isfile(cafile):
                ctx.load_verify_locations(cafile=cafile)
                break
    yield
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/truststore/_api.py =====
import os
import platform
import socket
import ssl
import sys
import typing
import _ssl
from ._ssl_constants import (
    _original_SSLContext,
    _original_super_SSLContext,
    _truststore_SSLContext_dunder_class,
    _truststore_SSLContext_super_class,
)
if platform.system() == "Windows":
    from ._windows import _configure_context, _verify_peercerts_impl
elif platform.system() == "Darwin":
    from ._macos import _configure_context, _verify_peercerts_impl
else:
    from ._openssl import _configure_context, _verify_peercerts_impl
if typing.TYPE_CHECKING:
    from typing_extensions import Buffer
_StrOrBytesPath: typing.TypeAlias = str | bytes | os.PathLike[str] | os.PathLike[bytes]
_PasswordType: typing.TypeAlias = str | bytes | typing.Callable[[], str | bytes]
def inject_into_ssl() -> None:
    """Injects the :class:`truststore.SSLContext` into the ``ssl``
    module by replacing :class:`ssl.SSLContext`.
    """
    setattr(ssl, "SSLContext", SSLContext)
    # urllib3 holds on to its own reference of ssl.SSLContext
    # so we need to replace that reference too.
    try:
        import pip._vendor.urllib3.util.ssl_ as urllib3_ssl
        setattr(urllib3_ssl, "SSLContext", SSLContext)
    except ImportError:
        pass
    # requests starting with 2.32.0 added a preloaded SSL context to improve concurrent performance;
    # this unfortunately leads to a RecursionError, which can be avoided by patching the preloaded SSL context with
    # the truststore patched instance
    # also see https://github.com/psf/requests/pull/6667
    try:
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/truststore/_macos.py =====
import contextlib
import ctypes
import platform
import ssl
import typing
from ctypes import (
    CDLL,
    POINTER,
    c_bool,
    c_char_p,
    c_int32,
    c_long,
    c_uint32,
    c_ulong,
    c_void_p,
)
from ctypes.util import find_library
from ._ssl_constants import _set_ssl_context_verify_mode
_mac_version = platform.mac_ver()[0]
_mac_version_info = tuple(map(int, _mac_version.split(".")))
if _mac_version_info < (10, 8):
    raise ImportError(
        f"Only OS X 10.8 and newer are supported, not {_mac_version_info[0]}.{_mac_version_info[1]}"
    )
_is_macos_version_10_14_or_later = _mac_version_info >= (10, 14)
def _load_cdll(name: str, macos10_16_path: str) -> CDLL:
    """Loads a CDLL by name, falling back to known path on 10.16+"""
    try:
        # Big Sur is technically 11 but we use 10.16 due to the Big Sur
        # beta being labeled as 10.16.
        path: str | None
        if _mac_version_info >= (10, 16):
            path = macos10_16_path
        else:
            path = find_library(name)
        if not path:
            raise OSError  # Caught and reraised as 'ImportError'
        return CDLL(path, use_errno=True)
    except OSError:
        raise ImportError(f"The library {name} failed to load") from None
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/truststore/__init__.py =====
"""Verify certificates using native system trust stores"""
import sys as _sys
if _sys.version_info < (3, 10):
    raise ImportError("truststore requires Python 3.10 or later")
if _sys.version_info < (3, 13) and _sys.implementation.name not in ("cpython", "pypy"):
    try:
        import ssl as _ssl
    except ImportError:
        raise ImportError("truststore requires the 'ssl' module")
    else:
        _sslmem = _ssl.MemoryBIO()
        _sslobj = _ssl.create_default_context().wrap_bio(
            _sslmem,
            _sslmem,
        )
        try:
            while not hasattr(_sslobj, "get_unverified_chain"):
                _sslobj = _sslobj._sslobj  # type: ignore[attr-defined]
        except AttributeError:
            raise ImportError(
                "truststore requires peer certificate chain APIs to be available"
            ) from None
        del _ssl, _sslobj, _sslmem  # noqa: F821
from ._api import SSLContext, extract_from_ssl, inject_into_ssl  # noqa: E402
del _api, _sys  # type: ignore[name-defined] # noqa: F821
__all__ = ["SSLContext", "inject_into_ssl", "extract_from_ssl"]
__version__ = "0.10.1"
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/truststore/_ssl_constants.py =====
import ssl
import sys
import typing
_original_SSLContext = ssl.SSLContext
_original_super_SSLContext = super(_original_SSLContext, _original_SSLContext)
_truststore_SSLContext_dunder_class: typing.Optional[type]
_truststore_SSLContext_super_class: type
if sys.implementation.name == "cpython":
    _truststore_SSLContext_super_class = _original_SSLContext
    _truststore_SSLContext_dunder_class = None
else:
    _truststore_SSLContext_super_class = object
    _truststore_SSLContext_dunder_class = _original_SSLContext
def _set_ssl_context_verify_mode(
    ssl_context: ssl.SSLContext, verify_mode: ssl.VerifyMode
) -> None:
    _original_super_SSLContext.verify_mode.__set__(ssl_context, verify_mode)  # type: ignore[attr-defined]
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/truststore/_windows.py =====
import contextlib
import ssl
import typing
from ctypes import WinDLL  # type: ignore
from ctypes import WinError  # type: ignore
from ctypes import (
    POINTER,
    Structure,
    c_char_p,
    c_ulong,
    c_void_p,
    c_wchar_p,
    cast,
    create_unicode_buffer,
    pointer,
    sizeof,
)
from ctypes.wintypes import (
    BOOL,
    DWORD,
    HANDLE,
    LONG,
    LPCSTR,
    LPCVOID,
    LPCWSTR,
    LPFILETIME,
    LPSTR,
    LPWSTR,
)
from typing import TYPE_CHECKING, Any
from ._ssl_constants import _set_ssl_context_verify_mode
HCERTCHAINENGINE = HANDLE
HCERTSTORE = HANDLE
HCRYPTPROV_LEGACY = HANDLE
class CERT_CONTEXT(Structure):
    _fields_ = (
        ("dwCertEncodingType", DWORD),
        ("pbCertEncoded", c_void_p),
        ("cbCertEncoded", DWORD),
        ("pCertInfo", c_void_p),
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/msgpack/__init__.py =====
import os
from .exceptions import *  # noqa: F403
from .ext import ExtType, Timestamp
version = (1, 1, 1)
__version__ = "1.1.1"
if os.environ.get("MSGPACK_PUREPYTHON"):
    from .fallback import Packer, Unpacker, unpackb
else:
    try:
        from ._cmsgpack import Packer, Unpacker, unpackb
    except ImportError:
        from .fallback import Packer, Unpacker, unpackb
def pack(o, stream, **kwargs):
    """
    Pack object `o` and write it to `stream`
    See :class:`Packer` for options.
    """
    packer = Packer(**kwargs)
    stream.write(packer.pack(o))
def packb(o, **kwargs):
    """
    Pack object `o` and return packed bytes
    See :class:`Packer` for options.
    """
    return Packer(**kwargs).pack(o)
def unpack(stream, **kwargs):
    """
    Unpack an object from `stream`.
    Raises `ExtraData` when `stream` contains extra bytes.
    See :class:`Unpacker` for options.
    """
    data = stream.read()
    return unpackb(data, **kwargs)
load = unpack
loads = unpackb
dump = pack
dumps = packb
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/msgpack/exceptions.py =====
class UnpackException(Exception):
    """Base class for some exceptions raised while unpacking.
    NOTE: unpack may raise exception other than subclass of
    UnpackException.  If you want to catch all error, catch
    Exception instead.
    """
class BufferFull(UnpackException):
    pass
class OutOfData(UnpackException):
    pass
class FormatError(ValueError, UnpackException):
    """Invalid msgpack format"""
class StackError(ValueError, UnpackException):
    """Too nested"""
UnpackValueError = ValueError
class ExtraData(UnpackValueError):
    """ExtraData is raised when there is trailing data.
    This exception is raised while only one-shot (not streaming)
    unpack.
    """
    def __init__(self, unpacked, extra):
        self.unpacked = unpacked
        self.extra = extra
    def __str__(self):
        return "unpack(b) received extra data."
PackException = Exception
PackValueError = ValueError
PackOverflowError = OverflowError
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/msgpack/fallback.py =====
"""Fallback pure Python implementation of msgpack"""
import struct
import sys
from datetime import datetime as _DateTime
if hasattr(sys, "pypy_version_info"):
    from __pypy__ import newlist_hint
    from __pypy__.builders import BytesBuilder
    _USING_STRINGBUILDER = True
    class BytesIO:
        def __init__(self, s=b""):
            if s:
                self.builder = BytesBuilder(len(s))
                self.builder.append(s)
            else:
                self.builder = BytesBuilder()
        def write(self, s):
            if isinstance(s, memoryview):
                s = s.tobytes()
            elif isinstance(s, bytearray):
                s = bytes(s)
            self.builder.append(s)
        def getvalue(self):
            return self.builder.build()
else:
    from io import BytesIO
    _USING_STRINGBUILDER = False
    def newlist_hint(size):
        return []
from .exceptions import BufferFull, ExtraData, FormatError, OutOfData, StackError
from .ext import ExtType, Timestamp
EX_SKIP = 0
EX_CONSTRUCT = 1
EX_READ_ARRAY_HEADER = 2
EX_READ_MAP_HEADER = 3
TYPE_IMMEDIATE = 0
TYPE_ARRAY = 1
TYPE_MAP = 2
TYPE_RAW = 3
TYPE_BIN = 4
TYPE_EXT = 5
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/msgpack/ext.py =====
import datetime
import struct
from collections import namedtuple
class ExtType(namedtuple("ExtType", "code data")):
    """ExtType represents ext type in msgpack."""
    def __new__(cls, code, data):
        if not isinstance(code, int):
            raise TypeError("code must be int")
        if not isinstance(data, bytes):
            raise TypeError("data must be bytes")
        if not 0 <= code <= 127:
            raise ValueError("code must be 0~127")
        return super().__new__(cls, code, data)
class Timestamp:
    """Timestamp represents the Timestamp extension type in msgpack.
    When built with Cython, msgpack uses C methods to pack and unpack `Timestamp`.
    When using pure-Python msgpack, :func:`to_bytes` and :func:`from_bytes` are used to pack and
    unpack `Timestamp`.
    This class is immutable: Do not override seconds and nanoseconds.
    """
    __slots__ = ["seconds", "nanoseconds"]
    def __init__(self, seconds, nanoseconds=0):
        """Initialize a Timestamp object.
        :param int seconds:
            Number of seconds since the UNIX epoch (00:00:00 UTC Jan 1 1970, minus leap seconds).
            May be negative.
        :param int nanoseconds:
            Number of nanoseconds to add to `seconds` to get fractional time.
            Maximum is 999_999_999.  Default is 0.
        Note: Negative times (before the UNIX epoch) are represented as neg. seconds + pos. ns.
        """
        if not isinstance(seconds, int):
            raise TypeError("seconds must be an integer")
        if not isinstance(nanoseconds, int):
            raise TypeError("nanoseconds must be an integer")
        if not (0 <= nanoseconds < 10**9):
            raise ValueError("nanoseconds must be a non-negative integer less than 999999999.")
        self.seconds = seconds
        self.nanoseconds = nanoseconds
    def __repr__(self):
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/dependency_groups/_lint_dependency_groups.py =====
from __future__ import annotations
import argparse
import sys
from ._implementation import DependencyGroupResolver
from ._toml_compat import tomllib
def main(*, argv: list[str] | None = None) -> None:
    if tomllib is None:
        print(
            "Usage error: dependency-groups CLI requires tomli or Python 3.11+",
            file=sys.stderr,
        )
        raise SystemExit(2)
    parser = argparse.ArgumentParser(
        description=(
            "Lint Dependency Groups for validity. "
            "This will eagerly load and check all of your Dependency Groups."
        )
    )
    parser.add_argument(
        "-f",
        "--pyproject-file",
        default="pyproject.toml",
        help="The pyproject.toml file. Defaults to trying in the current directory.",
    )
    args = parser.parse_args(argv if argv is not None else sys.argv[1:])
    with open(args.pyproject_file, "rb") as fp:
        pyproject = tomllib.load(fp)
    dependency_groups_raw = pyproject.get("dependency-groups", {})
    errors: list[str] = []
    try:
        resolver = DependencyGroupResolver(dependency_groups_raw)
    except (ValueError, TypeError) as e:
        errors.append(f"{type(e).__name__}: {e}")
    else:
        for groupname in resolver.dependency_groups:
            try:
                resolver.resolve(groupname)
            except (LookupError, ValueError, TypeError) as e:
                errors.append(f"{type(e).__name__}: {e}")
    if errors:
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/dependency_groups/__init__.py =====
from ._implementation import (
    CyclicDependencyError,
    DependencyGroupInclude,
    DependencyGroupResolver,
    resolve,
)
__all__ = (
    "CyclicDependencyError",
    "DependencyGroupInclude",
    "DependencyGroupResolver",
    "resolve",
)
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/dependency_groups/_pip_wrapper.py =====
from __future__ import annotations
import argparse
import subprocess
import sys
from ._implementation import DependencyGroupResolver
from ._toml_compat import tomllib
def _invoke_pip(deps: list[str]) -> None:
    subprocess.check_call([sys.executable, "-m", "pip", "install", *deps])
def main(*, argv: list[str] | None = None) -> None:
    if tomllib is None:
        print(
            "Usage error: dependency-groups CLI requires tomli or Python 3.11+",
            file=sys.stderr,
        )
        raise SystemExit(2)
    parser = argparse.ArgumentParser(description="Install Dependency Groups.")
    parser.add_argument(
        "DEPENDENCY_GROUP", nargs="+", help="The dependency groups to install."
    )
    parser.add_argument(
        "-f",
        "--pyproject-file",
        default="pyproject.toml",
        help="The pyproject.toml file. Defaults to trying in the current directory.",
    )
    args = parser.parse_args(argv if argv is not None else sys.argv[1:])
    with open(args.pyproject_file, "rb") as fp:
        pyproject = tomllib.load(fp)
    dependency_groups_raw = pyproject.get("dependency-groups", {})
    errors: list[str] = []
    resolved: list[str] = []
    try:
        resolver = DependencyGroupResolver(dependency_groups_raw)
    except (ValueError, TypeError) as e:
        errors.append(f"{type(e).__name__}: {e}")
    else:
        for groupname in args.DEPENDENCY_GROUP:
            try:
                resolved.extend(str(r) for r in resolver.resolve(groupname))
            except (LookupError, ValueError, TypeError) as e:
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/dependency_groups/_implementation.py =====
from __future__ import annotations
import dataclasses
import re
from collections.abc import Mapping
from pip._vendor.packaging.requirements import Requirement
def _normalize_name(name: str) -> str:
    return re.sub(r"[-_.]+", "-", name).lower()
def _normalize_group_names(
    dependency_groups: Mapping[str, str | Mapping[str, str]],
) -> Mapping[str, str | Mapping[str, str]]:
    original_names: dict[str, list[str]] = {}
    normalized_groups = {}
    for group_name, value in dependency_groups.items():
        normed_group_name = _normalize_name(group_name)
        original_names.setdefault(normed_group_name, []).append(group_name)
        normalized_groups[normed_group_name] = value
    errors = []
    for normed_name, names in original_names.items():
        if len(names) > 1:
            errors.append(f"{normed_name} ({', '.join(names)})")
    if errors:
        raise ValueError(f"Duplicate dependency group names: {', '.join(errors)}")
    return normalized_groups
@dataclasses.dataclass
class DependencyGroupInclude:
    include_group: str
class CyclicDependencyError(ValueError):
    """
    An error representing the detection of a cycle.
    """
    def __init__(self, requested_group: str, group: str, include_group: str) -> None:
        self.requested_group = requested_group
        self.group = group
        self.include_group = include_group
        if include_group == group:
            reason = f"{group} includes itself"
        else:
            reason = f"{include_group} -> {group}, {group} -> {include_group}"
        super().__init__(
            "Cyclic dependency group include while resolving "
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/dependency_groups/_toml_compat.py =====
try:
    import tomllib
except ImportError:
    try:
        from pip._vendor import tomli as tomllib  # type: ignore[no-redef, unused-ignore]
    except ModuleNotFoundError:  # pragma: no cover
        tomllib = None  # type: ignore[assignment, unused-ignore]
__all__ = ("tomllib",)
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/dependency_groups/__main__.py =====
import argparse
import sys
from ._implementation import resolve
from ._toml_compat import tomllib
def main() -> None:
    if tomllib is None:
        print(
            "Usage error: dependency-groups CLI requires tomli or Python 3.11+",
            file=sys.stderr,
        )
        raise SystemExit(2)
    parser = argparse.ArgumentParser(
        description=(
            "A dependency-groups CLI. Prints out a resolved group, newline-delimited."
        )
    )
    parser.add_argument(
        "GROUP_NAME", nargs="*", help="The dependency group(s) to resolve."
    )
    parser.add_argument(
        "-f",
        "--pyproject-file",
        default="pyproject.toml",
        help="The pyproject.toml file. Defaults to trying in the current directory.",
    )
    parser.add_argument(
        "-o",
        "--output",
        help="An output file. Defaults to stdout.",
    )
    parser.add_argument(
        "-l",
        "--list",
        action="store_true",
        help="List the available dependency groups",
    )
    args = parser.parse_args()
    with open(args.pyproject_file, "rb") as fp:
        pyproject = tomllib.load(fp)
    dependency_groups_raw = pyproject.get("dependency-groups", {})
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/pygments/filters/__init__.py =====
"""
    pygments.filters
    ~~~~~~~~~~~~~~~~
    Module containing filter lookup functions and default
    filters.
    :copyright: Copyright 2006-2025 by the Pygments team, see AUTHORS.
    :license: BSD, see LICENSE for details.
"""
import re
from pip._vendor.pygments.token import String, Comment, Keyword, Name, Error, Whitespace, \
    string_to_tokentype
from pip._vendor.pygments.filter import Filter
from pip._vendor.pygments.util import get_list_opt, get_int_opt, get_bool_opt, \
    get_choice_opt, ClassNotFound, OptionError
from pip._vendor.pygments.plugin import find_plugin_filters
def find_filter_class(filtername):
    """Lookup a filter by name. Return None if not found."""
    if filtername in FILTERS:
        return FILTERS[filtername]
    for name, cls in find_plugin_filters():
        if name == filtername:
            return cls
    return None
def get_filter_by_name(filtername, **options):
    """Return an instantiated filter.
    Options are passed to the filter initializer if wanted.
    Raise a ClassNotFound if not found.
    """
    cls = find_filter_class(filtername)
    if cls:
        return cls(**options)
    else:
        raise ClassNotFound(f'filter {filtername!r} not found')
def get_all_filters():
    """Return a generator of all filter names."""
    yield from FILTERS
    for name, _ in find_plugin_filters():
        yield name
def _replace_special(ttype, value, regex, specialttype,
                     replacefunc=lambda x: x):
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/pygments/modeline.py =====
"""
    pygments.modeline
    ~~~~~~~~~~~~~~~~~
    A simple modeline parser (based on pymodeline).
    :copyright: Copyright 2006-2025 by the Pygments team, see AUTHORS.
    :license: BSD, see LICENSE for details.
"""
import re
__all__ = ['get_filetype_from_buffer']
modeline_re = re.compile(r'''
    (?: vi | vim | ex ) (?: [<=>]? \d* )? :
    .* (?: ft | filetype | syn | syntax ) = ( [^:\s]+ )
''', re.VERBOSE)
def get_filetype_from_line(l): # noqa: E741
    m = modeline_re.search(l)
    if m:
        return m.group(1)
def get_filetype_from_buffer(buf, max_lines=5):
    """
    Scan the buffer for modelines and return filetype if one is found.
    """
    lines = buf.splitlines()
    for line in lines[-1:-max_lines-1:-1]:
        ret = get_filetype_from_line(line)
        if ret:
            return ret
    for i in range(max_lines, -1, -1):
        if i < len(lines):
            ret = get_filetype_from_line(lines[i])
            if ret:
                return ret
    return None
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/pygments/console.py =====
"""
    pygments.console
    ~~~~~~~~~~~~~~~~
    Format colored console output.
    :copyright: Copyright 2006-2025 by the Pygments team, see AUTHORS.
    :license: BSD, see LICENSE for details.
"""
esc = "\x1b["
codes = {}
codes[""] = ""
codes["reset"] = esc + "39;49;00m"
codes["bold"] = esc + "01m"
codes["faint"] = esc + "02m"
codes["standout"] = esc + "03m"
codes["underline"] = esc + "04m"
codes["blink"] = esc + "05m"
codes["overline"] = esc + "06m"
dark_colors = ["black", "red", "green", "yellow", "blue",
               "magenta", "cyan", "gray"]
light_colors = ["brightblack", "brightred", "brightgreen", "brightyellow", "brightblue",
                "brightmagenta", "brightcyan", "white"]
x = 30
for dark, light in zip(dark_colors, light_colors):
    codes[dark] = esc + "%im" % x
    codes[light] = esc + "%im" % (60 + x)
    x += 1
del dark, light, x
codes["white"] = codes["bold"]
def reset_color():
    return codes["reset"]
def colorize(color_key, text):
    return codes[color_key] + text + codes["reset"]
def ansiformat(attr, text):
    """
    Format ``text`` with a color and/or some attributes::
        color       normal color
        *color*     bold color
        _color_     underlined color
        +color+     blinking color
    """
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/pygments/scanner.py =====
"""
    pygments.scanner
    ~~~~~~~~~~~~~~~~
    This library implements a regex based scanner. Some languages
    like Pascal are easy to parse but have some keywords that
    depend on the context. Because of this it's impossible to lex
    that just by using a regular expression lexer like the
    `RegexLexer`.
    Have a look at the `DelphiLexer` to get an idea of how to use
    this scanner.
    :copyright: Copyright 2006-2025 by the Pygments team, see AUTHORS.
    :license: BSD, see LICENSE for details.
"""
import re
class EndOfText(RuntimeError):
    """
    Raise if end of text is reached and the user
    tried to call a match function.
    """
class Scanner:
    """
    Simple scanner
    All method patterns are regular expression strings (not
    compiled expressions!)
    """
    def __init__(self, text, flags=0):
        """
        :param text:    The text which should be scanned
        :param flags:   default regular expression flags
        """
        self.data = text
        self.data_length = len(text)
        self.start_pos = 0
        self.pos = 0
        self.flags = flags
        self.last = None
        self.match = None
        self._re_cache = {}
    def eos(self):
        """`True` if the scanner reached the end of text."""
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/pygments/formatter.py =====
"""
    pygments.formatter
    ~~~~~~~~~~~~~~~~~~
    Base formatter class.
    :copyright: Copyright 2006-2025 by the Pygments team, see AUTHORS.
    :license: BSD, see LICENSE for details.
"""
import codecs
from pip._vendor.pygments.util import get_bool_opt
from pip._vendor.pygments.styles import get_style_by_name
__all__ = ['Formatter']
def _lookup_style(style):
    if isinstance(style, str):
        return get_style_by_name(style)
    return style
class Formatter:
    """
    Converts a token stream to text.
    Formatters should have attributes to help selecting them. These
    are similar to the corresponding :class:`~pygments.lexer.Lexer`
    attributes.
    .. autoattribute:: name
       :no-value:
    .. autoattribute:: aliases
       :no-value:
    .. autoattribute:: filenames
       :no-value:
    You can pass options as keyword arguments to the constructor.
    All formatters accept these basic options:
    ``style``
        The style to use, can be a string or a Style subclass
        (default: "default"). Not used by e.g. the
        TerminalFormatter.
    ``full``
        Tells the formatter to output a "full" document, i.e.
        a complete self-contained document. This doesn't have
        any effect for some formatters (default: false).
    ``title``
        If ``full`` is true, the title that should be used to
        caption the document (default: '').
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/pygments/lexers/__init__.py =====
"""
    pygments.lexers
    ~~~~~~~~~~~~~~~
    Pygments lexers.
    :copyright: Copyright 2006-2025 by the Pygments team, see AUTHORS.
    :license: BSD, see LICENSE for details.
"""
import re
import sys
import types
import fnmatch
from os.path import basename
from pip._vendor.pygments.lexers._mapping import LEXERS
from pip._vendor.pygments.modeline import get_filetype_from_buffer
from pip._vendor.pygments.plugin import find_plugin_lexers
from pip._vendor.pygments.util import ClassNotFound, guess_decode
COMPAT = {
    'Python3Lexer': 'PythonLexer',
    'Python3TracebackLexer': 'PythonTracebackLexer',
    'LeanLexer': 'Lean3Lexer',
}
__all__ = ['get_lexer_by_name', 'get_lexer_for_filename', 'find_lexer_class',
           'guess_lexer', 'load_lexer_from_file'] + list(LEXERS) + list(COMPAT)
_lexer_cache = {}
_pattern_cache = {}
def _fn_matches(fn, glob):
    """Return whether the supplied file name fn matches pattern filename."""
    if glob not in _pattern_cache:
        pattern = _pattern_cache[glob] = re.compile(fnmatch.translate(glob))
        return pattern.match(fn)
    return _pattern_cache[glob].match(fn)
def _load_lexers(module_name):
    """Load a lexer (and all others in the module too)."""
    mod = __import__(module_name, None, None, ['__all__'])
    for lexer_name in mod.__all__:
        cls = getattr(mod, lexer_name)
        _lexer_cache[cls.name] = cls
def get_all_lexers(plugins=True):
    """Return a generator of tuples in the form ``(name, aliases,
    filenames, mimetypes)`` of all know lexers.
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/pygments/lexers/python.py =====
"""
    pygments.lexers.python
    ~~~~~~~~~~~~~~~~~~~~~~
    Lexers for Python and related languages.
    :copyright: Copyright 2006-2025 by the Pygments team, see AUTHORS.
    :license: BSD, see LICENSE for details.
"""
import keyword
from pip._vendor.pygments.lexer import DelegatingLexer, RegexLexer, include, \
    bygroups, using, default, words, combined, this
from pip._vendor.pygments.util import get_bool_opt, shebang_matches
from pip._vendor.pygments.token import Text, Comment, Operator, Keyword, Name, String, \
    Number, Punctuation, Generic, Other, Error, Whitespace
from pip._vendor.pygments import unistring as uni
__all__ = ['PythonLexer', 'PythonConsoleLexer', 'PythonTracebackLexer',
           'Python2Lexer', 'Python2TracebackLexer',
           'CythonLexer', 'DgLexer', 'NumPyLexer']
class PythonLexer(RegexLexer):
    """
    For Python source code (version 3.x).
    .. versionchanged:: 2.5
       This is now the default ``PythonLexer``.  It is still available as the
       alias ``Python3Lexer``.
    """
    name = 'Python'
    url = 'https://www.python.org'
    aliases = ['python', 'py', 'sage', 'python3', 'py3', 'bazel', 'starlark', 'pyi']
    filenames = [
        '*.py',
        '*.pyw',
        # Type stubs
        '*.pyi',
        # Jython
        '*.jy',
        # Sage
        '*.sage',
        # SCons
        '*.sc',
        'SConstruct',
        'SConscript',
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/pygments/lexers/_mapping.py =====
LEXERS = {
    'ABAPLexer': ('pip._vendor.pygments.lexers.business', 'ABAP', ('abap',), ('*.abap', '*.ABAP'), ('text/x-abap',)),
    'AMDGPULexer': ('pip._vendor.pygments.lexers.amdgpu', 'AMDGPU', ('amdgpu',), ('*.isa',), ()),
    'APLLexer': ('pip._vendor.pygments.lexers.apl', 'APL', ('apl',), ('*.apl', '*.aplf', '*.aplo', '*.apln', '*.aplc', '*.apli', '*.dyalog'), ()),
    'AbnfLexer': ('pip._vendor.pygments.lexers.grammar_notation', 'ABNF', ('abnf',), ('*.abnf',), ('text/x-abnf',)),
    'ActionScript3Lexer': ('pip._vendor.pygments.lexers.actionscript', 'ActionScript 3', ('actionscript3', 'as3'), ('*.as',), ('application/x-actionscript3', 'text/x-actionscript3', 'text/actionscript3')),
    'ActionScriptLexer': ('pip._vendor.pygments.lexers.actionscript', 'ActionScript', ('actionscript', 'as'), ('*.as',), ('application/x-actionscript', 'text/x-actionscript', 'text/actionscript')),
    'AdaLexer': ('pip._vendor.pygments.lexers.ada', 'Ada', ('ada', 'ada95', 'ada2005'), ('*.adb', '*.ads', '*.ada'), ('text/x-ada',)),
    'AdlLexer': ('pip._vendor.pygments.lexers.archetype', 'ADL', ('adl',), ('*.adl', '*.adls', '*.adlf', '*.adlx'), ()),
    'AgdaLexer': ('pip._vendor.pygments.lexers.haskell', 'Agda', ('agda',), ('*.agda',), ('text/x-agda',)),
    'AheuiLexer': ('pip._vendor.pygments.lexers.esoteric', 'Aheui', ('aheui',), ('*.aheui',), ()),
    'AlloyLexer': ('pip._vendor.pygments.lexers.dsls', 'Alloy', ('alloy',), ('*.als',), ('text/x-alloy',)),
    'AmbientTalkLexer': ('pip._vendor.pygments.lexers.ambient', 'AmbientTalk', ('ambienttalk', 'ambienttalk/2', 'at'), ('*.at',), ('text/x-ambienttalk',)),
    'AmplLexer': ('pip._vendor.pygments.lexers.ampl', 'Ampl', ('ampl',), ('*.run',), ()),
    'Angular2HtmlLexer': ('pip._vendor.pygments.lexers.templates', 'HTML + Angular2', ('html+ng2',), ('*.ng2',), ()),
    'Angular2Lexer': ('pip._vendor.pygments.lexers.templates', 'Angular2', ('ng2',), (), ()),
    'AntlrActionScriptLexer': ('pip._vendor.pygments.lexers.parsers', 'ANTLR With ActionScript Target', ('antlr-actionscript', 'antlr-as'), ('*.G', '*.g'), ()),
    'AntlrCSharpLexer': ('pip._vendor.pygments.lexers.parsers', 'ANTLR With C# Target', ('antlr-csharp', 'antlr-c#'), ('*.G', '*.g'), ()),
    'AntlrCppLexer': ('pip._vendor.pygments.lexers.parsers', 'ANTLR With CPP Target', ('antlr-cpp',), ('*.G', '*.g'), ()),
    'AntlrJavaLexer': ('pip._vendor.pygments.lexers.parsers', 'ANTLR With Java Target', ('antlr-java',), ('*.G', '*.g'), ()),
    'AntlrLexer': ('pip._vendor.pygments.lexers.parsers', 'ANTLR', ('antlr',), (), ()),
    'AntlrObjectiveCLexer': ('pip._vendor.pygments.lexers.parsers', 'ANTLR With ObjectiveC Target', ('antlr-objc',), ('*.G', '*.g'), ()),
    'AntlrPerlLexer': ('pip._vendor.pygments.lexers.parsers', 'ANTLR With Perl Target', ('antlr-perl',), ('*.G', '*.g'), ()),
    'AntlrPythonLexer': ('pip._vendor.pygments.lexers.parsers', 'ANTLR With Python Target', ('antlr-python',), ('*.G', '*.g'), ()),
    'AntlrRubyLexer': ('pip._vendor.pygments.lexers.parsers', 'ANTLR With Ruby Target', ('antlr-ruby', 'antlr-rb'), ('*.G', '*.g'), ()),
    'ApacheConfLexer': ('pip._vendor.pygments.lexers.configs', 'ApacheConf', ('apacheconf', 'aconf', 'apache'), ('.htaccess', 'apache.conf', 'apache2.conf'), ('text/x-apacheconf',)),
    'AppleScriptLexer': ('pip._vendor.pygments.lexers.scripting', 'AppleScript', ('applescript',), ('*.applescript',), ()),
    'ArduinoLexer': ('pip._vendor.pygments.lexers.c_like', 'Arduino', ('arduino',), ('*.ino',), ('text/x-arduino',)),
    'ArrowLexer': ('pip._vendor.pygments.lexers.arrow', 'Arrow', ('arrow',), ('*.arw',), ()),
    'ArturoLexer': ('pip._vendor.pygments.lexers.arturo', 'Arturo', ('arturo', 'art'), ('*.art',), ()),
    'AscLexer': ('pip._vendor.pygments.lexers.asc', 'ASCII armored', ('asc', 'pem'), ('*.asc', '*.pem', 'id_dsa', 'id_ecdsa', 'id_ecdsa_sk', 'id_ed25519', 'id_ed25519_sk', 'id_rsa'), ('application/pgp-keys', 'application/pgp-encrypted', 'application/pgp-signature', 'application/pem-certificate-chain')),
    'Asn1Lexer': ('pip._vendor.pygments.lexers.asn1', 'ASN.1', ('asn1',), ('*.asn1',), ()),
    'AspectJLexer': ('pip._vendor.pygments.lexers.jvm', 'AspectJ', ('aspectj',), ('*.aj',), ('text/x-aspectj',)),
    'AsymptoteLexer': ('pip._vendor.pygments.lexers.graphics', 'Asymptote', ('asymptote', 'asy'), ('*.asy',), ('text/x-asymptote',)),
    'AugeasLexer': ('pip._vendor.pygments.lexers.configs', 'Augeas', ('augeas',), ('*.aug',), ()),
    'AutoItLexer': ('pip._vendor.pygments.lexers.automation', 'AutoIt', ('autoit',), ('*.au3',), ('text/x-autoit',)),
    'AutohotkeyLexer': ('pip._vendor.pygments.lexers.automation', 'autohotkey', ('autohotkey', 'ahk'), ('*.ahk', '*.ahkl'), ('text/x-autohotkey',)),
    'AwkLexer': ('pip._vendor.pygments.lexers.textedit', 'Awk', ('awk', 'gawk', 'mawk', 'nawk'), ('*.awk',), ('application/x-awk',)),
    'BBCBasicLexer': ('pip._vendor.pygments.lexers.basic', 'BBC Basic', ('bbcbasic',), ('*.bbc',), ()),
    'BBCodeLexer': ('pip._vendor.pygments.lexers.markup', 'BBCode', ('bbcode',), (), ('text/x-bbcode',)),
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/pygments/token.py =====
"""
    pygments.token
    ~~~~~~~~~~~~~~
    Basic token types and the standard tokens.
    :copyright: Copyright 2006-2025 by the Pygments team, see AUTHORS.
    :license: BSD, see LICENSE for details.
"""
class _TokenType(tuple):
    parent = None
    def split(self):
        buf = []
        node = self
        while node is not None:
            buf.append(node)
            node = node.parent
        buf.reverse()
        return buf
    def __init__(self, *args):
        # no need to call super.__init__
        self.subtypes = set()
    def __contains__(self, val):
        return self is val or (
            type(val) is self.__class__ and
            val[:len(self)] == self
        )
    def __getattr__(self, val):
        if not val or not val[0].isupper():
            return tuple.__getattribute__(self, val)
        new = _TokenType(self + (val,))
        setattr(self, val, new)
        self.subtypes.add(new)
        new.parent = self
        return new
    def __repr__(self):
        return 'Token' + (self and '.' or '') + '.'.join(self)
    def __copy__(self):
        # These instances are supposed to be singletons
        return self
    def __deepcopy__(self, memo):
        # These instances are supposed to be singletons
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/pygments/style.py =====
"""
    pygments.style
    ~~~~~~~~~~~~~~
    Basic style object.
    :copyright: Copyright 2006-2025 by the Pygments team, see AUTHORS.
    :license: BSD, see LICENSE for details.
"""
from pip._vendor.pygments.token import Token, STANDARD_TYPES
_ansimap = {
    # dark
    'ansiblack': '000000',
    'ansired': '7f0000',
    'ansigreen': '007f00',
    'ansiyellow': '7f7fe0',
    'ansiblue': '00007f',
    'ansimagenta': '7f007f',
    'ansicyan': '007f7f',
    'ansigray': 'e5e5e5',
    # normal
    'ansibrightblack': '555555',
    'ansibrightred': 'ff0000',
    'ansibrightgreen': '00ff00',
    'ansibrightyellow': 'ffff00',
    'ansibrightblue': '0000ff',
    'ansibrightmagenta': 'ff00ff',
    'ansibrightcyan': '00ffff',
    'ansiwhite': 'ffffff',
}
_deprecated_ansicolors = {
    # dark
    '#ansiblack': 'ansiblack',
    '#ansidarkred': 'ansired',
    '#ansidarkgreen': 'ansigreen',
    '#ansibrown': 'ansiyellow',
    '#ansidarkblue': 'ansiblue',
    '#ansipurple': 'ansimagenta',
    '#ansiteal': 'ansicyan',
    '#ansilightgray': 'ansigray',
    # normal
    '#ansidarkgray': 'ansibrightblack',
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/pygments/util.py =====
"""
    pygments.util
    ~~~~~~~~~~~~~
    Utility functions.
    :copyright: Copyright 2006-2025 by the Pygments team, see AUTHORS.
    :license: BSD, see LICENSE for details.
"""
import re
from io import TextIOWrapper
split_path_re = re.compile(r'[/\\ ]')
doctype_lookup_re = re.compile(r'''
    <!DOCTYPE\s+(
     [a-zA-Z_][a-zA-Z0-9]*
     (?: \s+      # optional in HTML5
     [a-zA-Z_][a-zA-Z0-9]*\s+
     "[^"]*")?
     )
     [^>]*>
''', re.DOTALL | re.MULTILINE | re.VERBOSE)
tag_re = re.compile(r'<(.+?)(\s.*?)?>.*?</.+?>',
                    re.IGNORECASE | re.DOTALL | re.MULTILINE)
xml_decl_re = re.compile(r'\s*<\?xml[^>]*\?>', re.I)
class ClassNotFound(ValueError):
    """Raised if one of the lookup functions didn't find a matching class."""
class OptionError(Exception):
    """
    This exception will be raised by all option processing functions if
    the type or value of the argument is not correct.
    """
def get_choice_opt(options, optname, allowed, default=None, normcase=False):
    """
    If the key `optname` from the dictionary is not in the sequence
    `allowed`, raise an error, otherwise return it.
    """
    string = options.get(optname, default)
    if normcase:
        string = string.lower()
    if string not in allowed:
        raise OptionError('Value for option {} must be one of {}'.format(optname, ', '.join(map(str, allowed))))
    return string
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/pygments/sphinxext.py =====
"""
    pygments.sphinxext
    ~~~~~~~~~~~~~~~~~~
    Sphinx extension to generate automatic documentation of lexers,
    formatters and filters.
    :copyright: Copyright 2006-2025 by the Pygments team, see AUTHORS.
    :license: BSD, see LICENSE for details.
"""
import sys
from docutils import nodes
from docutils.statemachine import ViewList
from docutils.parsers.rst import Directive
from sphinx.util.nodes import nested_parse_with_titles
MODULEDOC = '''
.. module:: %s
%s
%s
'''
LEXERDOC = '''
.. class:: %s
    :Short names: %s
    :Filenames:   %s
    :MIME types:  %s
    %s
    %s
'''
FMTERDOC = '''
.. class:: %s
    :Short names: %s
    :Filenames: %s
    %s
'''
FILTERDOC = '''
.. class:: %s
    :Name: %s
    %s
'''
class PygmentsDoc(Directive):
    """
    A directive to collect all lexers/formatters/filters and generate
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/pygments/__init__.py =====
"""
    Pygments
    ~~~~~~~~
    Pygments is a syntax highlighting package written in Python.
    It is a generic syntax highlighter for general use in all kinds of software
    such as forum systems, wikis or other applications that need to prettify
    source code. Highlights are:
    * a wide range of common languages and markup formats is supported
    * special attention is paid to details, increasing quality by a fair amount
    * support for new languages and formats are added easily
    * a number of output formats, presently HTML, LaTeX, RTF, SVG, all image
      formats that PIL supports, and ANSI sequences
    * it is usable as a command-line tool and as a library
    * ... and it highlights even Brainfuck!
    The `Pygments master branch`_ is installable with ``easy_install Pygments==dev``.
    .. _Pygments master branch:
       https://github.com/pygments/pygments/archive/master.zip#egg=Pygments-dev
    :copyright: Copyright 2006-2025 by the Pygments team, see AUTHORS.
    :license: BSD, see LICENSE for details.
"""
from io import StringIO, BytesIO
__version__ = '2.19.2'
__docformat__ = 'restructuredtext'
__all__ = ['lex', 'format', 'highlight']
def lex(code, lexer):
    """
    Lex `code` with the `lexer` (must be a `Lexer` instance)
    and return an iterable of tokens. Currently, this only calls
    `lexer.get_tokens()`.
    """
    try:
        return lexer.get_tokens(code)
    except TypeError:
        # Heuristic to catch a common mistake.
        from pip._vendor.pygments.lexer import RegexLexer
        if isinstance(lexer, type) and issubclass(lexer, RegexLexer):
            raise TypeError('lex() argument must be a lexer instance, '
                            'not a class')
        raise
def format(tokens, formatter, outfile=None):  # pylint: disable=redefined-builtin
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/pygments/formatters/__init__.py =====
"""
    pygments.formatters
    ~~~~~~~~~~~~~~~~~~~
    Pygments formatters.
    :copyright: Copyright 2006-2025 by the Pygments team, see AUTHORS.
    :license: BSD, see LICENSE for details.
"""
import re
import sys
import types
import fnmatch
from os.path import basename
from pip._vendor.pygments.formatters._mapping import FORMATTERS
from pip._vendor.pygments.plugin import find_plugin_formatters
from pip._vendor.pygments.util import ClassNotFound
__all__ = ['get_formatter_by_name', 'get_formatter_for_filename',
           'get_all_formatters', 'load_formatter_from_file'] + list(FORMATTERS)
_formatter_cache = {}  # classes by name
_pattern_cache = {}
def _fn_matches(fn, glob):
    """Return whether the supplied file name fn matches pattern filename."""
    if glob not in _pattern_cache:
        pattern = _pattern_cache[glob] = re.compile(fnmatch.translate(glob))
        return pattern.match(fn)
    return _pattern_cache[glob].match(fn)
def _load_formatters(module_name):
    """Load a formatter (and all others in the module too)."""
    mod = __import__(module_name, None, None, ['__all__'])
    for formatter_name in mod.__all__:
        cls = getattr(mod, formatter_name)
        _formatter_cache[cls.name] = cls
def get_all_formatters():
    """Return a generator for all formatter classes."""
    # NB: this returns formatter classes, not info like get_all_lexers().
    for info in FORMATTERS.values():
        if info[1] not in _formatter_cache:
            _load_formatters(info[0])
        yield _formatter_cache[info[1]]
    for _, formatter in find_plugin_formatters():
        yield formatter
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/pygments/formatters/_mapping.py =====
FORMATTERS = {
    'BBCodeFormatter': ('pygments.formatters.bbcode', 'BBCode', ('bbcode', 'bb'), (), 'Format tokens with BBcodes. These formatting codes are used by many bulletin boards, so you can highlight your sourcecode with pygments before posting it there.'),
    'BmpImageFormatter': ('pygments.formatters.img', 'img_bmp', ('bmp', 'bitmap'), ('*.bmp',), 'Create a bitmap image from source code. This uses the Python Imaging Library to generate a pixmap from the source code.'),
    'GifImageFormatter': ('pygments.formatters.img', 'img_gif', ('gif',), ('*.gif',), 'Create a GIF image from source code. This uses the Python Imaging Library to generate a pixmap from the source code.'),
    'GroffFormatter': ('pygments.formatters.groff', 'groff', ('groff', 'troff', 'roff'), (), 'Format tokens with groff escapes to change their color and font style.'),
    'HtmlFormatter': ('pygments.formatters.html', 'HTML', ('html',), ('*.html', '*.htm'), "Format tokens as HTML 4 ``<span>`` tags. By default, the content is enclosed in a ``<pre>`` tag, itself wrapped in a ``<div>`` tag (but see the `nowrap` option). The ``<div>``'s CSS class can be set by the `cssclass` option."),
    'IRCFormatter': ('pygments.formatters.irc', 'IRC', ('irc', 'IRC'), (), 'Format tokens with IRC color sequences'),
    'ImageFormatter': ('pygments.formatters.img', 'img', ('img', 'IMG', 'png'), ('*.png',), 'Create a PNG image from source code. This uses the Python Imaging Library to generate a pixmap from the source code.'),
    'JpgImageFormatter': ('pygments.formatters.img', 'img_jpg', ('jpg', 'jpeg'), ('*.jpg',), 'Create a JPEG image from source code. This uses the Python Imaging Library to generate a pixmap from the source code.'),
    'LatexFormatter': ('pygments.formatters.latex', 'LaTeX', ('latex', 'tex'), ('*.tex',), 'Format tokens as LaTeX code. This needs the `fancyvrb` and `color` standard packages.'),
    'NullFormatter': ('pygments.formatters.other', 'Text only', ('text', 'null'), ('*.txt',), 'Output the text unchanged without any formatting.'),
    'PangoMarkupFormatter': ('pygments.formatters.pangomarkup', 'Pango Markup', ('pango', 'pangomarkup'), (), 'Format tokens as Pango Markup code. It can then be rendered to an SVG.'),
    'RawTokenFormatter': ('pygments.formatters.other', 'Raw tokens', ('raw', 'tokens'), ('*.raw',), 'Format tokens as a raw representation for storing token streams.'),
    'RtfFormatter': ('pygments.formatters.rtf', 'RTF', ('rtf',), ('*.rtf',), 'Format tokens as RTF markup. This formatter automatically outputs full RTF documents with color information and other useful stuff. Perfect for Copy and Paste into Microsoft(R) Word(R) documents.'),
    'SvgFormatter': ('pygments.formatters.svg', 'SVG', ('svg',), ('*.svg',), 'Format tokens as an SVG graphics file.  This formatter is still experimental. Each line of code is a ``<text>`` element with explicit ``x`` and ``y`` coordinates containing ``<tspan>`` elements with the individual token styles.'),
    'Terminal256Formatter': ('pygments.formatters.terminal256', 'Terminal256', ('terminal256', 'console256', '256'), (), 'Format tokens with ANSI color sequences, for output in a 256-color terminal or console.  Like in `TerminalFormatter` color sequences are terminated at newlines, so that paging the output works correctly.'),
    'TerminalFormatter': ('pygments.formatters.terminal', 'Terminal', ('terminal', 'console'), (), 'Format tokens with ANSI color sequences, for output in a text console. Color sequences are terminated at newlines, so that paging the output works correctly.'),
    'TerminalTrueColorFormatter': ('pygments.formatters.terminal256', 'TerminalTrueColor', ('terminal16m', 'console16m', '16m'), (), 'Format tokens with ANSI color sequences, for output in a true-color terminal or console.  Like in `TerminalFormatter` color sequences are terminated at newlines, so that paging the output works correctly.'),
    'TestcaseFormatter': ('pygments.formatters.other', 'Testcase', ('testcase',), (), 'Format tokens as appropriate for a new testcase.'),
}
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/pygments/styles/__init__.py =====
"""
    pygments.styles
    ~~~~~~~~~~~~~~~
    Contains built-in styles.
    :copyright: Copyright 2006-2025 by the Pygments team, see AUTHORS.
    :license: BSD, see LICENSE for details.
"""
from pip._vendor.pygments.plugin import find_plugin_styles
from pip._vendor.pygments.util import ClassNotFound
from pip._vendor.pygments.styles._mapping import STYLES
STYLE_MAP = {v[1]: v[0].split('.')[-1] + '::' + k for k, v in STYLES.items()}
_STYLE_NAME_TO_MODULE_MAP = {v[1]: (v[0], k) for k, v in STYLES.items()}
def get_style_by_name(name):
    """
    Return a style class by its short name. The names of the builtin styles
    are listed in :data:`pygments.styles.STYLE_MAP`.
    Will raise :exc:`pygments.util.ClassNotFound` if no style of that name is
    found.
    """
    if name in _STYLE_NAME_TO_MODULE_MAP:
        mod, cls = _STYLE_NAME_TO_MODULE_MAP[name]
        builtin = "yes"
    else:
        for found_name, style in find_plugin_styles():
            if name == found_name:
                return style
        # perhaps it got dropped into our styles package
        builtin = ""
        mod = 'pygments.styles.' + name
        cls = name.title() + "Style"
    try:
        mod = __import__(mod, None, None, [cls])
    except ImportError:
        raise ClassNotFound(f"Could not find style module {mod!r}" +
                            (builtin and ", though it should be builtin")
                            + ".")
    try:
        return getattr(mod, cls)
    except AttributeError:
        raise ClassNotFound(f"Could not find style class {cls!r} in style module.")
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/pygments/styles/_mapping.py =====
STYLES = {
    'AbapStyle': ('pygments.styles.abap', 'abap', ()),
    'AlgolStyle': ('pygments.styles.algol', 'algol', ()),
    'Algol_NuStyle': ('pygments.styles.algol_nu', 'algol_nu', ()),
    'ArduinoStyle': ('pygments.styles.arduino', 'arduino', ()),
    'AutumnStyle': ('pygments.styles.autumn', 'autumn', ()),
    'BlackWhiteStyle': ('pygments.styles.bw', 'bw', ()),
    'BorlandStyle': ('pygments.styles.borland', 'borland', ()),
    'CoffeeStyle': ('pygments.styles.coffee', 'coffee', ()),
    'ColorfulStyle': ('pygments.styles.colorful', 'colorful', ()),
    'DefaultStyle': ('pygments.styles.default', 'default', ()),
    'DraculaStyle': ('pygments.styles.dracula', 'dracula', ()),
    'EmacsStyle': ('pygments.styles.emacs', 'emacs', ()),
    'FriendlyGrayscaleStyle': ('pygments.styles.friendly_grayscale', 'friendly_grayscale', ()),
    'FriendlyStyle': ('pygments.styles.friendly', 'friendly', ()),
    'FruityStyle': ('pygments.styles.fruity', 'fruity', ()),
    'GhDarkStyle': ('pygments.styles.gh_dark', 'github-dark', ()),
    'GruvboxDarkStyle': ('pygments.styles.gruvbox', 'gruvbox-dark', ()),
    'GruvboxLightStyle': ('pygments.styles.gruvbox', 'gruvbox-light', ()),
    'IgorStyle': ('pygments.styles.igor', 'igor', ()),
    'InkPotStyle': ('pygments.styles.inkpot', 'inkpot', ()),
    'LightbulbStyle': ('pygments.styles.lightbulb', 'lightbulb', ()),
    'LilyPondStyle': ('pygments.styles.lilypond', 'lilypond', ()),
    'LovelaceStyle': ('pygments.styles.lovelace', 'lovelace', ()),
    'ManniStyle': ('pygments.styles.manni', 'manni', ()),
    'MaterialStyle': ('pygments.styles.material', 'material', ()),
    'MonokaiStyle': ('pygments.styles.monokai', 'monokai', ()),
    'MurphyStyle': ('pygments.styles.murphy', 'murphy', ()),
    'NativeStyle': ('pygments.styles.native', 'native', ()),
    'NordDarkerStyle': ('pygments.styles.nord', 'nord-darker', ()),
    'NordStyle': ('pygments.styles.nord', 'nord', ()),
    'OneDarkStyle': ('pygments.styles.onedark', 'one-dark', ()),
    'ParaisoDarkStyle': ('pygments.styles.paraiso_dark', 'paraiso-dark', ()),
    'ParaisoLightStyle': ('pygments.styles.paraiso_light', 'paraiso-light', ()),
    'PastieStyle': ('pygments.styles.pastie', 'pastie', ()),
    'PerldocStyle': ('pygments.styles.perldoc', 'perldoc', ()),
    'RainbowDashStyle': ('pygments.styles.rainbow_dash', 'rainbow_dash', ()),
    'RrtStyle': ('pygments.styles.rrt', 'rrt', ()),
    'SasStyle': ('pygments.styles.sas', 'sas', ()),
    'SolarizedDarkStyle': ('pygments.styles.solarized', 'solarized-dark', ()),
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/pygments/unistring.py =====
"""
    pygments.unistring
    ~~~~~~~~~~~~~~~~~~
    Strings of all Unicode characters of a certain category.
    Used for matching in Unicode-aware languages. Run to regenerate.
    Inspired by chartypes_create.py from the MoinMoin project.
    :copyright: Copyright 2006-2025 by the Pygments team, see AUTHORS.
    :license: BSD, see LICENSE for details.
"""
Cc = '\x00-\x1f\x7f-\x9f'
Cf = '\xad\u0600-\u0605\u061c\u06dd\u070f\u08e2\u180e\u200b-\u200f\u202a-\u202e\u2060-\u2064\u2066-\u206f\ufeff\ufff9-\ufffb\U000110bd\U000110cd\U0001bca0-\U0001bca3\U0001d173-\U0001d17a\U000e0001\U000e0020-\U000e007f'
Cn = '\u0378-\u0379\u0380-\u0383\u038b\u038d\u03a2\u0530\u0557-\u0558\u058b-\u058c\u0590\u05c8-\u05cf\u05eb-\u05ee\u05f5-\u05ff\u061d\u070e\u074b-\u074c\u07b2-\u07bf\u07fb-\u07fc\u082e-\u082f\u083f\u085c-\u085d\u085f\u086b-\u089f\u08b5\u08be-\u08d2\u0984\u098d-\u098e\u0991-\u0992\u09a9\u09b1\u09b3-\u09b5\u09ba-\u09bb\u09c5-\u09c6\u09c9-\u09ca\u09cf-\u09d6\u09d8-\u09db\u09de\u09e4-\u09e5\u09ff-\u0a00\u0a04\u0a0b-\u0a0e\u0a11-\u0a12\u0a29\u0a31\u0a34\u0a37\u0a3a-\u0a3b\u0a3d\u0a43-\u0a46\u0a49-\u0a4a\u0a4e-\u0a50\u0a52-\u0a58\u0a5d\u0a5f-\u0a65\u0a77-\u0a80\u0a84\u0a8e\u0a92\u0aa9\u0ab1\u0ab4\u0aba-\u0abb\u0ac6\u0aca\u0ace-\u0acf\u0ad1-\u0adf\u0ae4-\u0ae5\u0af2-\u0af8\u0b00\u0b04\u0b0d-\u0b0e\u0b11-\u0b12\u0b29\u0b31\u0b34\u0b3a-\u0b3b\u0b45-\u0b46\u0b49-\u0b4a\u0b4e-\u0b55\u0b58-\u0b5b\u0b5e\u0b64-\u0b65\u0b78-\u0b81\u0b84\u0b8b-\u0b8d\u0b91\u0b96-\u0b98\u0b9b\u0b9d\u0ba0-\u0ba2\u0ba5-\u0ba7\u0bab-\u0bad\u0bba-\u0bbd\u0bc3-\u0bc5\u0bc9\u0bce-\u0bcf\u0bd1-\u0bd6\u0bd8-\u0be5\u0bfb-\u0bff\u0c0d\u0c11\u0c29\u0c3a-\u0c3c\u0c45\u0c49\u0c4e-\u0c54\u0c57\u0c5b-\u0c5f\u0c64-\u0c65\u0c70-\u0c77\u0c8d\u0c91\u0ca9\u0cb4\u0cba-\u0cbb\u0cc5\u0cc9\u0cce-\u0cd4\u0cd7-\u0cdd\u0cdf\u0ce4-\u0ce5\u0cf0\u0cf3-\u0cff\u0d04\u0d0d\u0d11\u0d45\u0d49\u0d50-\u0d53\u0d64-\u0d65\u0d80-\u0d81\u0d84\u0d97-\u0d99\u0db2\u0dbc\u0dbe-\u0dbf\u0dc7-\u0dc9\u0dcb-\u0dce\u0dd5\u0dd7\u0de0-\u0de5\u0df0-\u0df1\u0df5-\u0e00\u0e3b-\u0e3e\u0e5c-\u0e80\u0e83\u0e85-\u0e86\u0e89\u0e8b-\u0e8c\u0e8e-\u0e93\u0e98\u0ea0\u0ea4\u0ea6\u0ea8-\u0ea9\u0eac\u0eba\u0ebe-\u0ebf\u0ec5\u0ec7\u0ece-\u0ecf\u0eda-\u0edb\u0ee0-\u0eff\u0f48\u0f6d-\u0f70\u0f98\u0fbd\u0fcd\u0fdb-\u0fff\u10c6\u10c8-\u10cc\u10ce-\u10cf\u1249\u124e-\u124f\u1257\u1259\u125e-\u125f\u1289\u128e-\u128f\u12b1\u12b6-\u12b7\u12bf\u12c1\u12c6-\u12c7\u12d7\u1311\u1316-\u1317\u135b-\u135c\u137d-\u137f\u139a-\u139f\u13f6-\u13f7\u13fe-\u13ff\u169d-\u169f\u16f9-\u16ff\u170d\u1715-\u171f\u1737-\u173f\u1754-\u175f\u176d\u1771\u1774-\u177f\u17de-\u17df\u17ea-\u17ef\u17fa-\u17ff\u180f\u181a-\u181f\u1879-\u187f\u18ab-\u18af\u18f6-\u18ff\u191f\u192c-\u192f\u193c-\u193f\u1941-\u1943\u196e-\u196f\u1975-\u197f\u19ac-\u19af\u19ca-\u19cf\u19db-\u19dd\u1a1c-\u1a1d\u1a5f\u1a7d-\u1a7e\u1a8a-\u1a8f\u1a9a-\u1a9f\u1aae-\u1aaf\u1abf-\u1aff\u1b4c-\u1b4f\u1b7d-\u1b7f\u1bf4-\u1bfb\u1c38-\u1c3a\u1c4a-\u1c4c\u1c89-\u1c8f\u1cbb-\u1cbc\u1cc8-\u1ccf\u1cfa-\u1cff\u1dfa\u1f16-\u1f17\u1f1e-\u1f1f\u1f46-\u1f47\u1f4e-\u1f4f\u1f58\u1f5a\u1f5c\u1f5e\u1f7e-\u1f7f\u1fb5\u1fc5\u1fd4-\u1fd5\u1fdc\u1ff0-\u1ff1\u1ff5\u1fff\u2065\u2072-\u2073\u208f\u209d-\u209f\u20c0-\u20cf\u20f1-\u20ff\u218c-\u218f\u2427-\u243f\u244b-\u245f\u2b74-\u2b75\u2b96-\u2b97\u2bc9\u2bff\u2c2f\u2c5f\u2cf4-\u2cf8\u2d26\u2d28-\u2d2c\u2d2e-\u2d2f\u2d68-\u2d6e\u2d71-\u2d7e\u2d97-\u2d9f\u2da7\u2daf\u2db7\u2dbf\u2dc7\u2dcf\u2dd7\u2ddf\u2e4f-\u2e7f\u2e9a\u2ef4-\u2eff\u2fd6-\u2fef\u2ffc-\u2fff\u3040\u3097-\u3098\u3100-\u3104\u3130\u318f\u31bb-\u31bf\u31e4-\u31ef\u321f\u32ff\u4db6-\u4dbf\u9ff0-\u9fff\ua48d-\ua48f\ua4c7-\ua4cf\ua62c-\ua63f\ua6f8-\ua6ff\ua7ba-\ua7f6\ua82c-\ua82f\ua83a-\ua83f\ua878-\ua87f\ua8c6-\ua8cd\ua8da-\ua8df\ua954-\ua95e\ua97d-\ua97f\ua9ce\ua9da-\ua9dd\ua9ff\uaa37-\uaa3f\uaa4e-\uaa4f\uaa5a-\uaa5b\uaac3-\uaada\uaaf7-\uab00\uab07-\uab08\uab0f-\uab10\uab17-\uab1f\uab27\uab2f\uab66-\uab6f\uabee-\uabef\uabfa-\uabff\ud7a4-\ud7af\ud7c7-\ud7ca\ud7fc-\ud7ff\ufa6e-\ufa6f\ufada-\ufaff\ufb07-\ufb12\ufb18-\ufb1c\ufb37\ufb3d\ufb3f\ufb42\ufb45\ufbc2-\ufbd2\ufd40-\ufd4f\ufd90-\ufd91\ufdc8-\ufdef\ufdfe-\ufdff\ufe1a-\ufe1f\ufe53\ufe67\ufe6c-\ufe6f\ufe75\ufefd-\ufefe\uff00\uffbf-\uffc1\uffc8-\uffc9\uffd0-\uffd1\uffd8-\uffd9\uffdd-\uffdf\uffe7\uffef-\ufff8\ufffe-\uffff\U0001000c\U00010027\U0001003b\U0001003e\U0001004e-\U0001004f\U0001005e-\U0001007f\U000100fb-\U000100ff\U00010103-\U00010106\U00010134-\U00010136\U0001018f\U0001019c-\U0001019f\U000101a1-\U000101cf\U000101fe-\U0001027f\U0001029d-\U0001029f\U000102d1-\U000102df\U000102fc-\U000102ff\U00010324-\U0001032c\U0001034b-\U0001034f\U0001037b-\U0001037f\U0001039e\U000103c4-\U000103c7\U000103d6-\U000103ff\U0001049e-\U0001049f\U000104aa-\U000104af\U000104d4-\U000104d7\U000104fc-\U000104ff\U00010528-\U0001052f\U00010564-\U0001056e\U00010570-\U000105ff\U00010737-\U0001073f\U00010756-\U0001075f\U00010768-\U000107ff\U00010806-\U00010807\U00010809\U00010836\U00010839-\U0001083b\U0001083d-\U0001083e\U00010856\U0001089f-\U000108a6\U000108b0-\U000108df\U000108f3\U000108f6-\U000108fa\U0001091c-\U0001091e\U0001093a-\U0001093e\U00010940-\U0001097f\U000109b8-\U000109bb\U000109d0-\U000109d1\U00010a04\U00010a07-\U00010a0b\U00010a14\U00010a18\U00010a36-\U00010a37\U00010a3b-\U00010a3e\U00010a49-\U00010a4f\U00010a59-\U00010a5f\U00010aa0-\U00010abf\U00010ae7-\U00010aea\U00010af7-\U00010aff\U00010b36-\U00010b38\U00010b56-\U00010b57\U00010b73-\U00010b77\U00010b92-\U00010b98\U00010b9d-\U00010ba8\U00010bb0-\U00010bff\U00010c49-\U00010c7f\U00010cb3-\U00010cbf\U00010cf3-\U00010cf9\U00010d28-\U00010d2f\U00010d3a-\U00010e5f\U00010e7f-\U00010eff\U00010f28-\U00010f2f\U00010f5a-\U00010fff\U0001104e-\U00011051\U00011070-\U0001107e\U000110c2-\U000110cc\U000110ce-\U000110cf\U000110e9-\U000110ef\U000110fa-\U000110ff\U00011135\U00011147-\U0001114f\U00011177-\U0001117f\U000111ce-\U000111cf\U000111e0\U000111f5-\U000111ff\U00011212\U0001123f-\U0001127f\U00011287\U00011289\U0001128e\U0001129e\U000112aa-\U000112af\U000112eb-\U000112ef\U000112fa-\U000112ff\U00011304\U0001130d-\U0001130e\U00011311-\U00011312\U00011329\U00011331\U00011334\U0001133a\U00011345-\U00011346\U00011349-\U0001134a\U0001134e-\U0001134f\U00011351-\U00011356\U00011358-\U0001135c\U00011364-\U00011365\U0001136d-\U0001136f\U00011375-\U000113ff\U0001145a\U0001145c\U0001145f-\U0001147f\U000114c8-\U000114cf\U000114da-\U0001157f\U000115b6-\U000115b7\U000115de-\U000115ff\U00011645-\U0001164f\U0001165a-\U0001165f\U0001166d-\U0001167f\U000116b8-\U000116bf\U000116ca-\U000116ff\U0001171b-\U0001171c\U0001172c-\U0001172f\U00011740-\U000117ff\U0001183c-\U0001189f\U000118f3-\U000118fe\U00011900-\U000119ff\U00011a48-\U00011a4f\U00011a84-\U00011a85\U00011aa3-\U00011abf\U00011af9-\U00011bff\U00011c09\U00011c37\U00011c46-\U00011c4f\U00011c6d-\U00011c6f\U00011c90-\U00011c91\U00011ca8\U00011cb7-\U00011cff\U00011d07\U00011d0a\U00011d37-\U00011d39\U00011d3b\U00011d3e\U00011d48-\U00011d4f\U00011d5a-\U00011d5f\U00011d66\U00011d69\U00011d8f\U00011d92\U00011d99-\U00011d9f\U00011daa-\U00011edf\U00011ef9-\U00011fff\U0001239a-\U000123ff\U0001246f\U00012475-\U0001247f\U00012544-\U00012fff\U0001342f-\U000143ff\U00014647-\U000167ff\U00016a39-\U00016a3f\U00016a5f\U00016a6a-\U00016a6d\U00016a70-\U00016acf\U00016aee-\U00016aef\U00016af6-\U00016aff\U00016b46-\U00016b4f\U00016b5a\U00016b62\U00016b78-\U00016b7c\U00016b90-\U00016e3f\U00016e9b-\U00016eff\U00016f45-\U00016f4f\U00016f7f-\U00016f8e\U00016fa0-\U00016fdf\U00016fe2-\U00016fff\U000187f2-\U000187ff\U00018af3-\U0001afff\U0001b11f-\U0001b16f\U0001b2fc-\U0001bbff\U0001bc6b-\U0001bc6f\U0001bc7d-\U0001bc7f\U0001bc89-\U0001bc8f\U0001bc9a-\U0001bc9b\U0001bca4-\U0001cfff\U0001d0f6-\U0001d0ff\U0001d127-\U0001d128\U0001d1e9-\U0001d1ff\U0001d246-\U0001d2df\U0001d2f4-\U0001d2ff\U0001d357-\U0001d35f\U0001d379-\U0001d3ff\U0001d455\U0001d49d\U0001d4a0-\U0001d4a1\U0001d4a3-\U0001d4a4\U0001d4a7-\U0001d4a8\U0001d4ad\U0001d4ba\U0001d4bc\U0001d4c4\U0001d506\U0001d50b-\U0001d50c\U0001d515\U0001d51d\U0001d53a\U0001d53f\U0001d545\U0001d547-\U0001d549\U0001d551\U0001d6a6-\U0001d6a7\U0001d7cc-\U0001d7cd\U0001da8c-\U0001da9a\U0001daa0\U0001dab0-\U0001dfff\U0001e007\U0001e019-\U0001e01a\U0001e022\U0001e025\U0001e02b-\U0001e7ff\U0001e8c5-\U0001e8c6\U0001e8d7-\U0001e8ff\U0001e94b-\U0001e94f\U0001e95a-\U0001e95d\U0001e960-\U0001ec70\U0001ecb5-\U0001edff\U0001ee04\U0001ee20\U0001ee23\U0001ee25-\U0001ee26\U0001ee28\U0001ee33\U0001ee38\U0001ee3a\U0001ee3c-\U0001ee41\U0001ee43-\U0001ee46\U0001ee48\U0001ee4a\U0001ee4c\U0001ee50\U0001ee53\U0001ee55-\U0001ee56\U0001ee58\U0001ee5a\U0001ee5c\U0001ee5e\U0001ee60\U0001ee63\U0001ee65-\U0001ee66\U0001ee6b\U0001ee73\U0001ee78\U0001ee7d\U0001ee7f\U0001ee8a\U0001ee9c-\U0001eea0\U0001eea4\U0001eeaa\U0001eebc-\U0001eeef\U0001eef2-\U0001efff\U0001f02c-\U0001f02f\U0001f094-\U0001f09f\U0001f0af-\U0001f0b0\U0001f0c0\U0001f0d0\U0001f0f6-\U0001f0ff\U0001f10d-\U0001f10f\U0001f16c-\U0001f16f\U0001f1ad-\U0001f1e5\U0001f203-\U0001f20f\U0001f23c-\U0001f23f\U0001f249-\U0001f24f\U0001f252-\U0001f25f\U0001f266-\U0001f2ff\U0001f6d5-\U0001f6df\U0001f6ed-\U0001f6ef\U0001f6fa-\U0001f6ff\U0001f774-\U0001f77f\U0001f7d9-\U0001f7ff\U0001f80c-\U0001f80f\U0001f848-\U0001f84f\U0001f85a-\U0001f85f\U0001f888-\U0001f88f\U0001f8ae-\U0001f8ff\U0001f90c-\U0001f90f\U0001f93f\U0001f971-\U0001f972\U0001f977-\U0001f979\U0001f97b\U0001f9a3-\U0001f9af\U0001f9ba-\U0001f9bf\U0001f9c3-\U0001f9cf\U0001fa00-\U0001fa5f\U0001fa6e-\U0001ffff\U0002a6d7-\U0002a6ff\U0002b735-\U0002b73f\U0002b81e-\U0002b81f\U0002cea2-\U0002ceaf\U0002ebe1-\U0002f7ff\U0002fa1e-\U000e0000\U000e0002-\U000e001f\U000e0080-\U000e00ff\U000e01f0-\U000effff\U000ffffe-\U000fffff\U0010fffe-\U0010ffff'
Co = '\ue000-\uf8ff\U000f0000-\U000ffffd\U00100000-\U0010fffd'
Cs = '\ud800-\udbff\\\udc00\udc01-\udfff'
Ll = 'a-z\xb5\xdf-\xf6\xf8-\xff\u0101\u0103\u0105\u0107\u0109\u010b\u010d\u010f\u0111\u0113\u0115\u0117\u0119\u011b\u011d\u011f\u0121\u0123\u0125\u0127\u0129\u012b\u012d\u012f\u0131\u0133\u0135\u0137-\u0138\u013a\u013c\u013e\u0140\u0142\u0144\u0146\u0148-\u0149\u014b\u014d\u014f\u0151\u0153\u0155\u0157\u0159\u015b\u015d\u015f\u0161\u0163\u0165\u0167\u0169\u016b\u016d\u016f\u0171\u0173\u0175\u0177\u017a\u017c\u017e-\u0180\u0183\u0185\u0188\u018c-\u018d\u0192\u0195\u0199-\u019b\u019e\u01a1\u01a3\u01a5\u01a8\u01aa-\u01ab\u01ad\u01b0\u01b4\u01b6\u01b9-\u01ba\u01bd-\u01bf\u01c6\u01c9\u01cc\u01ce\u01d0\u01d2\u01d4\u01d6\u01d8\u01da\u01dc-\u01dd\u01df\u01e1\u01e3\u01e5\u01e7\u01e9\u01eb\u01ed\u01ef-\u01f0\u01f3\u01f5\u01f9\u01fb\u01fd\u01ff\u0201\u0203\u0205\u0207\u0209\u020b\u020d\u020f\u0211\u0213\u0215\u0217\u0219\u021b\u021d\u021f\u0221\u0223\u0225\u0227\u0229\u022b\u022d\u022f\u0231\u0233-\u0239\u023c\u023f-\u0240\u0242\u0247\u0249\u024b\u024d\u024f-\u0293\u0295-\u02af\u0371\u0373\u0377\u037b-\u037d\u0390\u03ac-\u03ce\u03d0-\u03d1\u03d5-\u03d7\u03d9\u03db\u03dd\u03df\u03e1\u03e3\u03e5\u03e7\u03e9\u03eb\u03ed\u03ef-\u03f3\u03f5\u03f8\u03fb-\u03fc\u0430-\u045f\u0461\u0463\u0465\u0467\u0469\u046b\u046d\u046f\u0471\u0473\u0475\u0477\u0479\u047b\u047d\u047f\u0481\u048b\u048d\u048f\u0491\u0493\u0495\u0497\u0499\u049b\u049d\u049f\u04a1\u04a3\u04a5\u04a7\u04a9\u04ab\u04ad\u04af\u04b1\u04b3\u04b5\u04b7\u04b9\u04bb\u04bd\u04bf\u04c2\u04c4\u04c6\u04c8\u04ca\u04cc\u04ce-\u04cf\u04d1\u04d3\u04d5\u04d7\u04d9\u04db\u04dd\u04df\u04e1\u04e3\u04e5\u04e7\u04e9\u04eb\u04ed\u04ef\u04f1\u04f3\u04f5\u04f7\u04f9\u04fb\u04fd\u04ff\u0501\u0503\u0505\u0507\u0509\u050b\u050d\u050f\u0511\u0513\u0515\u0517\u0519\u051b\u051d\u051f\u0521\u0523\u0525\u0527\u0529\u052b\u052d\u052f\u0560-\u0588\u10d0-\u10fa\u10fd-\u10ff\u13f8-\u13fd\u1c80-\u1c88\u1d00-\u1d2b\u1d6b-\u1d77\u1d79-\u1d9a\u1e01\u1e03\u1e05\u1e07\u1e09\u1e0b\u1e0d\u1e0f\u1e11\u1e13\u1e15\u1e17\u1e19\u1e1b\u1e1d\u1e1f\u1e21\u1e23\u1e25\u1e27\u1e29\u1e2b\u1e2d\u1e2f\u1e31\u1e33\u1e35\u1e37\u1e39\u1e3b\u1e3d\u1e3f\u1e41\u1e43\u1e45\u1e47\u1e49\u1e4b\u1e4d\u1e4f\u1e51\u1e53\u1e55\u1e57\u1e59\u1e5b\u1e5d\u1e5f\u1e61\u1e63\u1e65\u1e67\u1e69\u1e6b\u1e6d\u1e6f\u1e71\u1e73\u1e75\u1e77\u1e79\u1e7b\u1e7d\u1e7f\u1e81\u1e83\u1e85\u1e87\u1e89\u1e8b\u1e8d\u1e8f\u1e91\u1e93\u1e95-\u1e9d\u1e9f\u1ea1\u1ea3\u1ea5\u1ea7\u1ea9\u1eab\u1ead\u1eaf\u1eb1\u1eb3\u1eb5\u1eb7\u1eb9\u1ebb\u1ebd\u1ebf\u1ec1\u1ec3\u1ec5\u1ec7\u1ec9\u1ecb\u1ecd\u1ecf\u1ed1\u1ed3\u1ed5\u1ed7\u1ed9\u1edb\u1edd\u1edf\u1ee1\u1ee3\u1ee5\u1ee7\u1ee9\u1eeb\u1eed\u1eef\u1ef1\u1ef3\u1ef5\u1ef7\u1ef9\u1efb\u1efd\u1eff-\u1f07\u1f10-\u1f15\u1f20-\u1f27\u1f30-\u1f37\u1f40-\u1f45\u1f50-\u1f57\u1f60-\u1f67\u1f70-\u1f7d\u1f80-\u1f87\u1f90-\u1f97\u1fa0-\u1fa7\u1fb0-\u1fb4\u1fb6-\u1fb7\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fc7\u1fd0-\u1fd3\u1fd6-\u1fd7\u1fe0-\u1fe7\u1ff2-\u1ff4\u1ff6-\u1ff7\u210a\u210e-\u210f\u2113\u212f\u2134\u2139\u213c-\u213d\u2146-\u2149\u214e\u2184\u2c30-\u2c5e\u2c61\u2c65-\u2c66\u2c68\u2c6a\u2c6c\u2c71\u2c73-\u2c74\u2c76-\u2c7b\u2c81\u2c83\u2c85\u2c87\u2c89\u2c8b\u2c8d\u2c8f\u2c91\u2c93\u2c95\u2c97\u2c99\u2c9b\u2c9d\u2c9f\u2ca1\u2ca3\u2ca5\u2ca7\u2ca9\u2cab\u2cad\u2caf\u2cb1\u2cb3\u2cb5\u2cb7\u2cb9\u2cbb\u2cbd\u2cbf\u2cc1\u2cc3\u2cc5\u2cc7\u2cc9\u2ccb\u2ccd\u2ccf\u2cd1\u2cd3\u2cd5\u2cd7\u2cd9\u2cdb\u2cdd\u2cdf\u2ce1\u2ce3-\u2ce4\u2cec\u2cee\u2cf3\u2d00-\u2d25\u2d27\u2d2d\ua641\ua643\ua645\ua647\ua649\ua64b\ua64d\ua64f\ua651\ua653\ua655\ua657\ua659\ua65b\ua65d\ua65f\ua661\ua663\ua665\ua667\ua669\ua66b\ua66d\ua681\ua683\ua685\ua687\ua689\ua68b\ua68d\ua68f\ua691\ua693\ua695\ua697\ua699\ua69b\ua723\ua725\ua727\ua729\ua72b\ua72d\ua72f-\ua731\ua733\ua735\ua737\ua739\ua73b\ua73d\ua73f\ua741\ua743\ua745\ua747\ua749\ua74b\ua74d\ua74f\ua751\ua753\ua755\ua757\ua759\ua75b\ua75d\ua75f\ua761\ua763\ua765\ua767\ua769\ua76b\ua76d\ua76f\ua771-\ua778\ua77a\ua77c\ua77f\ua781\ua783\ua785\ua787\ua78c\ua78e\ua791\ua793-\ua795\ua797\ua799\ua79b\ua79d\ua79f\ua7a1\ua7a3\ua7a5\ua7a7\ua7a9\ua7af\ua7b5\ua7b7\ua7b9\ua7fa\uab30-\uab5a\uab60-\uab65\uab70-\uabbf\ufb00-\ufb06\ufb13-\ufb17\uff41-\uff5a\U00010428-\U0001044f\U000104d8-\U000104fb\U00010cc0-\U00010cf2\U000118c0-\U000118df\U00016e60-\U00016e7f\U0001d41a-\U0001d433\U0001d44e-\U0001d454\U0001d456-\U0001d467\U0001d482-\U0001d49b\U0001d4b6-\U0001d4b9\U0001d4bb\U0001d4bd-\U0001d4c3\U0001d4c5-\U0001d4cf\U0001d4ea-\U0001d503\U0001d51e-\U0001d537\U0001d552-\U0001d56b\U0001d586-\U0001d59f\U0001d5ba-\U0001d5d3\U0001d5ee-\U0001d607\U0001d622-\U0001d63b\U0001d656-\U0001d66f\U0001d68a-\U0001d6a5\U0001d6c2-\U0001d6da\U0001d6dc-\U0001d6e1\U0001d6fc-\U0001d714\U0001d716-\U0001d71b\U0001d736-\U0001d74e\U0001d750-\U0001d755\U0001d770-\U0001d788\U0001d78a-\U0001d78f\U0001d7aa-\U0001d7c2\U0001d7c4-\U0001d7c9\U0001d7cb\U0001e922-\U0001e943'
Lm = '\u02b0-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0374\u037a\u0559\u0640\u06e5-\u06e6\u07f4-\u07f5\u07fa\u081a\u0824\u0828\u0971\u0e46\u0ec6\u10fc\u17d7\u1843\u1aa7\u1c78-\u1c7d\u1d2c-\u1d6a\u1d78\u1d9b-\u1dbf\u2071\u207f\u2090-\u209c\u2c7c-\u2c7d\u2d6f\u2e2f\u3005\u3031-\u3035\u303b\u309d-\u309e\u30fc-\u30fe\ua015\ua4f8-\ua4fd\ua60c\ua67f\ua69c-\ua69d\ua717-\ua71f\ua770\ua788\ua7f8-\ua7f9\ua9cf\ua9e6\uaa70\uaadd\uaaf3-\uaaf4\uab5c-\uab5f\uff70\uff9e-\uff9f\U00016b40-\U00016b43\U00016f93-\U00016f9f\U00016fe0-\U00016fe1'
Lo = '\xaa\xba\u01bb\u01c0-\u01c3\u0294\u05d0-\u05ea\u05ef-\u05f2\u0620-\u063f\u0641-\u064a\u066e-\u066f\u0671-\u06d3\u06d5\u06ee-\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u0800-\u0815\u0840-\u0858\u0860-\u086a\u08a0-\u08b4\u08b6-\u08bd\u0904-\u0939\u093d\u0950\u0958-\u0961\u0972-\u0980\u0985-\u098c\u098f-\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc-\u09dd\u09df-\u09e1\u09f0-\u09f1\u09fc\u0a05-\u0a0a\u0a0f-\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32-\u0a33\u0a35-\u0a36\u0a38-\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2-\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0-\u0ae1\u0af9\u0b05-\u0b0c\u0b0f-\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32-\u0b33\u0b35-\u0b39\u0b3d\u0b5c-\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99-\u0b9a\u0b9c\u0b9e-\u0b9f\u0ba3-\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c60-\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0-\u0ce1\u0cf1-\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32-\u0e33\u0e40-\u0e45\u0e81-\u0e82\u0e84\u0e87-\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa-\u0eab\u0ead-\u0eb0\u0eb2-\u0eb3\u0ebd\u0ec0-\u0ec4\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065-\u1066\u106e-\u1070\u1075-\u1081\u108e\u1100-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16f1-\u16f8\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17dc\u1820-\u1842\u1844-\u1878\u1880-\u1884\u1887-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae-\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c77\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5-\u1cf6\u2135-\u2138\u2d30-\u2d67\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3006\u303c\u3041-\u3096\u309f\u30a1-\u30fa\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fef\ua000-\ua014\ua016-\ua48c\ua4d0-\ua4f7\ua500-\ua60b\ua610-\ua61f\ua62a-\ua62b\ua66e\ua6a0-\ua6e5\ua78f\ua7f7\ua7fb-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd-\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9e0-\ua9e4\ua9e7-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa6f\uaa71-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5-\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadc\uaae0-\uaaea\uaaf2\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff66-\uff6f\uff71-\uff9d\uffa0-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc\U00010000-\U0001000b\U0001000d-\U00010026\U00010028-\U0001003a\U0001003c-\U0001003d\U0001003f-\U0001004d\U00010050-\U0001005d\U00010080-\U000100fa\U00010280-\U0001029c\U000102a0-\U000102d0\U00010300-\U0001031f\U0001032d-\U00010340\U00010342-\U00010349\U00010350-\U00010375\U00010380-\U0001039d\U000103a0-\U000103c3\U000103c8-\U000103cf\U00010450-\U0001049d\U00010500-\U00010527\U00010530-\U00010563\U00010600-\U00010736\U00010740-\U00010755\U00010760-\U00010767\U00010800-\U00010805\U00010808\U0001080a-\U00010835\U00010837-\U00010838\U0001083c\U0001083f-\U00010855\U00010860-\U00010876\U00010880-\U0001089e\U000108e0-\U000108f2\U000108f4-\U000108f5\U00010900-\U00010915\U00010920-\U00010939\U00010980-\U000109b7\U000109be-\U000109bf\U00010a00\U00010a10-\U00010a13\U00010a15-\U00010a17\U00010a19-\U00010a35\U00010a60-\U00010a7c\U00010a80-\U00010a9c\U00010ac0-\U00010ac7\U00010ac9-\U00010ae4\U00010b00-\U00010b35\U00010b40-\U00010b55\U00010b60-\U00010b72\U00010b80-\U00010b91\U00010c00-\U00010c48\U00010d00-\U00010d23\U00010f00-\U00010f1c\U00010f27\U00010f30-\U00010f45\U00011003-\U00011037\U00011083-\U000110af\U000110d0-\U000110e8\U00011103-\U00011126\U00011144\U00011150-\U00011172\U00011176\U00011183-\U000111b2\U000111c1-\U000111c4\U000111da\U000111dc\U00011200-\U00011211\U00011213-\U0001122b\U00011280-\U00011286\U00011288\U0001128a-\U0001128d\U0001128f-\U0001129d\U0001129f-\U000112a8\U000112b0-\U000112de\U00011305-\U0001130c\U0001130f-\U00011310\U00011313-\U00011328\U0001132a-\U00011330\U00011332-\U00011333\U00011335-\U00011339\U0001133d\U00011350\U0001135d-\U00011361\U00011400-\U00011434\U00011447-\U0001144a\U00011480-\U000114af\U000114c4-\U000114c5\U000114c7\U00011580-\U000115ae\U000115d8-\U000115db\U00011600-\U0001162f\U00011644\U00011680-\U000116aa\U00011700-\U0001171a\U00011800-\U0001182b\U000118ff\U00011a00\U00011a0b-\U00011a32\U00011a3a\U00011a50\U00011a5c-\U00011a83\U00011a86-\U00011a89\U00011a9d\U00011ac0-\U00011af8\U00011c00-\U00011c08\U00011c0a-\U00011c2e\U00011c40\U00011c72-\U00011c8f\U00011d00-\U00011d06\U00011d08-\U00011d09\U00011d0b-\U00011d30\U00011d46\U00011d60-\U00011d65\U00011d67-\U00011d68\U00011d6a-\U00011d89\U00011d98\U00011ee0-\U00011ef2\U00012000-\U00012399\U00012480-\U00012543\U00013000-\U0001342e\U00014400-\U00014646\U00016800-\U00016a38\U00016a40-\U00016a5e\U00016ad0-\U00016aed\U00016b00-\U00016b2f\U00016b63-\U00016b77\U00016b7d-\U00016b8f\U00016f00-\U00016f44\U00016f50\U00017000-\U000187f1\U00018800-\U00018af2\U0001b000-\U0001b11e\U0001b170-\U0001b2fb\U0001bc00-\U0001bc6a\U0001bc70-\U0001bc7c\U0001bc80-\U0001bc88\U0001bc90-\U0001bc99\U0001e800-\U0001e8c4\U0001ee00-\U0001ee03\U0001ee05-\U0001ee1f\U0001ee21-\U0001ee22\U0001ee24\U0001ee27\U0001ee29-\U0001ee32\U0001ee34-\U0001ee37\U0001ee39\U0001ee3b\U0001ee42\U0001ee47\U0001ee49\U0001ee4b\U0001ee4d-\U0001ee4f\U0001ee51-\U0001ee52\U0001ee54\U0001ee57\U0001ee59\U0001ee5b\U0001ee5d\U0001ee5f\U0001ee61-\U0001ee62\U0001ee64\U0001ee67-\U0001ee6a\U0001ee6c-\U0001ee72\U0001ee74-\U0001ee77\U0001ee79-\U0001ee7c\U0001ee7e\U0001ee80-\U0001ee89\U0001ee8b-\U0001ee9b\U0001eea1-\U0001eea3\U0001eea5-\U0001eea9\U0001eeab-\U0001eebb\U00020000-\U0002a6d6\U0002a700-\U0002b734\U0002b740-\U0002b81d\U0002b820-\U0002cea1\U0002ceb0-\U0002ebe0\U0002f800-\U0002fa1d'
Lt = '\u01c5\u01c8\u01cb\u01f2\u1f88-\u1f8f\u1f98-\u1f9f\u1fa8-\u1faf\u1fbc\u1fcc\u1ffc'
Lu = 'A-Z\xc0-\xd6\xd8-\xde\u0100\u0102\u0104\u0106\u0108\u010a\u010c\u010e\u0110\u0112\u0114\u0116\u0118\u011a\u011c\u011e\u0120\u0122\u0124\u0126\u0128\u012a\u012c\u012e\u0130\u0132\u0134\u0136\u0139\u013b\u013d\u013f\u0141\u0143\u0145\u0147\u014a\u014c\u014e\u0150\u0152\u0154\u0156\u0158\u015a\u015c\u015e\u0160\u0162\u0164\u0166\u0168\u016a\u016c\u016e\u0170\u0172\u0174\u0176\u0178-\u0179\u017b\u017d\u0181-\u0182\u0184\u0186-\u0187\u0189-\u018b\u018e-\u0191\u0193-\u0194\u0196-\u0198\u019c-\u019d\u019f-\u01a0\u01a2\u01a4\u01a6-\u01a7\u01a9\u01ac\u01ae-\u01af\u01b1-\u01b3\u01b5\u01b7-\u01b8\u01bc\u01c4\u01c7\u01ca\u01cd\u01cf\u01d1\u01d3\u01d5\u01d7\u01d9\u01db\u01de\u01e0\u01e2\u01e4\u01e6\u01e8\u01ea\u01ec\u01ee\u01f1\u01f4\u01f6-\u01f8\u01fa\u01fc\u01fe\u0200\u0202\u0204\u0206\u0208\u020a\u020c\u020e\u0210\u0212\u0214\u0216\u0218\u021a\u021c\u021e\u0220\u0222\u0224\u0226\u0228\u022a\u022c\u022e\u0230\u0232\u023a-\u023b\u023d-\u023e\u0241\u0243-\u0246\u0248\u024a\u024c\u024e\u0370\u0372\u0376\u037f\u0386\u0388-\u038a\u038c\u038e-\u038f\u0391-\u03a1\u03a3-\u03ab\u03cf\u03d2-\u03d4\u03d8\u03da\u03dc\u03de\u03e0\u03e2\u03e4\u03e6\u03e8\u03ea\u03ec\u03ee\u03f4\u03f7\u03f9-\u03fa\u03fd-\u042f\u0460\u0462\u0464\u0466\u0468\u046a\u046c\u046e\u0470\u0472\u0474\u0476\u0478\u047a\u047c\u047e\u0480\u048a\u048c\u048e\u0490\u0492\u0494\u0496\u0498\u049a\u049c\u049e\u04a0\u04a2\u04a4\u04a6\u04a8\u04aa\u04ac\u04ae\u04b0\u04b2\u04b4\u04b6\u04b8\u04ba\u04bc\u04be\u04c0-\u04c1\u04c3\u04c5\u04c7\u04c9\u04cb\u04cd\u04d0\u04d2\u04d4\u04d6\u04d8\u04da\u04dc\u04de\u04e0\u04e2\u04e4\u04e6\u04e8\u04ea\u04ec\u04ee\u04f0\u04f2\u04f4\u04f6\u04f8\u04fa\u04fc\u04fe\u0500\u0502\u0504\u0506\u0508\u050a\u050c\u050e\u0510\u0512\u0514\u0516\u0518\u051a\u051c\u051e\u0520\u0522\u0524\u0526\u0528\u052a\u052c\u052e\u0531-\u0556\u10a0-\u10c5\u10c7\u10cd\u13a0-\u13f5\u1c90-\u1cba\u1cbd-\u1cbf\u1e00\u1e02\u1e04\u1e06\u1e08\u1e0a\u1e0c\u1e0e\u1e10\u1e12\u1e14\u1e16\u1e18\u1e1a\u1e1c\u1e1e\u1e20\u1e22\u1e24\u1e26\u1e28\u1e2a\u1e2c\u1e2e\u1e30\u1e32\u1e34\u1e36\u1e38\u1e3a\u1e3c\u1e3e\u1e40\u1e42\u1e44\u1e46\u1e48\u1e4a\u1e4c\u1e4e\u1e50\u1e52\u1e54\u1e56\u1e58\u1e5a\u1e5c\u1e5e\u1e60\u1e62\u1e64\u1e66\u1e68\u1e6a\u1e6c\u1e6e\u1e70\u1e72\u1e74\u1e76\u1e78\u1e7a\u1e7c\u1e7e\u1e80\u1e82\u1e84\u1e86\u1e88\u1e8a\u1e8c\u1e8e\u1e90\u1e92\u1e94\u1e9e\u1ea0\u1ea2\u1ea4\u1ea6\u1ea8\u1eaa\u1eac\u1eae\u1eb0\u1eb2\u1eb4\u1eb6\u1eb8\u1eba\u1ebc\u1ebe\u1ec0\u1ec2\u1ec4\u1ec6\u1ec8\u1eca\u1ecc\u1ece\u1ed0\u1ed2\u1ed4\u1ed6\u1ed8\u1eda\u1edc\u1ede\u1ee0\u1ee2\u1ee4\u1ee6\u1ee8\u1eea\u1eec\u1eee\u1ef0\u1ef2\u1ef4\u1ef6\u1ef8\u1efa\u1efc\u1efe\u1f08-\u1f0f\u1f18-\u1f1d\u1f28-\u1f2f\u1f38-\u1f3f\u1f48-\u1f4d\u1f59\u1f5b\u1f5d\u1f5f\u1f68-\u1f6f\u1fb8-\u1fbb\u1fc8-\u1fcb\u1fd8-\u1fdb\u1fe8-\u1fec\u1ff8-\u1ffb\u2102\u2107\u210b-\u210d\u2110-\u2112\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u2130-\u2133\u213e-\u213f\u2145\u2183\u2c00-\u2c2e\u2c60\u2c62-\u2c64\u2c67\u2c69\u2c6b\u2c6d-\u2c70\u2c72\u2c75\u2c7e-\u2c80\u2c82\u2c84\u2c86\u2c88\u2c8a\u2c8c\u2c8e\u2c90\u2c92\u2c94\u2c96\u2c98\u2c9a\u2c9c\u2c9e\u2ca0\u2ca2\u2ca4\u2ca6\u2ca8\u2caa\u2cac\u2cae\u2cb0\u2cb2\u2cb4\u2cb6\u2cb8\u2cba\u2cbc\u2cbe\u2cc0\u2cc2\u2cc4\u2cc6\u2cc8\u2cca\u2ccc\u2cce\u2cd0\u2cd2\u2cd4\u2cd6\u2cd8\u2cda\u2cdc\u2cde\u2ce0\u2ce2\u2ceb\u2ced\u2cf2\ua640\ua642\ua644\ua646\ua648\ua64a\ua64c\ua64e\ua650\ua652\ua654\ua656\ua658\ua65a\ua65c\ua65e\ua660\ua662\ua664\ua666\ua668\ua66a\ua66c\ua680\ua682\ua684\ua686\ua688\ua68a\ua68c\ua68e\ua690\ua692\ua694\ua696\ua698\ua69a\ua722\ua724\ua726\ua728\ua72a\ua72c\ua72e\ua732\ua734\ua736\ua738\ua73a\ua73c\ua73e\ua740\ua742\ua744\ua746\ua748\ua74a\ua74c\ua74e\ua750\ua752\ua754\ua756\ua758\ua75a\ua75c\ua75e\ua760\ua762\ua764\ua766\ua768\ua76a\ua76c\ua76e\ua779\ua77b\ua77d-\ua77e\ua780\ua782\ua784\ua786\ua78b\ua78d\ua790\ua792\ua796\ua798\ua79a\ua79c\ua79e\ua7a0\ua7a2\ua7a4\ua7a6\ua7a8\ua7aa-\ua7ae\ua7b0-\ua7b4\ua7b6\ua7b8\uff21-\uff3a\U00010400-\U00010427\U000104b0-\U000104d3\U00010c80-\U00010cb2\U000118a0-\U000118bf\U00016e40-\U00016e5f\U0001d400-\U0001d419\U0001d434-\U0001d44d\U0001d468-\U0001d481\U0001d49c\U0001d49e-\U0001d49f\U0001d4a2\U0001d4a5-\U0001d4a6\U0001d4a9-\U0001d4ac\U0001d4ae-\U0001d4b5\U0001d4d0-\U0001d4e9\U0001d504-\U0001d505\U0001d507-\U0001d50a\U0001d50d-\U0001d514\U0001d516-\U0001d51c\U0001d538-\U0001d539\U0001d53b-\U0001d53e\U0001d540-\U0001d544\U0001d546\U0001d54a-\U0001d550\U0001d56c-\U0001d585\U0001d5a0-\U0001d5b9\U0001d5d4-\U0001d5ed\U0001d608-\U0001d621\U0001d63c-\U0001d655\U0001d670-\U0001d689\U0001d6a8-\U0001d6c0\U0001d6e2-\U0001d6fa\U0001d71c-\U0001d734\U0001d756-\U0001d76e\U0001d790-\U0001d7a8\U0001d7ca\U0001e900-\U0001e921'
Mc = '\u0903\u093b\u093e-\u0940\u0949-\u094c\u094e-\u094f\u0982-\u0983\u09be-\u09c0\u09c7-\u09c8\u09cb-\u09cc\u09d7\u0a03\u0a3e-\u0a40\u0a83\u0abe-\u0ac0\u0ac9\u0acb-\u0acc\u0b02-\u0b03\u0b3e\u0b40\u0b47-\u0b48\u0b4b-\u0b4c\u0b57\u0bbe-\u0bbf\u0bc1-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcc\u0bd7\u0c01-\u0c03\u0c41-\u0c44\u0c82-\u0c83\u0cbe\u0cc0-\u0cc4\u0cc7-\u0cc8\u0cca-\u0ccb\u0cd5-\u0cd6\u0d02-\u0d03\u0d3e-\u0d40\u0d46-\u0d48\u0d4a-\u0d4c\u0d57\u0d82-\u0d83\u0dcf-\u0dd1\u0dd8-\u0ddf\u0df2-\u0df3\u0f3e-\u0f3f\u0f7f\u102b-\u102c\u1031\u1038\u103b-\u103c\u1056-\u1057\u1062-\u1064\u1067-\u106d\u1083-\u1084\u1087-\u108c\u108f\u109a-\u109c\u17b6\u17be-\u17c5\u17c7-\u17c8\u1923-\u1926\u1929-\u192b\u1930-\u1931\u1933-\u1938\u1a19-\u1a1a\u1a55\u1a57\u1a61\u1a63-\u1a64\u1a6d-\u1a72\u1b04\u1b35\u1b3b\u1b3d-\u1b41\u1b43-\u1b44\u1b82\u1ba1\u1ba6-\u1ba7\u1baa\u1be7\u1bea-\u1bec\u1bee\u1bf2-\u1bf3\u1c24-\u1c2b\u1c34-\u1c35\u1ce1\u1cf2-\u1cf3\u1cf7\u302e-\u302f\ua823-\ua824\ua827\ua880-\ua881\ua8b4-\ua8c3\ua952-\ua953\ua983\ua9b4-\ua9b5\ua9ba-\ua9bb\ua9bd-\ua9c0\uaa2f-\uaa30\uaa33-\uaa34\uaa4d\uaa7b\uaa7d\uaaeb\uaaee-\uaaef\uaaf5\uabe3-\uabe4\uabe6-\uabe7\uabe9-\uabea\uabec\U00011000\U00011002\U00011082\U000110b0-\U000110b2\U000110b7-\U000110b8\U0001112c\U00011145-\U00011146\U00011182\U000111b3-\U000111b5\U000111bf-\U000111c0\U0001122c-\U0001122e\U00011232-\U00011233\U00011235\U000112e0-\U000112e2\U00011302-\U00011303\U0001133e-\U0001133f\U00011341-\U00011344\U00011347-\U00011348\U0001134b-\U0001134d\U00011357\U00011362-\U00011363\U00011435-\U00011437\U00011440-\U00011441\U00011445\U000114b0-\U000114b2\U000114b9\U000114bb-\U000114be\U000114c1\U000115af-\U000115b1\U000115b8-\U000115bb\U000115be\U00011630-\U00011632\U0001163b-\U0001163c\U0001163e\U000116ac\U000116ae-\U000116af\U000116b6\U00011720-\U00011721\U00011726\U0001182c-\U0001182e\U00011838\U00011a39\U00011a57-\U00011a58\U00011a97\U00011c2f\U00011c3e\U00011ca9\U00011cb1\U00011cb4\U00011d8a-\U00011d8e\U00011d93-\U00011d94\U00011d96\U00011ef5-\U00011ef6\U00016f51-\U00016f7e\U0001d165-\U0001d166\U0001d16d-\U0001d172'
Me = '\u0488-\u0489\u1abe\u20dd-\u20e0\u20e2-\u20e4\ua670-\ua672'
Mn = '\u0300-\u036f\u0483-\u0487\u0591-\u05bd\u05bf\u05c1-\u05c2\u05c4-\u05c5\u05c7\u0610-\u061a\u064b-\u065f\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7-\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08d3-\u08e1\u08e3-\u0902\u093a\u093c\u0941-\u0948\u094d\u0951-\u0957\u0962-\u0963\u0981\u09bc\u09c1-\u09c4\u09cd\u09e2-\u09e3\u09fe\u0a01-\u0a02\u0a3c\u0a41-\u0a42\u0a47-\u0a48\u0a4b-\u0a4d\u0a51\u0a70-\u0a71\u0a75\u0a81-\u0a82\u0abc\u0ac1-\u0ac5\u0ac7-\u0ac8\u0acd\u0ae2-\u0ae3\u0afa-\u0aff\u0b01\u0b3c\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b62-\u0b63\u0b82\u0bc0\u0bcd\u0c00\u0c04\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55-\u0c56\u0c62-\u0c63\u0c81\u0cbc\u0cbf\u0cc6\u0ccc-\u0ccd\u0ce2-\u0ce3\u0d00-\u0d01\u0d3b-\u0d3c\u0d41-\u0d44\u0d4d\u0d62-\u0d63\u0dca\u0dd2-\u0dd4\u0dd6\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb-\u0ebc\u0ec8-\u0ecd\u0f18-\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86-\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039-\u103a\u103d-\u103e\u1058-\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085-\u1086\u108d\u109d\u135d-\u135f\u1712-\u1714\u1732-\u1734\u1752-\u1753\u1772-\u1773\u17b4-\u17b5\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u1885-\u1886\u18a9\u1920-\u1922\u1927-\u1928\u1932\u1939-\u193b\u1a17-\u1a18\u1a1b\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1ab0-\u1abd\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80-\u1b81\u1ba2-\u1ba5\u1ba8-\u1ba9\u1bab-\u1bad\u1be6\u1be8-\u1be9\u1bed\u1bef-\u1bf1\u1c2c-\u1c33\u1c36-\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1cf4\u1cf8-\u1cf9\u1dc0-\u1df9\u1dfb-\u1dff\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302d\u3099-\u309a\ua66f\ua674-\ua67d\ua69e-\ua69f\ua6f0-\ua6f1\ua802\ua806\ua80b\ua825-\ua826\ua8c4-\ua8c5\ua8e0-\ua8f1\ua8ff\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\ua9e5\uaa29-\uaa2e\uaa31-\uaa32\uaa35-\uaa36\uaa43\uaa4c\uaa7c\uaab0\uaab2-\uaab4\uaab7-\uaab8\uaabe-\uaabf\uaac1\uaaec-\uaaed\uaaf6\uabe5\uabe8\uabed\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\U000101fd\U000102e0\U00010376-\U0001037a\U00010a01-\U00010a03\U00010a05-\U00010a06\U00010a0c-\U00010a0f\U00010a38-\U00010a3a\U00010a3f\U00010ae5-\U00010ae6\U00010d24-\U00010d27\U00010f46-\U00010f50\U00011001\U00011038-\U00011046\U0001107f-\U00011081\U000110b3-\U000110b6\U000110b9-\U000110ba\U00011100-\U00011102\U00011127-\U0001112b\U0001112d-\U00011134\U00011173\U00011180-\U00011181\U000111b6-\U000111be\U000111c9-\U000111cc\U0001122f-\U00011231\U00011234\U00011236-\U00011237\U0001123e\U000112df\U000112e3-\U000112ea\U00011300-\U00011301\U0001133b-\U0001133c\U00011340\U00011366-\U0001136c\U00011370-\U00011374\U00011438-\U0001143f\U00011442-\U00011444\U00011446\U0001145e\U000114b3-\U000114b8\U000114ba\U000114bf-\U000114c0\U000114c2-\U000114c3\U000115b2-\U000115b5\U000115bc-\U000115bd\U000115bf-\U000115c0\U000115dc-\U000115dd\U00011633-\U0001163a\U0001163d\U0001163f-\U00011640\U000116ab\U000116ad\U000116b0-\U000116b5\U000116b7\U0001171d-\U0001171f\U00011722-\U00011725\U00011727-\U0001172b\U0001182f-\U00011837\U00011839-\U0001183a\U00011a01-\U00011a0a\U00011a33-\U00011a38\U00011a3b-\U00011a3e\U00011a47\U00011a51-\U00011a56\U00011a59-\U00011a5b\U00011a8a-\U00011a96\U00011a98-\U00011a99\U00011c30-\U00011c36\U00011c38-\U00011c3d\U00011c3f\U00011c92-\U00011ca7\U00011caa-\U00011cb0\U00011cb2-\U00011cb3\U00011cb5-\U00011cb6\U00011d31-\U00011d36\U00011d3a\U00011d3c-\U00011d3d\U00011d3f-\U00011d45\U00011d47\U00011d90-\U00011d91\U00011d95\U00011d97\U00011ef3-\U00011ef4\U00016af0-\U00016af4\U00016b30-\U00016b36\U00016f8f-\U00016f92\U0001bc9d-\U0001bc9e\U0001d167-\U0001d169\U0001d17b-\U0001d182\U0001d185-\U0001d18b\U0001d1aa-\U0001d1ad\U0001d242-\U0001d244\U0001da00-\U0001da36\U0001da3b-\U0001da6c\U0001da75\U0001da84\U0001da9b-\U0001da9f\U0001daa1-\U0001daaf\U0001e000-\U0001e006\U0001e008-\U0001e018\U0001e01b-\U0001e021\U0001e023-\U0001e024\U0001e026-\U0001e02a\U0001e8d0-\U0001e8d6\U0001e944-\U0001e94a\U000e0100-\U000e01ef'
Nd = '0-9\u0660-\u0669\u06f0-\u06f9\u07c0-\u07c9\u0966-\u096f\u09e6-\u09ef\u0a66-\u0a6f\u0ae6-\u0aef\u0b66-\u0b6f\u0be6-\u0bef\u0c66-\u0c6f\u0ce6-\u0cef\u0d66-\u0d6f\u0de6-\u0def\u0e50-\u0e59\u0ed0-\u0ed9\u0f20-\u0f29\u1040-\u1049\u1090-\u1099\u17e0-\u17e9\u1810-\u1819\u1946-\u194f\u19d0-\u19d9\u1a80-\u1a89\u1a90-\u1a99\u1b50-\u1b59\u1bb0-\u1bb9\u1c40-\u1c49\u1c50-\u1c59\ua620-\ua629\ua8d0-\ua8d9\ua900-\ua909\ua9d0-\ua9d9\ua9f0-\ua9f9\uaa50-\uaa59\uabf0-\uabf9\uff10-\uff19\U000104a0-\U000104a9\U00010d30-\U00010d39\U00011066-\U0001106f\U000110f0-\U000110f9\U00011136-\U0001113f\U000111d0-\U000111d9\U000112f0-\U000112f9\U00011450-\U00011459\U000114d0-\U000114d9\U00011650-\U00011659\U000116c0-\U000116c9\U00011730-\U00011739\U000118e0-\U000118e9\U00011c50-\U00011c59\U00011d50-\U00011d59\U00011da0-\U00011da9\U00016a60-\U00016a69\U00016b50-\U00016b59\U0001d7ce-\U0001d7ff\U0001e950-\U0001e959'
Nl = '\u16ee-\u16f0\u2160-\u2182\u2185-\u2188\u3007\u3021-\u3029\u3038-\u303a\ua6e6-\ua6ef\U00010140-\U00010174\U00010341\U0001034a\U000103d1-\U000103d5\U00012400-\U0001246e'
No = '\xb2-\xb3\xb9\xbc-\xbe\u09f4-\u09f9\u0b72-\u0b77\u0bf0-\u0bf2\u0c78-\u0c7e\u0d58-\u0d5e\u0d70-\u0d78\u0f2a-\u0f33\u1369-\u137c\u17f0-\u17f9\u19da\u2070\u2074-\u2079\u2080-\u2089\u2150-\u215f\u2189\u2460-\u249b\u24ea-\u24ff\u2776-\u2793\u2cfd\u3192-\u3195\u3220-\u3229\u3248-\u324f\u3251-\u325f\u3280-\u3289\u32b1-\u32bf\ua830-\ua835\U00010107-\U00010133\U00010175-\U00010178\U0001018a-\U0001018b\U000102e1-\U000102fb\U00010320-\U00010323\U00010858-\U0001085f\U00010879-\U0001087f\U000108a7-\U000108af\U000108fb-\U000108ff\U00010916-\U0001091b\U000109bc-\U000109bd\U000109c0-\U000109cf\U000109d2-\U000109ff\U00010a40-\U00010a48\U00010a7d-\U00010a7e\U00010a9d-\U00010a9f\U00010aeb-\U00010aef\U00010b58-\U00010b5f\U00010b78-\U00010b7f\U00010ba9-\U00010baf\U00010cfa-\U00010cff\U00010e60-\U00010e7e\U00010f1d-\U00010f26\U00010f51-\U00010f54\U00011052-\U00011065\U000111e1-\U000111f4\U0001173a-\U0001173b\U000118ea-\U000118f2\U00011c5a-\U00011c6c\U00016b5b-\U00016b61\U00016e80-\U00016e96\U0001d2e0-\U0001d2f3\U0001d360-\U0001d378\U0001e8c7-\U0001e8cf\U0001ec71-\U0001ecab\U0001ecad-\U0001ecaf\U0001ecb1-\U0001ecb4\U0001f100-\U0001f10c'
Pc = '_\u203f-\u2040\u2054\ufe33-\ufe34\ufe4d-\ufe4f\uff3f'
Pd = '\\-\u058a\u05be\u1400\u1806\u2010-\u2015\u2e17\u2e1a\u2e3a-\u2e3b\u2e40\u301c\u3030\u30a0\ufe31-\ufe32\ufe58\ufe63\uff0d'
Pe = ')\\]}\u0f3b\u0f3d\u169c\u2046\u207e\u208e\u2309\u230b\u232a\u2769\u276b\u276d\u276f\u2771\u2773\u2775\u27c6\u27e7\u27e9\u27eb\u27ed\u27ef\u2984\u2986\u2988\u298a\u298c\u298e\u2990\u2992\u2994\u2996\u2998\u29d9\u29db\u29fd\u2e23\u2e25\u2e27\u2e29\u3009\u300b\u300d\u300f\u3011\u3015\u3017\u3019\u301b\u301e-\u301f\ufd3e\ufe18\ufe36\ufe38\ufe3a\ufe3c\ufe3e\ufe40\ufe42\ufe44\ufe48\ufe5a\ufe5c\ufe5e\uff09\uff3d\uff5d\uff60\uff63'
Pf = '\xbb\u2019\u201d\u203a\u2e03\u2e05\u2e0a\u2e0d\u2e1d\u2e21'
Pi = '\xab\u2018\u201b-\u201c\u201f\u2039\u2e02\u2e04\u2e09\u2e0c\u2e1c\u2e20'
Po = "!-#%-'*,.-/:-;?-@\\\\\xa1\xa7\xb6-\xb7\xbf\u037e\u0387\u055a-\u055f\u0589\u05c0\u05c3\u05c6\u05f3-\u05f4\u0609-\u060a\u060c-\u060d\u061b\u061e-\u061f\u066a-\u066d\u06d4\u0700-\u070d\u07f7-\u07f9\u0830-\u083e\u085e\u0964-\u0965\u0970\u09fd\u0a76\u0af0\u0c84\u0df4\u0e4f\u0e5a-\u0e5b\u0f04-\u0f12\u0f14\u0f85\u0fd0-\u0fd4\u0fd9-\u0fda\u104a-\u104f\u10fb\u1360-\u1368\u166d-\u166e\u16eb-\u16ed\u1735-\u1736\u17d4-\u17d6\u17d8-\u17da\u1800-\u1805\u1807-\u180a\u1944-\u1945\u1a1e-\u1a1f\u1aa0-\u1aa6\u1aa8-\u1aad\u1b5a-\u1b60\u1bfc-\u1bff\u1c3b-\u1c3f\u1c7e-\u1c7f\u1cc0-\u1cc7\u1cd3\u2016-\u2017\u2020-\u2027\u2030-\u2038\u203b-\u203e\u2041-\u2043\u2047-\u2051\u2053\u2055-\u205e\u2cf9-\u2cfc\u2cfe-\u2cff\u2d70\u2e00-\u2e01\u2e06-\u2e08\u2e0b\u2e0e-\u2e16\u2e18-\u2e19\u2e1b\u2e1e-\u2e1f\u2e2a-\u2e2e\u2e30-\u2e39\u2e3c-\u2e3f\u2e41\u2e43-\u2e4e\u3001-\u3003\u303d\u30fb\ua4fe-\ua4ff\ua60d-\ua60f\ua673\ua67e\ua6f2-\ua6f7\ua874-\ua877\ua8ce-\ua8cf\ua8f8-\ua8fa\ua8fc\ua92e-\ua92f\ua95f\ua9c1-\ua9cd\ua9de-\ua9df\uaa5c-\uaa5f\uaade-\uaadf\uaaf0-\uaaf1\uabeb\ufe10-\ufe16\ufe19\ufe30\ufe45-\ufe46\ufe49-\ufe4c\ufe50-\ufe52\ufe54-\ufe57\ufe5f-\ufe61\ufe68\ufe6a-\ufe6b\uff01-\uff03\uff05-\uff07\uff0a\uff0c\uff0e-\uff0f\uff1a-\uff1b\uff1f-\uff20\uff3c\uff61\uff64-\uff65\U00010100-\U00010102\U0001039f\U000103d0\U0001056f\U00010857\U0001091f\U0001093f\U00010a50-\U00010a58\U00010a7f\U00010af0-\U00010af6\U00010b39-\U00010b3f\U00010b99-\U00010b9c\U00010f55-\U00010f59\U00011047-\U0001104d\U000110bb-\U000110bc\U000110be-\U000110c1\U00011140-\U00011143\U00011174-\U00011175\U000111c5-\U000111c8\U000111cd\U000111db\U000111dd-\U000111df\U00011238-\U0001123d\U000112a9\U0001144b-\U0001144f\U0001145b\U0001145d\U000114c6\U000115c1-\U000115d7\U00011641-\U00011643\U00011660-\U0001166c\U0001173c-\U0001173e\U0001183b\U00011a3f-\U00011a46\U00011a9a-\U00011a9c\U00011a9e-\U00011aa2\U00011c41-\U00011c45\U00011c70-\U00011c71\U00011ef7-\U00011ef8\U00012470-\U00012474\U00016a6e-\U00016a6f\U00016af5\U00016b37-\U00016b3b\U00016b44\U00016e97-\U00016e9a\U0001bc9f\U0001da87-\U0001da8b\U0001e95e-\U0001e95f"
Ps = '(\\[{\u0f3a\u0f3c\u169b\u201a\u201e\u2045\u207d\u208d\u2308\u230a\u2329\u2768\u276a\u276c\u276e\u2770\u2772\u2774\u27c5\u27e6\u27e8\u27ea\u27ec\u27ee\u2983\u2985\u2987\u2989\u298b\u298d\u298f\u2991\u2993\u2995\u2997\u29d8\u29da\u29fc\u2e22\u2e24\u2e26\u2e28\u2e42\u3008\u300a\u300c\u300e\u3010\u3014\u3016\u3018\u301a\u301d\ufd3f\ufe17\ufe35\ufe37\ufe39\ufe3b\ufe3d\ufe3f\ufe41\ufe43\ufe47\ufe59\ufe5b\ufe5d\uff08\uff3b\uff5b\uff5f\uff62'
Sc = '$\xa2-\xa5\u058f\u060b\u07fe-\u07ff\u09f2-\u09f3\u09fb\u0af1\u0bf9\u0e3f\u17db\u20a0-\u20bf\ua838\ufdfc\ufe69\uff04\uffe0-\uffe1\uffe5-\uffe6\U0001ecb0'
Sk = '\\^`\xa8\xaf\xb4\xb8\u02c2-\u02c5\u02d2-\u02df\u02e5-\u02eb\u02ed\u02ef-\u02ff\u0375\u0384-\u0385\u1fbd\u1fbf-\u1fc1\u1fcd-\u1fcf\u1fdd-\u1fdf\u1fed-\u1fef\u1ffd-\u1ffe\u309b-\u309c\ua700-\ua716\ua720-\ua721\ua789-\ua78a\uab5b\ufbb2-\ufbc1\uff3e\uff40\uffe3\U0001f3fb-\U0001f3ff'
Sm = '+<->|~\xac\xb1\xd7\xf7\u03f6\u0606-\u0608\u2044\u2052\u207a-\u207c\u208a-\u208c\u2118\u2140-\u2144\u214b\u2190-\u2194\u219a-\u219b\u21a0\u21a3\u21a6\u21ae\u21ce-\u21cf\u21d2\u21d4\u21f4-\u22ff\u2320-\u2321\u237c\u239b-\u23b3\u23dc-\u23e1\u25b7\u25c1\u25f8-\u25ff\u266f\u27c0-\u27c4\u27c7-\u27e5\u27f0-\u27ff\u2900-\u2982\u2999-\u29d7\u29dc-\u29fb\u29fe-\u2aff\u2b30-\u2b44\u2b47-\u2b4c\ufb29\ufe62\ufe64-\ufe66\uff0b\uff1c-\uff1e\uff5c\uff5e\uffe2\uffe9-\uffec\U0001d6c1\U0001d6db\U0001d6fb\U0001d715\U0001d735\U0001d74f\U0001d76f\U0001d789\U0001d7a9\U0001d7c3\U0001eef0-\U0001eef1'
So = '\xa6\xa9\xae\xb0\u0482\u058d-\u058e\u060e-\u060f\u06de\u06e9\u06fd-\u06fe\u07f6\u09fa\u0b70\u0bf3-\u0bf8\u0bfa\u0c7f\u0d4f\u0d79\u0f01-\u0f03\u0f13\u0f15-\u0f17\u0f1a-\u0f1f\u0f34\u0f36\u0f38\u0fbe-\u0fc5\u0fc7-\u0fcc\u0fce-\u0fcf\u0fd5-\u0fd8\u109e-\u109f\u1390-\u1399\u1940\u19de-\u19ff\u1b61-\u1b6a\u1b74-\u1b7c\u2100-\u2101\u2103-\u2106\u2108-\u2109\u2114\u2116-\u2117\u211e-\u2123\u2125\u2127\u2129\u212e\u213a-\u213b\u214a\u214c-\u214d\u214f\u218a-\u218b\u2195-\u2199\u219c-\u219f\u21a1-\u21a2\u21a4-\u21a5\u21a7-\u21ad\u21af-\u21cd\u21d0-\u21d1\u21d3\u21d5-\u21f3\u2300-\u2307\u230c-\u231f\u2322-\u2328\u232b-\u237b\u237d-\u239a\u23b4-\u23db\u23e2-\u2426\u2440-\u244a\u249c-\u24e9\u2500-\u25b6\u25b8-\u25c0\u25c2-\u25f7\u2600-\u266e\u2670-\u2767\u2794-\u27bf\u2800-\u28ff\u2b00-\u2b2f\u2b45-\u2b46\u2b4d-\u2b73\u2b76-\u2b95\u2b98-\u2bc8\u2bca-\u2bfe\u2ce5-\u2cea\u2e80-\u2e99\u2e9b-\u2ef3\u2f00-\u2fd5\u2ff0-\u2ffb\u3004\u3012-\u3013\u3020\u3036-\u3037\u303e-\u303f\u3190-\u3191\u3196-\u319f\u31c0-\u31e3\u3200-\u321e\u322a-\u3247\u3250\u3260-\u327f\u328a-\u32b0\u32c0-\u32fe\u3300-\u33ff\u4dc0-\u4dff\ua490-\ua4c6\ua828-\ua82b\ua836-\ua837\ua839\uaa77-\uaa79\ufdfd\uffe4\uffe8\uffed-\uffee\ufffc-\ufffd\U00010137-\U0001013f\U00010179-\U00010189\U0001018c-\U0001018e\U00010190-\U0001019b\U000101a0\U000101d0-\U000101fc\U00010877-\U00010878\U00010ac8\U0001173f\U00016b3c-\U00016b3f\U00016b45\U0001bc9c\U0001d000-\U0001d0f5\U0001d100-\U0001d126\U0001d129-\U0001d164\U0001d16a-\U0001d16c\U0001d183-\U0001d184\U0001d18c-\U0001d1a9\U0001d1ae-\U0001d1e8\U0001d200-\U0001d241\U0001d245\U0001d300-\U0001d356\U0001d800-\U0001d9ff\U0001da37-\U0001da3a\U0001da6d-\U0001da74\U0001da76-\U0001da83\U0001da85-\U0001da86\U0001ecac\U0001f000-\U0001f02b\U0001f030-\U0001f093\U0001f0a0-\U0001f0ae\U0001f0b1-\U0001f0bf\U0001f0c1-\U0001f0cf\U0001f0d1-\U0001f0f5\U0001f110-\U0001f16b\U0001f170-\U0001f1ac\U0001f1e6-\U0001f202\U0001f210-\U0001f23b\U0001f240-\U0001f248\U0001f250-\U0001f251\U0001f260-\U0001f265\U0001f300-\U0001f3fa\U0001f400-\U0001f6d4\U0001f6e0-\U0001f6ec\U0001f6f0-\U0001f6f9\U0001f700-\U0001f773\U0001f780-\U0001f7d8\U0001f800-\U0001f80b\U0001f810-\U0001f847\U0001f850-\U0001f859\U0001f860-\U0001f887\U0001f890-\U0001f8ad\U0001f900-\U0001f90b\U0001f910-\U0001f93e\U0001f940-\U0001f970\U0001f973-\U0001f976\U0001f97a\U0001f97c-\U0001f9a2\U0001f9b0-\U0001f9b9\U0001f9c0-\U0001f9c2\U0001f9d0-\U0001f9ff\U0001fa60-\U0001fa6d'
Zl = '\u2028'
Zp = '\u2029'
Zs = ' \xa0\u1680\u2000-\u200a\u202f\u205f\u3000'
xid_continue = '0-9A-Z_a-z\xaa\xb5\xb7\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0300-\u0374\u0376-\u0377\u037b-\u037d\u037f\u0386-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u0483-\u0487\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u0591-\u05bd\u05bf\u05c1-\u05c2\u05c4-\u05c5\u05c7\u05d0-\u05ea\u05ef-\u05f2\u0610-\u061a\u0620-\u0669\u066e-\u06d3\u06d5-\u06dc\u06df-\u06e8\u06ea-\u06fc\u06ff\u0710-\u074a\u074d-\u07b1\u07c0-\u07f5\u07fa\u07fd\u0800-\u082d\u0840-\u085b\u0860-\u086a\u08a0-\u08b4\u08b6-\u08bd\u08d3-\u08e1\u08e3-\u0963\u0966-\u096f\u0971-\u0983\u0985-\u098c\u098f-\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bc-\u09c4\u09c7-\u09c8\u09cb-\u09ce\u09d7\u09dc-\u09dd\u09df-\u09e3\u09e6-\u09f1\u09fc\u09fe\u0a01-\u0a03\u0a05-\u0a0a\u0a0f-\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32-\u0a33\u0a35-\u0a36\u0a38-\u0a39\u0a3c\u0a3e-\u0a42\u0a47-\u0a48\u0a4b-\u0a4d\u0a51\u0a59-\u0a5c\u0a5e\u0a66-\u0a75\u0a81-\u0a83\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2-\u0ab3\u0ab5-\u0ab9\u0abc-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ad0\u0ae0-\u0ae3\u0ae6-\u0aef\u0af9-\u0aff\u0b01-\u0b03\u0b05-\u0b0c\u0b0f-\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32-\u0b33\u0b35-\u0b39\u0b3c-\u0b44\u0b47-\u0b48\u0b4b-\u0b4d\u0b56-\u0b57\u0b5c-\u0b5d\u0b5f-\u0b63\u0b66-\u0b6f\u0b71\u0b82-\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99-\u0b9a\u0b9c\u0b9e-\u0b9f\u0ba3-\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd0\u0bd7\u0be6-\u0bef\u0c00-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55-\u0c56\u0c58-\u0c5a\u0c60-\u0c63\u0c66-\u0c6f\u0c80-\u0c83\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbc-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5-\u0cd6\u0cde\u0ce0-\u0ce3\u0ce6-\u0cef\u0cf1-\u0cf2\u0d00-\u0d03\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d44\u0d46-\u0d48\u0d4a-\u0d4e\u0d54-\u0d57\u0d5f-\u0d63\u0d66-\u0d6f\u0d7a-\u0d7f\u0d82-\u0d83\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2-\u0df3\u0e01-\u0e3a\u0e40-\u0e4e\u0e50-\u0e59\u0e81-\u0e82\u0e84\u0e87-\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa-\u0eab\u0ead-\u0eb9\u0ebb-\u0ebd\u0ec0-\u0ec4\u0ec6\u0ec8-\u0ecd\u0ed0-\u0ed9\u0edc-\u0edf\u0f00\u0f18-\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e-\u0f47\u0f49-\u0f6c\u0f71-\u0f84\u0f86-\u0f97\u0f99-\u0fbc\u0fc6\u1000-\u1049\u1050-\u109d\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u135d-\u135f\u1369-\u1371\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176c\u176e-\u1770\u1772-\u1773\u1780-\u17d3\u17d7\u17dc-\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u1820-\u1878\u1880-\u18aa\u18b0-\u18f5\u1900-\u191e\u1920-\u192b\u1930-\u193b\u1946-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u19d0-\u19da\u1a00-\u1a1b\u1a20-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1aa7\u1ab0-\u1abd\u1b00-\u1b4b\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1bf3\u1c00-\u1c37\u1c40-\u1c49\u1c4d-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1cd0-\u1cd2\u1cd4-\u1cf9\u1d00-\u1df9\u1dfb-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u203f-\u2040\u2054\u2071\u207f\u2090-\u209c\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d7f-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2de0-\u2dff\u3005-\u3007\u3021-\u302f\u3031-\u3035\u3038-\u303c\u3041-\u3096\u3099-\u309a\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fef\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua62b\ua640-\ua66f\ua674-\ua67d\ua67f-\ua6f1\ua717-\ua71f\ua722-\ua788\ua78b-\ua7b9\ua7f7-\ua827\ua840-\ua873\ua880-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f7\ua8fb\ua8fd-\ua92d\ua930-\ua953\ua960-\ua97c\ua980-\ua9c0\ua9cf-\ua9d9\ua9e0-\ua9fe\uaa00-\uaa36\uaa40-\uaa4d\uaa50-\uaa59\uaa60-\uaa76\uaa7a-\uaac2\uaadb-\uaadd\uaae0-\uaaef\uaaf2-\uaaf6\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab65\uab70-\uabea\uabec-\uabed\uabf0-\uabf9\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufbb1\ufbd3-\ufc5d\ufc64-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdf9\ufe00-\ufe0f\ufe20-\ufe2f\ufe33-\ufe34\ufe4d-\ufe4f\ufe71\ufe73\ufe77\ufe79\ufe7b\ufe7d\ufe7f-\ufefc\uff10-\uff19\uff21-\uff3a\uff3f\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc\U00010000-\U0001000b\U0001000d-\U00010026\U00010028-\U0001003a\U0001003c-\U0001003d\U0001003f-\U0001004d\U00010050-\U0001005d\U00010080-\U000100fa\U00010140-\U00010174\U000101fd\U00010280-\U0001029c\U000102a0-\U000102d0\U000102e0\U00010300-\U0001031f\U0001032d-\U0001034a\U00010350-\U0001037a\U00010380-\U0001039d\U000103a0-\U000103c3\U000103c8-\U000103cf\U000103d1-\U000103d5\U00010400-\U0001049d\U000104a0-\U000104a9\U000104b0-\U000104d3\U000104d8-\U000104fb\U00010500-\U00010527\U00010530-\U00010563\U00010600-\U00010736\U00010740-\U00010755\U00010760-\U00010767\U00010800-\U00010805\U00010808\U0001080a-\U00010835\U00010837-\U00010838\U0001083c\U0001083f-\U00010855\U00010860-\U00010876\U00010880-\U0001089e\U000108e0-\U000108f2\U000108f4-\U000108f5\U00010900-\U00010915\U00010920-\U00010939\U00010980-\U000109b7\U000109be-\U000109bf\U00010a00-\U00010a03\U00010a05-\U00010a06\U00010a0c-\U00010a13\U00010a15-\U00010a17\U00010a19-\U00010a35\U00010a38-\U00010a3a\U00010a3f\U00010a60-\U00010a7c\U00010a80-\U00010a9c\U00010ac0-\U00010ac7\U00010ac9-\U00010ae6\U00010b00-\U00010b35\U00010b40-\U00010b55\U00010b60-\U00010b72\U00010b80-\U00010b91\U00010c00-\U00010c48\U00010c80-\U00010cb2\U00010cc0-\U00010cf2\U00010d00-\U00010d27\U00010d30-\U00010d39\U00010f00-\U00010f1c\U00010f27\U00010f30-\U00010f50\U00011000-\U00011046\U00011066-\U0001106f\U0001107f-\U000110ba\U000110d0-\U000110e8\U000110f0-\U000110f9\U00011100-\U00011134\U00011136-\U0001113f\U00011144-\U00011146\U00011150-\U00011173\U00011176\U00011180-\U000111c4\U000111c9-\U000111cc\U000111d0-\U000111da\U000111dc\U00011200-\U00011211\U00011213-\U00011237\U0001123e\U00011280-\U00011286\U00011288\U0001128a-\U0001128d\U0001128f-\U0001129d\U0001129f-\U000112a8\U000112b0-\U000112ea\U000112f0-\U000112f9\U00011300-\U00011303\U00011305-\U0001130c\U0001130f-\U00011310\U00011313-\U00011328\U0001132a-\U00011330\U00011332-\U00011333\U00011335-\U00011339\U0001133b-\U00011344\U00011347-\U00011348\U0001134b-\U0001134d\U00011350\U00011357\U0001135d-\U00011363\U00011366-\U0001136c\U00011370-\U00011374\U00011400-\U0001144a\U00011450-\U00011459\U0001145e\U00011480-\U000114c5\U000114c7\U000114d0-\U000114d9\U00011580-\U000115b5\U000115b8-\U000115c0\U000115d8-\U000115dd\U00011600-\U00011640\U00011644\U00011650-\U00011659\U00011680-\U000116b7\U000116c0-\U000116c9\U00011700-\U0001171a\U0001171d-\U0001172b\U00011730-\U00011739\U00011800-\U0001183a\U000118a0-\U000118e9\U000118ff\U00011a00-\U00011a3e\U00011a47\U00011a50-\U00011a83\U00011a86-\U00011a99\U00011a9d\U00011ac0-\U00011af8\U00011c00-\U00011c08\U00011c0a-\U00011c36\U00011c38-\U00011c40\U00011c50-\U00011c59\U00011c72-\U00011c8f\U00011c92-\U00011ca7\U00011ca9-\U00011cb6\U00011d00-\U00011d06\U00011d08-\U00011d09\U00011d0b-\U00011d36\U00011d3a\U00011d3c-\U00011d3d\U00011d3f-\U00011d47\U00011d50-\U00011d59\U00011d60-\U00011d65\U00011d67-\U00011d68\U00011d6a-\U00011d8e\U00011d90-\U00011d91\U00011d93-\U00011d98\U00011da0-\U00011da9\U00011ee0-\U00011ef6\U00012000-\U00012399\U00012400-\U0001246e\U00012480-\U00012543\U00013000-\U0001342e\U00014400-\U00014646\U00016800-\U00016a38\U00016a40-\U00016a5e\U00016a60-\U00016a69\U00016ad0-\U00016aed\U00016af0-\U00016af4\U00016b00-\U00016b36\U00016b40-\U00016b43\U00016b50-\U00016b59\U00016b63-\U00016b77\U00016b7d-\U00016b8f\U00016e40-\U00016e7f\U00016f00-\U00016f44\U00016f50-\U00016f7e\U00016f8f-\U00016f9f\U00016fe0-\U00016fe1\U00017000-\U000187f1\U00018800-\U00018af2\U0001b000-\U0001b11e\U0001b170-\U0001b2fb\U0001bc00-\U0001bc6a\U0001bc70-\U0001bc7c\U0001bc80-\U0001bc88\U0001bc90-\U0001bc99\U0001bc9d-\U0001bc9e\U0001d165-\U0001d169\U0001d16d-\U0001d172\U0001d17b-\U0001d182\U0001d185-\U0001d18b\U0001d1aa-\U0001d1ad\U0001d242-\U0001d244\U0001d400-\U0001d454\U0001d456-\U0001d49c\U0001d49e-\U0001d49f\U0001d4a2\U0001d4a5-\U0001d4a6\U0001d4a9-\U0001d4ac\U0001d4ae-\U0001d4b9\U0001d4bb\U0001d4bd-\U0001d4c3\U0001d4c5-\U0001d505\U0001d507-\U0001d50a\U0001d50d-\U0001d514\U0001d516-\U0001d51c\U0001d51e-\U0001d539\U0001d53b-\U0001d53e\U0001d540-\U0001d544\U0001d546\U0001d54a-\U0001d550\U0001d552-\U0001d6a5\U0001d6a8-\U0001d6c0\U0001d6c2-\U0001d6da\U0001d6dc-\U0001d6fa\U0001d6fc-\U0001d714\U0001d716-\U0001d734\U0001d736-\U0001d74e\U0001d750-\U0001d76e\U0001d770-\U0001d788\U0001d78a-\U0001d7a8\U0001d7aa-\U0001d7c2\U0001d7c4-\U0001d7cb\U0001d7ce-\U0001d7ff\U0001da00-\U0001da36\U0001da3b-\U0001da6c\U0001da75\U0001da84\U0001da9b-\U0001da9f\U0001daa1-\U0001daaf\U0001e000-\U0001e006\U0001e008-\U0001e018\U0001e01b-\U0001e021\U0001e023-\U0001e024\U0001e026-\U0001e02a\U0001e800-\U0001e8c4\U0001e8d0-\U0001e8d6\U0001e900-\U0001e94a\U0001e950-\U0001e959\U0001ee00-\U0001ee03\U0001ee05-\U0001ee1f\U0001ee21-\U0001ee22\U0001ee24\U0001ee27\U0001ee29-\U0001ee32\U0001ee34-\U0001ee37\U0001ee39\U0001ee3b\U0001ee42\U0001ee47\U0001ee49\U0001ee4b\U0001ee4d-\U0001ee4f\U0001ee51-\U0001ee52\U0001ee54\U0001ee57\U0001ee59\U0001ee5b\U0001ee5d\U0001ee5f\U0001ee61-\U0001ee62\U0001ee64\U0001ee67-\U0001ee6a\U0001ee6c-\U0001ee72\U0001ee74-\U0001ee77\U0001ee79-\U0001ee7c\U0001ee7e\U0001ee80-\U0001ee89\U0001ee8b-\U0001ee9b\U0001eea1-\U0001eea3\U0001eea5-\U0001eea9\U0001eeab-\U0001eebb\U00020000-\U0002a6d6\U0002a700-\U0002b734\U0002b740-\U0002b81d\U0002b820-\U0002cea1\U0002ceb0-\U0002ebe0\U0002f800-\U0002fa1d\U000e0100-\U000e01ef'
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/pygments/lexer.py =====
"""
    pygments.lexer
    ~~~~~~~~~~~~~~
    Base lexer classes.
    :copyright: Copyright 2006-2025 by the Pygments team, see AUTHORS.
    :license: BSD, see LICENSE for details.
"""
import re
import sys
import time
from pip._vendor.pygments.filter import apply_filters, Filter
from pip._vendor.pygments.filters import get_filter_by_name
from pip._vendor.pygments.token import Error, Text, Other, Whitespace, _TokenType
from pip._vendor.pygments.util import get_bool_opt, get_int_opt, get_list_opt, \
    make_analysator, Future, guess_decode
from pip._vendor.pygments.regexopt import regex_opt
__all__ = ['Lexer', 'RegexLexer', 'ExtendedRegexLexer', 'DelegatingLexer',
           'LexerContext', 'include', 'inherit', 'bygroups', 'using', 'this',
           'default', 'words', 'line_re']
line_re = re.compile('.*?\n')
_encoding_map = [(b'\xef\xbb\xbf', 'utf-8'),
                 (b'\xff\xfe\0\0', 'utf-32'),
                 (b'\0\0\xfe\xff', 'utf-32be'),
                 (b'\xff\xfe', 'utf-16'),
                 (b'\xfe\xff', 'utf-16be')]
_default_analyse = staticmethod(lambda x: 0.0)
class LexerMeta(type):
    """
    This metaclass automagically converts ``analyse_text`` methods into
    static methods which always return float values.
    """
    def __new__(mcs, name, bases, d):
        if 'analyse_text' in d:
            d['analyse_text'] = make_analysator(d['analyse_text'])
        return type.__new__(mcs, name, bases, d)
class Lexer(metaclass=LexerMeta):
    """
    Lexer for a specific language.
    See also :doc:`lexerdevelopment`, a high-level guide to writing
    lexers.
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/pygments/regexopt.py =====
"""
    pygments.regexopt
    ~~~~~~~~~~~~~~~~~
    An algorithm that generates optimized regexes for matching long lists of
    literal strings.
    :copyright: Copyright 2006-2025 by the Pygments team, see AUTHORS.
    :license: BSD, see LICENSE for details.
"""
import re
from re import escape
from os.path import commonprefix
from itertools import groupby
from operator import itemgetter
CS_ESCAPE = re.compile(r'[\[\^\\\-\]]')
FIRST_ELEMENT = itemgetter(0)
def make_charset(letters):
    return '[' + CS_ESCAPE.sub(lambda m: '\\' + m.group(), ''.join(letters)) + ']'
def regex_opt_inner(strings, open_paren):
    """Return a regex that matches any string in the sorted list of strings."""
    close_paren = open_paren and ')' or ''
    # print strings, repr(open_paren)
    if not strings:
        # print '-> nothing left'
        return ''
    first = strings[0]
    if len(strings) == 1:
        # print '-> only 1 string'
        return open_paren + escape(first) + close_paren
    if not first:
        # print '-> first string empty'
        return open_paren + regex_opt_inner(strings[1:], '(?:') \
            + '?' + close_paren
    if len(first) == 1:
        # multiple one-char strings? make a charset
        oneletter = []
        rest = []
        for s in strings:
            if len(s) == 1:
                oneletter.append(s)
            else:
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/pygments/plugin.py =====
"""
    pygments.plugin
    ~~~~~~~~~~~~~~~
    Pygments plugin interface.
    lexer plugins::
        [pygments.lexers]
        yourlexer = yourmodule:YourLexer
    formatter plugins::
        [pygments.formatters]
        yourformatter = yourformatter:YourFormatter
        /.ext = yourformatter:YourFormatter
    As you can see, you can define extensions for the formatter
    with a leading slash.
    syntax plugins::
        [pygments.styles]
        yourstyle = yourstyle:YourStyle
    filter plugin::
        [pygments.filter]
        yourfilter = yourfilter:YourFilter
    :copyright: Copyright 2006-2025 by the Pygments team, see AUTHORS.
    :license: BSD, see LICENSE for details.
"""
from importlib.metadata import entry_points
LEXER_ENTRY_POINT = 'pygments.lexers'
FORMATTER_ENTRY_POINT = 'pygments.formatters'
STYLE_ENTRY_POINT = 'pygments.styles'
FILTER_ENTRY_POINT = 'pygments.filters'
def iter_entry_points(group_name):
    groups = entry_points()
    if hasattr(groups, 'select'):
        # New interface in Python 3.10 and newer versions of the
        # importlib_metadata backport.
        return groups.select(group=group_name)
    else:
        # Older interface, deprecated in Python 3.10 and recent
        # importlib_metadata, but we need it in Python 3.8 and 3.9.
        return groups.get(group_name, [])
def find_plugin_lexers():
    for entrypoint in iter_entry_points(LEXER_ENTRY_POINT):
        yield entrypoint.load()
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/pygments/filter.py =====
"""
    pygments.filter
    ~~~~~~~~~~~~~~~
    Module that implements the default filter.
    :copyright: Copyright 2006-2025 by the Pygments team, see AUTHORS.
    :license: BSD, see LICENSE for details.
"""
def apply_filters(stream, filters, lexer=None):
    """
    Use this method to apply an iterable of filters to
    a stream. If lexer is given it's forwarded to the
    filter, otherwise the filter receives `None`.
    """
    def _apply(filter_, stream):
        yield from filter_.filter(lexer, stream)
    for filter_ in filters:
        stream = _apply(filter_, stream)
    return stream
def simplefilter(f):
    """
    Decorator that converts a function into a filter::
        @simplefilter
        def lowercase(self, lexer, stream, options):
            for ttype, value in stream:
                yield ttype, value.lower()
    """
    return type(f.__name__, (FunctionFilter,), {
        '__module__': getattr(f, '__module__'),
        '__doc__': f.__doc__,
        'function': f,
    })
class Filter:
    """
    Default filter. Subclass this class or use the `simplefilter`
    decorator to create own filters.
    """
    def __init__(self, **options):
        self.options = options
    def filter(self, lexer, stream):
        raise NotImplementedError()
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/pygments/__main__.py =====
"""
    pygments.__main__
    ~~~~~~~~~~~~~~~~~
    Main entry point for ``python -m pygments``.
    :copyright: Copyright 2006-2025 by the Pygments team, see AUTHORS.
    :license: BSD, see LICENSE for details.
"""
import sys
from pip._vendor.pygments.cmdline import main
try:
    sys.exit(main(sys.argv))
except KeyboardInterrupt:
    sys.exit(1)
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/distlib/compat.py =====
from __future__ import absolute_import
import os
import re
import shutil
import sys
try:
    import ssl
except ImportError:  # pragma: no cover
    ssl = None
if sys.version_info[0] < 3:  # pragma: no cover
    from StringIO import StringIO
    string_types = basestring,
    text_type = unicode
    from types import FileType as file_type
    import __builtin__ as builtins
    import ConfigParser as configparser
    from urlparse import urlparse, urlunparse, urljoin, urlsplit, urlunsplit
    from urllib import (urlretrieve, quote as _quote, unquote, url2pathname,
                        pathname2url, ContentTooShortError, splittype)
    def quote(s):
        if isinstance(s, unicode):
            s = s.encode('utf-8')
        return _quote(s)
    import urllib2
    from urllib2 import (Request, urlopen, URLError, HTTPError,
                         HTTPBasicAuthHandler, HTTPPasswordMgr, HTTPHandler,
                         HTTPRedirectHandler, build_opener)
    if ssl:
        from urllib2 import HTTPSHandler
    import httplib
    import xmlrpclib
    import Queue as queue
    from HTMLParser import HTMLParser
    import htmlentitydefs
    raw_input = raw_input
    from itertools import ifilter as filter
    from itertools import ifilterfalse as filterfalse
    # Leaving this around for now, in case it needs resurrecting in some way
    # _userprog = None
    # def splituser(host):
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/distlib/util.py =====
import codecs
from collections import deque
import contextlib
import csv
from glob import iglob as std_iglob
import io
import json
import logging
import os
import py_compile
import re
import socket
try:
    import ssl
except ImportError:  # pragma: no cover
    ssl = None
import subprocess
import sys
import tarfile
import tempfile
import textwrap
try:
    import threading
except ImportError:  # pragma: no cover
    import dummy_threading as threading
import time
from . import DistlibException
from .compat import (string_types, text_type, shutil, raw_input, StringIO, cache_from_source, urlopen, urljoin, httplib,
                     xmlrpclib, HTTPHandler, BaseConfigurator, valid_ident, Container, configparser, URLError, ZipFile,
                     fsdecode, unquote, urlparse)
logger = logging.getLogger(__name__)
IDENTIFIER = re.compile(r'^([\w\.-]+)\s*')
VERSION_IDENTIFIER = re.compile(r'^([\w\.*+-]+)\s*')
COMPARE_OP = re.compile(r'^(<=?|>=?|={2,3}|[~!]=)\s*')
MARKER_OP = re.compile(r'^((<=?)|(>=?)|={2,3}|[~!]=|in|not\s+in)\s*')
OR = re.compile(r'^or\b\s*')
AND = re.compile(r'^and\b\s*')
NON_SPACE = re.compile(r'(\S+)\s*')
STRING_CHUNK = re.compile(r'([\s\w\.{}()*+#:;,/?!~`@$%^&=|<>\[\]-]+)')
def parse_marker(marker_string):
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/distlib/__init__.py =====
import logging
__version__ = '0.4.0'
class DistlibException(Exception):
    pass
try:
    from logging import NullHandler
except ImportError:  # pragma: no cover
    class NullHandler(logging.Handler):
        def handle(self, record):
            pass
        def emit(self, record):
            pass
        def createLock(self):
            self.lock = None
logger = logging.getLogger(__name__)
logger.addHandler(NullHandler())
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/distlib/resources.py =====
from __future__ import unicode_literals
import bisect
import io
import logging
import os
import pkgutil
import sys
import types
import zipimport
from . import DistlibException
from .util import cached_property, get_cache_base, Cache
logger = logging.getLogger(__name__)
cache = None    # created when needed
class ResourceCache(Cache):
    def __init__(self, base=None):
        if base is None:
            # Use native string to avoid issues on 2.x: see Python #20140.
            base = os.path.join(get_cache_base(), str('resource-cache'))
        super(ResourceCache, self).__init__(base)
    def is_stale(self, resource, path):
        """
        Is the cache stale for the given resource?
        :param resource: The :class:`Resource` being cached.
        :param path: The path of the resource in the cache.
        :return: True if the cache is stale.
        """
        # Cache invalidation is a hard problem :-)
        return True
    def get(self, resource):
        """
        Get a resource into the cache,
        :param resource: A :class:`Resource` instance.
        :return: The pathname of the resource in the cache.
        """
        prefix, path = resource.finder.get_cache_info(resource)
        if prefix is None:
            result = path
        else:
            result = os.path.join(self.base, self.prefix_to_dir(prefix), path)
            dirname = os.path.dirname(result)
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/distlib/scripts.py =====
from io import BytesIO
import logging
import os
import re
import struct
import sys
import time
from zipfile import ZipInfo
from .compat import sysconfig, detect_encoding, ZipFile
from .resources import finder
from .util import (FileOperator, get_export_entry, convert_path, get_executable, get_platform, in_venv)
logger = logging.getLogger(__name__)
_DEFAULT_MANIFEST = '''
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
 <assemblyIdentity version="1.0.0.0"
 processorArchitecture="X86"
 name="%s"
 type="win32"/>
 <!-- Identify the application security requirements. -->
 <trustInfo xmlns="urn:schemas-microsoft-com:asm.v3">
 <security>
 <requestedPrivileges>
 <requestedExecutionLevel level="asInvoker" uiAccess="false"/>
 </requestedPrivileges>
 </security>
 </trustInfo>
</assembly>'''.strip()
FIRST_LINE_RE = re.compile(b'^#!.*pythonw?[0-9.]*([ \t].*)?$')
SCRIPT_TEMPLATE = r'''# -*- coding: utf-8 -*-
import re
import sys
if __name__ == '__main__':
    from %(module)s import %(import_name)s
    sys.argv[0] = re.sub(r'(-script\.pyw|\.exe)?$', '', sys.argv[0])
    sys.exit(%(func)s())
'''
if os.name == 'nt' or (os.name == 'java' and os._name == 'nt'):
    # Issue 31: don't hardcode an absolute package name, but
    # determine it relative to the current package
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/distro/__init__.py =====
from .distro import (
    NORMALIZED_DISTRO_ID,
    NORMALIZED_LSB_ID,
    NORMALIZED_OS_ID,
    LinuxDistribution,
    __version__,
    build_number,
    codename,
    distro_release_attr,
    distro_release_info,
    id,
    info,
    like,
    linux_distribution,
    lsb_release_attr,
    lsb_release_info,
    major_version,
    minor_version,
    name,
    os_release_attr,
    os_release_info,
    uname_attr,
    uname_info,
    version,
    version_parts,
)
__all__ = [
    "NORMALIZED_DISTRO_ID",
    "NORMALIZED_LSB_ID",
    "NORMALIZED_OS_ID",
    "LinuxDistribution",
    "build_number",
    "codename",
    "distro_release_attr",
    "distro_release_info",
    "id",
    "info",
    "like",
    "linux_distribution",
    "lsb_release_attr",
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/distro/distro.py =====
"""
The ``distro`` package (``distro`` stands for Linux Distribution) provides
information about the Linux distribution it runs on, such as a reliable
machine-readable distro ID, or version information.
It is the recommended replacement for Python's original
:py:func:`platform.linux_distribution` function, but it provides much more
functionality. An alternative implementation became necessary because Python
3.5 deprecated this function, and Python 3.8 removed it altogether. Its
predecessor function :py:func:`platform.dist` was already deprecated since
Python 2.6 and removed in Python 3.8. Still, there are many cases in which
access to OS distribution information is needed. See `Python issue 1322
<https://bugs.python.org/issue1322>`_ for more information.
"""
import argparse
import json
import logging
import os
import re
import shlex
import subprocess
import sys
import warnings
from typing import (
    Any,
    Callable,
    Dict,
    Iterable,
    Optional,
    Sequence,
    TextIO,
    Tuple,
    Type,
)
try:
    from typing import TypedDict
except ImportError:
    # Python 3.7
    TypedDict = dict
__version__ = "1.9.0"
class VersionDict(TypedDict):
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/distro/__main__.py =====
from .distro import main
if __name__ == "__main__":
    main()
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/cachecontrol/serialize.py =====
from __future__ import annotations
import io
from typing import IO, TYPE_CHECKING, Any, Mapping, cast
from pip._vendor import msgpack
from pip._vendor.requests.structures import CaseInsensitiveDict
from pip._vendor.urllib3 import HTTPResponse
if TYPE_CHECKING:
    from pip._vendor.requests import PreparedRequest
class Serializer:
    serde_version = "4"
    def dumps(
        self,
        request: PreparedRequest,
        response: HTTPResponse,
        body: bytes | None = None,
    ) -> bytes:
        response_headers: CaseInsensitiveDict[str] = CaseInsensitiveDict(
            response.headers
        )
        if body is None:
            # When a body isn't passed in, we'll read the response. We
            # also update the response with a new file handler to be
            # sure it acts as though it was never read.
            body = response.read(decode_content=False)
            response._fp = io.BytesIO(body)  # type: ignore[assignment]
            response.length_remaining = len(body)
        data = {
            "response": {
                "body": body,  # Empty bytestring if body is stored separately
                "headers": {str(k): str(v) for k, v in response.headers.items()},
                "status": response.status,
                "version": response.version,
                "reason": str(response.reason),
                "decode_content": response.decode_content,
            }
        }
        # Construct our vary headers
        data["vary"] = {}
        if "vary" in response_headers:
            varied_headers = response_headers["vary"].split(",")
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/cachecontrol/wrapper.py =====
from __future__ import annotations
from typing import TYPE_CHECKING, Collection
from pip._vendor.cachecontrol.adapter import CacheControlAdapter
from pip._vendor.cachecontrol.cache import DictCache
if TYPE_CHECKING:
    from pip._vendor import requests
    from pip._vendor.cachecontrol.cache import BaseCache
    from pip._vendor.cachecontrol.controller import CacheController
    from pip._vendor.cachecontrol.heuristics import BaseHeuristic
    from pip._vendor.cachecontrol.serialize import Serializer
def CacheControl(
    sess: requests.Session,
    cache: BaseCache | None = None,
    cache_etags: bool = True,
    serializer: Serializer | None = None,
    heuristic: BaseHeuristic | None = None,
    controller_class: type[CacheController] | None = None,
    adapter_class: type[CacheControlAdapter] | None = None,
    cacheable_methods: Collection[str] | None = None,
) -> requests.Session:
    cache = DictCache() if cache is None else cache
    adapter_class = adapter_class or CacheControlAdapter
    adapter = adapter_class(
        cache,
        cache_etags=cache_etags,
        serializer=serializer,
        heuristic=heuristic,
        controller_class=controller_class,
        cacheable_methods=cacheable_methods,
    )
    sess.mount("http://", adapter)
    sess.mount("https://", adapter)
    return sess
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/cachecontrol/controller.py =====
"""
The httplib2 algorithms ported for use with requests.
"""
from __future__ import annotations
import calendar
import logging
import re
import time
import weakref
from email.utils import parsedate_tz
from typing import TYPE_CHECKING, Collection, Mapping
from pip._vendor.requests.structures import CaseInsensitiveDict
from pip._vendor.cachecontrol.cache import DictCache, SeparateBodyBaseCache
from pip._vendor.cachecontrol.serialize import Serializer
if TYPE_CHECKING:
    from typing import Literal
    from pip._vendor.requests import PreparedRequest
    from pip._vendor.urllib3 import HTTPResponse
    from pip._vendor.cachecontrol.cache import BaseCache
logger = logging.getLogger(__name__)
URI = re.compile(r"^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?")
PERMANENT_REDIRECT_STATUSES = (301, 308)
def parse_uri(uri: str) -> tuple[str, str, str, str, str]:
    """Parses a URI using the regex given in Appendix B of RFC 3986.
    (scheme, authority, path, query, fragment) = parse_uri(uri)
    """
    match = URI.match(uri)
    assert match is not None
    groups = match.groups()
    return (groups[1], groups[3], groups[4], groups[6], groups[8])
class CacheController:
    """An interface to see if request should cached or not."""
    def __init__(
        self,
        cache: BaseCache | None = None,
        cache_etags: bool = True,
        serializer: Serializer | None = None,
        status_codes: Collection[int] | None = None,
    ):
        self.cache = DictCache() if cache is None else cache
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/cachecontrol/filewrapper.py =====
from __future__ import annotations
import mmap
from tempfile import NamedTemporaryFile
from typing import TYPE_CHECKING, Any, Callable
if TYPE_CHECKING:
    from http.client import HTTPResponse
class CallbackFileWrapper:
    """
    Small wrapper around a fp object which will tee everything read into a
    buffer, and when that file is closed it will execute a callback with the
    contents of that buffer.
    All attributes are proxied to the underlying file object.
    This class uses members with a double underscore (__) leading prefix so as
    not to accidentally shadow an attribute.
    The data is stored in a temporary file until it is all available.  As long
    as the temporary files directory is disk-based (sometimes it's a
    memory-backed-``tmpfs`` on Linux), data will be unloaded to disk if memory
    pressure is high.  For small files the disk usually won't be used at all,
    it'll all be in the filesystem memory cache, so there should be no
    performance impact.
    """
    def __init__(
        self, fp: HTTPResponse, callback: Callable[[bytes], None] | None
    ) -> None:
        self.__buf = NamedTemporaryFile("rb+", delete=True)
        self.__fp = fp
        self.__callback = callback
    def __getattr__(self, name: str) -> Any:
        # The vagaries of garbage collection means that self.__fp is
        # not always set.  By using __getattribute__ and the private
        # name[0] allows looking up the attribute value and raising an
        # AttributeError when it doesn't exist. This stop things from
        # infinitely recursing calls to getattr in the case where
        # self.__fp hasn't been set.
        #
        # [0] https://docs.python.org/2/reference/expressions.html#atom-identifiers
        fp = self.__getattribute__("_CallbackFileWrapper__fp")
        return getattr(fp, name)
    def __is_fp_closed(self) -> bool:
        try:
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/cachecontrol/heuristics.py =====
from __future__ import annotations
import calendar
import time
from datetime import datetime, timedelta, timezone
from email.utils import formatdate, parsedate, parsedate_tz
from typing import TYPE_CHECKING, Any, Mapping
if TYPE_CHECKING:
    from pip._vendor.urllib3 import HTTPResponse
TIME_FMT = "%a, %d %b %Y %H:%M:%S GMT"
def expire_after(delta: timedelta, date: datetime | None = None) -> datetime:
    date = date or datetime.now(timezone.utc)
    return date + delta
def datetime_to_header(dt: datetime) -> str:
    return formatdate(calendar.timegm(dt.timetuple()))
class BaseHeuristic:
    def warning(self, response: HTTPResponse) -> str | None:
        """
        Return a valid 1xx warning header value describing the cache
        adjustments.
        The response is provided too allow warnings like 113
        http://tools.ietf.org/html/rfc7234#section-5.5.4 where we need
        to explicitly say response is over 24 hours old.
        """
        return '110 - "Response is Stale"'
    def update_headers(self, response: HTTPResponse) -> dict[str, str]:
        """Update the response headers with any new headers.
        NOTE: This SHOULD always include some Warning header to
              signify that the response was cached by the client, not
              by way of the provided headers.
        """
        return {}
    def apply(self, response: HTTPResponse) -> HTTPResponse:
        updated_headers = self.update_headers(response)
        if updated_headers:
            response.headers.update(updated_headers)
            warning_header_value = self.warning(response)
            if warning_header_value is not None:
                response.headers.update({"Warning": warning_header_value})
        return response
class OneDayCache(BaseHeuristic):
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/cachecontrol/adapter.py =====
from __future__ import annotations
import functools
import types
import weakref
import zlib
from typing import TYPE_CHECKING, Any, Collection, Mapping
from pip._vendor.requests.adapters import HTTPAdapter
from pip._vendor.cachecontrol.cache import DictCache
from pip._vendor.cachecontrol.controller import PERMANENT_REDIRECT_STATUSES, CacheController
from pip._vendor.cachecontrol.filewrapper import CallbackFileWrapper
if TYPE_CHECKING:
    from pip._vendor.requests import PreparedRequest, Response
    from pip._vendor.urllib3 import HTTPResponse
    from pip._vendor.cachecontrol.cache import BaseCache
    from pip._vendor.cachecontrol.heuristics import BaseHeuristic
    from pip._vendor.cachecontrol.serialize import Serializer
class CacheControlAdapter(HTTPAdapter):
    invalidating_methods = {"PUT", "PATCH", "DELETE"}
    def __init__(
        self,
        cache: BaseCache | None = None,
        cache_etags: bool = True,
        controller_class: type[CacheController] | None = None,
        serializer: Serializer | None = None,
        heuristic: BaseHeuristic | None = None,
        cacheable_methods: Collection[str] | None = None,
        *args: Any,
        **kw: Any,
    ) -> None:
        super().__init__(*args, **kw)
        self.cache = DictCache() if cache is None else cache
        self.heuristic = heuristic
        self.cacheable_methods = cacheable_methods or ("GET",)
        controller_factory = controller_class or CacheController
        self.controller = controller_factory(
            self.cache, cache_etags=cache_etags, serializer=serializer
        )
    def send(
        self,
        request: PreparedRequest,
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/cachecontrol/cache.py =====
"""
The cache object API for implementing caches. The default is a thread
safe in-memory dictionary.
"""
from __future__ import annotations
from threading import Lock
from typing import IO, TYPE_CHECKING, MutableMapping
if TYPE_CHECKING:
    from datetime import datetime
class BaseCache:
    def get(self, key: str) -> bytes | None:
        raise NotImplementedError()
    def set(
        self, key: str, value: bytes, expires: int | datetime | None = None
    ) -> None:
        raise NotImplementedError()
    def delete(self, key: str) -> None:
        raise NotImplementedError()
    def close(self) -> None:
        pass
class DictCache(BaseCache):
    def __init__(self, init_dict: MutableMapping[str, bytes] | None = None) -> None:
        self.lock = Lock()
        self.data = init_dict or {}
    def get(self, key: str) -> bytes | None:
        return self.data.get(key, None)
    def set(
        self, key: str, value: bytes, expires: int | datetime | None = None
    ) -> None:
        with self.lock:
            self.data.update({key: value})
    def delete(self, key: str) -> None:
        with self.lock:
            if key in self.data:
                self.data.pop(key)
class SeparateBodyBaseCache(BaseCache):
    """
    In this variant, the body is not stored mixed in with the metadata, but is
    passed in (as a bytes-like object) in a separate call to ``set_body()``.
    That is, the expected interaction pattern is::
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/cachecontrol/__init__.py =====
"""CacheControl import Interface.
Make it easy to import from cachecontrol without long namespaces.
"""
__author__ = "Eric Larson"
__email__ = "eric@ionrock.org"
__version__ = "0.14.3"
from pip._vendor.cachecontrol.adapter import CacheControlAdapter
from pip._vendor.cachecontrol.controller import CacheController
from pip._vendor.cachecontrol.wrapper import CacheControl
__all__ = [
    "__author__",
    "__email__",
    "__version__",
    "CacheControlAdapter",
    "CacheController",
    "CacheControl",
]
import logging
logging.getLogger(__name__).addHandler(logging.NullHandler())
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/cachecontrol/_cmd.py =====
from __future__ import annotations
import logging
from argparse import ArgumentParser
from typing import TYPE_CHECKING
from pip._vendor import requests
from pip._vendor.cachecontrol.adapter import CacheControlAdapter
from pip._vendor.cachecontrol.cache import DictCache
from pip._vendor.cachecontrol.controller import logger
if TYPE_CHECKING:
    from argparse import Namespace
    from pip._vendor.cachecontrol.controller import CacheController
def setup_logging() -> None:
    logger.setLevel(logging.DEBUG)
    handler = logging.StreamHandler()
    logger.addHandler(handler)
def get_session() -> requests.Session:
    adapter = CacheControlAdapter(
        DictCache(), cache_etags=True, serializer=None, heuristic=None
    )
    sess = requests.Session()
    sess.mount("http://", adapter)
    sess.mount("https://", adapter)
    sess.cache_controller = adapter.controller  # type: ignore[attr-defined]
    return sess
def get_args() -> Namespace:
    parser = ArgumentParser()
    parser.add_argument("url", help="The URL to try and cache")
    return parser.parse_args()
def main() -> None:
    args = get_args()
    sess = get_session()
    # Make a request to get a response
    resp = sess.get(args.url)
    # Turn on logging
    setup_logging()
    # try setting the cache
    cache_controller: CacheController = (
        sess.cache_controller  # type: ignore[attr-defined]
    )
    cache_controller.cache_response(resp.request, resp.raw)
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/cachecontrol/caches/file_cache.py =====
from __future__ import annotations
import hashlib
import os
import tempfile
from textwrap import dedent
from typing import IO, TYPE_CHECKING
from pathlib import Path
from pip._vendor.cachecontrol.cache import BaseCache, SeparateBodyBaseCache
from pip._vendor.cachecontrol.controller import CacheController
if TYPE_CHECKING:
    from datetime import datetime
    from filelock import BaseFileLock
class _FileCacheMixin:
    """Shared implementation for both FileCache variants."""
    def __init__(
        self,
        directory: str | Path,
        forever: bool = False,
        filemode: int = 0o0600,
        dirmode: int = 0o0700,
        lock_class: type[BaseFileLock] | None = None,
    ) -> None:
        try:
            if lock_class is None:
                from filelock import FileLock
                lock_class = FileLock
        except ImportError:
            notice = dedent(
                """
            NOTE: In order to use the FileCache you must have
            filelock installed. You can install it via pip:
              pip install cachecontrol[filecache]
            """
            )
            raise ImportError(notice)
        self.directory = directory
        self.forever = forever
        self.filemode = filemode
        self.dirmode = dirmode
        self.lock_class = lock_class
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/cachecontrol/caches/__init__.py =====
from pip._vendor.cachecontrol.caches.file_cache import FileCache, SeparateBodyFileCache
from pip._vendor.cachecontrol.caches.redis_cache import RedisCache
__all__ = ["FileCache", "SeparateBodyFileCache", "RedisCache"]
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/cachecontrol/caches/redis_cache.py =====
from __future__ import annotations
from datetime import datetime, timezone
from typing import TYPE_CHECKING
from pip._vendor.cachecontrol.cache import BaseCache
if TYPE_CHECKING:
    from redis import Redis
class RedisCache(BaseCache):
    def __init__(self, conn: Redis[bytes]) -> None:
        self.conn = conn
    def get(self, key: str) -> bytes | None:
        return self.conn.get(key)
    def set(
        self, key: str, value: bytes, expires: int | datetime | None = None
    ) -> None:
        if not expires:
            self.conn.set(key, value)
        elif isinstance(expires, datetime):
            now_utc = datetime.now(timezone.utc)
            if expires.tzinfo is None:
                now_utc = now_utc.replace(tzinfo=None)
            delta = expires - now_utc
            self.conn.setex(key, int(delta.total_seconds()), value)
        else:
            self.conn.setex(key, expires, value)
    def delete(self, key: str) -> None:
        self.conn.delete(key)
    def clear(self) -> None:
        """Helper for clearing all the keys in a database. Use with
        caution!"""
        for key in self.conn.keys():
            self.conn.delete(key)
    def close(self) -> None:
        """Redis uses connection pooling, no need to close the connection."""
        pass
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/idna/intranges.py =====
"""
Given a list of integers, made up of (hopefully) a small number of long runs
of consecutive integers, compute a representation of the form
((start1, end1), (start2, end2) ...). Then answer the question "was x present
in the original list?" in time O(log(# runs)).
"""
import bisect
from typing import List, Tuple
def intranges_from_list(list_: List[int]) -> Tuple[int, ...]:
    """Represent a list of integers as a sequence of ranges:
    ((start_0, end_0), (start_1, end_1), ...), such that the original
    integers are exactly those x such that start_i <= x < end_i for some i.
    Ranges are encoded as single integers (start << 32 | end), not as tuples.
    """
    sorted_list = sorted(list_)
    ranges = []
    last_write = -1
    for i in range(len(sorted_list)):
        if i + 1 < len(sorted_list):
            if sorted_list[i] == sorted_list[i + 1] - 1:
                continue
        current_range = sorted_list[last_write + 1 : i + 1]
        ranges.append(_encode_range(current_range[0], current_range[-1] + 1))
        last_write = i
    return tuple(ranges)
def _encode_range(start: int, end: int) -> int:
    return (start << 32) | end
def _decode_range(r: int) -> Tuple[int, int]:
    return (r >> 32), (r & ((1 << 32) - 1))
def intranges_contain(int_: int, ranges: Tuple[int, ...]) -> bool:
    """Determine if `int_` falls into one of the ranges in `ranges`."""
    tuple_ = _encode_range(int_, 0)
    pos = bisect.bisect_left(ranges, tuple_)
    # we could be immediately ahead of a tuple (start, end)
    # with start < int_ <= end
    if pos > 0:
        left, right = _decode_range(ranges[pos - 1])
        if left <= int_ < right:
            return True
    # or we could be immediately behind a tuple (int_, end)
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/idna/package_data.py =====
__version__ = "3.10"
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/idna/compat.py =====
from typing import Any, Union
from .core import decode, encode
def ToASCII(label: str) -> bytes:
    return encode(label)
def ToUnicode(label: Union[bytes, bytearray]) -> str:
    return decode(label)
def nameprep(s: Any) -> None:
    raise NotImplementedError("IDNA 2008 does not utilise nameprep protocol")
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/idna/idnadata.py =====
__version__ = "15.1.0"
scripts = {
    "Greek": (
        0x37000000374,
        0x37500000378,
        0x37A0000037E,
        0x37F00000380,
        0x38400000385,
        0x38600000387,
        0x3880000038B,
        0x38C0000038D,
        0x38E000003A2,
        0x3A3000003E2,
        0x3F000000400,
        0x1D2600001D2B,
        0x1D5D00001D62,
        0x1D6600001D6B,
        0x1DBF00001DC0,
        0x1F0000001F16,
        0x1F1800001F1E,
        0x1F2000001F46,
        0x1F4800001F4E,
        0x1F5000001F58,
        0x1F5900001F5A,
        0x1F5B00001F5C,
        0x1F5D00001F5E,
        0x1F5F00001F7E,
        0x1F8000001FB5,
        0x1FB600001FC5,
        0x1FC600001FD4,
        0x1FD600001FDC,
        0x1FDD00001FF0,
        0x1FF200001FF5,
        0x1FF600001FFF,
        0x212600002127,
        0xAB650000AB66,
        0x101400001018F,
        0x101A0000101A1,
        0x1D2000001D246,
    ),
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/idna/__init__.py =====
from .core import (
    IDNABidiError,
    IDNAError,
    InvalidCodepoint,
    InvalidCodepointContext,
    alabel,
    check_bidi,
    check_hyphen_ok,
    check_initial_combiner,
    check_label,
    check_nfc,
    decode,
    encode,
    ulabel,
    uts46_remap,
    valid_contextj,
    valid_contexto,
    valid_label_length,
    valid_string_length,
)
from .intranges import intranges_contain
from .package_data import __version__
__all__ = [
    "__version__",
    "IDNABidiError",
    "IDNAError",
    "InvalidCodepoint",
    "InvalidCodepointContext",
    "alabel",
    "check_bidi",
    "check_hyphen_ok",
    "check_initial_combiner",
    "check_label",
    "check_nfc",
    "decode",
    "encode",
    "intranges_contain",
    "ulabel",
    "uts46_remap",
    "valid_contextj",
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/idna/core.py =====
import bisect
import re
import unicodedata
from typing import Optional, Union
from . import idnadata
from .intranges import intranges_contain
_virama_combining_class = 9
_alabel_prefix = b"xn--"
_unicode_dots_re = re.compile("[\u002e\u3002\uff0e\uff61]")
class IDNAError(UnicodeError):
    """Base exception for all IDNA-encoding related problems"""
    pass
class IDNABidiError(IDNAError):
    """Exception when bidirectional requirements are not satisfied"""
    pass
class InvalidCodepoint(IDNAError):
    """Exception when a disallowed or unallocated codepoint is used"""
    pass
class InvalidCodepointContext(IDNAError):
    """Exception when the codepoint is not valid in the context it is used"""
    pass
def _combining_class(cp: int) -> int:
    v = unicodedata.combining(chr(cp))
    if v == 0:
        if not unicodedata.name(chr(cp)):
            raise ValueError("Unknown character in unicodedata")
    return v
def _is_script(cp: str, script: str) -> bool:
    return intranges_contain(ord(cp), idnadata.scripts[script])
def _punycode(s: str) -> bytes:
    return s.encode("punycode")
def _unot(s: int) -> str:
    return "U+{:04X}".format(s)
def valid_label_length(label: Union[bytes, str]) -> bool:
    if len(label) > 63:
        return False
    return True
def valid_string_length(label: Union[bytes, str], trailing_dot: bool) -> bool:
    if len(label) > (254 if trailing_dot else 253):
        return False
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/idna/codec.py =====
import codecs
import re
from typing import Any, Optional, Tuple
from .core import IDNAError, alabel, decode, encode, ulabel
_unicode_dots_re = re.compile("[\u002e\u3002\uff0e\uff61]")
class Codec(codecs.Codec):
    def encode(self, data: str, errors: str = "strict") -> Tuple[bytes, int]:
        if errors != "strict":
            raise IDNAError('Unsupported error handling "{}"'.format(errors))
        if not data:
            return b"", 0
        return encode(data), len(data)
    def decode(self, data: bytes, errors: str = "strict") -> Tuple[str, int]:
        if errors != "strict":
            raise IDNAError('Unsupported error handling "{}"'.format(errors))
        if not data:
            return "", 0
        return decode(data), len(data)
class IncrementalEncoder(codecs.BufferedIncrementalEncoder):
    def _buffer_encode(self, data: str, errors: str, final: bool) -> Tuple[bytes, int]:
        if errors != "strict":
            raise IDNAError('Unsupported error handling "{}"'.format(errors))
        if not data:
            return b"", 0
        labels = _unicode_dots_re.split(data)
        trailing_dot = b""
        if labels:
            if not labels[-1]:
                trailing_dot = b"."
                del labels[-1]
            elif not final:
                # Keep potentially unfinished label until the next call
                del labels[-1]
                if labels:
                    trailing_dot = b"."
        result = []
        size = 0
        for label in labels:
            result.append(alabel(label))
            if size:
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/idna/uts46data.py =====
from typing import List, Tuple, Union
"""IDNA Mapping Table from UTS46."""
__version__ = "15.1.0"
def _seg_0() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:
    return [
        (0x0, "3"),
        (0x1, "3"),
        (0x2, "3"),
        (0x3, "3"),
        (0x4, "3"),
        (0x5, "3"),
        (0x6, "3"),
        (0x7, "3"),
        (0x8, "3"),
        (0x9, "3"),
        (0xA, "3"),
        (0xB, "3"),
        (0xC, "3"),
        (0xD, "3"),
        (0xE, "3"),
        (0xF, "3"),
        (0x10, "3"),
        (0x11, "3"),
        (0x12, "3"),
        (0x13, "3"),
        (0x14, "3"),
        (0x15, "3"),
        (0x16, "3"),
        (0x17, "3"),
        (0x18, "3"),
        (0x19, "3"),
        (0x1A, "3"),
        (0x1B, "3"),
        (0x1C, "3"),
        (0x1D, "3"),
        (0x1E, "3"),
        (0x1F, "3"),
        (0x20, "3"),
        (0x21, "3"),
        (0x22, "3"),
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/__init__.py =====
"""
pip._vendor is for vendoring dependencies of pip to prevent needing pip to
depend on something external.
Files inside of pip._vendor should be considered immutable and should only be
updated to versions from upstream.
"""
from __future__ import absolute_import
import glob
import os.path
import sys
DEBUNDLED = False
WHEEL_DIR = os.path.abspath(os.path.dirname(__file__))
def vendored(modulename):
    vendored_name = "{0}.{1}".format(__name__, modulename)
    try:
        __import__(modulename, globals(), locals(), level=0)
    except ImportError:
        # We can just silently allow import failures to pass here. If we
        # got to this point it means that ``import pip._vendor.whatever``
        # failed and so did ``import whatever``. Since we're importing this
        # upfront in an attempt to alias imports, not erroring here will
        # just mean we get a regular import error whenever pip *actually*
        # tries to import one of these modules to use it, which actually
        # gives us a better error message than we would have otherwise
        # gotten.
        pass
    else:
        sys.modules[vendored_name] = sys.modules[modulename]
        base, head = vendored_name.rsplit(".", 1)
        setattr(sys.modules[base], head, sys.modules[modulename])
if DEBUNDLED:
    # Actually look inside of WHEEL_DIR to find .whl files and add them to the
    # front of our sys.path.
    sys.path[:] = glob.glob(os.path.join(WHEEL_DIR, "*.whl")) + sys.path
    # Actually alias all of our vendored dependencies.
    vendored("cachecontrol")
    vendored("certifi")
    vendored("dependency-groups")
    vendored("distlib")
    vendored("distro")
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/requests/cookies.py =====
"""
requests.cookies
~~~~~~~~~~~~~~~~
Compatibility code to be able to use `http.cookiejar.CookieJar` with requests.
requests.utils imports from here, so be careful with imports.
"""
import calendar
import copy
import time
from ._internal_utils import to_native_string
from .compat import Morsel, MutableMapping, cookielib, urlparse, urlunparse
try:
    import threading
except ImportError:
    import dummy_threading as threading
class MockRequest:
    """Wraps a `requests.Request` to mimic a `urllib2.Request`.
    The code in `http.cookiejar.CookieJar` expects this interface in order to correctly
    manage cookie policies, i.e., determine whether a cookie can be set, given the
    domains of the request and the cookie.
    The original request object is read-only. The client is responsible for collecting
    the new headers via `get_new_headers()` and interpreting them appropriately. You
    probably want `get_cookie_header`, defined below.
    """
    def __init__(self, request):
        self._r = request
        self._new_headers = {}
        self.type = urlparse(self._r.url).scheme
    def get_type(self):
        return self.type
    def get_host(self):
        return urlparse(self._r.url).netloc
    def get_origin_req_host(self):
        return self.get_host()
    def get_full_url(self):
        # Only return the response's URL if the user hadn't set the Host
        # header
        if not self._r.headers.get("Host"):
            return self._r.url
        # If they did set it, retrieve it and reconstruct the expected domain
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/requests/auth.py =====
"""
requests.auth
~~~~~~~~~~~~~
This module contains the authentication handlers for Requests.
"""
import hashlib
import os
import re
import threading
import time
import warnings
from base64 import b64encode
from ._internal_utils import to_native_string
from .compat import basestring, str, urlparse
from .cookies import extract_cookies_to_jar
from .utils import parse_dict_header
CONTENT_TYPE_FORM_URLENCODED = "application/x-www-form-urlencoded"
CONTENT_TYPE_MULTI_PART = "multipart/form-data"
def _basic_auth_str(username, password):
    """Returns a Basic Auth string."""
    # "I want us to put a big-ol' comment on top of it that
    # says that this behaviour is dumb but we need to preserve
    # it because people are relying on it."
    #    - Lukasa
    #
    # These are here solely to maintain backwards compatibility
    # for things like ints. This will be removed in 3.0.0.
    if not isinstance(username, basestring):
        warnings.warn(
            "Non-string usernames will no longer be supported in Requests "
            "3.0.0. Please convert the object you've passed in ({!r}) to "
            "a string or bytes object in the near future to avoid "
            "problems.".format(username),
            category=DeprecationWarning,
        )
        username = str(username)
    if not isinstance(password, basestring):
        warnings.warn(
            "Non-string passwords will no longer be supported in Requests "
            "3.0.0. Please convert the object you've passed in ({!r}) to "
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/requests/sessions.py =====
"""
requests.sessions
~~~~~~~~~~~~~~~~~
This module provides a Session object to manage and persist settings across
requests (cookies, auth, proxies).
"""
import os
import sys
import time
from collections import OrderedDict
from datetime import timedelta
from ._internal_utils import to_native_string
from .adapters import HTTPAdapter
from .auth import _basic_auth_str
from .compat import Mapping, cookielib, urljoin, urlparse
from .cookies import (
    RequestsCookieJar,
    cookiejar_from_dict,
    extract_cookies_to_jar,
    merge_cookies,
)
from .exceptions import (
    ChunkedEncodingError,
    ContentDecodingError,
    InvalidSchema,
    TooManyRedirects,
)
from .hooks import default_hooks, dispatch_hook
from .models import (  # noqa: F401
    DEFAULT_REDIRECT_LIMIT,
    REDIRECT_STATI,
    PreparedRequest,
    Request,
)
from .status_codes import codes
from .structures import CaseInsensitiveDict
from .utils import (  # noqa: F401
    DEFAULT_PORTS,
    default_headers,
    get_auth_from_url,
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/requests/hooks.py =====
"""
requests.hooks
~~~~~~~~~~~~~~
This module provides the capabilities for the Requests hooks system.
Available hooks:
``response``:
    The response generated from a Request.
"""
HOOKS = ["response"]
def default_hooks():
    return {event: [] for event in HOOKS}
def dispatch_hook(key, hooks, hook_data, **kwargs):
    """Dispatches a hook dictionary on a given piece of data."""
    hooks = hooks or {}
    hooks = hooks.get(key)
    if hooks:
        if hasattr(hooks, "__call__"):
            hooks = [hooks]
        for hook in hooks:
            _hook_data = hook(hook_data, **kwargs)
            if _hook_data is not None:
                hook_data = _hook_data
    return hook_data
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/requests/compat.py =====
"""
requests.compat
~~~~~~~~~~~~~~~
This module previously handled import compatibility issues
between Python 2 and Python 3. It remains for backwards
compatibility until the next major version.
"""
import sys
from pip._vendor.urllib3 import __version__ as urllib3_version
try:
    is_urllib3_1 = int(urllib3_version.split(".")[0]) == 1
except (TypeError, AttributeError):
    # If we can't discern a version, prefer old functionality.
    is_urllib3_1 = True
def _resolve_char_detection():
    """Find supported character detection libraries."""
    chardet = None
    return chardet
chardet = _resolve_char_detection()
_ver = sys.version_info
is_py2 = _ver[0] == 2
is_py3 = _ver[0] == 3
import json
from json import JSONDecodeError
from collections import OrderedDict
from collections.abc import Callable, Mapping, MutableMapping
from http import cookiejar as cookielib
from http.cookies import Morsel
from io import StringIO
from urllib.parse import (
    quote,
    quote_plus,
    unquote,
    unquote_plus,
    urldefrag,
    urlencode,
    urljoin,
    urlparse,
    urlsplit,
    urlunparse,
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/requests/models.py =====
"""
requests.models
~~~~~~~~~~~~~~~
This module contains the primary objects that power Requests.
"""
import datetime
import encodings.idna  # noqa: F401
from io import UnsupportedOperation
from pip._vendor.urllib3.exceptions import (
    DecodeError,
    LocationParseError,
    ProtocolError,
    ReadTimeoutError,
    SSLError,
)
from pip._vendor.urllib3.fields import RequestField
from pip._vendor.urllib3.filepost import encode_multipart_formdata
from pip._vendor.urllib3.util import parse_url
from ._internal_utils import to_native_string, unicode_is_ascii
from .auth import HTTPBasicAuth
from .compat import (
    Callable,
    JSONDecodeError,
    Mapping,
    basestring,
    builtin_str,
    chardet,
    cookielib,
)
from .compat import json as complexjson
from .compat import urlencode, urlsplit, urlunparse
from .cookies import _copy_cookie_jar, cookiejar_from_dict, get_cookie_header
from .exceptions import (
    ChunkedEncodingError,
    ConnectionError,
    ContentDecodingError,
    HTTPError,
    InvalidJSONError,
    InvalidURL,
)
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/requests/certs.py =====
"""
requests.certs
~~~~~~~~~~~~~~
This module returns the preferred default CA certificate bundle. There is
only one — the one from the certifi package.
If you are packaging Requests, e.g., for a Linux distribution or a managed
environment, you can change the definition of where() to return a separately
packaged CA bundle.
"""
from pip._vendor.certifi import where
if __name__ == "__main__":
    print(where())
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/requests/__init__.py =====
"""
Requests HTTP Library
~~~~~~~~~~~~~~~~~~~~~
Requests is an HTTP library, written in Python, for human beings.
Basic GET usage:
   >>> import requests
   >>> r = requests.get('https://www.python.org')
   >>> r.status_code
   200
   >>> b'Python is a programming language' in r.content
   True
... or POST:
   >>> payload = dict(key1='value1', key2='value2')
   >>> r = requests.post('https://httpbin.org/post', data=payload)
   >>> print(r.text)
   {
     ...
     "form": {
       "key1": "value1",
       "key2": "value2"
     },
     ...
   }
The other HTTP methods are supported - see `requests.api`. Full documentation
is at <https://requests.readthedocs.io>.
:copyright: (c) 2017 by Kenneth Reitz.
:license: Apache 2.0, see LICENSE for more details.
"""
import warnings
from pip._vendor import urllib3
from .exceptions import RequestsDependencyWarning
charset_normalizer_version = None
chardet_version = None
def check_compatibility(urllib3_version, chardet_version, charset_normalizer_version):
    urllib3_version = urllib3_version.split(".")
    assert urllib3_version != ["dev"]  # Verify urllib3 isn't installed from git.
    # Sometimes, urllib3 only reports its version as 16.1.
    if len(urllib3_version) == 2:
        urllib3_version.append("0")
    # Check urllib3 for compatibility.
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/requests/status_codes.py =====
r"""
The ``codes`` object defines a mapping from common names for HTTP statuses
to their numerical codes, accessible either as attributes or as dictionary
items.
Example::
    >>> import requests
    >>> requests.codes['temporary_redirect']
    307
    >>> requests.codes.teapot
    418
    >>> requests.codes['\o/']
    200
Some codes have multiple names, and both upper- and lower-case versions of
the names are allowed. For example, ``codes.ok``, ``codes.OK``, and
``codes.okay`` all correspond to the HTTP status code 200.
"""
from .structures import LookupDict
_codes = {
    # Informational.
    100: ("continue",),
    101: ("switching_protocols",),
    102: ("processing", "early-hints"),
    103: ("checkpoint",),
    122: ("uri_too_long", "request_uri_too_long"),
    200: ("ok", "okay", "all_ok", "all_okay", "all_good", "\\o/", "✓"),
    201: ("created",),
    202: ("accepted",),
    203: ("non_authoritative_info", "non_authoritative_information"),
    204: ("no_content",),
    205: ("reset_content", "reset"),
    206: ("partial_content", "partial"),
    207: ("multi_status", "multiple_status", "multi_stati", "multiple_stati"),
    208: ("already_reported",),
    226: ("im_used",),
    # Redirection.
    300: ("multiple_choices",),
    301: ("moved_permanently", "moved", "\\o-"),
    302: ("found",),
    303: ("see_other", "other"),
    304: ("not_modified",),
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/requests/packages.py =====
import sys
from .compat import chardet
for package in ("urllib3", "idna"):
    vendored_package = "pip._vendor." + package
    locals()[package] = __import__(vendored_package)
    # This traversal is apparently necessary such that the identities are
    # preserved (requests.packages.urllib3.* is urllib3.*)
    for mod in list(sys.modules):
        if mod == vendored_package or mod.startswith(vendored_package + '.'):
            unprefixed_mod = mod[len("pip._vendor."):]
            sys.modules['pip._vendor.requests.packages.' + unprefixed_mod] = sys.modules[mod]
if chardet is not None:
    target = chardet.__name__
    for mod in list(sys.modules):
        if mod == target or mod.startswith(f"{target}."):
            imported_mod = sys.modules[mod]
            sys.modules[f"requests.packages.{mod}"] = imported_mod
            mod = mod.replace(target, "chardet")
            sys.modules[f"requests.packages.{mod}"] = imported_mod
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/requests/__version__.py =====
__title__ = "requests"
__description__ = "Python HTTP for Humans."
__url__ = "https://requests.readthedocs.io"
__version__ = "2.32.4"
__build__ = 0x023204
__author__ = "Kenneth Reitz"
__author_email__ = "me@kennethreitz.org"
__license__ = "Apache-2.0"
__copyright__ = "Copyright Kenneth Reitz"
__cake__ = "\u2728 \U0001f370 \u2728"
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/requests/api.py =====
"""
requests.api
~~~~~~~~~~~~
This module implements the Requests API.
:copyright: (c) 2012 by Kenneth Reitz.
:license: Apache2, see LICENSE for more details.
"""
from . import sessions
def request(method, url, **kwargs):
    """Constructs and sends a :class:`Request <Request>`.
    :param method: method for the new :class:`Request` object: ``GET``, ``OPTIONS``, ``HEAD``, ``POST``, ``PUT``, ``PATCH``, or ``DELETE``.
    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary, list of tuples or bytes to send
        in the query string for the :class:`Request`.
    :param data: (optional) Dictionary, list of tuples, bytes, or file-like
        object to send in the body of the :class:`Request`.
    :param json: (optional) A JSON serializable Python object to send in the body of the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.
    :param cookies: (optional) Dict or CookieJar object to send with the :class:`Request`.
    :param files: (optional) Dictionary of ``'name': file-like-objects`` (or ``{'name': file-tuple}``) for multipart encoding upload.
        ``file-tuple`` can be a 2-tuple ``('filename', fileobj)``, 3-tuple ``('filename', fileobj, 'content_type')``
        or a 4-tuple ``('filename', fileobj, 'content_type', custom_headers)``, where ``'content_type'`` is a string
        defining the content type of the given file and ``custom_headers`` a dict-like object containing additional headers
        to add for the file.
    :param auth: (optional) Auth tuple to enable Basic/Digest/Custom HTTP Auth.
    :param timeout: (optional) How many seconds to wait for the server to send data
        before giving up, as a float, or a :ref:`(connect timeout, read
        timeout) <timeouts>` tuple.
    :type timeout: float or tuple
    :param allow_redirects: (optional) Boolean. Enable/disable GET/OPTIONS/POST/PUT/PATCH/DELETE/HEAD redirection. Defaults to ``True``.
    :type allow_redirects: bool
    :param proxies: (optional) Dictionary mapping protocol to the URL of the proxy.
    :param verify: (optional) Either a boolean, in which case it controls whether we verify
            the server's TLS certificate, or a string, in which case it must be a path
            to a CA bundle to use. Defaults to ``True``.
    :param stream: (optional) if ``False``, the response content will be immediately downloaded.
    :param cert: (optional) if String, path to ssl client cert file (.pem). If Tuple, ('cert', 'key') pair.
    :return: :class:`Response <Response>` object
    :rtype: requests.Response
    Usage::
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/requests/_internal_utils.py =====
"""
requests._internal_utils
~~~~~~~~~~~~~~
Provides utility functions that are consumed internally by Requests
which depend on extremely few external helpers (such as compat)
"""
import re
from .compat import builtin_str
_VALID_HEADER_NAME_RE_BYTE = re.compile(rb"^[^:\s][^:\r\n]*$")
_VALID_HEADER_NAME_RE_STR = re.compile(r"^[^:\s][^:\r\n]*$")
_VALID_HEADER_VALUE_RE_BYTE = re.compile(rb"^\S[^\r\n]*$|^$")
_VALID_HEADER_VALUE_RE_STR = re.compile(r"^\S[^\r\n]*$|^$")
_HEADER_VALIDATORS_STR = (_VALID_HEADER_NAME_RE_STR, _VALID_HEADER_VALUE_RE_STR)
_HEADER_VALIDATORS_BYTE = (_VALID_HEADER_NAME_RE_BYTE, _VALID_HEADER_VALUE_RE_BYTE)
HEADER_VALIDATORS = {
    bytes: _HEADER_VALIDATORS_BYTE,
    str: _HEADER_VALIDATORS_STR,
}
def to_native_string(string, encoding="ascii"):
    """Given a string object, regardless of type, returns a representation of
    that string in the native string type, encoding and decoding where
    necessary. This assumes ASCII unless told otherwise.
    """
    if isinstance(string, builtin_str):
        out = string
    else:
        out = string.decode(encoding)
    return out
def unicode_is_ascii(u_string):
    """Determine if unicode string only contains ASCII characters.
    :param str u_string: unicode string to check. Must be unicode
        and not Python 2 `str`.
    :rtype: bool
    """
    assert isinstance(u_string, str)
    try:
        u_string.encode("ascii")
        return True
    except UnicodeEncodeError:
        return False
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/requests/utils.py =====
"""
requests.utils
~~~~~~~~~~~~~~
This module provides utility functions that are used within Requests
that are also useful for external consumption.
"""
import codecs
import contextlib
import io
import os
import re
import socket
import struct
import sys
import tempfile
import warnings
import zipfile
from collections import OrderedDict
from pip._vendor.urllib3.util import make_headers, parse_url
from . import certs
from .__version__ import __version__
from ._internal_utils import (  # noqa: F401
    _HEADER_VALIDATORS_BYTE,
    _HEADER_VALIDATORS_STR,
    HEADER_VALIDATORS,
    to_native_string,
)
from .compat import (
    Mapping,
    basestring,
    bytes,
    getproxies,
    getproxies_environment,
    integer_types,
    is_urllib3_1,
)
from .compat import parse_http_list as _parse_list_header
from .compat import (
    proxy_bypass,
    proxy_bypass_environment,
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/requests/exceptions.py =====
"""
requests.exceptions
~~~~~~~~~~~~~~~~~~~
This module contains the set of Requests' exceptions.
"""
from pip._vendor.urllib3.exceptions import HTTPError as BaseHTTPError
from .compat import JSONDecodeError as CompatJSONDecodeError
class RequestException(IOError):
    """There was an ambiguous exception that occurred while handling your
    request.
    """
    def __init__(self, *args, **kwargs):
        """Initialize RequestException with `request` and `response` objects."""
        response = kwargs.pop("response", None)
        self.response = response
        self.request = kwargs.pop("request", None)
        if response is not None and not self.request and hasattr(response, "request"):
            self.request = self.response.request
        super().__init__(*args, **kwargs)
class InvalidJSONError(RequestException):
    """A JSON error occurred."""
class JSONDecodeError(InvalidJSONError, CompatJSONDecodeError):
    """Couldn't decode the text into json"""
    def __init__(self, *args, **kwargs):
        """
        Construct the JSONDecodeError instance first with all
        args. Then use it's args to construct the IOError so that
        the json specific args aren't used as IOError specific args
        and the error message from JSONDecodeError is preserved.
        """
        CompatJSONDecodeError.__init__(self, *args)
        InvalidJSONError.__init__(self, *self.args, **kwargs)
    def __reduce__(self):
        """
        The __reduce__ method called when pickling the object must
        be the one from the JSONDecodeError (be it json/simplejson)
        as it expects all the arguments for instantiation, not just
        one like the IOError, and the MRO would by default call the
        __reduce__ method from the IOError due to the inheritance order.
        """
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/requests/structures.py =====
"""
requests.structures
~~~~~~~~~~~~~~~~~~~
Data structures that power Requests.
"""
from collections import OrderedDict
from .compat import Mapping, MutableMapping
class CaseInsensitiveDict(MutableMapping):
    """A case-insensitive ``dict``-like object.
    Implements all methods and operations of
    ``MutableMapping`` as well as dict's ``copy``. Also
    provides ``lower_items``.
    All keys are expected to be strings. The structure remembers the
    case of the last key to be set, and ``iter(instance)``,
    ``keys()``, ``items()``, ``iterkeys()``, and ``iteritems()``
    will contain case-sensitive keys. However, querying and contains
    testing is case insensitive::
        cid = CaseInsensitiveDict()
        cid['Accept'] = 'application/json'
        cid['aCCEPT'] == 'application/json'  # True
        list(cid) == ['Accept']  # True
    For example, ``headers['content-encoding']`` will return the
    value of a ``'Content-Encoding'`` response header, regardless
    of how the header name was originally stored.
    If the constructor, ``.update``, or equality comparison
    operations are given keys that have equal ``.lower()``s, the
    behavior is undefined.
    """
    def __init__(self, data=None, **kwargs):
        self._store = OrderedDict()
        if data is None:
            data = {}
        self.update(data, **kwargs)
    def __setitem__(self, key, value):
        # Use the lowercased key for lookups, but store the actual
        # key alongside the value.
        self._store[key.lower()] = (key, value)
    def __getitem__(self, key):
        return self._store[key.lower()][1]
    def __delitem__(self, key):
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/requests/help.py =====
"""Module containing bug report helper(s)."""
import json
import platform
import ssl
import sys
from pip._vendor import idna
from pip._vendor import urllib3
from . import __version__ as requests_version
charset_normalizer = None
chardet = None
try:
    from pip._vendor.urllib3.contrib import pyopenssl
except ImportError:
    pyopenssl = None
    OpenSSL = None
    cryptography = None
else:
    import cryptography
    import OpenSSL
def _implementation():
    """Return a dict with the Python implementation and version.
    Provide both the name and the version of the Python implementation
    currently running. For example, on CPython 3.10.3 it will return
    {'name': 'CPython', 'version': '3.10.3'}.
    This function works best on CPython and PyPy: in particular, it probably
    doesn't work for Jython or IronPython. Future investigation should be done
    to work out the correct shape of the code for those platforms.
    """
    implementation = platform.python_implementation()
    if implementation == "CPython":
        implementation_version = platform.python_version()
    elif implementation == "PyPy":
        implementation_version = "{}.{}.{}".format(
            sys.pypy_version_info.major,
            sys.pypy_version_info.minor,
            sys.pypy_version_info.micro,
        )
        if sys.pypy_version_info.releaselevel != "final":
            implementation_version = "".join(
                [implementation_version, sys.pypy_version_info.releaselevel]
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/requests/adapters.py =====
"""
requests.adapters
~~~~~~~~~~~~~~~~~
This module contains the transport adapters that Requests uses to define
and maintain connections.
"""
import os.path
import socket  # noqa: F401
import typing
import warnings
from pip._vendor.urllib3.exceptions import ClosedPoolError, ConnectTimeoutError
from pip._vendor.urllib3.exceptions import HTTPError as _HTTPError
from pip._vendor.urllib3.exceptions import InvalidHeader as _InvalidHeader
from pip._vendor.urllib3.exceptions import (
    LocationValueError,
    MaxRetryError,
    NewConnectionError,
    ProtocolError,
)
from pip._vendor.urllib3.exceptions import ProxyError as _ProxyError
from pip._vendor.urllib3.exceptions import ReadTimeoutError, ResponseError
from pip._vendor.urllib3.exceptions import SSLError as _SSLError
from pip._vendor.urllib3.poolmanager import PoolManager, proxy_from_url
from pip._vendor.urllib3.util import Timeout as TimeoutSauce
from pip._vendor.urllib3.util import parse_url
from pip._vendor.urllib3.util.retry import Retry
from pip._vendor.urllib3.util.ssl_ import create_urllib3_context
from .auth import _basic_auth_str
from .compat import basestring, urlparse
from .cookies import extract_cookies_to_jar
from .exceptions import (
    ConnectionError,
    ConnectTimeout,
    InvalidHeader,
    InvalidProxyURL,
    InvalidSchema,
    InvalidURL,
    ProxyError,
    ReadTimeout,
    RetryError,
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/tomli/_types.py =====
from typing import Any, Callable, Tuple
ParseFloat = Callable[[str], Any]
Key = Tuple[str, ...]
Pos = int
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/tomli/__init__.py =====
__all__ = ("loads", "load", "TOMLDecodeError")
__version__ = "2.2.1"  # DO NOT EDIT THIS LINE MANUALLY. LET bump2version UTILITY DO IT
from ._parser import TOMLDecodeError, load, loads
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/tomli/_parser.py =====
from __future__ import annotations
from collections.abc import Iterable
import string
import sys
from types import MappingProxyType
from typing import IO, Any, Final, NamedTuple
import warnings
from ._re import (
    RE_DATETIME,
    RE_LOCALTIME,
    RE_NUMBER,
    match_to_datetime,
    match_to_localtime,
    match_to_number,
)
from ._types import Key, ParseFloat, Pos
MAX_INLINE_NESTING: Final = sys.getrecursionlimit()
ASCII_CTRL: Final = frozenset(chr(i) for i in range(32)) | frozenset(chr(127))
ILLEGAL_BASIC_STR_CHARS: Final = ASCII_CTRL - frozenset("\t")
ILLEGAL_MULTILINE_BASIC_STR_CHARS: Final = ASCII_CTRL - frozenset("\t\n")
ILLEGAL_LITERAL_STR_CHARS: Final = ILLEGAL_BASIC_STR_CHARS
ILLEGAL_MULTILINE_LITERAL_STR_CHARS: Final = ILLEGAL_MULTILINE_BASIC_STR_CHARS
ILLEGAL_COMMENT_CHARS: Final = ILLEGAL_BASIC_STR_CHARS
TOML_WS: Final = frozenset(" \t")
TOML_WS_AND_NEWLINE: Final = TOML_WS | frozenset("\n")
BARE_KEY_CHARS: Final = frozenset(string.ascii_letters + string.digits + "-_")
KEY_INITIAL_CHARS: Final = BARE_KEY_CHARS | frozenset("\"'")
HEXDIGIT_CHARS: Final = frozenset(string.hexdigits)
BASIC_STR_ESCAPE_REPLACEMENTS: Final = MappingProxyType(
    {
        "\\b": "\u0008",  # backspace
        "\\t": "\u0009",  # tab
        "\\n": "\u000A",  # linefeed
        "\\f": "\u000C",  # form feed
        "\\r": "\u000D",  # carriage return
        '\\"': "\u0022",  # quote
        "\\\\": "\u005C",  # backslash
    }
)
class DEPRECATED_DEFAULT:
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/tomli/_re.py =====
from __future__ import annotations
from datetime import date, datetime, time, timedelta, timezone, tzinfo
from functools import lru_cache
import re
from typing import Any, Final
from ._types import ParseFloat
_TIME_RE_STR: Final = (
    r"([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9])(?:\.([0-9]{1,6})[0-9]*)?"
)
RE_NUMBER: Final = re.compile(
    r"""
0
(?:
    x[0-9A-Fa-f](?:_?[0-9A-Fa-f])*   # hex
    |
    b[01](?:_?[01])*                 # bin
    |
    o[0-7](?:_?[0-7])*               # oct
)
|
[+-]?(?:0|[1-9](?:_?[0-9])*)         # dec, integer part
(?P<floatpart>
    (?:\.[0-9](?:_?[0-9])*)?         # optional fractional part
    (?:[eE][+-]?[0-9](?:_?[0-9])*)?  # optional exponent part
)
""",
    flags=re.VERBOSE,
)
RE_LOCALTIME: Final = re.compile(_TIME_RE_STR)
RE_DATETIME: Final = re.compile(
    rf"""
([0-9]{{4}})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])  # date, e.g. 1988-10-27
(?:
    [Tt ]
    {_TIME_RE_STR}
    (?:([Zz])|([+-])([01][0-9]|2[0-3]):([0-5][0-9]))?  # optional time offset
)?
""",
    flags=re.VERBOSE,
)
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/certifi/__init__.py =====
from .core import contents, where
__all__ = ["contents", "where"]
__version__ = "2025.07.14"
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/certifi/core.py =====
"""
certifi.py
~~~~~~~~~~
This module returns the installation location of cacert.pem or its contents.
"""
import sys
import atexit
def exit_cacert_ctx() -> None:
    _CACERT_CTX.__exit__(None, None, None)  # type: ignore[union-attr]
if sys.version_info >= (3, 11):
    from importlib.resources import as_file, files
    _CACERT_CTX = None
    _CACERT_PATH = None
    def where() -> str:
        # This is slightly terrible, but we want to delay extracting the file
        # in cases where we're inside of a zipimport situation until someone
        # actually calls where(), but we don't want to re-extract the file
        # on every call of where(), so we'll do it once then store it in a
        # global variable.
        global _CACERT_CTX
        global _CACERT_PATH
        if _CACERT_PATH is None:
            # This is slightly janky, the importlib.resources API wants you to
            # manage the cleanup of this file, so it doesn't actually return a
            # path, it returns a context manager that will give you the path
            # when you enter it and will do any cleanup when you leave it. In
            # the common case of not needing a temporary file, it will just
            # return the file system location and the __exit__() is a no-op.
            #
            # We also have to hold onto the actual context manager, because
            # it will do the cleanup whenever it gets garbage collected, so
            # we will also store that at the global level as well.
            _CACERT_CTX = as_file(files("pip._vendor.certifi").joinpath("cacert.pem"))
            _CACERT_PATH = str(_CACERT_CTX.__enter__())
            atexit.register(exit_cacert_ctx)
        return _CACERT_PATH
    def contents() -> str:
        return files("pip._vendor.certifi").joinpath("cacert.pem").read_text(encoding="ascii")
else:
    from importlib.resources import path as get_path, read_text
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/certifi/__main__.py =====
import argparse
from pip._vendor.certifi import contents, where
parser = argparse.ArgumentParser()
parser.add_argument("-c", "--contents", action="store_true")
args = parser.parse_args()
if args.contents:
    print(contents())
else:
    print(where())
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/pyproject_hooks/_impl.py =====
import json
import os
import sys
import tempfile
from contextlib import contextmanager
from os.path import abspath
from os.path import join as pjoin
from subprocess import STDOUT, check_call, check_output
from typing import TYPE_CHECKING, Any, Iterator, Mapping, Optional, Sequence
from ._in_process import _in_proc_script_path
if TYPE_CHECKING:
    from typing import Protocol
    class SubprocessRunner(Protocol):
        """A protocol for the subprocess runner."""
        def __call__(
            self,
            cmd: Sequence[str],
            cwd: Optional[str] = None,
            extra_environ: Optional[Mapping[str, str]] = None,
        ) -> None:
            ...
def write_json(obj: Mapping[str, Any], path: str, **kwargs) -> None:
    with open(path, "w", encoding="utf-8") as f:
        json.dump(obj, f, **kwargs)
def read_json(path: str) -> Mapping[str, Any]:
    with open(path, encoding="utf-8") as f:
        return json.load(f)
class BackendUnavailable(Exception):
    """Will be raised if the backend cannot be imported in the hook process."""
    def __init__(
        self,
        traceback: str,
        message: Optional[str] = None,
        backend_name: Optional[str] = None,
        backend_path: Optional[Sequence[str]] = None,
    ) -> None:
        # Preserving arg order for the sake of API backward compatibility.
        self.backend_name = backend_name
        self.backend_path = backend_path
        self.traceback = traceback
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/pyproject_hooks/__init__.py =====
"""Wrappers to call pyproject.toml-based build backend hooks.
"""
from typing import TYPE_CHECKING
from ._impl import (
    BackendUnavailable,
    BuildBackendHookCaller,
    HookMissing,
    UnsupportedOperation,
    default_subprocess_runner,
    quiet_subprocess_runner,
)
__version__ = "1.2.0"
__all__ = [
    "BackendUnavailable",
    "BackendInvalid",
    "HookMissing",
    "UnsupportedOperation",
    "default_subprocess_runner",
    "quiet_subprocess_runner",
    "BuildBackendHookCaller",
]
BackendInvalid = BackendUnavailable  # Deprecated alias, previously a separate exception
if TYPE_CHECKING:
    from ._impl import SubprocessRunner
    __all__ += ["SubprocessRunner"]
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/pyproject_hooks/_in_process/_in_process.py =====
"""This is invoked in a subprocess to call the build backend hooks.
It expects:
- Command line args: hook_name, control_dir
- Environment variables:
      _PYPROJECT_HOOKS_BUILD_BACKEND=entry.point:spec
      _PYPROJECT_HOOKS_BACKEND_PATH=paths (separated with os.pathsep)
- control_dir/input.json:
  - {"kwargs": {...}}
Results:
- control_dir/output.json
  - {"return_val": ...}
"""
import json
import os
import os.path
import re
import shutil
import sys
import traceback
from glob import glob
from importlib import import_module
from importlib.machinery import PathFinder
from os.path import join as pjoin
def write_json(obj, path, **kwargs):
    with open(path, "w", encoding="utf-8") as f:
        json.dump(obj, f, **kwargs)
def read_json(path):
    with open(path, encoding="utf-8") as f:
        return json.load(f)
class BackendUnavailable(Exception):
    """Raised if we cannot import the backend"""
    def __init__(self, message, traceback=None):
        super().__init__(message)
        self.message = message
        self.traceback = traceback
class HookMissing(Exception):
    """Raised if a hook is missing and we are not executing the fallback"""
    def __init__(self, hook_name=None):
        super().__init__(hook_name)
        self.hook_name = hook_name
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/pyproject_hooks/_in_process/__init__.py =====
"""This is a subpackage because the directory is on sys.path for _in_process.py
The subpackage should stay as empty as possible to avoid shadowing modules that
the backend might import.
"""
import importlib.resources as resources
try:
    resources.files
except AttributeError:
    # Python 3.8 compatibility
    def _in_proc_script_path():
        return resources.path(__package__, "_in_process.py")
else:
    def _in_proc_script_path():
        return resources.as_file(
            resources.files(__package__).joinpath("_in_process.py")
        )
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/rich/themes.py =====
from .default_styles import DEFAULT_STYLES
from .theme import Theme
DEFAULT = Theme(DEFAULT_STYLES)
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/rich/screen.py =====
from typing import Optional, TYPE_CHECKING
from .segment import Segment
from .style import StyleType
from ._loop import loop_last
if TYPE_CHECKING:
    from .console import (
        Console,
        ConsoleOptions,
        RenderResult,
        RenderableType,
        Group,
    )
class Screen:
    """A renderable that fills the terminal screen and crops excess.
    Args:
        renderable (RenderableType): Child renderable.
        style (StyleType, optional): Optional background style. Defaults to None.
    """
    renderable: "RenderableType"
    def __init__(
        self,
        *renderables: "RenderableType",
        style: Optional[StyleType] = None,
        application_mode: bool = False,
    ) -> None:
        from pip._vendor.rich.console import Group
        self.renderable = Group(*renderables)
        self.style = style
        self.application_mode = application_mode
    def __rich_console__(
        self, console: "Console", options: "ConsoleOptions"
    ) -> "RenderResult":
        width, height = options.size
        style = console.get_style(self.style) if self.style else None
        render_options = options.update(width=width, height=height)
        lines = console.render_lines(
            self.renderable or "", render_options, style=style, pad=True
        )
        lines = Segment.set_shape(lines, width, height, style=style)
        new_line = Segment("\n\r") if self.application_mode else Segment.line()
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/rich/logging.py =====
import logging
from datetime import datetime
from logging import Handler, LogRecord
from pathlib import Path
from types import ModuleType
from typing import ClassVar, Iterable, List, Optional, Type, Union
from pip._vendor.rich._null_file import NullFile
from . import get_console
from ._log_render import FormatTimeCallable, LogRender
from .console import Console, ConsoleRenderable
from .highlighter import Highlighter, ReprHighlighter
from .text import Text
from .traceback import Traceback
class RichHandler(Handler):
    """A logging handler that renders output with Rich. The time / level / message and file are displayed in columns.
    The level is color coded, and the message is syntax highlighted.
    Note:
        Be careful when enabling console markup in log messages if you have configured logging for libraries not
        under your control. If a dependency writes messages containing square brackets, it may not produce the intended output.
    Args:
        level (Union[int, str], optional): Log level. Defaults to logging.NOTSET.
        console (:class:`~rich.console.Console`, optional): Optional console instance to write logs.
            Default will use a global console instance writing to stdout.
        show_time (bool, optional): Show a column for the time. Defaults to True.
        omit_repeated_times (bool, optional): Omit repetition of the same time. Defaults to True.
        show_level (bool, optional): Show a column for the level. Defaults to True.
        show_path (bool, optional): Show the path to the original log call. Defaults to True.
        enable_link_path (bool, optional): Enable terminal link of path column to file. Defaults to True.
        highlighter (Highlighter, optional): Highlighter to style log messages, or None to use ReprHighlighter. Defaults to None.
        markup (bool, optional): Enable console markup in log messages. Defaults to False.
        rich_tracebacks (bool, optional): Enable rich tracebacks with syntax highlighting and formatting. Defaults to False.
        tracebacks_width (Optional[int], optional): Number of characters used to render tracebacks, or None for full width. Defaults to None.
        tracebacks_code_width (int, optional): Number of code characters used to render tracebacks, or None for full width. Defaults to 88.
        tracebacks_extra_lines (int, optional): Additional lines of code to render tracebacks, or None for full width. Defaults to None.
        tracebacks_theme (str, optional): Override pygments theme used in traceback.
        tracebacks_word_wrap (bool, optional): Enable word wrapping of long tracebacks lines. Defaults to True.
        tracebacks_show_locals (bool, optional): Enable display of locals in tracebacks. Defaults to False.
        tracebacks_suppress (Sequence[Union[str, ModuleType]]): Optional sequence of modules or paths to exclude from traceback.
        tracebacks_max_frames (int, optional): Optional maximum number of frames returned by traceback.
        locals_max_length (int, optional): Maximum length of containers before abbreviating, or None for no abbreviation.
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/rich/measure.py =====
from operator import itemgetter
from typing import TYPE_CHECKING, Callable, NamedTuple, Optional, Sequence
from . import errors
from .protocol import is_renderable, rich_cast
if TYPE_CHECKING:
    from .console import Console, ConsoleOptions, RenderableType
class Measurement(NamedTuple):
    """Stores the minimum and maximum widths (in characters) required to render an object."""
    minimum: int
    """Minimum number of cells required to render."""
    maximum: int
    """Maximum number of cells required to render."""
    @property
    def span(self) -> int:
        """Get difference between maximum and minimum."""
        return self.maximum - self.minimum
    def normalize(self) -> "Measurement":
        """Get measurement that ensures that minimum <= maximum and minimum >= 0
        Returns:
            Measurement: A normalized measurement.
        """
        minimum, maximum = self
        minimum = min(max(0, minimum), maximum)
        return Measurement(max(0, minimum), max(0, max(minimum, maximum)))
    def with_maximum(self, width: int) -> "Measurement":
        """Get a RenderableWith where the widths are <= width.
        Args:
            width (int): Maximum desired width.
        Returns:
            Measurement: New Measurement object.
        """
        minimum, maximum = self
        return Measurement(min(minimum, width), min(maximum, width))
    def with_minimum(self, width: int) -> "Measurement":
        """Get a RenderableWith where the widths are >= width.
        Args:
            width (int): Minimum desired width.
        Returns:
            Measurement: New Measurement object.
        """
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/rich/tree.py =====
from typing import Iterator, List, Optional, Tuple
from ._loop import loop_first, loop_last
from .console import Console, ConsoleOptions, RenderableType, RenderResult
from .jupyter import JupyterMixin
from .measure import Measurement
from .segment import Segment
from .style import Style, StyleStack, StyleType
from .styled import Styled
GuideType = Tuple[str, str, str, str]
class Tree(JupyterMixin):
    """A renderable for a tree structure.
    Attributes:
        ASCII_GUIDES (GuideType): Guide lines used when Console.ascii_only is True.
        TREE_GUIDES (List[GuideType, GuideType, GuideType]): Default guide lines.
    Args:
        label (RenderableType): The renderable or str for the tree label.
        style (StyleType, optional): Style of this tree. Defaults to "tree".
        guide_style (StyleType, optional): Style of the guide lines. Defaults to "tree.line".
        expanded (bool, optional): Also display children. Defaults to True.
        highlight (bool, optional): Highlight renderable (if str). Defaults to False.
        hide_root (bool, optional): Hide the root node. Defaults to False.
    """
    ASCII_GUIDES = ("    ", "|   ", "+-- ", "`-- ")
    TREE_GUIDES = [
        ("    ", "│   ", "├── ", "└── "),
        ("    ", "┃   ", "┣━━ ", "┗━━ "),
        ("    ", "║   ", "╠══ ", "╚══ "),
    ]
    def __init__(
        self,
        label: RenderableType,
        *,
        style: StyleType = "tree",
        guide_style: StyleType = "tree.line",
        expanded: bool = True,
        highlight: bool = False,
        hide_root: bool = False,
    ) -> None:
        self.label = label
        self.style = style
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/rich/console.py =====
import inspect
import os
import sys
import threading
import zlib
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime
from functools import wraps
from getpass import getpass
from html import escape
from inspect import isclass
from itertools import islice
from math import ceil
from time import monotonic
from types import FrameType, ModuleType, TracebackType
from typing import (
    IO,
    TYPE_CHECKING,
    Any,
    Callable,
    Dict,
    Iterable,
    List,
    Literal,
    Mapping,
    NamedTuple,
    Optional,
    Protocol,
    TextIO,
    Tuple,
    Type,
    Union,
    cast,
    runtime_checkable,
)
from pip._vendor.rich._null_file import NULL_FILE
from . import errors, themes
from ._emoji_replace import _emoji_replace
from ._export_format import CONSOLE_HTML_FORMAT, CONSOLE_SVG_FORMAT
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/rich/live_render.py =====
from typing import Optional, Tuple, Literal
from ._loop import loop_last
from .console import Console, ConsoleOptions, RenderableType, RenderResult
from .control import Control
from .segment import ControlType, Segment
from .style import StyleType
from .text import Text
VerticalOverflowMethod = Literal["crop", "ellipsis", "visible"]
class LiveRender:
    """Creates a renderable that may be updated.
    Args:
        renderable (RenderableType): Any renderable object.
        style (StyleType, optional): An optional style to apply to the renderable. Defaults to "".
    """
    def __init__(
        self,
        renderable: RenderableType,
        style: StyleType = "",
        vertical_overflow: VerticalOverflowMethod = "ellipsis",
    ) -> None:
        self.renderable = renderable
        self.style = style
        self.vertical_overflow = vertical_overflow
        self._shape: Optional[Tuple[int, int]] = None
    def set_renderable(self, renderable: RenderableType) -> None:
        """Set a new renderable.
        Args:
            renderable (RenderableType): Any renderable object, including str.
        """
        self.renderable = renderable
    def position_cursor(self) -> Control:
        """Get control codes to move cursor to beginning of live render.
        Returns:
            Control: A control instance that may be printed.
        """
        if self._shape is not None:
            _, height = self._shape
            return Control(
                ControlType.CARRIAGE_RETURN,
                (ControlType.ERASE_IN_LINE, 2),
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/rich/_emoji_codes.py =====
EMOJI = {
    "1st_place_medal": "🥇",
    "2nd_place_medal": "🥈",
    "3rd_place_medal": "🥉",
    "ab_button_(blood_type)": "🆎",
    "atm_sign": "🏧",
    "a_button_(blood_type)": "🅰",
    "afghanistan": "🇦🇫",
    "albania": "🇦🇱",
    "algeria": "🇩🇿",
    "american_samoa": "🇦🇸",
    "andorra": "🇦🇩",
    "angola": "🇦🇴",
    "anguilla": "🇦🇮",
    "antarctica": "🇦🇶",
    "antigua_&_barbuda": "🇦🇬",
    "aquarius": "♒",
    "argentina": "🇦🇷",
    "aries": "♈",
    "armenia": "🇦🇲",
    "aruba": "🇦🇼",
    "ascension_island": "🇦🇨",
    "australia": "🇦🇺",
    "austria": "🇦🇹",
    "azerbaijan": "🇦🇿",
    "back_arrow": "🔙",
    "b_button_(blood_type)": "🅱",
    "bahamas": "🇧🇸",
    "bahrain": "🇧🇭",
    "bangladesh": "🇧🇩",
    "barbados": "🇧🇧",
    "belarus": "🇧🇾",
    "belgium": "🇧🇪",
    "belize": "🇧🇿",
    "benin": "🇧🇯",
    "bermuda": "🇧🇲",
    "bhutan": "🇧🇹",
    "bolivia": "🇧🇴",
    "bosnia_&_herzegovina": "🇧🇦",
    "botswana": "🇧🇼",
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/rich/box.py =====
from typing import TYPE_CHECKING, Iterable, List, Literal
from ._loop import loop_last
if TYPE_CHECKING:
    from pip._vendor.rich.console import ConsoleOptions
class Box:
    """Defines characters to render boxes.
    ┌─┬┐ top
    │ ││ head
    ├─┼┤ head_row
    │ ││ mid
    ├─┼┤ row
    ├─┼┤ foot_row
    │ ││ foot
    └─┴┘ bottom
    Args:
        box (str): Characters making up box.
        ascii (bool, optional): True if this box uses ascii characters only. Default is False.
    """
    def __init__(self, box: str, *, ascii: bool = False) -> None:
        self._box = box
        self.ascii = ascii
        line1, line2, line3, line4, line5, line6, line7, line8 = box.splitlines()
        # top
        self.top_left, self.top, self.top_divider, self.top_right = iter(line1)
        # head
        self.head_left, _, self.head_vertical, self.head_right = iter(line2)
        # head_row
        (
            self.head_row_left,
            self.head_row_horizontal,
            self.head_row_cross,
            self.head_row_right,
        ) = iter(line3)
        # mid
        self.mid_left, _, self.mid_vertical, self.mid_right = iter(line4)
        # row
        self.row_left, self.row_horizontal, self.row_cross, self.row_right = iter(line5)
        # foot_row
        (
            self.foot_row_left,
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/rich/color.py =====
import re
import sys
from colorsys import rgb_to_hls
from enum import IntEnum
from functools import lru_cache
from typing import TYPE_CHECKING, NamedTuple, Optional, Tuple
from ._palettes import EIGHT_BIT_PALETTE, STANDARD_PALETTE, WINDOWS_PALETTE
from .color_triplet import ColorTriplet
from .repr import Result, rich_repr
from .terminal_theme import DEFAULT_TERMINAL_THEME
if TYPE_CHECKING:  # pragma: no cover
    from .terminal_theme import TerminalTheme
    from .text import Text
WINDOWS = sys.platform == "win32"
class ColorSystem(IntEnum):
    """One of the 3 color system supported by terminals."""
    STANDARD = 1
    EIGHT_BIT = 2
    TRUECOLOR = 3
    WINDOWS = 4
    def __repr__(self) -> str:
        return f"ColorSystem.{self.name}"
    def __str__(self) -> str:
        return repr(self)
class ColorType(IntEnum):
    """Type of color stored in Color class."""
    DEFAULT = 0
    STANDARD = 1
    EIGHT_BIT = 2
    TRUECOLOR = 3
    WINDOWS = 4
    def __repr__(self) -> str:
        return f"ColorType.{self.name}"
ANSI_COLOR_NAMES = {
    "black": 0,
    "red": 1,
    "green": 2,
    "yellow": 3,
    "blue": 4,
    "magenta": 5,
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/rich/_timer.py =====
"""
Timer context manager, only used in debug.
"""
from time import time
import contextlib
from typing import Generator
@contextlib.contextmanager
def timer(subject: str = "time") -> Generator[None, None, None]:
    """print the elapsed time. (only used in debugging)"""
    start = time()
    yield
    elapsed = time() - start
    elapsed_ms = elapsed * 1000
    print(f"{subject} elapsed {elapsed_ms:.1f}ms")
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/rich/_fileno.py =====
from __future__ import annotations
from typing import IO, Callable
def get_fileno(file_like: IO[str]) -> int | None:
    """Get fileno() from a file, accounting for poorly implemented file-like objects.
    Args:
        file_like (IO): A file-like object.
    Returns:
        int | None: The result of fileno if available, or None if operation failed.
    """
    fileno: Callable[[], int] | None = getattr(file_like, "fileno", None)
    if fileno is not None:
        try:
            return fileno()
        except Exception:
            # `fileno` is documented as potentially raising a OSError
            # Alas, from the issues, there are so many poorly implemented file-like objects,
            # that `fileno()` can raise just about anything.
            return None
    return None
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/rich/align.py =====
from itertools import chain
from typing import TYPE_CHECKING, Iterable, Optional, Literal
from .constrain import Constrain
from .jupyter import JupyterMixin
from .measure import Measurement
from .segment import Segment
from .style import StyleType
if TYPE_CHECKING:
    from .console import Console, ConsoleOptions, RenderableType, RenderResult
AlignMethod = Literal["left", "center", "right"]
VerticalAlignMethod = Literal["top", "middle", "bottom"]
class Align(JupyterMixin):
    """Align a renderable by adding spaces if necessary.
    Args:
        renderable (RenderableType): A console renderable.
        align (AlignMethod): One of "left", "center", or "right""
        style (StyleType, optional): An optional style to apply to the background.
        vertical (Optional[VerticalAlignMethod], optional): Optional vertical align, one of "top", "middle", or "bottom". Defaults to None.
        pad (bool, optional): Pad the right with spaces. Defaults to True.
        width (int, optional): Restrict contents to given width, or None to use default width. Defaults to None.
        height (int, optional): Set height of align renderable, or None to fit to contents. Defaults to None.
    Raises:
        ValueError: if ``align`` is not one of the expected values.
    """
    def __init__(
        self,
        renderable: "RenderableType",
        align: AlignMethod = "left",
        style: Optional[StyleType] = None,
        *,
        vertical: Optional[VerticalAlignMethod] = None,
        pad: bool = True,
        width: Optional[int] = None,
        height: Optional[int] = None,
    ) -> None:
        if align not in ("left", "center", "right"):
            raise ValueError(
                f'invalid value for align, expected "left", "center", or "right" (not {align!r})'
            )
        if vertical is not None and vertical not in ("top", "middle", "bottom"):
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/rich/theme.py =====
import configparser
from typing import IO, Dict, List, Mapping, Optional
from .default_styles import DEFAULT_STYLES
from .style import Style, StyleType
class Theme:
    """A container for style information, used by :class:`~rich.console.Console`.
    Args:
        styles (Dict[str, Style], optional): A mapping of style names on to styles. Defaults to None for a theme with no styles.
        inherit (bool, optional): Inherit default styles. Defaults to True.
    """
    styles: Dict[str, Style]
    def __init__(
        self, styles: Optional[Mapping[str, StyleType]] = None, inherit: bool = True
    ):
        self.styles = DEFAULT_STYLES.copy() if inherit else {}
        if styles is not None:
            self.styles.update(
                {
                    name: style if isinstance(style, Style) else Style.parse(style)
                    for name, style in styles.items()
                }
            )
    @property
    def config(self) -> str:
        """Get contents of a config file for this theme."""
        config = "[styles]\n" + "\n".join(
            f"{name} = {style}" for name, style in sorted(self.styles.items())
        )
        return config
    @classmethod
    def from_file(
        cls, config_file: IO[str], source: Optional[str] = None, inherit: bool = True
    ) -> "Theme":
        """Load a theme from a text mode file.
        Args:
            config_file (IO[str]): An open conf file.
            source (str, optional): The filename of the open file. Defaults to None.
            inherit (bool, optional): Inherit default styles. Defaults to True.
        Returns:
            Theme: A New theme instance.
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/rich/style.py =====
import sys
from functools import lru_cache
from marshal import dumps, loads
from random import randint
from typing import Any, Dict, Iterable, List, Optional, Type, Union, cast
from . import errors
from .color import Color, ColorParseError, ColorSystem, blend_rgb
from .repr import Result, rich_repr
from .terminal_theme import DEFAULT_TERMINAL_THEME, TerminalTheme
StyleType = Union[str, "Style"]
class _Bit:
    """A descriptor to get/set a style attribute bit."""
    __slots__ = ["bit"]
    def __init__(self, bit_no: int) -> None:
        self.bit = 1 << bit_no
    def __get__(self, obj: "Style", objtype: Type["Style"]) -> Optional[bool]:
        if obj._set_attributes & self.bit:
            return obj._attributes & self.bit != 0
        return None
@rich_repr
class Style:
    """A terminal style.
    A terminal style consists of a color (`color`), a background color (`bgcolor`), and a number of attributes, such
    as bold, italic etc. The attributes have 3 states: they can either be on
    (``True``), off (``False``), or not set (``None``).
    Args:
        color (Union[Color, str], optional): Color of terminal text. Defaults to None.
        bgcolor (Union[Color, str], optional): Color of terminal background. Defaults to None.
        bold (bool, optional): Enable bold text. Defaults to None.
        dim (bool, optional): Enable dim text. Defaults to None.
        italic (bool, optional): Enable italic text. Defaults to None.
        underline (bool, optional): Enable underlined text. Defaults to None.
        blink (bool, optional): Enabled blinking text. Defaults to None.
        blink2 (bool, optional): Enable fast blinking text. Defaults to None.
        reverse (bool, optional): Enabled reverse text. Defaults to None.
        conceal (bool, optional): Enable concealed text. Defaults to None.
        strike (bool, optional): Enable strikethrough text. Defaults to None.
        underline2 (bool, optional): Enable doubly underlined text. Defaults to None.
        frame (bool, optional): Enable framed text. Defaults to None.
        encircle (bool, optional): Enable encircled text. Defaults to None.
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/rich/default_styles.py =====
from typing import Dict
from .style import Style
DEFAULT_STYLES: Dict[str, Style] = {
    "none": Style.null(),
    "reset": Style(
        color="default",
        bgcolor="default",
        dim=False,
        bold=False,
        italic=False,
        underline=False,
        blink=False,
        blink2=False,
        reverse=False,
        conceal=False,
        strike=False,
    ),
    "dim": Style(dim=True),
    "bright": Style(dim=False),
    "bold": Style(bold=True),
    "strong": Style(bold=True),
    "code": Style(reverse=True, bold=True),
    "italic": Style(italic=True),
    "emphasize": Style(italic=True),
    "underline": Style(underline=True),
    "blink": Style(blink=True),
    "blink2": Style(blink2=True),
    "reverse": Style(reverse=True),
    "strike": Style(strike=True),
    "black": Style(color="black"),
    "red": Style(color="red"),
    "green": Style(color="green"),
    "yellow": Style(color="yellow"),
    "magenta": Style(color="magenta"),
    "cyan": Style(color="cyan"),
    "white": Style(color="white"),
    "inspect.attr": Style(color="yellow", italic=True),
    "inspect.attr.dunder": Style(color="yellow", italic=True, dim=True),
    "inspect.callable": Style(bold=True, color="red"),
    "inspect.async_def": Style(italic=True, color="bright_cyan"),
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/rich/_wrap.py =====
from __future__ import annotations
import re
from typing import Iterable
from ._loop import loop_last
from .cells import cell_len, chop_cells
re_word = re.compile(r"\s*\S+\s*")
def words(text: str) -> Iterable[tuple[int, int, str]]:
    """Yields each word from the text as a tuple
    containing (start_index, end_index, word). A "word" in this context may
    include the actual word and any whitespace to the right.
    """
    position = 0
    word_match = re_word.match(text, position)
    while word_match is not None:
        start, end = word_match.span()
        word = word_match.group(0)
        yield start, end, word
        word_match = re_word.match(text, end)
def divide_line(text: str, width: int, fold: bool = True) -> list[int]:
    """Given a string of text, and a width (measured in cells), return a list
    of cell offsets which the string should be split at in order for it to fit
    within the given width.
    Args:
        text: The text to examine.
        width: The available cell width.
        fold: If True, words longer than `width` will be folded onto a new line.
    Returns:
        A list of indices to break the line at.
    """
    break_positions: list[int] = []  # offsets to insert the breaks at
    append = break_positions.append
    cell_offset = 0
    _cell_len = cell_len
    for start, _end, word in words(text):
        word_length = _cell_len(word.rstrip())
        remaining_space = width - cell_offset
        word_fits_remaining_space = remaining_space >= word_length
        if word_fits_remaining_space:
            # Simplest case - the word fits within the remaining width for this line.
            cell_offset += _cell_len(word)
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/rich/_log_render.py =====
from datetime import datetime
from typing import Iterable, List, Optional, TYPE_CHECKING, Union, Callable
from .text import Text, TextType
if TYPE_CHECKING:
    from .console import Console, ConsoleRenderable, RenderableType
    from .table import Table
FormatTimeCallable = Callable[[datetime], Text]
class LogRender:
    def __init__(
        self,
        show_time: bool = True,
        show_level: bool = False,
        show_path: bool = True,
        time_format: Union[str, FormatTimeCallable] = "[%x %X]",
        omit_repeated_times: bool = True,
        level_width: Optional[int] = 8,
    ) -> None:
        self.show_time = show_time
        self.show_level = show_level
        self.show_path = show_path
        self.time_format = time_format
        self.omit_repeated_times = omit_repeated_times
        self.level_width = level_width
        self._last_time: Optional[Text] = None
    def __call__(
        self,
        console: "Console",
        renderables: Iterable["ConsoleRenderable"],
        log_time: Optional[datetime] = None,
        time_format: Optional[Union[str, FormatTimeCallable]] = None,
        level: TextType = "",
        path: Optional[str] = None,
        line_no: Optional[int] = None,
        link_path: Optional[str] = None,
    ) -> "Table":
        from .containers import Renderables
        from .table import Table
        output = Table.grid(padding=(0, 1))
        output.expand = True
        if self.show_time:
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/rich/emoji.py =====
import sys
from typing import TYPE_CHECKING, Optional, Union, Literal
from .jupyter import JupyterMixin
from .segment import Segment
from .style import Style
from ._emoji_codes import EMOJI
from ._emoji_replace import _emoji_replace
if TYPE_CHECKING:
    from .console import Console, ConsoleOptions, RenderResult
EmojiVariant = Literal["emoji", "text"]
class NoEmoji(Exception):
    """No emoji by that name."""
class Emoji(JupyterMixin):
    __slots__ = ["name", "style", "_char", "variant"]
    VARIANTS = {"text": "\uFE0E", "emoji": "\uFE0F"}
    def __init__(
        self,
        name: str,
        style: Union[str, Style] = "none",
        variant: Optional[EmojiVariant] = None,
    ) -> None:
        """A single emoji character.
        Args:
            name (str): Name of emoji.
            style (Union[str, Style], optional): Optional style. Defaults to None.
        Raises:
            NoEmoji: If the emoji doesn't exist.
        """
        self.name = name
        self.style = style
        self.variant = variant
        try:
            self._char = EMOJI[name]
        except KeyError:
            raise NoEmoji(f"No emoji called {name!r}")
        if variant is not None:
            self._char += self.VARIANTS.get(variant, "")
    @classmethod
    def replace(cls, text: str) -> str:
        """Replace emoji markup with corresponding unicode characters.
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/rich/layout.py =====
from abc import ABC, abstractmethod
from itertools import islice
from operator import itemgetter
from threading import RLock
from typing import (
    TYPE_CHECKING,
    Dict,
    Iterable,
    List,
    NamedTuple,
    Optional,
    Sequence,
    Tuple,
    Union,
)
from ._ratio import ratio_resolve
from .align import Align
from .console import Console, ConsoleOptions, RenderableType, RenderResult
from .highlighter import ReprHighlighter
from .panel import Panel
from .pretty import Pretty
from .region import Region
from .repr import Result, rich_repr
from .segment import Segment
from .style import StyleType
if TYPE_CHECKING:
    from pip._vendor.rich.tree import Tree
class LayoutRender(NamedTuple):
    """An individual layout render."""
    region: Region
    render: List[List[Segment]]
RegionMap = Dict["Layout", Region]
RenderMap = Dict["Layout", LayoutRender]
class LayoutError(Exception):
    """Layout related error."""
class NoSplitter(LayoutError):
    """Requested splitter does not exist."""
class _Placeholder:
    """An internal renderable used as a Layout placeholder."""
    highlighter = ReprHighlighter()
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/rich/containers.py =====
from itertools import zip_longest
from typing import (
    TYPE_CHECKING,
    Iterable,
    Iterator,
    List,
    Optional,
    TypeVar,
    Union,
    overload,
)
if TYPE_CHECKING:
    from .console import (
        Console,
        ConsoleOptions,
        JustifyMethod,
        OverflowMethod,
        RenderResult,
        RenderableType,
    )
    from .text import Text
from .cells import cell_len
from .measure import Measurement
T = TypeVar("T")
class Renderables:
    """A list subclass which renders its contents to the console."""
    def __init__(
        self, renderables: Optional[Iterable["RenderableType"]] = None
    ) -> None:
        self._renderables: List["RenderableType"] = (
            list(renderables) if renderables is not None else []
        )
    def __rich_console__(
        self, console: "Console", options: "ConsoleOptions"
    ) -> "RenderResult":
        """Console render method to insert line-breaks."""
        yield from self._renderables
    def __rich_measure__(
        self, console: "Console", options: "ConsoleOptions"
    ) -> "Measurement":
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/rich/_emoji_replace.py =====
from typing import Callable, Match, Optional
import re
from ._emoji_codes import EMOJI
_ReStringMatch = Match[str]  # regex match object
_ReSubCallable = Callable[[_ReStringMatch], str]  # Callable invoked by re.sub
_EmojiSubMethod = Callable[[_ReSubCallable, str], str]  # Sub method of a compiled re
def _emoji_replace(
    text: str,
    default_variant: Optional[str] = None,
    _emoji_sub: _EmojiSubMethod = re.compile(r"(:(\S*?)(?:(?:\-)(emoji|text))?:)").sub,
) -> str:
    """Replace emoji code in text."""
    get_emoji = EMOJI.__getitem__
    variants = {"text": "\uFE0E", "emoji": "\uFE0F"}
    get_variant = variants.get
    default_variant_code = variants.get(default_variant, "") if default_variant else ""
    def do_replace(match: Match[str]) -> str:
        emoji_code, emoji_name, variant = match.groups()
        try:
            return get_emoji(emoji_name.lower()) + get_variant(
                variant, default_variant_code
            )
        except KeyError:
            return emoji_code
    return _emoji_sub(do_replace, text)
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/rich/traceback.py =====
import inspect
import linecache
import os
import sys
from dataclasses import dataclass, field
from itertools import islice
from traceback import walk_tb
from types import ModuleType, TracebackType
from typing import (
    Any,
    Callable,
    Dict,
    Iterable,
    List,
    Optional,
    Sequence,
    Set,
    Tuple,
    Type,
    Union,
)
from pip._vendor.pygments.lexers import guess_lexer_for_filename
from pip._vendor.pygments.token import Comment, Keyword, Name, Number, Operator, String
from pip._vendor.pygments.token import Text as TextToken
from pip._vendor.pygments.token import Token
from pip._vendor.pygments.util import ClassNotFound
from . import pretty
from ._loop import loop_first_last, loop_last
from .columns import Columns
from .console import (
    Console,
    ConsoleOptions,
    ConsoleRenderable,
    Group,
    RenderResult,
    group,
)
from .constrain import Constrain
from .highlighter import RegexHighlighter, ReprHighlighter
from .panel import Panel
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/rich/region.py =====
from typing import NamedTuple
class Region(NamedTuple):
    """Defines a rectangular region of the screen."""
    x: int
    y: int
    width: int
    height: int
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/rich/protocol.py =====
from typing import Any, cast, Set, TYPE_CHECKING
from inspect import isclass
if TYPE_CHECKING:
    from pip._vendor.rich.console import RenderableType
_GIBBERISH = """aihwerij235234ljsdnp34ksodfipwoe234234jlskjdf"""
def is_renderable(check_object: Any) -> bool:
    """Check if an object may be rendered by Rich."""
    return (
        isinstance(check_object, str)
        or hasattr(check_object, "__rich__")
        or hasattr(check_object, "__rich_console__")
    )
def rich_cast(renderable: object) -> "RenderableType":
    """Cast an object to a renderable by calling __rich__ if present.
    Args:
        renderable (object): A potentially renderable object
    Returns:
        object: The result of recursively calling __rich__.
    """
    from pip._vendor.rich.console import RenderableType
    rich_visited_set: Set[type] = set()  # Prevent potential infinite loop
    while hasattr(renderable, "__rich__") and not isclass(renderable):
        # Detect object which claim to have all the attributes
        if hasattr(renderable, _GIBBERISH):
            return repr(renderable)
        cast_method = getattr(renderable, "__rich__")
        renderable = cast_method()
        renderable_type = type(renderable)
        if renderable_type in rich_visited_set:
            break
        rich_visited_set.add(renderable_type)
    return cast(RenderableType, renderable)
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/rich/_loop.py =====
from typing import Iterable, Tuple, TypeVar
T = TypeVar("T")
def loop_first(values: Iterable[T]) -> Iterable[Tuple[bool, T]]:
    """Iterate and generate a tuple with a flag for first value."""
    iter_values = iter(values)
    try:
        value = next(iter_values)
    except StopIteration:
        return
    yield True, value
    for value in iter_values:
        yield False, value
def loop_last(values: Iterable[T]) -> Iterable[Tuple[bool, T]]:
    """Iterate and generate a tuple with a flag for last value."""
    iter_values = iter(values)
    try:
        previous_value = next(iter_values)
    except StopIteration:
        return
    for value in iter_values:
        yield False, previous_value
        previous_value = value
    yield True, previous_value
def loop_first_last(values: Iterable[T]) -> Iterable[Tuple[bool, bool, T]]:
    """Iterate and generate a tuple with a flag for first and last value."""
    iter_values = iter(values)
    try:
        previous_value = next(iter_values)
    except StopIteration:
        return
    first = True
    for value in iter_values:
        yield first, False, previous_value
        first = False
        previous_value = value
    yield first, True, previous_value
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/rich/control.py =====
import time
from typing import TYPE_CHECKING, Callable, Dict, Iterable, List, Union, Final
from .segment import ControlCode, ControlType, Segment
if TYPE_CHECKING:
    from .console import Console, ConsoleOptions, RenderResult
STRIP_CONTROL_CODES: Final = [
    7,  # Bell
    8,  # Backspace
    11,  # Vertical tab
    12,  # Form feed
    13,  # Carriage return
]
_CONTROL_STRIP_TRANSLATE: Final = {
    _codepoint: None for _codepoint in STRIP_CONTROL_CODES
}
CONTROL_ESCAPE: Final = {
    7: "\\a",
    8: "\\b",
    11: "\\v",
    12: "\\f",
    13: "\\r",
}
CONTROL_CODES_FORMAT: Dict[int, Callable[..., str]] = {
    ControlType.BELL: lambda: "\x07",
    ControlType.CARRIAGE_RETURN: lambda: "\r",
    ControlType.HOME: lambda: "\x1b[H",
    ControlType.CLEAR: lambda: "\x1b[2J",
    ControlType.ENABLE_ALT_SCREEN: lambda: "\x1b[?1049h",
    ControlType.DISABLE_ALT_SCREEN: lambda: "\x1b[?1049l",
    ControlType.SHOW_CURSOR: lambda: "\x1b[?25h",
    ControlType.HIDE_CURSOR: lambda: "\x1b[?25l",
    ControlType.CURSOR_UP: lambda param: f"\x1b[{param}A",
    ControlType.CURSOR_DOWN: lambda param: f"\x1b[{param}B",
    ControlType.CURSOR_FORWARD: lambda param: f"\x1b[{param}C",
    ControlType.CURSOR_BACKWARD: lambda param: f"\x1b[{param}D",
    ControlType.CURSOR_MOVE_TO_COLUMN: lambda param: f"\x1b[{param+1}G",
    ControlType.ERASE_IN_LINE: lambda param: f"\x1b[{param}K",
    ControlType.CURSOR_MOVE_TO: lambda x, y: f"\x1b[{y+1};{x+1}H",
    ControlType.SET_WINDOW_TITLE: lambda title: f"\x1b]0;{title}\x07",
}
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/rich/filesize.py =====
"""Functions for reporting filesizes. Borrowed from https://github.com/PyFilesystem/pyfilesystem2
The functions declared in this module should cover the different
use cases needed to generate a string representation of a file size
using several different units. Since there are many standards regarding
file size units, three different functions have been implemented.
See Also:
    * `Wikipedia: Binary prefix <https://en.wikipedia.org/wiki/Binary_prefix>`_
"""
__all__ = ["decimal"]
from typing import Iterable, List, Optional, Tuple
def _to_str(
    size: int,
    suffixes: Iterable[str],
    base: int,
    *,
    precision: Optional[int] = 1,
    separator: Optional[str] = " ",
) -> str:
    if size == 1:
        return "1 byte"
    elif size < base:
        return f"{size:,} bytes"
    for i, suffix in enumerate(suffixes, 2):  # noqa: B007
        unit = base**i
        if size < unit:
            break
    return "{:,.{precision}f}{separator}{}".format(
        (base * size / unit),
        suffix,
        precision=precision,
        separator=separator,
    )
def pick_unit_and_suffix(size: int, suffixes: List[str], base: int) -> Tuple[int, str]:
    """Pick a suffix and base for the given size."""
    for i, suffix in enumerate(suffixes):
        unit = base**i
        if size < unit * base:
            break
    return unit, suffix
def decimal(
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/rich/_null_file.py =====
from types import TracebackType
from typing import IO, Iterable, Iterator, List, Optional, Type
class NullFile(IO[str]):
    def close(self) -> None:
        pass
    def isatty(self) -> bool:
        return False
    def read(self, __n: int = 1) -> str:
        return ""
    def readable(self) -> bool:
        return False
    def readline(self, __limit: int = 1) -> str:
        return ""
    def readlines(self, __hint: int = 1) -> List[str]:
        return []
    def seek(self, __offset: int, __whence: int = 1) -> int:
        return 0
    def seekable(self) -> bool:
        return False
    def tell(self) -> int:
        return 0
    def truncate(self, __size: Optional[int] = 1) -> int:
        return 0
    def writable(self) -> bool:
        return False
    def writelines(self, __lines: Iterable[str]) -> None:
        pass
    def __next__(self) -> str:
        return ""
    def __iter__(self) -> Iterator[str]:
        return iter([""])
    def __enter__(self) -> IO[str]:
        return self
    def __exit__(
        self,
        __t: Optional[Type[BaseException]],
        __value: Optional[BaseException],
        __traceback: Optional[TracebackType],
    ) -> None:
        pass
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/rich/_palettes.py =====
from .palette import Palette
WINDOWS_PALETTE = Palette(
    [
        (12, 12, 12),
        (197, 15, 31),
        (19, 161, 14),
        (193, 156, 0),
        (0, 55, 218),
        (136, 23, 152),
        (58, 150, 221),
        (204, 204, 204),
        (118, 118, 118),
        (231, 72, 86),
        (22, 198, 12),
        (249, 241, 165),
        (59, 120, 255),
        (180, 0, 158),
        (97, 214, 214),
        (242, 242, 242),
    ]
)
STANDARD_PALETTE = Palette(
    [
        (0, 0, 0),
        (170, 0, 0),
        (0, 170, 0),
        (170, 85, 0),
        (0, 0, 170),
        (170, 0, 170),
        (0, 170, 170),
        (170, 170, 170),
        (85, 85, 85),
        (255, 85, 85),
        (85, 255, 85),
        (255, 255, 85),
        (85, 85, 255),
        (255, 85, 255),
        (85, 255, 255),
        (255, 255, 255),
    ]
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/rich/__init__.py =====
"""Rich text and beautiful formatting in the terminal."""
import os
from typing import IO, TYPE_CHECKING, Any, Callable, Optional, Union
from ._extension import load_ipython_extension  # noqa: F401
__all__ = ["get_console", "reconfigure", "print", "inspect", "print_json"]
if TYPE_CHECKING:
    from .console import Console
_console: Optional["Console"] = None
try:
    _IMPORT_CWD = os.path.abspath(os.getcwd())
except FileNotFoundError:
    # Can happen if the cwd has been deleted
    _IMPORT_CWD = ""
def get_console() -> "Console":
    """Get a global :class:`~rich.console.Console` instance. This function is used when Rich requires a Console,
    and hasn't been explicitly given one.
    Returns:
        Console: A console instance.
    """
    global _console
    if _console is None:
        from .console import Console
        _console = Console()
    return _console
def reconfigure(*args: Any, **kwargs: Any) -> None:
    """Reconfigures the global console by replacing it with another.
    Args:
        *args (Any): Positional arguments for the replacement :class:`~rich.console.Console`.
        **kwargs (Any): Keyword arguments for the replacement :class:`~rich.console.Console`.
    """
    from pip._vendor.rich.console import Console
    new_console = Console(*args, **kwargs)
    _console = get_console()
    _console.__dict__ = new_console.__dict__
def print(
    *objects: Any,
    sep: str = " ",
    end: str = "\n",
    file: Optional[IO[str]] = None,
    flush: bool = False,
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/rich/_pick.py =====
from typing import Optional
def pick_bool(*values: Optional[bool]) -> bool:
    """Pick the first non-none bool or return the last value.
    Args:
        *values (bool): Any number of boolean or None values.
    Returns:
        bool: First non-none boolean.
    """
    assert values, "1 or more values required"
    for value in values:
        if value is not None:
            return value
    return bool(value)
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/rich/file_proxy.py =====
import io
from typing import IO, TYPE_CHECKING, Any, List
from .ansi import AnsiDecoder
from .text import Text
if TYPE_CHECKING:
    from .console import Console
class FileProxy(io.TextIOBase):
    """Wraps a file (e.g. sys.stdout) and redirects writes to a console."""
    def __init__(self, console: "Console", file: IO[str]) -> None:
        self.__console = console
        self.__file = file
        self.__buffer: List[str] = []
        self.__ansi_decoder = AnsiDecoder()
    @property
    def rich_proxied_file(self) -> IO[str]:
        """Get proxied file."""
        return self.__file
    def __getattr__(self, name: str) -> Any:
        return getattr(self.__file, name)
    def write(self, text: str) -> int:
        if not isinstance(text, str):
            raise TypeError(f"write() argument must be str, not {type(text).__name__}")
        buffer = self.__buffer
        lines: List[str] = []
        while text:
            line, new_line, text = text.partition("\n")
            if new_line:
                lines.append("".join(buffer) + line)
                buffer.clear()
            else:
                buffer.append(line)
                break
        if lines:
            console = self.__console
            with console:
                output = Text("\n").join(
                    self.__ansi_decoder.decode_line(line) for line in lines
                )
                console.print(output)
        return len(text)
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/rich/palette.py =====
from math import sqrt
from functools import lru_cache
from typing import Sequence, Tuple, TYPE_CHECKING
from .color_triplet import ColorTriplet
if TYPE_CHECKING:
    from pip._vendor.rich.table import Table
class Palette:
    """A palette of available colors."""
    def __init__(self, colors: Sequence[Tuple[int, int, int]]):
        self._colors = colors
    def __getitem__(self, number: int) -> ColorTriplet:
        return ColorTriplet(*self._colors[number])
    def __rich__(self) -> "Table":
        from pip._vendor.rich.color import Color
        from pip._vendor.rich.style import Style
        from pip._vendor.rich.text import Text
        from pip._vendor.rich.table import Table
        table = Table(
            "index",
            "RGB",
            "Color",
            title="Palette",
            caption=f"{len(self._colors)} colors",
            highlight=True,
            caption_justify="right",
        )
        for index, color in enumerate(self._colors):
            table.add_row(
                str(index),
                repr(color),
                Text(" " * 16, style=Style(bgcolor=Color.from_rgb(*color))),
            )
        return table
    # This is somewhat inefficient and needs caching
    @lru_cache(maxsize=1024)
    def match(self, color: Tuple[int, int, int]) -> int:
        """Find a color from a palette that most closely matches a given color.
        Args:
            color (Tuple[int, int, int]): RGB components in range 0 > 255.
        Returns:
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/rich/markup.py =====
import re
from ast import literal_eval
from operator import attrgetter
from typing import Callable, Iterable, List, Match, NamedTuple, Optional, Tuple, Union
from ._emoji_replace import _emoji_replace
from .emoji import EmojiVariant
from .errors import MarkupError
from .style import Style
from .text import Span, Text
RE_TAGS = re.compile(
    r"""((\\*)\[([a-z#/@][^[]*?)])""",
    re.VERBOSE,
)
RE_HANDLER = re.compile(r"^([\w.]*?)(\(.*?\))?$")
class Tag(NamedTuple):
    """A tag in console markup."""
    name: str
    """The tag name. e.g. 'bold'."""
    parameters: Optional[str]
    """Any additional parameters after the name."""
    def __str__(self) -> str:
        return (
            self.name if self.parameters is None else f"{self.name} {self.parameters}"
        )
    @property
    def markup(self) -> str:
        """Get the string representation of this tag."""
        return (
            f"[{self.name}]"
            if self.parameters is None
            else f"[{self.name}={self.parameters}]"
        )
_ReStringMatch = Match[str]  # regex match object
_ReSubCallable = Callable[[_ReStringMatch], str]  # Callable invoked by re.sub
_EscapeSubMethod = Callable[[_ReSubCallable, str], str]  # Sub method of a compiled re
def escape(
    markup: str,
    _escape: _EscapeSubMethod = re.compile(r"(\\*)(\[[a-z#/@][^[]*?])").sub,
) -> str:
    """Escapes text so that it won't be interpreted as markup.
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/rich/_ratio.py =====
from fractions import Fraction
from math import ceil
from typing import cast, List, Optional, Sequence, Protocol
class Edge(Protocol):
    """Any object that defines an edge (such as Layout)."""
    size: Optional[int] = None
    ratio: int = 1
    minimum_size: int = 1
def ratio_resolve(total: int, edges: Sequence[Edge]) -> List[int]:
    """Divide total space to satisfy size, ratio, and minimum_size, constraints.
    The returned list of integers should add up to total in most cases, unless it is
    impossible to satisfy all the constraints. For instance, if there are two edges
    with a minimum size of 20 each and `total` is 30 then the returned list will be
    greater than total. In practice, this would mean that a Layout object would
    clip the rows that would overflow the screen height.
    Args:
        total (int): Total number of characters.
        edges (List[Edge]): Edges within total space.
    Returns:
        List[int]: Number of characters for each edge.
    """
    # Size of edge or None for yet to be determined
    sizes = [(edge.size or None) for edge in edges]
    _Fraction = Fraction
    # While any edges haven't been calculated
    while None in sizes:
        # Get flexible edges and index to map these back on to sizes list
        flexible_edges = [
            (index, edge)
            for index, (size, edge) in enumerate(zip(sizes, edges))
            if size is None
        ]
        # Remaining space in total
        remaining = total - sum(size or 0 for size in sizes)
        if remaining <= 0:
            # No room for flexible edges
            return [
                ((edge.minimum_size or 1) if size is None else size)
                for size, edge in zip(sizes, edges)
            ]
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/rich/repr.py =====
import inspect
from functools import partial
from typing import (
    Any,
    Callable,
    Iterable,
    List,
    Optional,
    Tuple,
    Type,
    TypeVar,
    Union,
    overload,
)
T = TypeVar("T")
Result = Iterable[Union[Any, Tuple[Any], Tuple[str, Any], Tuple[str, Any, Any]]]
RichReprResult = Result
class ReprError(Exception):
    """An error occurred when attempting to build a repr."""
@overload
def auto(cls: Optional[Type[T]]) -> Type[T]:
    ...
@overload
def auto(*, angular: bool = False) -> Callable[[Type[T]], Type[T]]:
    ...
def auto(
    cls: Optional[Type[T]] = None, *, angular: Optional[bool] = None
) -> Union[Type[T], Callable[[Type[T]], Type[T]]]:
    """Class decorator to create __repr__ from __rich_repr__"""
    def do_replace(cls: Type[T], angular: Optional[bool] = None) -> Type[T]:
        def auto_repr(self: T) -> str:
            """Create repr string from __rich_repr__"""
            repr_str: List[str] = []
            append = repr_str.append
            angular: bool = getattr(self.__rich_repr__, "angular", False)  # type: ignore[attr-defined]
            for arg in self.__rich_repr__():  # type: ignore[attr-defined]
                if isinstance(arg, tuple):
                    if len(arg) == 1:
                        append(repr(arg[0]))
                    else:
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/rich/constrain.py =====
from typing import Optional, TYPE_CHECKING
from .jupyter import JupyterMixin
from .measure import Measurement
if TYPE_CHECKING:
    from .console import Console, ConsoleOptions, RenderableType, RenderResult
class Constrain(JupyterMixin):
    """Constrain the width of a renderable to a given number of characters.
    Args:
        renderable (RenderableType): A renderable object.
        width (int, optional): The maximum width (in characters) to render. Defaults to 80.
    """
    def __init__(self, renderable: "RenderableType", width: Optional[int] = 80) -> None:
        self.renderable = renderable
        self.width = width
    def __rich_console__(
        self, console: "Console", options: "ConsoleOptions"
    ) -> "RenderResult":
        if self.width is None:
            yield self.renderable
        else:
            child_options = options.update_width(min(self.width, options.max_width))
            yield from console.render(self.renderable, child_options)
    def __rich_measure__(
        self, console: "Console", options: "ConsoleOptions"
    ) -> "Measurement":
        if self.width is not None:
            options = options.update_width(self.width)
        measurement = Measurement.get(console, options, self.renderable)
        return measurement
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/rich/pretty.py =====
import builtins
import collections
import dataclasses
import inspect
import os
import reprlib
import sys
from array import array
from collections import Counter, UserDict, UserList, defaultdict, deque
from dataclasses import dataclass, fields, is_dataclass
from inspect import isclass
from itertools import islice
from types import MappingProxyType
from typing import (
    TYPE_CHECKING,
    Any,
    Callable,
    DefaultDict,
    Deque,
    Dict,
    Iterable,
    List,
    Optional,
    Sequence,
    Set,
    Tuple,
    Union,
)
from pip._vendor.rich.repr import RichReprResult
try:
    import attr as _attr_module
    _has_attrs = hasattr(_attr_module, "ib")
except ImportError:  # pragma: no cover
    _has_attrs = False
from . import get_console
from ._loop import loop_last
from ._pick import pick_bool
from .abc import RichRenderable
from .cells import cell_len
from .highlighter import ReprHighlighter
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/rich/diagnose.py =====
import os
import platform
from pip._vendor.rich import inspect
from pip._vendor.rich.console import Console, get_windows_console_features
from pip._vendor.rich.panel import Panel
from pip._vendor.rich.pretty import Pretty
def report() -> None:  # pragma: no cover
    """Print a report to the terminal with debugging information"""
    console = Console()
    inspect(console)
    features = get_windows_console_features()
    inspect(features)
    env_names = (
        "CLICOLOR",
        "COLORTERM",
        "COLUMNS",
        "JPY_PARENT_PID",
        "JUPYTER_COLUMNS",
        "JUPYTER_LINES",
        "LINES",
        "NO_COLOR",
        "TERM_PROGRAM",
        "TERM",
        "TTY_COMPATIBLE",
        "TTY_INTERACTIVE",
        "VSCODE_VERBOSE_LOGGING",
    )
    env = {name: os.getenv(name) for name in env_names}
    console.print(Panel.fit((Pretty(env)), title="[b]Environment Variables"))
    console.print(f'platform="{platform.system()}"')
if __name__ == "__main__":  # pragma: no cover
    report()
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/rich/columns.py =====
from collections import defaultdict
from itertools import chain
from operator import itemgetter
from typing import Dict, Iterable, List, Optional, Tuple
from .align import Align, AlignMethod
from .console import Console, ConsoleOptions, RenderableType, RenderResult
from .constrain import Constrain
from .measure import Measurement
from .padding import Padding, PaddingDimensions
from .table import Table
from .text import TextType
from .jupyter import JupyterMixin
class Columns(JupyterMixin):
    """Display renderables in neat columns.
    Args:
        renderables (Iterable[RenderableType]): Any number of Rich renderables (including str).
        width (int, optional): The desired width of the columns, or None to auto detect. Defaults to None.
        padding (PaddingDimensions, optional): Optional padding around cells. Defaults to (0, 1).
        expand (bool, optional): Expand columns to full width. Defaults to False.
        equal (bool, optional): Arrange in to equal sized columns. Defaults to False.
        column_first (bool, optional): Align items from top to bottom (rather than left to right). Defaults to False.
        right_to_left (bool, optional): Start column from right hand side. Defaults to False.
        align (str, optional): Align value ("left", "right", or "center") or None for default. Defaults to None.
        title (TextType, optional): Optional title for Columns.
    """
    def __init__(
        self,
        renderables: Optional[Iterable[RenderableType]] = None,
        padding: PaddingDimensions = (0, 1),
        *,
        width: Optional[int] = None,
        expand: bool = False,
        equal: bool = False,
        column_first: bool = False,
        right_to_left: bool = False,
        align: Optional[AlignMethod] = None,
        title: Optional[TextType] = None,
    ) -> None:
        self.renderables = list(renderables or [])
        self.width = width
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/rich/rule.py =====
from typing import Union
from .align import AlignMethod
from .cells import cell_len, set_cell_size
from .console import Console, ConsoleOptions, RenderResult
from .jupyter import JupyterMixin
from .measure import Measurement
from .style import Style
from .text import Text
class Rule(JupyterMixin):
    """A console renderable to draw a horizontal rule (line).
    Args:
        title (Union[str, Text], optional): Text to render in the rule. Defaults to "".
        characters (str, optional): Character(s) used to draw the line. Defaults to "─".
        style (StyleType, optional): Style of Rule. Defaults to "rule.line".
        end (str, optional): Character at end of Rule. defaults to "\\\\n"
        align (str, optional): How to align the title, one of "left", "center", or "right". Defaults to "center".
    """
    def __init__(
        self,
        title: Union[str, Text] = "",
        *,
        characters: str = "─",
        style: Union[str, Style] = "rule.line",
        end: str = "\n",
        align: AlignMethod = "center",
    ) -> None:
        if cell_len(characters) < 1:
            raise ValueError(
                "'characters' argument must have a cell width of at least 1"
            )
        if align not in ("left", "center", "right"):
            raise ValueError(
                f'invalid value for align, expected "left", "center", "right" (not {align!r})'
            )
        self.title = title
        self.characters = characters
        self.style = style
        self.end = end
        self.align = align
    def __repr__(self) -> str:
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/rich/_inspect.py =====
import inspect
from inspect import cleandoc, getdoc, getfile, isclass, ismodule, signature
from typing import Any, Collection, Iterable, Optional, Tuple, Type, Union
from .console import Group, RenderableType
from .control import escape_control_codes
from .highlighter import ReprHighlighter
from .jupyter import JupyterMixin
from .panel import Panel
from .pretty import Pretty
from .table import Table
from .text import Text, TextType
def _first_paragraph(doc: str) -> str:
    """Get the first paragraph from a docstring."""
    paragraph, _, _ = doc.partition("\n\n")
    return paragraph
class Inspect(JupyterMixin):
    """A renderable to inspect any Python Object.
    Args:
        obj (Any): An object to inspect.
        title (str, optional): Title to display over inspect result, or None use type. Defaults to None.
        help (bool, optional): Show full help text rather than just first paragraph. Defaults to False.
        methods (bool, optional): Enable inspection of callables. Defaults to False.
        docs (bool, optional): Also render doc strings. Defaults to True.
        private (bool, optional): Show private attributes (beginning with underscore). Defaults to False.
        dunder (bool, optional): Show attributes starting with double underscore. Defaults to False.
        sort (bool, optional): Sort attributes alphabetically. Defaults to True.
        all (bool, optional): Show all attributes. Defaults to False.
        value (bool, optional): Pretty print value of object. Defaults to True.
    """
    def __init__(
        self,
        obj: Any,
        *,
        title: Optional[TextType] = None,
        help: bool = False,
        methods: bool = False,
        docs: bool = True,
        private: bool = False,
        dunder: bool = False,
        sort: bool = True,
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/rich/pager.py =====
from abc import ABC, abstractmethod
from typing import Any
class Pager(ABC):
    """Base class for a pager."""
    @abstractmethod
    def show(self, content: str) -> None:
        """Show content in pager.
        Args:
            content (str): Content to be displayed.
        """
class SystemPager(Pager):
    """Uses the pager installed on the system."""
    def _pager(self, content: str) -> Any:  #  pragma: no cover
        return __import__("pydoc").pager(content)
    def show(self, content: str) -> None:
        """Use the same pager used by pydoc."""
        self._pager(content)
if __name__ == "__main__":  # pragma: no cover
    from .__main__ import make_test_card
    from .console import Console
    console = Console()
    with console.pager(styles=True):
        console.print(make_test_card())
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/rich/text.py =====
import re
from functools import partial, reduce
from math import gcd
from operator import itemgetter
from typing import (
    TYPE_CHECKING,
    Any,
    Callable,
    Dict,
    Iterable,
    List,
    NamedTuple,
    Optional,
    Pattern,
    Tuple,
    Union,
)
from ._loop import loop_last
from ._pick import pick_bool
from ._wrap import divide_line
from .align import AlignMethod
from .cells import cell_len, set_cell_size
from .containers import Lines
from .control import strip_control_codes
from .emoji import EmojiVariant
from .jupyter import JupyterMixin
from .measure import Measurement
from .segment import Segment
from .style import Style, StyleType
if TYPE_CHECKING:  # pragma: no cover
    from .console import Console, ConsoleOptions, JustifyMethod, OverflowMethod
DEFAULT_JUSTIFY: "JustifyMethod" = "default"
DEFAULT_OVERFLOW: "OverflowMethod" = "fold"
_re_whitespace = re.compile(r"\s+$")
TextType = Union[str, "Text"]
"""A plain string or a :class:`Text` instance."""
GetStyleCallable = Callable[[str], Optional[StyleType]]
class Span(NamedTuple):
    """A marked up region in some text."""
    start: int
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/rich/highlighter.py =====
import re
from abc import ABC, abstractmethod
from typing import List, Union
from .text import Span, Text
def _combine_regex(*regexes: str) -> str:
    """Combine a number of regexes in to a single regex.
    Returns:
        str: New regex with all regexes ORed together.
    """
    return "|".join(regexes)
class Highlighter(ABC):
    """Abstract base class for highlighters."""
    def __call__(self, text: Union[str, Text]) -> Text:
        """Highlight a str or Text instance.
        Args:
            text (Union[str, ~Text]): Text to highlight.
        Raises:
            TypeError: If not called with text or str.
        Returns:
            Text: A test instance with highlighting applied.
        """
        if isinstance(text, str):
            highlight_text = Text(text)
        elif isinstance(text, Text):
            highlight_text = text.copy()
        else:
            raise TypeError(f"str or Text instance required, not {text!r}")
        self.highlight(highlight_text)
        return highlight_text
    @abstractmethod
    def highlight(self, text: Text) -> None:
        """Apply highlighting in place to text.
        Args:
            text (~Text): A text object highlight.
        """
class NullHighlighter(Highlighter):
    """A highlighter object that doesn't highlight.
    May be used to disable highlighting entirely.
    """
    def highlight(self, text: Text) -> None:
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/rich/_spinners.py =====
"""
Spinners are from:
* cli-spinners:
    MIT License
    Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)
    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights to
    use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
    the Software, and to permit persons to whom the Software is furnished to do so,
    subject to the following conditions:
    The above copyright notice and this permission notice shall be included
    in all copies or substantial portions of the Software.
    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
    INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
    PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
    FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
    ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
    IN THE SOFTWARE.
"""
SPINNERS = {
    "dots": {
        "interval": 80,
        "frames": "⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏",
    },
    "dots2": {"interval": 80, "frames": "⣾⣽⣻⢿⡿⣟⣯⣷"},
    "dots3": {
        "interval": 80,
        "frames": "⠋⠙⠚⠞⠖⠦⠴⠲⠳⠓",
    },
    "dots4": {
        "interval": 80,
        "frames": "⠄⠆⠇⠋⠙⠸⠰⠠⠰⠸⠙⠋⠇⠆",
    },
    "dots5": {
        "interval": 80,
        "frames": "⠋⠙⠚⠒⠂⠂⠒⠲⠴⠦⠖⠒⠐⠐⠒⠓⠋",
    },
    "dots6": {
        "interval": 80,
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/rich/terminal_theme.py =====
from typing import List, Optional, Tuple
from .color_triplet import ColorTriplet
from .palette import Palette
_ColorTuple = Tuple[int, int, int]
class TerminalTheme:
    """A color theme used when exporting console content.
    Args:
        background (Tuple[int, int, int]): The background color.
        foreground (Tuple[int, int, int]): The foreground (text) color.
        normal (List[Tuple[int, int, int]]): A list of 8 normal intensity colors.
        bright (List[Tuple[int, int, int]], optional): A list of 8 bright colors, or None
            to repeat normal intensity. Defaults to None.
    """
    def __init__(
        self,
        background: _ColorTuple,
        foreground: _ColorTuple,
        normal: List[_ColorTuple],
        bright: Optional[List[_ColorTuple]] = None,
    ) -> None:
        self.background_color = ColorTriplet(*background)
        self.foreground_color = ColorTriplet(*foreground)
        self.ansi_colors = Palette(normal + (bright or normal))
DEFAULT_TERMINAL_THEME = TerminalTheme(
    (255, 255, 255),
    (0, 0, 0),
    [
        (0, 0, 0),
        (128, 0, 0),
        (0, 128, 0),
        (128, 128, 0),
        (0, 0, 128),
        (128, 0, 128),
        (0, 128, 128),
        (192, 192, 192),
    ],
    [
        (128, 128, 128),
        (255, 0, 0),
        (0, 255, 0),
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/rich/bar.py =====
from typing import Optional, Union
from .color import Color
from .console import Console, ConsoleOptions, RenderResult
from .jupyter import JupyterMixin
from .measure import Measurement
from .segment import Segment
from .style import Style
BEGIN_BLOCK_ELEMENTS = ["█", "█", "█", "▐", "▐", "▐", "▕", "▕"]
END_BLOCK_ELEMENTS = [" ", "▏", "▎", "▍", "▌", "▋", "▊", "▉"]
FULL_BLOCK = "█"
class Bar(JupyterMixin):
    """Renders a solid block bar.
    Args:
        size (float): Value for the end of the bar.
        begin (float): Begin point (between 0 and size, inclusive).
        end (float): End point (between 0 and size, inclusive).
        width (int, optional): Width of the bar, or ``None`` for maximum width. Defaults to None.
        color (Union[Color, str], optional): Color of the bar. Defaults to "default".
        bgcolor (Union[Color, str], optional): Color of bar background. Defaults to "default".
    """
    def __init__(
        self,
        size: float,
        begin: float,
        end: float,
        *,
        width: Optional[int] = None,
        color: Union[Color, str] = "default",
        bgcolor: Union[Color, str] = "default",
    ):
        self.size = size
        self.begin = max(begin, 0)
        self.end = min(end, size)
        self.width = width
        self.style = Style(color=color, bgcolor=bgcolor)
    def __repr__(self) -> str:
        return f"Bar({self.size}, {self.begin}, {self.end})"
    def __rich_console__(
        self, console: Console, options: ConsoleOptions
    ) -> RenderResult:
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/rich/live.py =====
from __future__ import annotations
import sys
from threading import Event, RLock, Thread
from types import TracebackType
from typing import IO, TYPE_CHECKING, Any, Callable, List, Optional, TextIO, Type, cast
from . import get_console
from .console import Console, ConsoleRenderable, Group, RenderableType, RenderHook
from .control import Control
from .file_proxy import FileProxy
from .jupyter import JupyterMixin
from .live_render import LiveRender, VerticalOverflowMethod
from .screen import Screen
from .text import Text
if TYPE_CHECKING:
    # Can be replaced with `from typing import Self` in Python 3.11+
    from typing_extensions import Self  # pragma: no cover
class _RefreshThread(Thread):
    """A thread that calls refresh() at regular intervals."""
    def __init__(self, live: "Live", refresh_per_second: float) -> None:
        self.live = live
        self.refresh_per_second = refresh_per_second
        self.done = Event()
        super().__init__(daemon=True)
    def stop(self) -> None:
        self.done.set()
    def run(self) -> None:
        while not self.done.wait(1 / self.refresh_per_second):
            with self.live._lock:
                if not self.done.is_set():
                    self.live.refresh()
class Live(JupyterMixin, RenderHook):
    """Renders an auto-updating live display of any given renderable.
    Args:
        renderable (RenderableType, optional): The renderable to live display. Defaults to displaying nothing.
        console (Console, optional): Optional Console instance. Defaults to an internal Console instance writing to stdout.
        screen (bool, optional): Enable alternate screen mode. Defaults to False.
        auto_refresh (bool, optional): Enable auto refresh. If disabled, you will need to call `refresh()` or `update()` with refresh flag. Defaults to True
        refresh_per_second (float, optional): Number of times per second to refresh the live display. Defaults to 4.
        transient (bool, optional): Clear the renderable on exit (has no effect when screen=True). Defaults to False.
        redirect_stdout (bool, optional): Enable redirection of stdout, so ``print`` may be used. Defaults to True.
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/rich/syntax.py =====
from __future__ import annotations
import os.path
import re
import sys
import textwrap
from abc import ABC, abstractmethod
from pathlib import Path
from typing import (
    Any,
    Dict,
    Iterable,
    List,
    NamedTuple,
    Optional,
    Sequence,
    Set,
    Tuple,
    Type,
    Union,
)
from pip._vendor.pygments.lexer import Lexer
from pip._vendor.pygments.lexers import get_lexer_by_name, guess_lexer_for_filename
from pip._vendor.pygments.style import Style as PygmentsStyle
from pip._vendor.pygments.styles import get_style_by_name
from pip._vendor.pygments.token import (
    Comment,
    Error,
    Generic,
    Keyword,
    Name,
    Number,
    Operator,
    String,
    Token,
    Whitespace,
)
from pip._vendor.pygments.util import ClassNotFound
from pip._vendor.rich.containers import Lines
from pip._vendor.rich.padding import Padding, PaddingDimensions
from ._loop import loop_first
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/rich/table.py =====
from dataclasses import dataclass, field, replace
from typing import (
    TYPE_CHECKING,
    Dict,
    Iterable,
    List,
    NamedTuple,
    Optional,
    Sequence,
    Tuple,
    Union,
)
from . import box, errors
from ._loop import loop_first_last, loop_last
from ._pick import pick_bool
from ._ratio import ratio_distribute, ratio_reduce
from .align import VerticalAlignMethod
from .jupyter import JupyterMixin
from .measure import Measurement
from .padding import Padding, PaddingDimensions
from .protocol import is_renderable
from .segment import Segment
from .style import Style, StyleType
from .text import Text, TextType
if TYPE_CHECKING:
    from .console import (
        Console,
        ConsoleOptions,
        JustifyMethod,
        OverflowMethod,
        RenderableType,
        RenderResult,
    )
@dataclass
class Column:
    """Defines a column within a ~Table.
    Args:
        title (Union[str, Text], optional): The title of the table rendered at the top. Defaults to None.
        caption (Union[str, Text], optional): The table caption rendered below. Defaults to None.
        width (int, optional): The width in characters of the table, or ``None`` to automatically fit. Defaults to None.
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/rich/_export_format.py =====
CONSOLE_HTML_FORMAT = """\
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<style>
{stylesheet}
body {{
    color: {foreground};
    background-color: {background};
}}
</style>
</head>
<body>
    <pre style="font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"><code style="font-family:inherit">{code}</code></pre>
</body>
</html>
"""
CONSOLE_SVG_FORMAT = """\
<svg class="rich-terminal" viewBox="0 0 {width} {height}" xmlns="http://www.w3.org/2000/svg">
    <!-- Generated with Rich https://www.textualize.io -->
    <style>
    @font-face {{
        font-family: "Fira Code";
        src: local("FiraCode-Regular"),
                url("https://cdnjs.cloudflare.com/ajax/libs/firacode/6.2.0/woff2/FiraCode-Regular.woff2") format("woff2"),
                url("https://cdnjs.cloudflare.com/ajax/libs/firacode/6.2.0/woff/FiraCode-Regular.woff") format("woff");
        font-style: normal;
        font-weight: 400;
    }}
    @font-face {{
        font-family: "Fira Code";
        src: local("FiraCode-Bold"),
                url("https://cdnjs.cloudflare.com/ajax/libs/firacode/6.2.0/woff2/FiraCode-Bold.woff2") format("woff2"),
                url("https://cdnjs.cloudflare.com/ajax/libs/firacode/6.2.0/woff/FiraCode-Bold.woff") format("woff");
        font-style: bold;
        font-weight: 700;
    }}
    .{unique_id}-matrix {{
        font-family: Fira Code, monospace;
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/rich/progress_bar.py =====
import math
from functools import lru_cache
from time import monotonic
from typing import Iterable, List, Optional
from .color import Color, blend_rgb
from .color_triplet import ColorTriplet
from .console import Console, ConsoleOptions, RenderResult
from .jupyter import JupyterMixin
from .measure import Measurement
from .segment import Segment
from .style import Style, StyleType
PULSE_SIZE = 20
class ProgressBar(JupyterMixin):
    """Renders a (progress) bar. Used by rich.progress.
    Args:
        total (float, optional): Number of steps in the bar. Defaults to 100. Set to None to render a pulsing animation.
        completed (float, optional): Number of steps completed. Defaults to 0.
        width (int, optional): Width of the bar, or ``None`` for maximum width. Defaults to None.
        pulse (bool, optional): Enable pulse effect. Defaults to False. Will pulse if a None total was passed.
        style (StyleType, optional): Style for the bar background. Defaults to "bar.back".
        complete_style (StyleType, optional): Style for the completed bar. Defaults to "bar.complete".
        finished_style (StyleType, optional): Style for a finished bar. Defaults to "bar.finished".
        pulse_style (StyleType, optional): Style for pulsing bars. Defaults to "bar.pulse".
        animation_time (Optional[float], optional): Time in seconds to use for animation, or None to use system time.
    """
    def __init__(
        self,
        total: Optional[float] = 100.0,
        completed: float = 0,
        width: Optional[int] = None,
        pulse: bool = False,
        style: StyleType = "bar.back",
        complete_style: StyleType = "bar.complete",
        finished_style: StyleType = "bar.finished",
        pulse_style: StyleType = "bar.pulse",
        animation_time: Optional[float] = None,
    ):
        self.total = total
        self.completed = completed
        self.width = width
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/rich/errors.py =====
class ConsoleError(Exception):
    """An error in console operation."""
class StyleError(Exception):
    """An error in styles."""
class StyleSyntaxError(ConsoleError):
    """Style was badly formatted."""
class MissingStyle(StyleError):
    """No such style."""
class StyleStackError(ConsoleError):
    """Style stack is invalid."""
class NotRenderableError(ConsoleError):
    """Object is not renderable."""
class MarkupError(ConsoleError):
    """Markup was badly formatted."""
class LiveError(ConsoleError):
    """Error related to Live display."""
class NoAltScreen(ConsoleError):
    """Alt screen mode was required."""
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/rich/prompt.py =====
from typing import Any, Generic, List, Optional, TextIO, TypeVar, Union, overload
from . import get_console
from .console import Console
from .text import Text, TextType
PromptType = TypeVar("PromptType")
DefaultType = TypeVar("DefaultType")
class PromptError(Exception):
    """Exception base class for prompt related errors."""
class InvalidResponse(PromptError):
    """Exception to indicate a response was invalid. Raise this within process_response() to indicate an error
    and provide an error message.
    Args:
        message (Union[str, Text]): Error message.
    """
    def __init__(self, message: TextType) -> None:
        self.message = message
    def __rich__(self) -> TextType:
        return self.message
class PromptBase(Generic[PromptType]):
    """Ask the user for input until a valid response is received. This is the base class, see one of
    the concrete classes for examples.
    Args:
        prompt (TextType, optional): Prompt text. Defaults to "".
        console (Console, optional): A Console instance or None to use global console. Defaults to None.
        password (bool, optional): Enable password input. Defaults to False.
        choices (List[str], optional): A list of valid choices. Defaults to None.
        case_sensitive (bool, optional): Matching of choices should be case-sensitive. Defaults to True.
        show_default (bool, optional): Show default in prompt. Defaults to True.
        show_choices (bool, optional): Show choices in prompt. Defaults to True.
    """
    response_type: type = str
    validate_error_message = "[prompt.invalid]Please enter a valid value"
    illegal_choice_message = (
        "[prompt.invalid.choice]Please select one of the available options"
    )
    prompt_suffix = ": "
    choices: Optional[List[str]] = None
    def __init__(
        self,
        prompt: TextType = "",
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/rich/segment.py =====
from enum import IntEnum
from functools import lru_cache
from itertools import filterfalse
from logging import getLogger
from operator import attrgetter
from typing import (
    TYPE_CHECKING,
    Dict,
    Iterable,
    List,
    NamedTuple,
    Optional,
    Sequence,
    Tuple,
    Type,
    Union,
)
from .cells import (
    _is_single_cell_widths,
    cached_cell_len,
    cell_len,
    get_character_cell_size,
    set_cell_size,
)
from .repr import Result, rich_repr
from .style import Style
if TYPE_CHECKING:
    from .console import Console, ConsoleOptions, RenderResult
log = getLogger("rich")
class ControlType(IntEnum):
    """Non-printable control codes which typically translate to ANSI codes."""
    BELL = 1
    CARRIAGE_RETURN = 2
    HOME = 3
    CLEAR = 4
    SHOW_CURSOR = 5
    HIDE_CURSOR = 6
    ENABLE_ALT_SCREEN = 7
    DISABLE_ALT_SCREEN = 8
    CURSOR_UP = 9
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/rich/ansi.py =====
import re
import sys
from contextlib import suppress
from typing import Iterable, NamedTuple, Optional
from .color import Color
from .style import Style
from .text import Text
re_ansi = re.compile(
    r"""
(?:\x1b[0-?])|
(?:\x1b\](.*?)\x1b\\)|
(?:\x1b([(@-Z\\-_]|\[[0-?]*[ -/]*[@-~]))
""",
    re.VERBOSE,
)
class _AnsiToken(NamedTuple):
    """Result of ansi tokenized string."""
    plain: str = ""
    sgr: Optional[str] = ""
    osc: Optional[str] = ""
def _ansi_tokenize(ansi_text: str) -> Iterable[_AnsiToken]:
    """Tokenize a string in to plain text and ANSI codes.
    Args:
        ansi_text (str): A String containing ANSI codes.
    Yields:
        AnsiToken: A named tuple of (plain, sgr, osc)
    """
    position = 0
    sgr: Optional[str]
    osc: Optional[str]
    for match in re_ansi.finditer(ansi_text):
        start, end = match.span(0)
        osc, sgr = match.groups()
        if start > position:
            yield _AnsiToken(ansi_text[position:start])
        if sgr:
            if sgr == "(":
                position = end + 1
                continue
            if sgr.endswith("m"):
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/rich/progress.py =====
from __future__ import annotations
import io
import typing
import warnings
from abc import ABC, abstractmethod
from collections import deque
from dataclasses import dataclass, field
from datetime import timedelta
from io import RawIOBase, UnsupportedOperation
from math import ceil
from mmap import mmap
from operator import length_hint
from os import PathLike, stat
from threading import Event, RLock, Thread
from types import TracebackType
from typing import (
    TYPE_CHECKING,
    Any,
    BinaryIO,
    Callable,
    ContextManager,
    Deque,
    Dict,
    Generic,
    Iterable,
    List,
    Literal,
    NamedTuple,
    NewType,
    Optional,
    TextIO,
    Tuple,
    Type,
    TypeVar,
    Union,
)
if TYPE_CHECKING:
    # Can be replaced with `from typing import Self` in Python 3.11+
    from typing_extensions import Self  # pragma: no cover
from . import filesize, get_console
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/rich/_stack.py =====
from typing import List, TypeVar
T = TypeVar("T")
class Stack(List[T]):
    """A small shim over builtin list."""
    @property
    def top(self) -> T:
        """Get top of stack."""
        return self[-1]
    def push(self, item: T) -> None:
        """Push an item on to the stack (append in stack nomenclature)."""
        self.append(item)
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/rich/_windows.py =====
import sys
from dataclasses import dataclass
@dataclass
class WindowsConsoleFeatures:
    """Windows features available."""
    vt: bool = False
    """The console supports VT codes."""
    truecolor: bool = False
    """The console supports truecolor."""
try:
    import ctypes
    from ctypes import LibraryLoader
    if sys.platform == "win32":
        windll = LibraryLoader(ctypes.WinDLL)
    else:
        windll = None
        raise ImportError("Not windows")
    from pip._vendor.rich._win32_console import (
        ENABLE_VIRTUAL_TERMINAL_PROCESSING,
        GetConsoleMode,
        GetStdHandle,
        LegacyWindowsError,
    )
except (AttributeError, ImportError, ValueError):
    # Fallback if we can't load the Windows DLL
    def get_windows_console_features() -> WindowsConsoleFeatures:
        features = WindowsConsoleFeatures()
        return features
else:
    def get_windows_console_features() -> WindowsConsoleFeatures:
        """Get windows console features.
        Returns:
            WindowsConsoleFeatures: An instance of WindowsConsoleFeatures.
        """
        handle = GetStdHandle()
        try:
            console_mode = GetConsoleMode(handle)
            success = True
        except LegacyWindowsError:
            console_mode = 0
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/rich/_cell_widths.py =====
CELL_WIDTHS = [
    (0, 0, 0),
    (1, 31, -1),
    (127, 159, -1),
    (173, 173, 0),
    (768, 879, 0),
    (1155, 1161, 0),
    (1425, 1469, 0),
    (1471, 1471, 0),
    (1473, 1474, 0),
    (1476, 1477, 0),
    (1479, 1479, 0),
    (1536, 1541, 0),
    (1552, 1562, 0),
    (1564, 1564, 0),
    (1611, 1631, 0),
    (1648, 1648, 0),
    (1750, 1757, 0),
    (1759, 1764, 0),
    (1767, 1768, 0),
    (1770, 1773, 0),
    (1807, 1807, 0),
    (1809, 1809, 0),
    (1840, 1866, 0),
    (1958, 1968, 0),
    (2027, 2035, 0),
    (2045, 2045, 0),
    (2070, 2073, 0),
    (2075, 2083, 0),
    (2085, 2087, 0),
    (2089, 2093, 0),
    (2137, 2139, 0),
    (2192, 2193, 0),
    (2200, 2207, 0),
    (2250, 2307, 0),
    (2362, 2364, 0),
    (2366, 2383, 0),
    (2385, 2391, 0),
    (2402, 2403, 0),
    (2433, 2435, 0),
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/rich/cells.py =====
from __future__ import annotations
from functools import lru_cache
from typing import Callable
from ._cell_widths import CELL_WIDTHS
_SINGLE_CELL_UNICODE_RANGES: list[tuple[int, int]] = [
    (0x20, 0x7E),  # Latin (excluding non-printable)
    (0xA0, 0xAC),
    (0xAE, 0x002FF),
    (0x00370, 0x00482),  # Greek / Cyrillic
    (0x02500, 0x025FC),  # Box drawing, box elements, geometric shapes
    (0x02800, 0x028FF),  # Braille
]
_SINGLE_CELLS = frozenset(
    [
        character
        for _start, _end in _SINGLE_CELL_UNICODE_RANGES
        for character in map(chr, range(_start, _end + 1))
    ]
)
_is_single_cell_widths: Callable[[str], bool] = _SINGLE_CELLS.issuperset
@lru_cache(4096)
def cached_cell_len(text: str) -> int:
    """Get the number of cells required to display text.
    This method always caches, which may use up a lot of memory. It is recommended to use
    `cell_len` over this method.
    Args:
        text (str): Text to display.
    Returns:
        int: Get the number of cells required to display text.
    """
    if _is_single_cell_widths(text):
        return len(text)
    return sum(map(get_character_cell_size, text))
def cell_len(text: str, _cell_len: Callable[[str], int] = cached_cell_len) -> int:
    """Get the number of cells required to display text.
    Args:
        text (str): Text to display.
    Returns:
        int: Get the number of cells required to display text.
    """
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/rich/_win32_console.py =====
"""Light wrapper around the Win32 Console API - this module should only be imported on Windows
The API that this module wraps is documented at https://docs.microsoft.com/en-us/windows/console/console-functions
"""
import ctypes
import sys
from typing import Any
windll: Any = None
if sys.platform == "win32":
    windll = ctypes.LibraryLoader(ctypes.WinDLL)
else:
    raise ImportError(f"{__name__} can only be imported on Windows")
import time
from ctypes import Structure, byref, wintypes
from typing import IO, NamedTuple, Type, cast
from pip._vendor.rich.color import ColorSystem
from pip._vendor.rich.style import Style
STDOUT = -11
ENABLE_VIRTUAL_TERMINAL_PROCESSING = 4
COORD = wintypes._COORD
class LegacyWindowsError(Exception):
    pass
class WindowsCoordinates(NamedTuple):
    """Coordinates in the Windows Console API are (y, x), not (x, y).
    This class is intended to prevent that confusion.
    Rows and columns are indexed from 0.
    This class can be used in place of wintypes._COORD in arguments and argtypes.
    """
    row: int
    col: int
    @classmethod
    def from_param(cls, value: "WindowsCoordinates") -> COORD:
        """Converts a WindowsCoordinates into a wintypes _COORD structure.
        This classmethod is internally called by ctypes to perform the conversion.
        Args:
            value (WindowsCoordinates): The input coordinates to convert.
        Returns:
            wintypes._COORD: The converted coordinates struct.
        """
        return COORD(value.col, value.row)
class CONSOLE_SCREEN_BUFFER_INFO(Structure):
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/rich/panel.py =====
from typing import TYPE_CHECKING, Optional
from .align import AlignMethod
from .box import ROUNDED, Box
from .cells import cell_len
from .jupyter import JupyterMixin
from .measure import Measurement, measure_renderables
from .padding import Padding, PaddingDimensions
from .segment import Segment
from .style import Style, StyleType
from .text import Text, TextType
if TYPE_CHECKING:
    from .console import Console, ConsoleOptions, RenderableType, RenderResult
class Panel(JupyterMixin):
    """A console renderable that draws a border around its contents.
    Example:
        >>> console.print(Panel("Hello, World!"))
    Args:
        renderable (RenderableType): A console renderable object.
        box (Box): A Box instance that defines the look of the border (see :ref:`appendix_box`. Defaults to box.ROUNDED.
        title (Optional[TextType], optional): Optional title displayed in panel header. Defaults to None.
        title_align (AlignMethod, optional): Alignment of title. Defaults to "center".
        subtitle (Optional[TextType], optional): Optional subtitle displayed in panel footer. Defaults to None.
        subtitle_align (AlignMethod, optional): Alignment of subtitle. Defaults to "center".
        safe_box (bool, optional): Disable box characters that don't display on windows legacy terminal with *raster* fonts. Defaults to True.
        expand (bool, optional): If True the panel will stretch to fill the console width, otherwise it will be sized to fit the contents. Defaults to True.
        style (str, optional): The style of the panel (border and contents). Defaults to "none".
        border_style (str, optional): The style of the border. Defaults to "none".
        width (Optional[int], optional): Optional width of panel. Defaults to None to auto-detect.
        height (Optional[int], optional): Optional height of panel. Defaults to None to auto-detect.
        padding (Optional[PaddingDimensions]): Optional padding around renderable. Defaults to 0.
        highlight (bool, optional): Enable automatic highlighting of panel title (if str). Defaults to False.
    """
    def __init__(
        self,
        renderable: "RenderableType",
        box: Box = ROUNDED,
        *,
        title: Optional[TextType] = None,
        title_align: AlignMethod = "center",
        subtitle: Optional[TextType] = None,
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/rich/styled.py =====
from typing import TYPE_CHECKING
from .measure import Measurement
from .segment import Segment
from .style import StyleType
if TYPE_CHECKING:
    from .console import Console, ConsoleOptions, RenderResult, RenderableType
class Styled:
    """Apply a style to a renderable.
    Args:
        renderable (RenderableType): Any renderable.
        style (StyleType): A style to apply across the entire renderable.
    """
    def __init__(self, renderable: "RenderableType", style: "StyleType") -> None:
        self.renderable = renderable
        self.style = style
    def __rich_console__(
        self, console: "Console", options: "ConsoleOptions"
    ) -> "RenderResult":
        style = console.get_style(self.style)
        rendered_segments = console.render(self.renderable, options)
        segments = Segment.apply_style(rendered_segments, style)
        return segments
    def __rich_measure__(
        self, console: "Console", options: "ConsoleOptions"
    ) -> Measurement:
        return Measurement.get(console, options, self.renderable)
if __name__ == "__main__":  # pragma: no cover
    from pip._vendor.rich import print
    from pip._vendor.rich.panel import Panel
    panel = Styled(Panel("hello"), "on blue")
    print(panel)
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/rich/spinner.py =====
from typing import TYPE_CHECKING, List, Optional, Union, cast
from ._spinners import SPINNERS
from .measure import Measurement
from .table import Table
from .text import Text
if TYPE_CHECKING:
    from .console import Console, ConsoleOptions, RenderableType, RenderResult
    from .style import StyleType
class Spinner:
    """A spinner animation.
    Args:
        name (str): Name of spinner (run python -m rich.spinner).
        text (RenderableType, optional): A renderable to display at the right of the spinner (str or Text typically). Defaults to "".
        style (StyleType, optional): Style for spinner animation. Defaults to None.
        speed (float, optional): Speed factor for animation. Defaults to 1.0.
    Raises:
        KeyError: If name isn't one of the supported spinner animations.
    """
    def __init__(
        self,
        name: str,
        text: "RenderableType" = "",
        *,
        style: Optional["StyleType"] = None,
        speed: float = 1.0,
    ) -> None:
        try:
            spinner = SPINNERS[name]
        except KeyError:
            raise KeyError(f"no spinner called {name!r}")
        self.text: "Union[RenderableType, Text]" = (
            Text.from_markup(text) if isinstance(text, str) else text
        )
        self.name = name
        self.frames = cast(List[str], spinner["frames"])[:]
        self.interval = cast(float, spinner["interval"])
        self.start_time: Optional[float] = None
        self.style = style
        self.speed = speed
        self.frame_no_offset: float = 0.0
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/rich/_windows_renderer.py =====
from typing import Iterable, Sequence, Tuple, cast
from pip._vendor.rich._win32_console import LegacyWindowsTerm, WindowsCoordinates
from pip._vendor.rich.segment import ControlCode, ControlType, Segment
def legacy_windows_render(buffer: Iterable[Segment], term: LegacyWindowsTerm) -> None:
    """Makes appropriate Windows Console API calls based on the segments in the buffer.
    Args:
        buffer (Iterable[Segment]): Iterable of Segments to convert to Win32 API calls.
        term (LegacyWindowsTerm): Used to call the Windows Console API.
    """
    for text, style, control in buffer:
        if not control:
            if style:
                term.write_styled(text, style)
            else:
                term.write_text(text)
        else:
            control_codes: Sequence[ControlCode] = control
            for control_code in control_codes:
                control_type = control_code[0]
                if control_type == ControlType.CURSOR_MOVE_TO:
                    _, x, y = cast(Tuple[ControlType, int, int], control_code)
                    term.move_cursor_to(WindowsCoordinates(row=y - 1, col=x - 1))
                elif control_type == ControlType.CARRIAGE_RETURN:
                    term.write_text("\r")
                elif control_type == ControlType.HOME:
                    term.move_cursor_to(WindowsCoordinates(0, 0))
                elif control_type == ControlType.CURSOR_UP:
                    term.move_cursor_up()
                elif control_type == ControlType.CURSOR_DOWN:
                    term.move_cursor_down()
                elif control_type == ControlType.CURSOR_FORWARD:
                    term.move_cursor_forward()
                elif control_type == ControlType.CURSOR_BACKWARD:
                    term.move_cursor_backward()
                elif control_type == ControlType.CURSOR_MOVE_TO_COLUMN:
                    _, column = cast(Tuple[ControlType, int], control_code)
                    term.move_cursor_to_column(column - 1)
                elif control_type == ControlType.HIDE_CURSOR:
                    term.hide_cursor()
                elif control_type == ControlType.SHOW_CURSOR:
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/rich/json.py =====
from pathlib import Path
from json import loads, dumps
from typing import Any, Callable, Optional, Union
from .text import Text
from .highlighter import JSONHighlighter, NullHighlighter
class JSON:
    """A renderable which pretty prints JSON.
    Args:
        json (str): JSON encoded data.
        indent (Union[None, int, str], optional): Number of characters to indent by. Defaults to 2.
        highlight (bool, optional): Enable highlighting. Defaults to True.
        skip_keys (bool, optional): Skip keys not of a basic type. Defaults to False.
        ensure_ascii (bool, optional): Escape all non-ascii characters. Defaults to False.
        check_circular (bool, optional): Check for circular references. Defaults to True.
        allow_nan (bool, optional): Allow NaN and Infinity values. Defaults to True.
        default (Callable, optional): A callable that converts values that can not be encoded
            in to something that can be JSON encoded. Defaults to None.
        sort_keys (bool, optional): Sort dictionary keys. Defaults to False.
    """
    def __init__(
        self,
        json: str,
        indent: Union[None, int, str] = 2,
        highlight: bool = True,
        skip_keys: bool = False,
        ensure_ascii: bool = False,
        check_circular: bool = True,
        allow_nan: bool = True,
        default: Optional[Callable[[Any], Any]] = None,
        sort_keys: bool = False,
    ) -> None:
        data = loads(json)
        json = dumps(
            data,
            indent=indent,
            skipkeys=skip_keys,
            ensure_ascii=ensure_ascii,
            check_circular=check_circular,
            allow_nan=allow_nan,
            default=default,
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/rich/padding.py =====
from typing import TYPE_CHECKING, List, Optional, Tuple, Union
if TYPE_CHECKING:
    from .console import (
        Console,
        ConsoleOptions,
        RenderableType,
        RenderResult,
    )
from .jupyter import JupyterMixin
from .measure import Measurement
from .segment import Segment
from .style import Style
PaddingDimensions = Union[int, Tuple[int], Tuple[int, int], Tuple[int, int, int, int]]
class Padding(JupyterMixin):
    """Draw space around content.
    Example:
        >>> print(Padding("Hello", (2, 4), style="on blue"))
    Args:
        renderable (RenderableType): String or other renderable.
        pad (Union[int, Tuple[int]]): Padding for top, right, bottom, and left borders.
            May be specified with 1, 2, or 4 integers (CSS style).
        style (Union[str, Style], optional): Style for padding characters. Defaults to "none".
        expand (bool, optional): Expand padding to fit available width. Defaults to True.
    """
    def __init__(
        self,
        renderable: "RenderableType",
        pad: "PaddingDimensions" = (0, 0, 0, 0),
        *,
        style: Union[str, Style] = "none",
        expand: bool = True,
    ):
        self.renderable = renderable
        self.top, self.right, self.bottom, self.left = self.unpack(pad)
        self.style = style
        self.expand = expand
    @classmethod
    def indent(cls, renderable: "RenderableType", level: int) -> "Padding":
        """Make padding instance to render an indent.
        Args:
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/rich/__main__.py =====
import colorsys
import io
from time import process_time
from pip._vendor.rich import box
from pip._vendor.rich.color import Color
from pip._vendor.rich.console import Console, ConsoleOptions, Group, RenderableType, RenderResult
from pip._vendor.rich.markdown import Markdown
from pip._vendor.rich.measure import Measurement
from pip._vendor.rich.pretty import Pretty
from pip._vendor.rich.segment import Segment
from pip._vendor.rich.style import Style
from pip._vendor.rich.syntax import Syntax
from pip._vendor.rich.table import Table
from pip._vendor.rich.text import Text
class ColorBox:
    def __rich_console__(
        self, console: Console, options: ConsoleOptions
    ) -> RenderResult:
        for y in range(0, 5):
            for x in range(options.max_width):
                h = x / options.max_width
                l = 0.1 + ((y / 5) * 0.7)
                r1, g1, b1 = colorsys.hls_to_rgb(h, l, 1.0)
                r2, g2, b2 = colorsys.hls_to_rgb(h, l + 0.7 / 10, 1.0)
                bgcolor = Color.from_rgb(r1 * 255, g1 * 255, b1 * 255)
                color = Color.from_rgb(r2 * 255, g2 * 255, b2 * 255)
                yield Segment("▄", Style(color=color, bgcolor=bgcolor))
            yield Segment.line()
    def __rich_measure__(
        self, console: "Console", options: ConsoleOptions
    ) -> Measurement:
        return Measurement(1, options.max_width)
def make_test_card() -> Table:
    """Get a renderable that demonstrates a number of features."""
    table = Table.grid(padding=1, pad_edge=True)
    table.title = "Rich features"
    table.add_column("Feature", no_wrap=True, justify="center", style="bold red")
    table.add_column("Demonstration")
    color_table = Table(
        box=None,
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/rich/scope.py =====
from collections.abc import Mapping
from typing import TYPE_CHECKING, Any, Optional, Tuple
from .highlighter import ReprHighlighter
from .panel import Panel
from .pretty import Pretty
from .table import Table
from .text import Text, TextType
if TYPE_CHECKING:
    from .console import ConsoleRenderable
def render_scope(
    scope: "Mapping[str, Any]",
    *,
    title: Optional[TextType] = None,
    sort_keys: bool = True,
    indent_guides: bool = False,
    max_length: Optional[int] = None,
    max_string: Optional[int] = None,
) -> "ConsoleRenderable":
    """Render python variables in a given scope.
    Args:
        scope (Mapping): A mapping containing variable names and values.
        title (str, optional): Optional title. Defaults to None.
        sort_keys (bool, optional): Enable sorting of items. Defaults to True.
        indent_guides (bool, optional): Enable indentation guides. Defaults to False.
        max_length (int, optional): Maximum length of containers before abbreviating, or None for no abbreviation.
            Defaults to None.
        max_string (int, optional): Maximum length of string before truncating, or None to disable. Defaults to None.
    Returns:
        ConsoleRenderable: A renderable object.
    """
    highlighter = ReprHighlighter()
    items_table = Table.grid(padding=(0, 1), expand=False)
    items_table.add_column(justify="right")
    def sort_items(item: Tuple[str, Any]) -> Tuple[bool, str]:
        """Sort special variables first, then alphabetically."""
        key, _ = item
        return (not key.startswith("__"), key.lower())
    items = sorted(scope.items(), key=sort_items) if sort_keys else scope.items()
    for key, value in items:
        key_text = Text.assemble(
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/rich/_extension.py =====
from typing import Any
def load_ipython_extension(ip: Any) -> None:  # pragma: no cover
    # prevent circular import
    from pip._vendor.rich.pretty import install
    from pip._vendor.rich.traceback import install as tr_install
    install()
    tr_install()
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/rich/status.py =====
from types import TracebackType
from typing import Optional, Type
from .console import Console, RenderableType
from .jupyter import JupyterMixin
from .live import Live
from .spinner import Spinner
from .style import StyleType
class Status(JupyterMixin):
    """Displays a status indicator with a 'spinner' animation.
    Args:
        status (RenderableType): A status renderable (str or Text typically).
        console (Console, optional): Console instance to use, or None for global console. Defaults to None.
        spinner (str, optional): Name of spinner animation (see python -m rich.spinner). Defaults to "dots".
        spinner_style (StyleType, optional): Style of spinner. Defaults to "status.spinner".
        speed (float, optional): Speed factor for spinner animation. Defaults to 1.0.
        refresh_per_second (float, optional): Number of refreshes per second. Defaults to 12.5.
    """
    def __init__(
        self,
        status: RenderableType,
        *,
        console: Optional[Console] = None,
        spinner: str = "dots",
        spinner_style: StyleType = "status.spinner",
        speed: float = 1.0,
        refresh_per_second: float = 12.5,
    ):
        self.status = status
        self.spinner_style = spinner_style
        self.speed = speed
        self._spinner = Spinner(spinner, text=status, style=spinner_style, speed=speed)
        self._live = Live(
            self.renderable,
            console=console,
            refresh_per_second=refresh_per_second,
            transient=True,
        )
    @property
    def renderable(self) -> Spinner:
        return self._spinner
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/rich/abc.py =====
from abc import ABC
class RichRenderable(ABC):
    """An abstract base class for Rich renderables.
    Note that there is no need to extend this class, the intended use is to check if an
    object supports the Rich renderable protocol. For example::
        if isinstance(my_object, RichRenderable):
            console.print(my_object)
    """
    @classmethod
    def __subclasshook__(cls, other: type) -> bool:
        """Check if this class supports the rich render protocol."""
        return hasattr(other, "__rich_console__") or hasattr(other, "__rich__")
if __name__ == "__main__":  # pragma: no cover
    from pip._vendor.rich.text import Text
    t = Text()
    print(isinstance(Text, RichRenderable))
    print(isinstance(t, RichRenderable))
    class Foo:
        pass
    f = Foo()
    print(isinstance(f, RichRenderable))
    print(isinstance("", RichRenderable))
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/rich/jupyter.py =====
from typing import TYPE_CHECKING, Any, Dict, Iterable, List, Sequence
if TYPE_CHECKING:
    from pip._vendor.rich.console import ConsoleRenderable
from . import get_console
from .segment import Segment
from .terminal_theme import DEFAULT_TERMINAL_THEME
if TYPE_CHECKING:
    from pip._vendor.rich.console import ConsoleRenderable
JUPYTER_HTML_FORMAT = """\
<pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace">{code}</pre>
"""
class JupyterRenderable:
    """A shim to write html to Jupyter notebook."""
    def __init__(self, html: str, text: str) -> None:
        self.html = html
        self.text = text
    def _repr_mimebundle_(
        self, include: Sequence[str], exclude: Sequence[str], **kwargs: Any
    ) -> Dict[str, str]:
        data = {"text/plain": self.text, "text/html": self.html}
        if include:
            data = {k: v for (k, v) in data.items() if k in include}
        if exclude:
            data = {k: v for (k, v) in data.items() if k not in exclude}
        return data
class JupyterMixin:
    """Add to an Rich renderable to make it render in Jupyter notebook."""
    __slots__ = ()
    def _repr_mimebundle_(
        self: "ConsoleRenderable",
        include: Sequence[str],
        exclude: Sequence[str],
        **kwargs: Any,
    ) -> Dict[str, str]:
        console = get_console()
        segments = list(console.render(self, console.options))
        html = _render_segments(segments)
        text = console._render_buffer(segments)
        data = {"text/plain": text, "text/html": html}
        if include:
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/rich/color_triplet.py =====
from typing import NamedTuple, Tuple
class ColorTriplet(NamedTuple):
    """The red, green, and blue components of a color."""
    red: int
    """Red component in 0 to 255 range."""
    green: int
    """Green component in 0 to 255 range."""
    blue: int
    """Blue component in 0 to 255 range."""
    @property
    def hex(self) -> str:
        """get the color triplet in CSS style."""
        red, green, blue = self
        return f"#{red:02x}{green:02x}{blue:02x}"
    @property
    def rgb(self) -> str:
        """The color in RGB format.
        Returns:
            str: An rgb color, e.g. ``"rgb(100,23,255)"``.
        """
        red, green, blue = self
        return f"rgb({red},{green},{blue})"
    @property
    def normalized(self) -> Tuple[float, float, float]:
        """Convert components into floats between 0 and 1.
        Returns:
            Tuple[float, float, float]: A tuple of three normalized colour components.
        """
        red, green, blue = self
        return red / 255.0, green / 255.0, blue / 255.0
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/tomli_w/_writer.py =====
from __future__ import annotations
from collections.abc import Mapping
from datetime import date, datetime, time
from types import MappingProxyType
TYPE_CHECKING = False
if TYPE_CHECKING:
    from collections.abc import Generator
    from decimal import Decimal
    from typing import IO, Any, Final
ASCII_CTRL = frozenset(chr(i) for i in range(32)) | frozenset(chr(127))
ILLEGAL_BASIC_STR_CHARS = frozenset('"\\') | ASCII_CTRL - frozenset("\t")
BARE_KEY_CHARS = frozenset(
    "abcdefghijklmnopqrstuvwxyz" "ABCDEFGHIJKLMNOPQRSTUVWXYZ" "0123456789" "-_"
)
ARRAY_TYPES = (list, tuple)
MAX_LINE_LENGTH = 100
COMPACT_ESCAPES = MappingProxyType(
    {
        "\u0008": "\\b",  # backspace
        "\u000A": "\\n",  # linefeed
        "\u000C": "\\f",  # form feed
        "\u000D": "\\r",  # carriage return
        "\u0022": '\\"',  # quote
        "\u005C": "\\\\",  # backslash
    }
)
class Context:
    def __init__(self, allow_multiline: bool, indent: int):
        if indent < 0:
            raise ValueError("Indent width must be non-negative")
        self.allow_multiline: Final = allow_multiline
        # cache rendered inline tables (mapping from object id to rendered inline table)
        self.inline_table_cache: Final[dict[int, str]] = {}
        self.indent_str: Final = " " * indent
def dump(
    obj: Mapping[str, Any],
    fp: IO[bytes],
    /,
    *,
    multiline_strings: bool = False,
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/tomli_w/__init__.py =====
__all__ = ("dumps", "dump")
__version__ = "1.2.0"  # DO NOT EDIT THIS LINE MANUALLY. LET bump2version UTILITY DO IT
from pip._vendor.tomli_w._writer import dump, dumps
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/urllib3/filepost.py =====
from __future__ import absolute_import
import binascii
import codecs
import os
from io import BytesIO
from .fields import RequestField
from .packages import six
from .packages.six import b
writer = codecs.lookup("utf-8")[3]
def choose_boundary():
    """
    Our embarrassingly-simple replacement for mimetools.choose_boundary.
    """
    boundary = binascii.hexlify(os.urandom(16))
    if not six.PY2:
        boundary = boundary.decode("ascii")
    return boundary
def iter_field_objects(fields):
    """
    Iterate over fields.
    Supports list of (k, v) tuples and dicts, and lists of
    :class:`~urllib3.fields.RequestField`.
    """
    if isinstance(fields, dict):
        i = six.iteritems(fields)
    else:
        i = iter(fields)
    for field in i:
        if isinstance(field, RequestField):
            yield field
        else:
            yield RequestField.from_tuples(*field)
def iter_fields(fields):
    """
    .. deprecated:: 1.6
    Iterate over fields.
    The addition of :class:`~urllib3.fields.RequestField` makes this function
    obsolete. Instead, use :func:`iter_field_objects`, which returns
    :class:`~urllib3.fields.RequestField` objects.
    Supports list of (k, v) tuples and dicts.
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/urllib3/fields.py =====
from __future__ import absolute_import
import email.utils
import mimetypes
import re
from .packages import six
def guess_content_type(filename, default="application/octet-stream"):
    """
    Guess the "Content-Type" of a file.
    :param filename:
        The filename to guess the "Content-Type" of using :mod:`mimetypes`.
    :param default:
        If no "Content-Type" can be guessed, default to `default`.
    """
    if filename:
        return mimetypes.guess_type(filename)[0] or default
    return default
def format_header_param_rfc2231(name, value):
    """
    Helper function to format and quote a single header parameter using the
    strategy defined in RFC 2231.
    Particularly useful for header parameters which might contain
    non-ASCII values, like file names. This follows
    `RFC 2388 Section 4.4 <https://tools.ietf.org/html/rfc2388#section-4.4>`_.
    :param name:
        The name of the parameter, a string expected to be ASCII only.
    :param value:
        The value of the parameter, provided as ``bytes`` or `str``.
    :ret:
        An RFC-2231-formatted unicode string.
    """
    if isinstance(value, six.binary_type):
        value = value.decode("utf-8")
    if not any(ch in value for ch in '"\\\r\n'):
        result = u'%s="%s"' % (name, value)
        try:
            result.encode("ascii")
        except (UnicodeEncodeError, UnicodeDecodeError):
            pass
        else:
            return result
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/urllib3/util/queue.py =====
import collections
from ..packages import six
from ..packages.six.moves import queue
if six.PY2:
    # Queue is imported for side effects on MS Windows. See issue #229.
    import Queue as _unused_module_Queue  # noqa: F401
class LifoQueue(queue.Queue):
    def _init(self, _):
        self.queue = collections.deque()
    def _qsize(self, len=len):
        return len(self.queue)
    def _put(self, item):
        self.queue.append(item)
    def _get(self):
        return self.queue.pop()
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/urllib3/util/ssltransport.py =====
import io
import socket
import ssl
from ..exceptions import ProxySchemeUnsupported
from ..packages import six
SSL_BLOCKSIZE = 16384
class SSLTransport:
    """
    The SSLTransport wraps an existing socket and establishes an SSL connection.
    Contrary to Python's implementation of SSLSocket, it allows you to chain
    multiple TLS connections together. It's particularly useful if you need to
    implement TLS within TLS.
    The class supports most of the socket API operations.
    """
    @staticmethod
    def _validate_ssl_context_for_tls_in_tls(ssl_context):
        """
        Raises a ProxySchemeUnsupported if the provided ssl_context can't be used
        for TLS in TLS.
        The only requirement is that the ssl_context provides the 'wrap_bio'
        methods.
        """
        if not hasattr(ssl_context, "wrap_bio"):
            if six.PY2:
                raise ProxySchemeUnsupported(
                    "TLS in TLS requires SSLContext.wrap_bio() which isn't "
                    "supported on Python 2"
                )
            else:
                raise ProxySchemeUnsupported(
                    "TLS in TLS requires SSLContext.wrap_bio() which isn't "
                    "available on non-native SSLContext"
                )
    def __init__(
        self, socket, ssl_context, server_hostname=None, suppress_ragged_eofs=True
    ):
        """
        Create an SSLTransport around socket using the provided ssl_context.
        """
        self.incoming = ssl.MemoryBIO()
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/urllib3/util/proxy.py =====
from .ssl_ import create_urllib3_context, resolve_cert_reqs, resolve_ssl_version
def connection_requires_http_tunnel(
    proxy_url=None, proxy_config=None, destination_scheme=None
):
    """
    Returns True if the connection requires an HTTP CONNECT through the proxy.
    :param URL proxy_url:
        URL of the proxy.
    :param ProxyConfig proxy_config:
        Proxy configuration from poolmanager.py
    :param str destination_scheme:
        The scheme of the destination. (i.e https, http, etc)
    """
    # If we're not using a proxy, no way to use a tunnel.
    if proxy_url is None:
        return False
    # HTTP destinations never require tunneling, we always forward.
    if destination_scheme == "http":
        return False
    # Support for forwarding with HTTPS proxies and HTTPS destinations.
    if (
        proxy_url.scheme == "https"
        and proxy_config
        and proxy_config.use_forwarding_for_https
    ):
        return False
    # Otherwise always use a tunnel.
    return True
def create_proxy_ssl_context(
    ssl_version, cert_reqs, ca_certs=None, ca_cert_dir=None, ca_cert_data=None
):
    """
    Generates a default proxy ssl context if one hasn't been provided by the
    user.
    """
    ssl_context = create_urllib3_context(
        ssl_version=resolve_ssl_version(ssl_version),
        cert_reqs=resolve_cert_reqs(cert_reqs),
    )
    if (
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/urllib3/util/wait.py =====
import errno
import select
import sys
from functools import partial
try:
    from time import monotonic
except ImportError:
    from time import time as monotonic
__all__ = ["NoWayToWaitForSocketError", "wait_for_read", "wait_for_write"]
class NoWayToWaitForSocketError(Exception):
    pass
if sys.version_info >= (3, 5):
    # Modern Python, that retries syscalls by default
    def _retry_on_intr(fn, timeout):
        return fn(timeout)
else:
    # Old and broken Pythons.
    def _retry_on_intr(fn, timeout):
        if timeout is None:
            deadline = float("inf")
        else:
            deadline = monotonic() + timeout
        while True:
            try:
                return fn(timeout)
            # OSError for 3 <= pyver < 3.5, select.error for pyver <= 2.7
            except (OSError, select.error) as e:
                # 'e.args[0]' incantation works for both OSError and select.error
                if e.args[0] != errno.EINTR:
                    raise
                else:
                    timeout = deadline - monotonic()
                    if timeout < 0:
                        timeout = 0
                    if timeout == float("inf"):
                        timeout = None
                    continue
def select_wait_for_socket(sock, read=False, write=False, timeout=None):
    if not read and not write:
        raise RuntimeError("must specify at least one of read=True, write=True")
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/urllib3/util/request.py =====
from __future__ import absolute_import
from base64 import b64encode
from ..exceptions import UnrewindableBodyError
from ..packages.six import b, integer_types
SKIP_HEADER = "@@@SKIP_HEADER@@@"
SKIPPABLE_HEADERS = frozenset(["accept-encoding", "host", "user-agent"])
ACCEPT_ENCODING = "gzip,deflate"
_FAILEDTELL = object()
def make_headers(
    keep_alive=None,
    accept_encoding=None,
    user_agent=None,
    basic_auth=None,
    proxy_basic_auth=None,
    disable_cache=None,
):
    """
    Shortcuts for generating request headers.
    :param keep_alive:
        If ``True``, adds 'connection: keep-alive' header.
    :param accept_encoding:
        Can be a boolean, list, or string.
        ``True`` translates to 'gzip,deflate'.
        List will get joined by comma.
        String will be used as provided.
    :param user_agent:
        String representing the user-agent you want, such as
        "python-urllib3/0.6"
    :param basic_auth:
        Colon-separated username:password string for 'authorization: basic ...'
        auth header.
    :param proxy_basic_auth:
        Colon-separated username:password string for 'proxy-authorization: basic ...'
        auth header.
    :param disable_cache:
        If ``True``, adds 'cache-control: no-cache' header.
    Example::
        >>> make_headers(keep_alive=True, user_agent="Batman/1.0")
        {'connection': 'keep-alive', 'user-agent': 'Batman/1.0'}
        >>> make_headers(accept_encoding=True)
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/urllib3/util/timeout.py =====
from __future__ import absolute_import
import time
from socket import _GLOBAL_DEFAULT_TIMEOUT, getdefaulttimeout
from ..exceptions import TimeoutStateError
_Default = object()
current_time = getattr(time, "monotonic", time.time)
class Timeout(object):
    """Timeout configuration.
    Timeouts can be defined as a default for a pool:
    .. code-block:: python
       timeout = Timeout(connect=2.0, read=7.0)
       http = PoolManager(timeout=timeout)
       response = http.request('GET', 'http://example.com/')
    Or per-request (which overrides the default for the pool):
    .. code-block:: python
       response = http.request('GET', 'http://example.com/', timeout=Timeout(10))
    Timeouts can be disabled by setting all the parameters to ``None``:
    .. code-block:: python
       no_timeout = Timeout(connect=None, read=None)
       response = http.request('GET', 'http://example.com/, timeout=no_timeout)
    :param total:
        This combines the connect and read timeouts into one; the read timeout
        will be set to the time leftover from the connect attempt. In the
        event that both a connect timeout and a total are specified, or a read
        timeout and a total are specified, the shorter timeout will be applied.
        Defaults to None.
    :type total: int, float, or None
    :param connect:
        The maximum amount of time (in seconds) to wait for a connection
        attempt to a server to succeed. Omitting the parameter will default the
        connect timeout to the system default, probably `the global default
        timeout in socket.py
        <http://hg.python.org/cpython/file/603b4d593758/Lib/socket.py#l535>`_.
        None will set an infinite timeout for connection attempts.
    :type connect: int, float, or None
    :param read:
        The maximum amount of time (in seconds) to wait between consecutive
        read operations for a response from the server. Omitting the parameter
        will default the read timeout to the system default, probably `the
        global default timeout in socket.py
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/urllib3/util/__init__.py =====
from __future__ import absolute_import
from .connection import is_connection_dropped
from .request import SKIP_HEADER, SKIPPABLE_HEADERS, make_headers
from .response import is_fp_closed
from .retry import Retry
from .ssl_ import (
    ALPN_PROTOCOLS,
    HAS_SNI,
    IS_PYOPENSSL,
    IS_SECURETRANSPORT,
    PROTOCOL_TLS,
    SSLContext,
    assert_fingerprint,
    resolve_cert_reqs,
    resolve_ssl_version,
    ssl_wrap_socket,
)
from .timeout import Timeout, current_time
from .url import Url, get_host, parse_url, split_first
from .wait import wait_for_read, wait_for_write
__all__ = (
    "HAS_SNI",
    "IS_PYOPENSSL",
    "IS_SECURETRANSPORT",
    "SSLContext",
    "PROTOCOL_TLS",
    "ALPN_PROTOCOLS",
    "Retry",
    "Timeout",
    "Url",
    "assert_fingerprint",
    "current_time",
    "is_connection_dropped",
    "is_fp_closed",
    "get_host",
    "parse_url",
    "make_headers",
    "resolve_cert_reqs",
    "resolve_ssl_version",
    "split_first",
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/urllib3/util/response.py =====
from __future__ import absolute_import
from email.errors import MultipartInvariantViolationDefect, StartBoundaryNotFoundDefect
from ..exceptions import HeaderParsingError
from ..packages.six.moves import http_client as httplib
def is_fp_closed(obj):
    """
    Checks whether a given file-like object is closed.
    :param obj:
        The file-like object to check.
    """
    try:
        # Check `isclosed()` first, in case Python3 doesn't set `closed`.
        # GH Issue #928
        return obj.isclosed()
    except AttributeError:
        pass
    try:
        # Check via the official file-like-object way.
        return obj.closed
    except AttributeError:
        pass
    try:
        # Check if the object is a container for another file-like object that
        # gets released on exhaustion (e.g. HTTPResponse).
        return obj.fp is None
    except AttributeError:
        pass
    raise ValueError("Unable to determine whether fp is closed.")
def assert_header_parsing(headers):
    """
    Asserts whether all headers have been successfully parsed.
    Extracts encountered errors from the result of parsing headers.
    Only works on Python 3.
    :param http.client.HTTPMessage headers: Headers to verify.
    :raises urllib3.exceptions.HeaderParsingError:
        If parsing errors are found.
    """
    # This will fail silently if we pass in the wrong kind of parameter.
    # To make debugging easier add an explicit check.
    if not isinstance(headers, httplib.HTTPMessage):
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/urllib3/util/ssl_.py =====
from __future__ import absolute_import
import hashlib
import hmac
import os
import sys
import warnings
from binascii import hexlify, unhexlify
from ..exceptions import (
    InsecurePlatformWarning,
    ProxySchemeUnsupported,
    SNIMissingWarning,
    SSLError,
)
from ..packages import six
from .url import BRACELESS_IPV6_ADDRZ_RE, IPV4_RE
SSLContext = None
SSLTransport = None
HAS_SNI = False
IS_PYOPENSSL = False
IS_SECURETRANSPORT = False
ALPN_PROTOCOLS = ["http/1.1"]
HASHFUNC_MAP = {
    length: getattr(hashlib, algorithm, None)
    for length, algorithm in ((32, "md5"), (40, "sha1"), (64, "sha256"))
}
def _const_compare_digest_backport(a, b):
    """
    Compare two digests of equal length in constant time.
    The digests must be of type str/bytes.
    Returns True if the digests match, and False otherwise.
    """
    result = abs(len(a) - len(b))
    for left, right in zip(bytearray(a), bytearray(b)):
        result |= left ^ right
    return result == 0
_const_compare_digest = getattr(hmac, "compare_digest", _const_compare_digest_backport)
try:  # Test for SSL features
    import ssl
    from ssl import CERT_REQUIRED, wrap_socket
except ImportError:
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/urllib3/util/retry.py =====
from __future__ import absolute_import
import email
import logging
import re
import time
import warnings
from collections import namedtuple
from itertools import takewhile
from ..exceptions import (
    ConnectTimeoutError,
    InvalidHeader,
    MaxRetryError,
    ProtocolError,
    ProxyError,
    ReadTimeoutError,
    ResponseError,
)
from ..packages import six
log = logging.getLogger(__name__)
RequestHistory = namedtuple(
    "RequestHistory", ["method", "url", "error", "status", "redirect_location"]
)
_Default = object()
class _RetryMeta(type):
    @property
    def DEFAULT_METHOD_WHITELIST(cls):
        warnings.warn(
            "Using 'Retry.DEFAULT_METHOD_WHITELIST' is deprecated and "
            "will be removed in v2.0. Use 'Retry.DEFAULT_ALLOWED_METHODS' instead",
            DeprecationWarning,
        )
        return cls.DEFAULT_ALLOWED_METHODS
    @DEFAULT_METHOD_WHITELIST.setter
    def DEFAULT_METHOD_WHITELIST(cls, value):
        warnings.warn(
            "Using 'Retry.DEFAULT_METHOD_WHITELIST' is deprecated and "
            "will be removed in v2.0. Use 'Retry.DEFAULT_ALLOWED_METHODS' instead",
            DeprecationWarning,
        )
        cls.DEFAULT_ALLOWED_METHODS = value
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/urllib3/util/url.py =====
from __future__ import absolute_import
import re
from collections import namedtuple
from ..exceptions import LocationParseError
from ..packages import six
url_attrs = ["scheme", "auth", "host", "port", "path", "query", "fragment"]
NORMALIZABLE_SCHEMES = ("http", "https", None)
PERCENT_RE = re.compile(r"%[a-fA-F0-9]{2}")
SCHEME_RE = re.compile(r"^(?:[a-zA-Z][a-zA-Z0-9+-]*:|/)")
URI_RE = re.compile(
    r"^(?:([a-zA-Z][a-zA-Z0-9+.-]*):)?"
    r"(?://([^\\/?#]*))?"
    r"([^?#]*)"
    r"(?:\?([^#]*))?"
    r"(?:#(.*))?$",
    re.UNICODE | re.DOTALL,
)
IPV4_PAT = r"(?:[0-9]{1,3}\.){3}[0-9]{1,3}"
HEX_PAT = "[0-9A-Fa-f]{1,4}"
LS32_PAT = "(?:{hex}:{hex}|{ipv4})".format(hex=HEX_PAT, ipv4=IPV4_PAT)
_subs = {"hex": HEX_PAT, "ls32": LS32_PAT}
_variations = [
    #                            6( h16 ":" ) ls32
    "(?:%(hex)s:){6}%(ls32)s",
    #                       "::" 5( h16 ":" ) ls32
    "::(?:%(hex)s:){5}%(ls32)s",
    # [               h16 ] "::" 4( h16 ":" ) ls32
    "(?:%(hex)s)?::(?:%(hex)s:){4}%(ls32)s",
    # [ *1( h16 ":" ) h16 ] "::" 3( h16 ":" ) ls32
    "(?:(?:%(hex)s:)?%(hex)s)?::(?:%(hex)s:){3}%(ls32)s",
    # [ *2( h16 ":" ) h16 ] "::" 2( h16 ":" ) ls32
    "(?:(?:%(hex)s:){0,2}%(hex)s)?::(?:%(hex)s:){2}%(ls32)s",
    # [ *3( h16 ":" ) h16 ] "::"    h16 ":"   ls32
    "(?:(?:%(hex)s:){0,3}%(hex)s)?::%(hex)s:%(ls32)s",
    # [ *4( h16 ":" ) h16 ] "::"              ls32
    "(?:(?:%(hex)s:){0,4}%(hex)s)?::%(ls32)s",
    # [ *5( h16 ":" ) h16 ] "::"              h16
    "(?:(?:%(hex)s:){0,5}%(hex)s)?::%(hex)s",
    # [ *6( h16 ":" ) h16 ] "::"
    "(?:(?:%(hex)s:){0,6}%(hex)s)?::",
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/urllib3/util/connection.py =====
from __future__ import absolute_import
import socket
from ..contrib import _appengine_environ
from ..exceptions import LocationParseError
from ..packages import six
from .wait import NoWayToWaitForSocketError, wait_for_read
def is_connection_dropped(conn):  # Platform-specific
    """
    Returns True if the connection is dropped and should be closed.
    :param conn:
        :class:`http.client.HTTPConnection` object.
    Note: For platforms like AppEngine, this will always return ``False`` to
    let the platform handle connection recycling transparently for us.
    """
    sock = getattr(conn, "sock", False)
    if sock is False:  # Platform-specific: AppEngine
        return False
    if sock is None:  # Connection already closed (such as by httplib).
        return True
    try:
        # Returns True if readable, which here means it's been dropped
        return wait_for_read(sock, timeout=0.0)
    except NoWayToWaitForSocketError:  # Platform-specific: AppEngine
        return False
def create_connection(
    address,
    timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
    source_address=None,
    socket_options=None,
):
    """Connect to *address* and return the socket object.
    Convenience function.  Connect to *address* (a 2-tuple ``(host,
    port)``) and return the socket object.  Passing the optional
    *timeout* parameter will set the timeout on the socket instance
    before attempting to connect.  If no *timeout* is supplied, the
    global default timeout setting returned by :func:`socket.getdefaulttimeout`
    is used.  If *source_address* is set it must be a tuple of (host, port)
    for the socket to bind as a source address before making the connection.
    An host of '' or port 0 tells the OS to use the default.
    """
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/urllib3/util/ssl_match_hostname.py =====
"""The match_hostname() function from Python 3.3.3, essential when using SSL."""
import re
import sys
try:
    import ipaddress
except ImportError:
    ipaddress = None
__version__ = "3.5.0.1"
class CertificateError(ValueError):
    pass
def _dnsname_match(dn, hostname, max_wildcards=1):
    """Matching according to RFC 6125, section 6.4.3
    http://tools.ietf.org/html/rfc6125#section-6.4.3
    """
    pats = []
    if not dn:
        return False
    # Ported from python3-syntax:
    # leftmost, *remainder = dn.split(r'.')
    parts = dn.split(r".")
    leftmost = parts[0]
    remainder = parts[1:]
    wildcards = leftmost.count("*")
    if wildcards > max_wildcards:
        # Issue #17980: avoid denials of service by refusing more
        # than one wildcard per fragment.  A survey of established
        # policy among SSL implementations showed it to be a
        # reasonable choice.
        raise CertificateError(
            "too many wildcards in certificate DNS name: " + repr(dn)
        )
    # speed up common case w/o wildcards
    if not wildcards:
        return dn.lower() == hostname.lower()
    # RFC 6125, section 6.4.3, subitem 1.
    # The client SHOULD NOT attempt to match a presented identifier in which
    # the wildcard character comprises a label other than the left-most label.
    if leftmost == "*":
        # When '*' is a fragment by itself, it matches a non-empty dotless
        # fragment.
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/urllib3/_version.py =====
__version__ = "1.26.20"
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/urllib3/request.py =====
from __future__ import absolute_import
import sys
from .filepost import encode_multipart_formdata
from .packages import six
from .packages.six.moves.urllib.parse import urlencode
__all__ = ["RequestMethods"]
class RequestMethods(object):
    """
    Convenience mixin for classes who implement a :meth:`urlopen` method, such
    as :class:`urllib3.HTTPConnectionPool` and
    :class:`urllib3.PoolManager`.
    Provides behavior for making common types of HTTP request methods and
    decides which type of request field encoding to use.
    Specifically,
    :meth:`.request_encode_url` is for sending requests whose fields are
    encoded in the URL (such as GET, HEAD, DELETE).
    :meth:`.request_encode_body` is for sending requests whose fields are
    encoded in the *body* of the request using multipart or www-form-urlencoded
    (such as for POST, PUT, PATCH).
    :meth:`.request` is for making any kind of request, it will look up the
    appropriate encoding format and use one of the above two methods to make
    the request.
    Initializer parameters:
    :param headers:
        Headers to include with all requests, unless other headers are given
        explicitly.
    """
    _encode_url_methods = {"DELETE", "GET", "HEAD", "OPTIONS"}
    def __init__(self, headers=None):
        self.headers = headers or {}
    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        encode_multipart=True,
        multipart_boundary=None,
        **kw
    ):  # Abstract
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/urllib3/__init__.py =====
"""
Python HTTP library with thread-safe connection pooling, file post support, user friendly, and more
"""
from __future__ import absolute_import
import logging
import warnings
from logging import NullHandler
from . import exceptions
from ._version import __version__
from .connectionpool import HTTPConnectionPool, HTTPSConnectionPool, connection_from_url
from .filepost import encode_multipart_formdata
from .poolmanager import PoolManager, ProxyManager, proxy_from_url
from .response import HTTPResponse
from .util.request import make_headers
from .util.retry import Retry
from .util.timeout import Timeout
from .util.url import get_host
try:
    import urllib3_secure_extra  # type: ignore # noqa: F401
except ImportError:
    pass
else:
    warnings.warn(
        "'urllib3[secure]' extra is deprecated and will be removed "
        "in a future release of urllib3 2.x. Read more in this issue: "
        "https://github.com/urllib3/urllib3/issues/2680",
        category=DeprecationWarning,
        stacklevel=2,
    )
__author__ = "Andrey Petrov (andrey.petrov@shazow.net)"
__license__ = "MIT"
__version__ = __version__
__all__ = (
    "HTTPConnectionPool",
    "HTTPSConnectionPool",
    "PoolManager",
    "ProxyManager",
    "HTTPResponse",
    "Retry",
    "Timeout",
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/urllib3/poolmanager.py =====
from __future__ import absolute_import
import collections
import functools
import logging
from ._collections import HTTPHeaderDict, RecentlyUsedContainer
from .connectionpool import HTTPConnectionPool, HTTPSConnectionPool, port_by_scheme
from .exceptions import (
    LocationValueError,
    MaxRetryError,
    ProxySchemeUnknown,
    ProxySchemeUnsupported,
    URLSchemeUnknown,
)
from .packages import six
from .packages.six.moves.urllib.parse import urljoin
from .request import RequestMethods
from .util.proxy import connection_requires_http_tunnel
from .util.retry import Retry
from .util.url import parse_url
__all__ = ["PoolManager", "ProxyManager", "proxy_from_url"]
log = logging.getLogger(__name__)
SSL_KEYWORDS = (
    "key_file",
    "cert_file",
    "cert_reqs",
    "ca_certs",
    "ssl_version",
    "ca_cert_dir",
    "ssl_context",
    "key_password",
    "server_hostname",
)
_key_fields = (
    "key_scheme",  # str
    "key_host",  # str
    "key_port",  # int
    "key_timeout",  # int or float or Timeout
    "key_retries",  # int or Retry
    "key_strict",  # bool
    "key_block",  # bool
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/urllib3/response.py =====
from __future__ import absolute_import
import io
import logging
import sys
import warnings
import zlib
from contextlib import contextmanager
from socket import error as SocketError
from socket import timeout as SocketTimeout
brotli = None
from . import util
from ._collections import HTTPHeaderDict
from .connection import BaseSSLError, HTTPException
from .exceptions import (
    BodyNotHttplibCompatible,
    DecodeError,
    HTTPError,
    IncompleteRead,
    InvalidChunkLength,
    InvalidHeader,
    ProtocolError,
    ReadTimeoutError,
    ResponseNotChunked,
    SSLError,
)
from .packages import six
from .util.response import is_fp_closed, is_response_to_head
log = logging.getLogger(__name__)
class DeflateDecoder(object):
    def __init__(self):
        self._first_try = True
        self._data = b""
        self._obj = zlib.decompressobj()
    def __getattr__(self, name):
        return getattr(self._obj, name)
    def decompress(self, data):
        if not data:
            return data
        if not self._first_try:
            return self._obj.decompress(data)
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/urllib3/contrib/securetransport.py =====
"""
SecureTranport support for urllib3 via ctypes.
This makes platform-native TLS available to urllib3 users on macOS without the
use of a compiler. This is an important feature because the Python Package
Index is moving to become a TLSv1.2-or-higher server, and the default OpenSSL
that ships with macOS is not capable of doing TLSv1.2. The only way to resolve
this is to give macOS users an alternative solution to the problem, and that
solution is to use SecureTransport.
We use ctypes here because this solution must not require a compiler. That's
because pip is not allowed to require a compiler either.
This is not intended to be a seriously long-term solution to this problem.
The hope is that PEP 543 will eventually solve this issue for us, at which
point we can retire this contrib module. But in the short term, we need to
solve the impending tire fire that is Python on Mac without this kind of
contrib module. So...here we are.
To use this module, simply import and inject it::
    import pip._vendor.urllib3.contrib.securetransport as securetransport
    securetransport.inject_into_urllib3()
Happy TLSing!
This code is a bastardised version of the code found in Will Bond's oscrypto
library. An enormous debt is owed to him for blazing this trail for us. For
that reason, this code should be considered to be covered both by urllib3's
license and by oscrypto's:
.. code-block::
    Copyright (c) 2015-2016 Will Bond <will@wbond.net>
    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:
    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.
    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/urllib3/contrib/__init__.py =====
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/urllib3/contrib/socks.py =====
"""
This module contains provisional support for SOCKS proxies from within
urllib3. This module supports SOCKS4, SOCKS4A (an extension of SOCKS4), and
SOCKS5. To enable its functionality, either install PySocks or install this
module with the ``socks`` extra.
The SOCKS implementation supports the full range of urllib3 features. It also
supports the following SOCKS features:
- SOCKS4A (``proxy_url='socks4a://...``)
- SOCKS4 (``proxy_url='socks4://...``)
- SOCKS5 with remote DNS (``proxy_url='socks5h://...``)
- SOCKS5 with local DNS (``proxy_url='socks5://...``)
- Usernames and passwords for the SOCKS proxy
.. note::
   It is recommended to use ``socks5h://`` or ``socks4a://`` schemes in
   your ``proxy_url`` to ensure that DNS resolution is done from the remote
   server instead of client-side when connecting to a domain name.
SOCKS4 supports IPv4 and domain names with the SOCKS4A extension. SOCKS5
supports IPv4, IPv6, and domain names.
When connecting to a SOCKS4 proxy the ``username`` portion of the ``proxy_url``
will be sent as the ``userid`` section of the SOCKS request:
.. code-block:: python
    proxy_url="socks4a://<userid>@proxy-host"
When connecting to a SOCKS5 proxy the ``username`` and ``password`` portion
of the ``proxy_url`` will be sent as the username/password to authenticate
with the proxy:
.. code-block:: python
    proxy_url="socks5h://<username>:<password>@proxy-host"
"""
from __future__ import absolute_import
try:
    import socks
except ImportError:
    import warnings
    from ..exceptions import DependencyWarning
    warnings.warn(
        (
            "SOCKS support in urllib3 requires the installation of optional "
            "dependencies: specifically, PySocks.  For more information, see "
            "https://urllib3.readthedocs.io/en/1.26.x/contrib.html#socks-proxies"
        ),
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/urllib3/contrib/_appengine_environ.py =====
"""
This module provides means to detect the App Engine environment.
"""
import os
def is_appengine():
    return is_local_appengine() or is_prod_appengine()
def is_appengine_sandbox():
    """Reports if the app is running in the first generation sandbox.
    The second generation runtimes are technically still in a sandbox, but it
    is much less restrictive, so generally you shouldn't need to check for it.
    see https://cloud.google.com/appengine/docs/standard/runtimes
    """
    return is_appengine() and os.environ["APPENGINE_RUNTIME"] == "python27"
def is_local_appengine():
    return "APPENGINE_RUNTIME" in os.environ and os.environ.get(
        "SERVER_SOFTWARE", ""
    ).startswith("Development/")
def is_prod_appengine():
    return "APPENGINE_RUNTIME" in os.environ and os.environ.get(
        "SERVER_SOFTWARE", ""
    ).startswith("Google App Engine/")
def is_prod_appengine_mvms():
    """Deprecated."""
    return False
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/urllib3/contrib/pyopenssl.py =====
"""
TLS with SNI_-support for Python 2. Follow these instructions if you would
like to verify TLS certificates in Python 2. Note, the default libraries do
*not* do certificate checking; you need to do additional work to validate
certificates yourself.
This needs the following packages installed:
* `pyOpenSSL`_ (tested with 16.0.0)
* `cryptography`_ (minimum 1.3.4, from pyopenssl)
* `idna`_ (minimum 2.0, from cryptography)
However, pyopenssl depends on cryptography, which depends on idna, so while we
use all three directly here we end up having relatively few packages required.
You can install them with the following command:
.. code-block:: bash
    $ python -m pip install pyopenssl cryptography idna
To activate certificate checking, call
:func:`~urllib3.contrib.pyopenssl.inject_into_urllib3` from your Python code
before you begin making HTTP requests. This can be done in a ``sitecustomize``
module, or at any other time before your application begins using ``urllib3``,
like this:
.. code-block:: python
    try:
        import pip._vendor.urllib3.contrib.pyopenssl as pyopenssl
        pyopenssl.inject_into_urllib3()
    except ImportError:
        pass
Now you can use :mod:`urllib3` as you normally would, and it will support SNI
when the required modules are installed.
Activating this module also has the positive side effect of disabling SSL/TLS
compression in Python 2 (see `CRIME attack`_).
.. _sni: https://en.wikipedia.org/wiki/Server_Name_Indication
.. _crime attack: https://en.wikipedia.org/wiki/CRIME_(security_exploit)
.. _pyopenssl: https://www.pyopenssl.org
.. _cryptography: https://cryptography.io
.. _idna: https://github.com/kjd/idna
"""
from __future__ import absolute_import
import OpenSSL.crypto
import OpenSSL.SSL
from cryptography import x509
from cryptography.hazmat.backends.openssl import backend as openssl_backend
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/urllib3/contrib/appengine.py =====
"""
This module provides a pool manager that uses Google App Engine's
`URLFetch Service <https://cloud.google.com/appengine/docs/python/urlfetch>`_.
Example usage::
    from pip._vendor.urllib3 import PoolManager
    from pip._vendor.urllib3.contrib.appengine import AppEngineManager, is_appengine_sandbox
    if is_appengine_sandbox():
        # AppEngineManager uses AppEngine's URLFetch API behind the scenes
        http = AppEngineManager()
    else:
        # PoolManager uses a socket-level API behind the scenes
        http = PoolManager()
    r = http.request('GET', 'https://google.com/')
There are `limitations <https://cloud.google.com/appengine/docs/python/\
urlfetch/#Python_Quotas_and_limits>`_ to the URLFetch service and it may not be
the best choice for your application. There are three options for using
urllib3 on Google App Engine:
1. You can use :class:`AppEngineManager` with URLFetch. URLFetch is
   cost-effective in many circumstances as long as your usage is within the
   limitations.
2. You can use a normal :class:`~urllib3.PoolManager` by enabling sockets.
   Sockets also have `limitations and restrictions
   <https://cloud.google.com/appengine/docs/python/sockets/\
   #limitations-and-restrictions>`_ and have a lower free quota than URLFetch.
   To use sockets, be sure to specify the following in your ``app.yaml``::
        env_variables:
            GAE_USE_SOCKETS_HTTPLIB : 'true'
3. If you are using `App Engine Flexible
<https://cloud.google.com/appengine/docs/flexible/>`_, you can use the standard
:class:`PoolManager` without any configuration or special environment variables.
"""
from __future__ import absolute_import
import io
import logging
import warnings
from ..exceptions import (
    HTTPError,
    HTTPWarning,
    MaxRetryError,
    ProtocolError,
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/urllib3/contrib/_securetransport/__init__.py =====
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/urllib3/contrib/_securetransport/low_level.py =====
"""
Low-level helpers for the SecureTransport bindings.
These are Python functions that are not directly related to the high-level APIs
but are necessary to get them to work. They include a whole bunch of low-level
CoreFoundation messing about and memory management. The concerns in this module
are almost entirely about trying to avoid memory leaks and providing
appropriate and useful assistance to the higher-level code.
"""
import base64
import ctypes
import itertools
import os
import re
import ssl
import struct
import tempfile
from .bindings import CFConst, CoreFoundation, Security
_PEM_CERTS_RE = re.compile(
    b"-----BEGIN CERTIFICATE-----\n(.*?)\n-----END CERTIFICATE-----", re.DOTALL
)
def _cf_data_from_bytes(bytestring):
    """
    Given a bytestring, create a CFData object from it. This CFData object must
    be CFReleased by the caller.
    """
    return CoreFoundation.CFDataCreate(
        CoreFoundation.kCFAllocatorDefault, bytestring, len(bytestring)
    )
def _cf_dictionary_from_tuples(tuples):
    """
    Given a list of Python tuples, create an associated CFDictionary.
    """
    dictionary_size = len(tuples)
    # We need to get the dictionary keys and values out in the same order.
    keys = (t[0] for t in tuples)
    values = (t[1] for t in tuples)
    cf_keys = (CoreFoundation.CFTypeRef * dictionary_size)(*keys)
    cf_values = (CoreFoundation.CFTypeRef * dictionary_size)(*values)
    return CoreFoundation.CFDictionaryCreate(
        CoreFoundation.kCFAllocatorDefault,
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/urllib3/contrib/_securetransport/bindings.py =====
"""
This module uses ctypes to bind a whole bunch of functions and constants from
SecureTransport. The goal here is to provide the low-level API to
SecureTransport. These are essentially the C-level functions and constants, and
they're pretty gross to work with.
This code is a bastardised version of the code found in Will Bond's oscrypto
library. An enormous debt is owed to him for blazing this trail for us. For
that reason, this code should be considered to be covered both by urllib3's
license and by oscrypto's:
    Copyright (c) 2015-2016 Will Bond <will@wbond.net>
    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:
    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.
    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
"""
from __future__ import absolute_import
import platform
from ctypes import (
    CDLL,
    CFUNCTYPE,
    POINTER,
    c_bool,
    c_byte,
    c_char_p,
    c_int32,
    c_long,
    c_size_t,
    c_uint32,
    c_ulong,
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/urllib3/contrib/ntlmpool.py =====
"""
NTLM authenticating pool, contributed by erikcederstran
Issue #10, see: http://code.google.com/p/urllib3/issues/detail?id=10
"""
from __future__ import absolute_import
import warnings
from logging import getLogger
from ntlm import ntlm
from .. import HTTPSConnectionPool
from ..packages.six.moves.http_client import HTTPSConnection
warnings.warn(
    "The 'urllib3.contrib.ntlmpool' module is deprecated and will be removed "
    "in urllib3 v2.0 release, urllib3 is not able to support it properly due "
    "to reasons listed in issue: https://github.com/urllib3/urllib3/issues/2282. "
    "If you are a user of this module please comment in the mentioned issue.",
    DeprecationWarning,
)
log = getLogger(__name__)
class NTLMConnectionPool(HTTPSConnectionPool):
    """
    Implements an NTLM authentication version of an urllib3 connection pool
    """
    scheme = "https"
    def __init__(self, user, pw, authurl, *args, **kwargs):
        """
        authurl is a random URL on the server that is protected by NTLM.
        user is the Windows user, probably in the DOMAIN\\username format.
        pw is the password for the user.
        """
        super(NTLMConnectionPool, self).__init__(*args, **kwargs)
        self.authurl = authurl
        self.rawuser = user
        user_parts = user.split("\\", 1)
        self.domain = user_parts[0].upper()
        self.user = user_parts[1]
        self.pw = pw
    def _new_conn(self):
        # Performs the NTLM handshake that secures the connection. The socket
        # must be kept open while requests are performed.
        self.num_connections += 1
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/urllib3/connection.py =====
from __future__ import absolute_import
import datetime
import logging
import os
import re
import socket
import warnings
from socket import error as SocketError
from socket import timeout as SocketTimeout
from .packages import six
from .packages.six.moves.http_client import HTTPConnection as _HTTPConnection
from .packages.six.moves.http_client import HTTPException  # noqa: F401
from .util.proxy import create_proxy_ssl_context
try:  # Compiled with SSL?
    import ssl
    BaseSSLError = ssl.SSLError
except (ImportError, AttributeError):  # Platform-specific: No SSL.
    ssl = None
    class BaseSSLError(BaseException):
        pass
try:
    # Python 3: not a no-op, we're adding this to the namespace so it can be imported.
    ConnectionError = ConnectionError
except NameError:
    # Python 2
    class ConnectionError(Exception):
        pass
try:  # Python 3:
    # Not a no-op, we're adding this to the namespace so it can be imported.
    BrokenPipeError = BrokenPipeError
except NameError:  # Python 2:
    class BrokenPipeError(Exception):
        pass
from ._collections import HTTPHeaderDict  # noqa (historical, removed in v2)
from ._version import __version__
from .exceptions import (
    ConnectTimeoutError,
    NewConnectionError,
    SubjectAltNameWarning,
    SystemTimeWarning,
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/urllib3/_collections.py =====
from __future__ import absolute_import
try:
    from collections.abc import Mapping, MutableMapping
except ImportError:
    from collections import Mapping, MutableMapping
try:
    from threading import RLock
except ImportError:  # Platform-specific: No threads available
    class RLock:
        def __enter__(self):
            pass
        def __exit__(self, exc_type, exc_value, traceback):
            pass
from collections import OrderedDict
from .exceptions import InvalidHeader
from .packages import six
from .packages.six import iterkeys, itervalues
__all__ = ["RecentlyUsedContainer", "HTTPHeaderDict"]
_Null = object()
class RecentlyUsedContainer(MutableMapping):
    """
    Provides a thread-safe dict-like container which maintains up to
    ``maxsize`` keys while throwing away the least-recently-used keys beyond
    ``maxsize``.
    :param maxsize:
        Maximum number of recent elements to retain.
    :param dispose_func:
        Every time an item is evicted from the container,
        ``dispose_func(value)`` is called.  Callback which will get called
    """
    ContainerCls = OrderedDict
    def __init__(self, maxsize=10, dispose_func=None):
        self._maxsize = maxsize
        self.dispose_func = dispose_func
        self._container = self.ContainerCls()
        self.lock = RLock()
    def __getitem__(self, key):
        # Re-insert the item, moving it to the end of the eviction line.
        with self.lock:
            item = self._container.pop(key)
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/urllib3/packages/__init__.py =====
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/urllib3/packages/backports/__init__.py =====
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/urllib3/packages/backports/makefile.py =====
"""
backports.makefile
~~~~~~~~~~~~~~~~~~
Backports the Python 3 ``socket.makefile`` method for use with anything that
wants to create a "fake" socket object.
"""
import io
from socket import SocketIO
def backport_makefile(
    self, mode="r", buffering=None, encoding=None, errors=None, newline=None
):
    """
    Backport of ``socket.makefile`` from Python 3.5.
    """
    if not set(mode) <= {"r", "w", "b"}:
        raise ValueError("invalid mode %r (only r, w, b allowed)" % (mode,))
    writing = "w" in mode
    reading = "r" in mode or not writing
    assert reading or writing
    binary = "b" in mode
    rawmode = ""
    if reading:
        rawmode += "r"
    if writing:
        rawmode += "w"
    raw = SocketIO(self, rawmode)
    self._makefile_refs += 1
    if buffering is None:
        buffering = -1
    if buffering < 0:
        buffering = io.DEFAULT_BUFFER_SIZE
    if buffering == 0:
        if not binary:
            raise ValueError("unbuffered streams must be binary")
        return raw
    if reading and writing:
        buffer = io.BufferedRWPair(raw, raw, buffering)
    elif reading:
        buffer = io.BufferedReader(raw, buffering)
    else:
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/urllib3/packages/backports/weakref_finalize.py =====
"""
backports.weakref_finalize
~~~~~~~~~~~~~~~~~~
Backports the Python 3 ``weakref.finalize`` method.
"""
from __future__ import absolute_import
import itertools
import sys
from weakref import ref
__all__ = ["weakref_finalize"]
class weakref_finalize(object):
    """Class for finalization of weakrefable objects
    finalize(obj, func, *args, **kwargs) returns a callable finalizer
    object which will be called when obj is garbage collected. The
    first time the finalizer is called it evaluates func(*arg, **kwargs)
    and returns the result. After this the finalizer is dead, and
    calling it just returns None.
    When the program exits any remaining finalizers for which the
    atexit attribute is true will be run in reverse order of creation.
    By default atexit is true.
    """
    # Finalizer objects don't have any state of their own.  They are
    # just used as keys to lookup _Info objects in the registry.  This
    # ensures that they cannot be part of a ref-cycle.
    __slots__ = ()
    _registry = {}
    _shutdown = False
    _index_iter = itertools.count()
    _dirty = False
    _registered_with_atexit = False
    class _Info(object):
        __slots__ = ("weakref", "func", "args", "kwargs", "atexit", "index")
    def __init__(self, obj, func, *args, **kwargs):
        if not self._registered_with_atexit:
            # We may register the exit function more than once because
            # of a thread race, but that is harmless
            import atexit
            atexit.register(self._exitfunc)
            weakref_finalize._registered_with_atexit = True
        info = self._Info()
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/urllib3/packages/six.py =====
"""Utilities for writing code that runs on Python 2 and 3"""
from __future__ import absolute_import
import functools
import itertools
import operator
import sys
import types
__author__ = "Benjamin Peterson <benjamin@python.org>"
__version__ = "1.16.0"
PY2 = sys.version_info[0] == 2
PY3 = sys.version_info[0] == 3
PY34 = sys.version_info[0:2] >= (3, 4)
if PY3:
    string_types = (str,)
    integer_types = (int,)
    class_types = (type,)
    text_type = str
    binary_type = bytes
    MAXSIZE = sys.maxsize
else:
    string_types = (basestring,)
    integer_types = (int, long)
    class_types = (type, types.ClassType)
    text_type = unicode
    binary_type = str
    if sys.platform.startswith("java"):
        # Jython always uses 32 bits.
        MAXSIZE = int((1 << 31) - 1)
    else:
        # It's possible to have sizeof(long) != sizeof(Py_ssize_t).
        class X(object):
            def __len__(self):
                return 1 << 31
        try:
            len(X())
        except OverflowError:
            # 32-bit
            MAXSIZE = int((1 << 31) - 1)
        else:
            # 64-bit
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/urllib3/exceptions.py =====
from __future__ import absolute_import
from .packages.six.moves.http_client import IncompleteRead as httplib_IncompleteRead
class HTTPError(Exception):
    """Base exception used by this module."""
    pass
class HTTPWarning(Warning):
    """Base warning used by this module."""
    pass
class PoolError(HTTPError):
    """Base exception for errors caused within a pool."""
    def __init__(self, pool, message):
        self.pool = pool
        HTTPError.__init__(self, "%s: %s" % (pool, message))
    def __reduce__(self):
        # For pickling purposes.
        return self.__class__, (None, None)
class RequestError(PoolError):
    """Base exception for PoolErrors that have associated URLs."""
    def __init__(self, pool, url, message):
        self.url = url
        PoolError.__init__(self, pool, message)
    def __reduce__(self):
        # For pickling purposes.
        return self.__class__, (None, self.url, None)
class SSLError(HTTPError):
    """Raised when SSL certificate fails in an HTTPS connection."""
    pass
class ProxyError(HTTPError):
    """Raised when the connection to a proxy fails."""
    def __init__(self, message, error, *args):
        super(ProxyError, self).__init__(message, error, *args)
        self.original_error = error
class DecodeError(HTTPError):
    """Raised when automatic decoding based on Content-Type fails."""
    pass
class ProtocolError(HTTPError):
    """Raised when something unexpected happens mid-request/response."""
    pass
ConnectionError = ProtocolError
class MaxRetryError(RequestError):
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/urllib3/connectionpool.py =====
from __future__ import absolute_import
import errno
import logging
import re
import socket
import sys
import warnings
from socket import error as SocketError
from socket import timeout as SocketTimeout
from ._collections import HTTPHeaderDict
from .connection import (
    BaseSSLError,
    BrokenPipeError,
    DummyConnection,
    HTTPConnection,
    HTTPException,
    HTTPSConnection,
    VerifiedHTTPSConnection,
    port_by_scheme,
)
from .exceptions import (
    ClosedPoolError,
    EmptyPoolError,
    HeaderParsingError,
    HostChangedError,
    InsecureRequestWarning,
    LocationValueError,
    MaxRetryError,
    NewConnectionError,
    ProtocolError,
    ProxyError,
    ReadTimeoutError,
    SSLError,
    TimeoutError,
)
from .packages import six
from .packages.six.moves import queue
from .request import RequestMethods
from .response import HTTPResponse
from .util.connection import is_connection_dropped
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/pkg_resources/__init__.py =====
"""
Package resource API
--------------------
A resource is a logical file contained within a package, or a logical
subdirectory thereof.  The package resource API expects resource names
to have their path parts separated with ``/``, *not* whatever the local
path separator is.  Do not use os.path operations to manipulate resource
names being passed into the API.
The package resource API is designed to work with normal filesystem packages,
.egg files, and unpacked .egg files.  It can also work in a limited way with
.zip files and with custom PEP 302 loaders that support the ``get_data()``
method.
This module is deprecated. Users are directed to :mod:`importlib.resources`,
:mod:`importlib.metadata` and :pypi:`packaging` instead.
"""
from __future__ import annotations
import sys
if sys.version_info < (3, 8):  # noqa: UP036 # Check for unsupported versions
    raise RuntimeError("Python 3.8 or later is required")
import os
import io
import time
import re
import types
from typing import (
    Any,
    Literal,
    Dict,
    Iterator,
    Mapping,
    MutableSequence,
    NamedTuple,
    NoReturn,
    Tuple,
    Union,
    TYPE_CHECKING,
    Protocol,
    Callable,
    Iterable,
    TypeVar,
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/resolvelib/__init__.py =====
__all__ = [
    "AbstractProvider",
    "AbstractResolver",
    "BaseReporter",
    "InconsistentCandidate",
    "RequirementsConflicted",
    "ResolutionError",
    "ResolutionImpossible",
    "ResolutionTooDeep",
    "Resolver",
    "__version__",
]
__version__ = "1.2.0"
from .providers import AbstractProvider
from .reporters import BaseReporter
from .resolvers import (
    AbstractResolver,
    InconsistentCandidate,
    RequirementsConflicted,
    ResolutionError,
    ResolutionImpossible,
    ResolutionTooDeep,
    Resolver,
)
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/resolvelib/resolvers/abstract.py =====
from __future__ import annotations
import collections
from typing import TYPE_CHECKING, Any, Generic, Iterable, Mapping, NamedTuple
from ..structs import CT, KT, RT, DirectedGraph
if TYPE_CHECKING:
    from ..providers import AbstractProvider
    from ..reporters import BaseReporter
    from .criterion import Criterion
    class Result(NamedTuple, Generic[RT, CT, KT]):
        mapping: Mapping[KT, CT]
        graph: DirectedGraph[KT | None]
        criteria: Mapping[KT, Criterion[RT, CT]]
else:
    Result = collections.namedtuple("Result", ["mapping", "graph", "criteria"])
class AbstractResolver(Generic[RT, CT, KT]):
    """The thing that performs the actual resolution work."""
    base_exception = Exception
    def __init__(
        self,
        provider: AbstractProvider[RT, CT, KT],
        reporter: BaseReporter[RT, CT, KT],
    ) -> None:
        self.provider = provider
        self.reporter = reporter
    def resolve(self, requirements: Iterable[RT], **kwargs: Any) -> Result[RT, CT, KT]:
        """Take a collection of constraints, spit out the resolution result.
        This returns a representation of the final resolution state, with one
        guarenteed attribute ``mapping`` that contains resolved candidates as
        values. The keys are their respective identifiers.
        :param requirements: A collection of constraints.
        :param kwargs: Additional keyword arguments that subclasses may accept.
        :raises: ``self.base_exception`` or its subclass.
        """
        raise NotImplementedError
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/resolvelib/resolvers/__init__.py =====
from ..structs import RequirementInformation
from .abstract import AbstractResolver, Result
from .criterion import Criterion
from .exceptions import (
    InconsistentCandidate,
    RequirementsConflicted,
    ResolutionError,
    ResolutionImpossible,
    ResolutionTooDeep,
    ResolverException,
)
from .resolution import Resolution, Resolver
__all__ = [
    "AbstractResolver",
    "Criterion",
    "InconsistentCandidate",
    "RequirementInformation",
    "RequirementsConflicted",
    "Resolution",
    "ResolutionError",
    "ResolutionImpossible",
    "ResolutionTooDeep",
    "Resolver",
    "ResolverException",
    "Result",
]
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/resolvelib/resolvers/exceptions.py =====
from __future__ import annotations
from typing import TYPE_CHECKING, Collection, Generic
from ..structs import CT, RT, RequirementInformation
if TYPE_CHECKING:
    from .criterion import Criterion
class ResolverException(Exception):
    """A base class for all exceptions raised by this module.
    Exceptions derived by this class should all be handled in this module. Any
    bubbling pass the resolver should be treated as a bug.
    """
class RequirementsConflicted(ResolverException, Generic[RT, CT]):
    def __init__(self, criterion: Criterion[RT, CT]) -> None:
        super().__init__(criterion)
        self.criterion = criterion
    def __str__(self) -> str:
        return "Requirements conflict: {}".format(
            ", ".join(repr(r) for r in self.criterion.iter_requirement()),
        )
class InconsistentCandidate(ResolverException, Generic[RT, CT]):
    def __init__(self, candidate: CT, criterion: Criterion[RT, CT]):
        super().__init__(candidate, criterion)
        self.candidate = candidate
        self.criterion = criterion
    def __str__(self) -> str:
        return "Provided candidate {!r} does not satisfy {}".format(
            self.candidate,
            ", ".join(repr(r) for r in self.criterion.iter_requirement()),
        )
class ResolutionError(ResolverException):
    pass
class ResolutionImpossible(ResolutionError, Generic[RT, CT]):
    def __init__(self, causes: Collection[RequirementInformation[RT, CT]]):
        super().__init__(causes)
        # causes is a list of RequirementInformation objects
        self.causes = causes
class ResolutionTooDeep(ResolutionError):
    def __init__(self, round_count: int) -> None:
        super().__init__(round_count)
        self.round_count = round_count
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/resolvelib/resolvers/criterion.py =====
from __future__ import annotations
from typing import Collection, Generic, Iterable, Iterator
from ..structs import CT, RT, RequirementInformation
class Criterion(Generic[RT, CT]):
    """Representation of possible resolution results of a package.
    This holds three attributes:
    * `information` is a collection of `RequirementInformation` pairs.
      Each pair is a requirement contributing to this criterion, and the
      candidate that provides the requirement.
    * `incompatibilities` is a collection of all known not-to-work candidates
      to exclude from consideration.
    * `candidates` is a collection containing all possible candidates deducted
      from the union of contributing requirements and known incompatibilities.
      It should never be empty, except when the criterion is an attribute of a
      raised `RequirementsConflicted` (in which case it is always empty).
    .. note::
        This class is intended to be externally immutable. **Do not** mutate
        any of its attribute containers.
    """
    def __init__(
        self,
        candidates: Iterable[CT],
        information: Collection[RequirementInformation[RT, CT]],
        incompatibilities: Collection[CT],
    ) -> None:
        self.candidates = candidates
        self.information = information
        self.incompatibilities = incompatibilities
    def __repr__(self) -> str:
        requirements = ", ".join(
            f"({req!r}, via={parent!r})" for req, parent in self.information
        )
        return f"Criterion({requirements})"
    def iter_requirement(self) -> Iterator[RT]:
        return (i.requirement for i in self.information)
    def iter_parent(self) -> Iterator[CT | None]:
        return (i.parent for i in self.information)
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/resolvelib/resolvers/resolution.py =====
from __future__ import annotations
import collections
import itertools
import operator
from typing import TYPE_CHECKING, Generic
from ..structs import (
    CT,
    KT,
    RT,
    DirectedGraph,
    IterableView,
    IteratorMapping,
    RequirementInformation,
    State,
    build_iter_view,
)
from .abstract import AbstractResolver, Result
from .criterion import Criterion
from .exceptions import (
    InconsistentCandidate,
    RequirementsConflicted,
    ResolutionImpossible,
    ResolutionTooDeep,
    ResolverException,
)
if TYPE_CHECKING:
    from collections.abc import Collection, Iterable, Mapping
    from ..providers import AbstractProvider, Preference
    from ..reporters import BaseReporter
_OPTIMISTIC_BACKJUMPING_RATIO: float = 0.1
def _build_result(state: State[RT, CT, KT]) -> Result[RT, CT, KT]:
    mapping = state.mapping
    all_keys: dict[int, KT | None] = {id(v): k for k, v in mapping.items()}
    all_keys[id(None)] = None
    graph: DirectedGraph[KT | None] = DirectedGraph()
    graph.add(None)  # Sentinel as root dependencies' parent.
    connected: set[KT | None] = {None}
    for key, criterion in state.criteria.items():
        if not _has_route_to_root(state.criteria, key, all_keys, connected):
            continue
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/resolvelib/providers.py =====
from __future__ import annotations
from typing import (
    TYPE_CHECKING,
    Generic,
    Iterable,
    Iterator,
    Mapping,
    Sequence,
)
from .structs import CT, KT, RT, Matches, RequirementInformation
if TYPE_CHECKING:
    from typing import Any, Protocol
    class Preference(Protocol):
        def __lt__(self, __other: Any) -> bool: ...
class AbstractProvider(Generic[RT, CT, KT]):
    """Delegate class to provide the required interface for the resolver."""
    def identify(self, requirement_or_candidate: RT | CT) -> KT:
        """Given a requirement or candidate, return an identifier for it.
        This is used to identify, e.g. whether two requirements
        should have their specifier parts merged or a candidate matches a
        requirement via ``find_matches()``.
        """
        raise NotImplementedError
    def get_preference(
        self,
        identifier: KT,
        resolutions: Mapping[KT, CT],
        candidates: Mapping[KT, Iterator[CT]],
        information: Mapping[KT, Iterator[RequirementInformation[RT, CT]]],
        backtrack_causes: Sequence[RequirementInformation[RT, CT]],
    ) -> Preference:
        """Produce a sort key for given requirement based on preference.
        As this is a sort key it will be called O(n) times per backtrack
        step, where n is the number of `identifier`s, if you have a check
        which is expensive in some sense. E.g. It needs to make O(n) checks
        per call or takes significant wall clock time, consider using
        `narrow_requirement_selection` to filter the `identifier`s, which
        is applied before this sort key is called.
        The preference is defined as "I think this requirement should be
        resolved first". The lower the return value is, the more preferred
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/resolvelib/structs.py =====
from __future__ import annotations
import itertools
from collections import namedtuple
from typing import (
    TYPE_CHECKING,
    Callable,
    Generic,
    Iterable,
    Iterator,
    Mapping,
    NamedTuple,
    Sequence,
    TypeVar,
    Union,
)
KT = TypeVar("KT")  # Identifier.
RT = TypeVar("RT")  # Requirement.
CT = TypeVar("CT")  # Candidate.
Matches = Union[Iterable[CT], Callable[[], Iterable[CT]]]
if TYPE_CHECKING:
    from .resolvers.criterion import Criterion
    class RequirementInformation(NamedTuple, Generic[RT, CT]):
        requirement: RT
        parent: CT | None
    class State(NamedTuple, Generic[RT, CT, KT]):
        """Resolution state in a round."""
        mapping: dict[KT, CT]
        criteria: dict[KT, Criterion[RT, CT]]
        backtrack_causes: list[RequirementInformation[RT, CT]]
else:
    RequirementInformation = namedtuple(
        "RequirementInformation", ["requirement", "parent"]
    )
    State = namedtuple("State", ["mapping", "criteria", "backtrack_causes"])
class DirectedGraph(Generic[KT]):
    """A graph structure with directed edges."""
    def __init__(self) -> None:
        self._vertices: set[KT] = set()
        self._forwards: dict[KT, set[KT]] = {}  # <key> -> Set[<key>]
        self._backwards: dict[KT, set[KT]] = {}  # <key> -> Set[<key>]
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/resolvelib/reporters.py =====
from __future__ import annotations
from typing import TYPE_CHECKING, Collection, Generic
from .structs import CT, KT, RT, RequirementInformation, State
if TYPE_CHECKING:
    from .resolvers import Criterion
class BaseReporter(Generic[RT, CT, KT]):
    """Delegate class to provide progress reporting for the resolver."""
    def starting(self) -> None:
        """Called before the resolution actually starts."""
    def starting_round(self, index: int) -> None:
        """Called before each round of resolution starts.
        The index is zero-based.
        """
    def ending_round(self, index: int, state: State[RT, CT, KT]) -> None:
        """Called before each round of resolution ends.
        This is NOT called if the resolution ends at this round. Use `ending`
        if you want to report finalization. The index is zero-based.
        """
    def ending(self, state: State[RT, CT, KT]) -> None:
        """Called before the resolution ends successfully."""
    def adding_requirement(self, requirement: RT, parent: CT | None) -> None:
        """Called when adding a new requirement into the resolve criteria.
        :param requirement: The additional requirement to be applied to filter
            the available candidaites.
        :param parent: The candidate that requires ``requirement`` as a
            dependency, or None if ``requirement`` is one of the root
            requirements passed in from ``Resolver.resolve()``.
        """
    def resolving_conflicts(
        self, causes: Collection[RequirementInformation[RT, CT]]
    ) -> None:
        """Called when starting to attempt requirement conflict resolution.
        :param causes: The information on the collision that caused the backtracking.
        """
    def rejecting_candidate(self, criterion: Criterion[RT, CT], candidate: CT) -> None:
        """Called when rejecting a candidate during backtracking."""
    def pinning(self, candidate: CT) -> None:
        """Called when adding a candidate to the potential solution."""
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/platformdirs/macos.py =====
"""macOS."""
from __future__ import annotations
import os.path
import sys
from typing import TYPE_CHECKING
from .api import PlatformDirsABC
if TYPE_CHECKING:
    from pathlib import Path
class MacOS(PlatformDirsABC):
    """
    Platform directories for the macOS operating system.
    Follows the guidance from
    `Apple documentation <https://developer.apple.com/library/archive/documentation/FileManagement/Conceptual/FileSystemProgrammingGuide/MacOSXDirectories/MacOSXDirectories.html>`_.
    Makes use of the `appname <platformdirs.api.PlatformDirsABC.appname>`,
    `version <platformdirs.api.PlatformDirsABC.version>`,
    `ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.
    """
    @property
    def user_data_dir(self) -> str:
        """:return: data directory tied to the user, e.g. ``~/Library/Application Support/$appname/$version``"""
        return self._append_app_name_and_version(os.path.expanduser("~/Library/Application Support"))  # noqa: PTH111
    @property
    def site_data_dir(self) -> str:
        """
        :return: data directory shared by users, e.g. ``/Library/Application Support/$appname/$version``.
          If we're using a Python binary managed by `Homebrew <https://brew.sh>`_, the directory
          will be under the Homebrew prefix, e.g. ``/opt/homebrew/share/$appname/$version``.
          If `multipath <platformdirs.api.PlatformDirsABC.multipath>` is enabled, and we're in Homebrew,
          the response is a multi-path string separated by ":", e.g.
          ``/opt/homebrew/share/$appname/$version:/Library/Application Support/$appname/$version``
        """
        is_homebrew = sys.prefix.startswith("/opt/homebrew")
        path_list = [self._append_app_name_and_version("/opt/homebrew/share")] if is_homebrew else []
        path_list.append(self._append_app_name_and_version("/Library/Application Support"))
        if self.multipath:
            return os.pathsep.join(path_list)
        return path_list[0]
    @property
    def site_data_path(self) -> Path:
        """:return: data path shared by users. Only return the first item, even if ``multipath`` is set to ``True``"""
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/platformdirs/unix.py =====
"""Unix."""
from __future__ import annotations
import os
import sys
from configparser import ConfigParser
from pathlib import Path
from typing import TYPE_CHECKING, NoReturn
from .api import PlatformDirsABC
if TYPE_CHECKING:
    from collections.abc import Iterator
if sys.platform == "win32":
    def getuid() -> NoReturn:
        msg = "should only be used on Unix"
        raise RuntimeError(msg)
else:
    from os import getuid
class Unix(PlatformDirsABC):  # noqa: PLR0904
    """
    On Unix/Linux, we follow the `XDG Basedir Spec <https://specifications.freedesktop.org/basedir-spec/basedir-spec-
    latest.html>`_.
    The spec allows overriding directories with environment variables. The examples shown are the default values,
    alongside the name of the environment variable that overrides them. Makes use of the `appname
    <platformdirs.api.PlatformDirsABC.appname>`, `version <platformdirs.api.PlatformDirsABC.version>`, `multipath
    <platformdirs.api.PlatformDirsABC.multipath>`, `opinion <platformdirs.api.PlatformDirsABC.opinion>`, `ensure_exists
    <platformdirs.api.PlatformDirsABC.ensure_exists>`.
    """
    @property
    def user_data_dir(self) -> str:
        """
        :return: data directory tied to the user, e.g. ``~/.local/share/$appname/$version`` or
         ``$XDG_DATA_HOME/$appname/$version``
        """
        path = os.environ.get("XDG_DATA_HOME", "")
        if not path.strip():
            path = os.path.expanduser("~/.local/share")  # noqa: PTH111
        return self._append_app_name_and_version(path)
    @property
    def _site_data_dirs(self) -> list[str]:
        path = os.environ.get("XDG_DATA_DIRS", "")
        if not path.strip():
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/platformdirs/version.py =====
__all__ = ["__version__", "__version_tuple__", "version", "version_tuple"]
TYPE_CHECKING = False
if TYPE_CHECKING:
    from typing import Tuple
    from typing import Union
    VERSION_TUPLE = Tuple[Union[int, str], ...]
else:
    VERSION_TUPLE = object
version: str
__version__: str
__version_tuple__: VERSION_TUPLE
version_tuple: VERSION_TUPLE
__version__ = version = '4.3.8'
__version_tuple__ = version_tuple = (4, 3, 8)
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/platformdirs/__init__.py =====
"""
Utilities for determining application-specific dirs.
See <https://github.com/platformdirs/platformdirs> for details and usage.
"""
from __future__ import annotations
import os
import sys
from typing import TYPE_CHECKING
from .api import PlatformDirsABC
from .version import __version__
from .version import __version_tuple__ as __version_info__
if TYPE_CHECKING:
    from pathlib import Path
    from typing import Literal
if sys.platform == "win32":
    from pip._vendor.platformdirs.windows import Windows as _Result
elif sys.platform == "darwin":
    from pip._vendor.platformdirs.macos import MacOS as _Result
else:
    from pip._vendor.platformdirs.unix import Unix as _Result
def _set_platform_dir_class() -> type[PlatformDirsABC]:
    if os.getenv("ANDROID_DATA") == "/data" and os.getenv("ANDROID_ROOT") == "/system":
        if os.getenv("SHELL") or os.getenv("PREFIX"):
            return _Result
        from pip._vendor.platformdirs.android import _android_folder  # noqa: PLC0415
        if _android_folder() is not None:
            from pip._vendor.platformdirs.android import Android  # noqa: PLC0415
            return Android  # return to avoid redefinition of a result
    return _Result
if TYPE_CHECKING:
    # Work around mypy issue: https://github.com/python/mypy/issues/10962
    PlatformDirs = _Result
else:
    PlatformDirs = _set_platform_dir_class()  #: Currently active platform
AppDirs = PlatformDirs  #: Backwards compatibility with appdirs
def user_data_dir(
    appname: str | None = None,
    appauthor: str | Literal[False] | None = None,
    version: str | None = None,
    roaming: bool = False,  # noqa: FBT001, FBT002
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/platformdirs/api.py =====
"""Base API."""
from __future__ import annotations
import os
from abc import ABC, abstractmethod
from pathlib import Path
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from collections.abc import Iterator
    from typing import Literal
class PlatformDirsABC(ABC):  # noqa: PLR0904
    """Abstract base class for platform directories."""
    def __init__(  # noqa: PLR0913, PLR0917
        self,
        appname: str | None = None,
        appauthor: str | Literal[False] | None = None,
        version: str | None = None,
        roaming: bool = False,  # noqa: FBT001, FBT002
        multipath: bool = False,  # noqa: FBT001, FBT002
        opinion: bool = True,  # noqa: FBT001, FBT002
        ensure_exists: bool = False,  # noqa: FBT001, FBT002
    ) -> None:
        """
        Create a new platform directory.
        :param appname: See `appname`.
        :param appauthor: See `appauthor`.
        :param version: See `version`.
        :param roaming: See `roaming`.
        :param multipath: See `multipath`.
        :param opinion: See `opinion`.
        :param ensure_exists: See `ensure_exists`.
        """
        self.appname = appname  #: The name of application.
        self.appauthor = appauthor
        """
        The name of the app author or distributing body for this application.
        Typically, it is the owning company name. Defaults to `appname`. You may pass ``False`` to disable it.
        """
        self.version = version
        """
        An optional version path element to append to the path.
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/platformdirs/android.py =====
"""Android."""
from __future__ import annotations
import os
import re
import sys
from functools import lru_cache
from typing import TYPE_CHECKING, cast
from .api import PlatformDirsABC
class Android(PlatformDirsABC):
    """
    Follows the guidance `from here <https://android.stackexchange.com/a/216132>`_.
    Makes use of the `appname <platformdirs.api.PlatformDirsABC.appname>`, `version
    <platformdirs.api.PlatformDirsABC.version>`, `ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.
    """
    @property
    def user_data_dir(self) -> str:
        """:return: data directory tied to the user, e.g. ``/data/user/<userid>/<packagename>/files/<AppName>``"""
        return self._append_app_name_and_version(cast("str", _android_folder()), "files")
    @property
    def site_data_dir(self) -> str:
        """:return: data directory shared by users, same as `user_data_dir`"""
        return self.user_data_dir
    @property
    def user_config_dir(self) -> str:
        """
        :return: config directory tied to the user, e.g. \
        ``/data/user/<userid>/<packagename>/shared_prefs/<AppName>``
        """
        return self._append_app_name_and_version(cast("str", _android_folder()), "shared_prefs")
    @property
    def site_config_dir(self) -> str:
        """:return: config directory shared by the users, same as `user_config_dir`"""
        return self.user_config_dir
    @property
    def user_cache_dir(self) -> str:
        """:return: cache directory tied to the user, e.g.,``/data/user/<userid>/<packagename>/cache/<AppName>``"""
        return self._append_app_name_and_version(cast("str", _android_folder()), "cache")
    @property
    def site_cache_dir(self) -> str:
        """:return: cache directory shared by users, same as `user_cache_dir`"""
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/platformdirs/windows.py =====
"""Windows."""
from __future__ import annotations
import os
import sys
from functools import lru_cache
from typing import TYPE_CHECKING
from .api import PlatformDirsABC
if TYPE_CHECKING:
    from collections.abc import Callable
class Windows(PlatformDirsABC):
    """
    `MSDN on where to store app data files <https://learn.microsoft.com/en-us/windows/win32/shell/knownfolderid>`_.
    Makes use of the `appname <platformdirs.api.PlatformDirsABC.appname>`, `appauthor
    <platformdirs.api.PlatformDirsABC.appauthor>`, `version <platformdirs.api.PlatformDirsABC.version>`, `roaming
    <platformdirs.api.PlatformDirsABC.roaming>`, `opinion <platformdirs.api.PlatformDirsABC.opinion>`, `ensure_exists
    <platformdirs.api.PlatformDirsABC.ensure_exists>`.
    """
    @property
    def user_data_dir(self) -> str:
        """
        :return: data directory tied to the user, e.g.
         ``%USERPROFILE%\\AppData\\Local\\$appauthor\\$appname`` (not roaming) or
         ``%USERPROFILE%\\AppData\\Roaming\\$appauthor\\$appname`` (roaming)
        """
        const = "CSIDL_APPDATA" if self.roaming else "CSIDL_LOCAL_APPDATA"
        path = os.path.normpath(get_win_folder(const))
        return self._append_parts(path)
    def _append_parts(self, path: str, *, opinion_value: str | None = None) -> str:
        params = []
        if self.appname:
            if self.appauthor is not False:
                author = self.appauthor or self.appname
                params.append(author)
            params.append(self.appname)
            if opinion_value is not None and self.opinion:
                params.append(opinion_value)
            if self.version:
                params.append(self.version)
        path = os.path.join(path, *params)  # noqa: PTH118
        self._optionally_create_directory(path)
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/_vendor/platformdirs/__main__.py =====
"""Main entry point."""
from __future__ import annotations
from pip._vendor.platformdirs import PlatformDirs, __version__
PROPS = (
    "user_data_dir",
    "user_config_dir",
    "user_cache_dir",
    "user_state_dir",
    "user_log_dir",
    "user_documents_dir",
    "user_downloads_dir",
    "user_pictures_dir",
    "user_videos_dir",
    "user_music_dir",
    "user_runtime_dir",
    "site_data_dir",
    "site_config_dir",
    "site_cache_dir",
    "site_runtime_dir",
)
def main() -> None:
    """Run the main entry point."""
    app_name = "MyApp"
    app_author = "MyCompany"
    print(f"-- platformdirs {__version__} --")  # noqa: T201
    print("-- app dirs (with optional 'version')")  # noqa: T201
    dirs = PlatformDirs(app_name, app_author, version="1.0")
    for prop in PROPS:
        print(f"{prop}: {getattr(dirs, prop)}")  # noqa: T201
    print("\n-- app dirs (without optional 'version')")  # noqa: T201
    dirs = PlatformDirs(app_name, app_author)
    for prop in PROPS:
        print(f"{prop}: {getattr(dirs, prop)}")  # noqa: T201
    print("\n-- app dirs (without optional 'appauthor')")  # noqa: T201
    dirs = PlatformDirs(app_name)
    for prop in PROPS:
        print(f"{prop}: {getattr(dirs, prop)}")  # noqa: T201
    print("\n-- app dirs (with disabled 'appauthor')")  # noqa: T201
    dirs = PlatformDirs(app_name, appauthor=False)
    for prop in PROPS:
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/__init__.py =====
from __future__ import annotations
__version__ = "25.2"
def main(args: list[str] | None = None) -> int:
    """This is an internal API only meant for use by pip's own console scripts.
    For additional details, see https://github.com/pypa/pip/issues/7498.
    """
    from pip._internal.utils.entrypoints import _wrapper
    return _wrapper(args)
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/__pip-runner__.py =====
"""Execute exactly this copy of pip, within a different environment.
This file is named as it is, to ensure that this module can't be imported via
an import statement.
"""
import sys
PYTHON_REQUIRES = (3, 9)
def version_str(version):  # type: ignore
    return ".".join(str(v) for v in version)
if sys.version_info[:2] < PYTHON_REQUIRES:
    raise SystemExit(
        "This version of pip does not support python {} (requires >={}).".format(
            version_str(sys.version_info[:2]), version_str(PYTHON_REQUIRES)
        )
    )
import runpy  # noqa: E402
from importlib.machinery import PathFinder  # noqa: E402
from os.path import dirname  # noqa: E402
PIP_SOURCES_ROOT = dirname(dirname(__file__))
class PipImportRedirectingFinder:
    @classmethod
    def find_spec(self, fullname, path=None, target=None):  # type: ignore
        if fullname != "pip":
            return None
        spec = PathFinder.find_spec(fullname, [PIP_SOURCES_ROOT], target)
        assert spec, (PIP_SOURCES_ROOT, fullname)
        return spec
sys.meta_path.insert(0, PipImportRedirectingFinder())
assert __name__ == "__main__", "Cannot run __pip-runner__.py as a non-main module"
runpy.run_module("pip", run_name="__main__", alter_sys=True)
...(truncado)

===== ./venv/lib/python3.13/site-packages/pip/__main__.py =====
import os
import sys
if sys.path[0] in ("", os.getcwd()):
    sys.path.pop(0)
if __package__ == "":
    # __file__ is pip-*.whl/pip/__main__.py
    # first dirname call strips of '/__main__.py', second strips off '/pip'
    # Resulting path is the name of the wheel itself
    # Add that to sys.path so we can import pip
    path = os.path.dirname(os.path.dirname(__file__))
    sys.path.insert(0, path)
if __name__ == "__main__":
    from pip._internal.cli.main import main as _main
    sys.exit(_main())
...(truncado)

===== ./venv/lib/python3.13/site-packages/alembic/command.py =====
from __future__ import annotations
import os
import pathlib
from typing import List
from typing import Optional
from typing import TYPE_CHECKING
from typing import Union
from . import autogenerate as autogen
from . import util
from .runtime.environment import EnvironmentContext
from .script import ScriptDirectory
from .util import compat
if TYPE_CHECKING:
    from alembic.config import Config
    from alembic.script.base import Script
    from alembic.script.revision import _RevIdType
    from .runtime.environment import ProcessRevisionDirectiveFn
def list_templates(config: Config) -> None:
    """List available templates.
    :param config: a :class:`.Config` object.
    """
    config.print_stdout("Available templates:\n")
    for tempname in config._get_template_path().iterdir():
        with (tempname / "README").open() as readme:
            synopsis = next(readme).rstrip()
        config.print_stdout("%s - %s", tempname.name, synopsis)
    config.print_stdout("\nTemplates are used via the 'init' command, e.g.:")
    config.print_stdout("\n  alembic init --template generic ./scripts")
def init(
    config: Config,
    directory: str,
    template: str = "generic",
    package: bool = False,
) -> None:
    """Initialize a new scripts directory.
    :param config: a :class:`.Config` object.
    :param directory: string path of the target directory.
    :param template: string name of the migration environment template to
     use.
    :param package: when True, write ``__init__.py`` files into the
...(truncado)

===== ./venv/lib/python3.13/site-packages/alembic/config.py =====
from __future__ import annotations
from argparse import ArgumentParser
from argparse import Namespace
from configparser import ConfigParser
import inspect
import os
from pathlib import Path
import re
import sys
from typing import Any
from typing import cast
from typing import Dict
from typing import Mapping
from typing import Optional
from typing import overload
from typing import Protocol
from typing import Sequence
from typing import TextIO
from typing import Union
from typing_extensions import TypedDict
from . import __version__
from . import command
from . import util
from .util import compat
from .util.pyfiles import _preserving_path_as_str
class Config:
    r"""Represent an Alembic configuration.
    Within an ``env.py`` script, this is available
    via the :attr:`.EnvironmentContext.config` attribute,
    which in turn is available at ``alembic.context``::
        from alembic import context
        some_param = context.config.get_main_option("my option")
    When invoking Alembic programmatically, a new
    :class:`.Config` can be created by passing
    the name of an .ini file to the constructor::
        from alembic.config import Config
        alembic_cfg = Config("/path/to/yourapp/alembic.ini")
    With a :class:`.Config` object, you can then
    run Alembic commands programmatically using the directives
    in :mod:`alembic.command`.
...(truncado)

===== ./venv/lib/python3.13/site-packages/alembic/util/compat.py =====
from __future__ import annotations
from configparser import ConfigParser
import io
import os
from pathlib import Path
import sys
import typing
from typing import Any
from typing import Iterator
from typing import List
from typing import Optional
from typing import Sequence
from typing import Union
if True:
    # zimports hack for too-long names
    from sqlalchemy.util import (  # noqa: F401
        inspect_getfullargspec as inspect_getfullargspec,
    )
    from sqlalchemy.util.compat import (  # noqa: F401
        inspect_formatargspec as inspect_formatargspec,
    )
is_posix = os.name == "posix"
py314 = sys.version_info >= (3, 14)
py313 = sys.version_info >= (3, 13)
py312 = sys.version_info >= (3, 12)
py311 = sys.version_info >= (3, 11)
py310 = sys.version_info >= (3, 10)
py39 = sys.version_info >= (3, 9)
class EncodedIO(io.TextIOWrapper):
    def close(self) -> None:
        pass
if py39:
    from importlib import resources as _resources
    importlib_resources = _resources
    from importlib import metadata as _metadata
    importlib_metadata = _metadata
    from importlib.metadata import EntryPoint as EntryPoint
else:
    import importlib_resources  # type:ignore # noqa
    import importlib_metadata  # type:ignore # noqa
...(truncado)

===== ./venv/lib/python3.13/site-packages/alembic/util/pyfiles.py =====
from __future__ import annotations
import atexit
from contextlib import ExitStack
import importlib
import importlib.machinery
import importlib.util
import os
import pathlib
import re
import tempfile
from types import ModuleType
from typing import Any
from typing import Optional
from typing import Union
from mako import exceptions
from mako.template import Template
from . import compat
from .exc import CommandError
def template_to_file(
    template_file: Union[str, os.PathLike[str]],
    dest: Union[str, os.PathLike[str]],
    output_encoding: str,
    *,
    append_with_newlines: bool = False,
    **kw: Any,
) -> None:
    template = Template(filename=_preserving_path_as_str(template_file))
    try:
        output = template.render_unicode(**kw).encode(output_encoding)
    except:
        with tempfile.NamedTemporaryFile(suffix=".txt", delete=False) as ntf:
            ntf.write(
                exceptions.text_error_template()
                .render_unicode()
                .encode(output_encoding)
            )
            fname = ntf.name
        raise CommandError(
            "Template rendering failed; see %s for a "
            "template-oriented traceback." % fname
...(truncado)

===== ./venv/lib/python3.13/site-packages/alembic/util/__init__.py =====
from .editor import open_in_editor as open_in_editor
from .exc import AutogenerateDiffsDetected as AutogenerateDiffsDetected
from .exc import CommandError as CommandError
from .langhelpers import _with_legacy_names as _with_legacy_names
from .langhelpers import asbool as asbool
from .langhelpers import dedupe_tuple as dedupe_tuple
from .langhelpers import Dispatcher as Dispatcher
from .langhelpers import EMPTY_DICT as EMPTY_DICT
from .langhelpers import immutabledict as immutabledict
from .langhelpers import memoized_property as memoized_property
from .langhelpers import ModuleClsProxy as ModuleClsProxy
from .langhelpers import not_none as not_none
from .langhelpers import rev_id as rev_id
from .langhelpers import to_list as to_list
from .langhelpers import to_tuple as to_tuple
from .langhelpers import unique_list as unique_list
from .messaging import err as err
from .messaging import format_as_comma as format_as_comma
from .messaging import msg as msg
from .messaging import obfuscate_url_pw as obfuscate_url_pw
from .messaging import status as status
from .messaging import warn as warn
from .messaging import warn_deprecated as warn_deprecated
from .messaging import write_outstream as write_outstream
from .pyfiles import coerce_resource_to_filename as coerce_resource_to_filename
from .pyfiles import load_python_file as load_python_file
from .pyfiles import pyc_file_from_path as pyc_file_from_path
from .pyfiles import template_to_file as template_to_file
from .sqla_compat import sqla_2 as sqla_2
...(truncado)

===== ./venv/lib/python3.13/site-packages/alembic/util/exc.py =====
from __future__ import annotations
from typing import Any
from typing import List
from typing import Tuple
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from alembic.autogenerate import RevisionContext
class CommandError(Exception):
    pass
class AutogenerateDiffsDetected(CommandError):
    def __init__(
        self,
        message: str,
        revision_context: RevisionContext,
        diffs: List[Tuple[Any, ...]],
    ) -> None:
        super().__init__(message)
        self.revision_context = revision_context
        self.diffs = diffs
...(truncado)

===== ./venv/lib/python3.13/site-packages/alembic/util/langhelpers.py =====
from __future__ import annotations
import collections
from collections.abc import Iterable
import textwrap
from typing import Any
from typing import Callable
from typing import cast
from typing import Dict
from typing import List
from typing import Mapping
from typing import MutableMapping
from typing import NoReturn
from typing import Optional
from typing import overload
from typing import Sequence
from typing import Set
from typing import Tuple
from typing import Type
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union
import uuid
import warnings
from sqlalchemy.util import asbool as asbool  # noqa: F401
from sqlalchemy.util import immutabledict as immutabledict  # noqa: F401
from sqlalchemy.util import to_list as to_list  # noqa: F401
from sqlalchemy.util import unique_list as unique_list
from .compat import inspect_getfullargspec
if True:
    # zimports workaround :(
    from sqlalchemy.util import (  # noqa: F401
        memoized_property as memoized_property,
    )
EMPTY_DICT: Mapping[Any, Any] = immutabledict()
_T = TypeVar("_T", bound=Any)
_C = TypeVar("_C", bound=Callable[..., Any])
class _ModuleClsMeta(type):
    def __setattr__(cls, key: str, value: Callable[..., Any]) -> None:
        super().__setattr__(key, value)
        cls._update_module_proxies(key)  # type: ignore
...(truncado)

===== ./venv/lib/python3.13/site-packages/alembic/util/editor.py =====
from __future__ import annotations
import os
from os.path import exists
from os.path import join
from os.path import splitext
from subprocess import check_call
from typing import Dict
from typing import List
from typing import Mapping
from typing import Optional
from .compat import is_posix
from .exc import CommandError
def open_in_editor(
    filename: str, environ: Optional[Dict[str, str]] = None
) -> None:
    """
    Opens the given file in a text editor. If the environment variable
    ``EDITOR`` is set, this is taken as preference.
    Otherwise, a list of commonly installed editors is tried.
    If no editor matches, an :py:exc:`OSError` is raised.
    :param filename: The filename to open. Will be passed  verbatim to the
        editor command.
    :param environ: An optional drop-in replacement for ``os.environ``. Used
        mainly for testing.
    """
    env = os.environ if environ is None else environ
    try:
        editor = _find_editor(env)
        check_call([editor, filename])
    except Exception as exc:
        raise CommandError("Error executing editor (%s)" % (exc,)) from exc
def _find_editor(environ: Mapping[str, str]) -> str:
    candidates = _default_editors()
    for i, var in enumerate(("EDITOR", "VISUAL")):
        if var in environ:
            user_choice = environ[var]
            if exists(user_choice):
                return user_choice
            if os.sep not in user_choice:
                candidates.insert(i, user_choice)
...(truncado)

===== ./venv/lib/python3.13/site-packages/alembic/util/sqla_compat.py =====
from __future__ import annotations
import contextlib
import re
from typing import Any
from typing import Callable
from typing import Dict
from typing import Iterable
from typing import Iterator
from typing import Optional
from typing import Protocol
from typing import Set
from typing import Type
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union
from sqlalchemy import __version__
from sqlalchemy import schema
from sqlalchemy import sql
from sqlalchemy import types as sqltypes
from sqlalchemy.schema import CheckConstraint
from sqlalchemy.schema import Column
from sqlalchemy.schema import ForeignKeyConstraint
from sqlalchemy.sql import visitors
from sqlalchemy.sql.base import DialectKWArgs
from sqlalchemy.sql.elements import BindParameter
from sqlalchemy.sql.elements import ColumnClause
from sqlalchemy.sql.elements import TextClause
from sqlalchemy.sql.elements import UnaryExpression
from sqlalchemy.sql.naming import _NONE_NAME as _NONE_NAME  # type: ignore[attr-defined] # noqa: E501
from sqlalchemy.sql.visitors import traverse
from typing_extensions import TypeGuard
if TYPE_CHECKING:
    from sqlalchemy import ClauseElement
    from sqlalchemy import Identity
    from sqlalchemy import Index
    from sqlalchemy import Table
    from sqlalchemy.engine import Connection
    from sqlalchemy.engine import Dialect
    from sqlalchemy.engine import Transaction
    from sqlalchemy.sql.base import ColumnCollection
...(truncado)

===== ./venv/lib/python3.13/site-packages/alembic/util/messaging.py =====
from __future__ import annotations
from collections.abc import Iterable
from contextlib import contextmanager
import logging
import sys
import textwrap
from typing import Iterator
from typing import Optional
from typing import TextIO
from typing import Union
import warnings
from sqlalchemy.engine import url
log = logging.getLogger(__name__)
logging.getLogger("alembic").addHandler(logging.NullHandler())
try:
    import fcntl
    import termios
    import struct
    ioctl = fcntl.ioctl(0, termios.TIOCGWINSZ, struct.pack("HHHH", 0, 0, 0, 0))
    _h, TERMWIDTH, _hp, _wp = struct.unpack("HHHH", ioctl)
    if TERMWIDTH <= 0:  # can occur if running in emacs pseudo-tty
        TERMWIDTH = None
except (ImportError, OSError):
    TERMWIDTH = None
def write_outstream(
    stream: TextIO, *text: Union[str, bytes], quiet: bool = False
) -> None:
    if quiet:
        return
    encoding = getattr(stream, "encoding", "ascii") or "ascii"
    for t in text:
        if not isinstance(t, bytes):
            t = t.encode(encoding, "replace")
        t = t.decode(encoding)
        try:
            stream.write(t)
        except OSError:
            # suppress "broken pipe" errors.
            # no known way to handle this on Python 3 however
            # as the exception is "ignored" (noisily) in TextIOWrapper.
...(truncado)

===== ./venv/lib/python3.13/site-packages/alembic/ddl/postgresql.py =====
from __future__ import annotations
import logging
import re
from typing import Any
from typing import cast
from typing import Dict
from typing import List
from typing import Optional
from typing import Sequence
from typing import Tuple
from typing import TYPE_CHECKING
from typing import Union
from sqlalchemy import Column
from sqlalchemy import Float
from sqlalchemy import Identity
from sqlalchemy import literal_column
from sqlalchemy import Numeric
from sqlalchemy import select
from sqlalchemy import text
from sqlalchemy import types as sqltypes
from sqlalchemy.dialects.postgresql import BIGINT
from sqlalchemy.dialects.postgresql import ExcludeConstraint
from sqlalchemy.dialects.postgresql import INTEGER
from sqlalchemy.schema import CreateIndex
from sqlalchemy.sql.elements import ColumnClause
from sqlalchemy.sql.elements import TextClause
from sqlalchemy.sql.functions import FunctionElement
from sqlalchemy.types import NULLTYPE
from .base import alter_column
from .base import alter_table
from .base import AlterColumn
from .base import ColumnComment
from .base import format_column_name
from .base import format_table_name
from .base import format_type
from .base import IdentityColumnDefault
from .base import RenameTable
from .impl import ComparisonResult
from .impl import DefaultImpl
from .. import util
...(truncado)

===== ./venv/lib/python3.13/site-packages/alembic/ddl/mssql.py =====
from __future__ import annotations
import re
from typing import Any
from typing import Dict
from typing import List
from typing import Optional
from typing import TYPE_CHECKING
from typing import Union
from sqlalchemy import types as sqltypes
from sqlalchemy.schema import Column
from sqlalchemy.schema import CreateIndex
from sqlalchemy.sql.base import Executable
from sqlalchemy.sql.elements import ClauseElement
from .base import AddColumn
from .base import alter_column
from .base import alter_table
from .base import ColumnDefault
from .base import ColumnName
from .base import ColumnNullable
from .base import ColumnType
from .base import format_column_name
from .base import format_server_default
from .base import format_table_name
from .base import format_type
from .base import RenameTable
from .impl import DefaultImpl
from .. import util
from ..util import sqla_compat
from ..util.sqla_compat import compiles
if TYPE_CHECKING:
    from typing import Literal
    from sqlalchemy.dialects.mssql.base import MSDDLCompiler
    from sqlalchemy.dialects.mssql.base import MSSQLCompiler
    from sqlalchemy.engine.cursor import CursorResult
    from sqlalchemy.sql.schema import Index
    from sqlalchemy.sql.schema import Table
    from sqlalchemy.sql.selectable import TableClause
    from sqlalchemy.sql.type_api import TypeEngine
    from .base import _ServerDefault
class MSSQLImpl(DefaultImpl):
...(truncado)

===== ./venv/lib/python3.13/site-packages/alembic/ddl/__init__.py =====
from . import mssql
from . import mysql
from . import oracle
from . import postgresql
from . import sqlite
from .impl import DefaultImpl as DefaultImpl
...(truncado)

===== ./venv/lib/python3.13/site-packages/alembic/ddl/_autogen.py =====
from __future__ import annotations
from typing import Any
from typing import ClassVar
from typing import Dict
from typing import Generic
from typing import NamedTuple
from typing import Optional
from typing import Sequence
from typing import Tuple
from typing import Type
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union
from sqlalchemy.sql.schema import Constraint
from sqlalchemy.sql.schema import ForeignKeyConstraint
from sqlalchemy.sql.schema import Index
from sqlalchemy.sql.schema import UniqueConstraint
from typing_extensions import TypeGuard
from .. import util
from ..util import sqla_compat
if TYPE_CHECKING:
    from typing import Literal
    from alembic.autogenerate.api import AutogenContext
    from alembic.ddl.impl import DefaultImpl
CompareConstraintType = Union[Constraint, Index]
_C = TypeVar("_C", bound=CompareConstraintType)
_clsreg: Dict[str, Type[_constraint_sig]] = {}
class ComparisonResult(NamedTuple):
    status: Literal["equal", "different", "skip"]
    message: str
    @property
    def is_equal(self) -> bool:
        return self.status == "equal"
    @property
    def is_different(self) -> bool:
        return self.status == "different"
    @property
    def is_skip(self) -> bool:
        return self.status == "skip"
    @classmethod
...(truncado)

===== ./venv/lib/python3.13/site-packages/alembic/ddl/sqlite.py =====
from __future__ import annotations
import re
from typing import Any
from typing import Dict
from typing import Optional
from typing import TYPE_CHECKING
from typing import Union
from sqlalchemy import cast
from sqlalchemy import Computed
from sqlalchemy import JSON
from sqlalchemy import schema
from sqlalchemy import sql
from .base import alter_table
from .base import ColumnName
from .base import format_column_name
from .base import format_table_name
from .base import RenameTable
from .impl import DefaultImpl
from .. import util
from ..util.sqla_compat import compiles
if TYPE_CHECKING:
    from sqlalchemy.engine.reflection import Inspector
    from sqlalchemy.sql.compiler import DDLCompiler
    from sqlalchemy.sql.elements import Cast
    from sqlalchemy.sql.elements import ClauseElement
    from sqlalchemy.sql.schema import Column
    from sqlalchemy.sql.schema import Constraint
    from sqlalchemy.sql.schema import Table
    from sqlalchemy.sql.type_api import TypeEngine
    from ..operations.batch import BatchOperationsImpl
class SQLiteImpl(DefaultImpl):
    __dialect__ = "sqlite"
    transactional_ddl = False
    """SQLite supports transactional DDL, but pysqlite does not:
    see: http://bugs.python.org/issue10740
    """
    def requires_recreate_in_batch(
        self, batch_op: BatchOperationsImpl
    ) -> bool:
        """Return True if the given :class:`.BatchOperationsImpl`
...(truncado)

===== ./venv/lib/python3.13/site-packages/alembic/ddl/impl.py =====
from __future__ import annotations
import logging
import re
from typing import Any
from typing import Callable
from typing import Dict
from typing import Iterable
from typing import List
from typing import Mapping
from typing import NamedTuple
from typing import Optional
from typing import Sequence
from typing import Set
from typing import Tuple
from typing import Type
from typing import TYPE_CHECKING
from typing import Union
from sqlalchemy import cast
from sqlalchemy import Column
from sqlalchemy import MetaData
from sqlalchemy import PrimaryKeyConstraint
from sqlalchemy import schema
from sqlalchemy import String
from sqlalchemy import Table
from sqlalchemy import text
from . import _autogen
from . import base
from ._autogen import _constraint_sig as _constraint_sig
from ._autogen import ComparisonResult as ComparisonResult
from .. import util
from ..util import sqla_compat
if TYPE_CHECKING:
    from typing import Literal
    from typing import TextIO
    from sqlalchemy.engine import Connection
    from sqlalchemy.engine import Dialect
    from sqlalchemy.engine.cursor import CursorResult
    from sqlalchemy.engine.reflection import Inspector
    from sqlalchemy.sql import ClauseElement
    from sqlalchemy.sql import Executable
...(truncado)

===== ./venv/lib/python3.13/site-packages/alembic/ddl/oracle.py =====
from __future__ import annotations
import re
from typing import Any
from typing import Optional
from typing import TYPE_CHECKING
from sqlalchemy.sql import sqltypes
from .base import AddColumn
from .base import alter_table
from .base import ColumnComment
from .base import ColumnDefault
from .base import ColumnName
from .base import ColumnNullable
from .base import ColumnType
from .base import format_column_name
from .base import format_server_default
from .base import format_table_name
from .base import format_type
from .base import IdentityColumnDefault
from .base import RenameTable
from .impl import DefaultImpl
from ..util.sqla_compat import compiles
if TYPE_CHECKING:
    from sqlalchemy.dialects.oracle.base import OracleDDLCompiler
    from sqlalchemy.engine.cursor import CursorResult
    from sqlalchemy.sql.schema import Column
class OracleImpl(DefaultImpl):
    __dialect__ = "oracle"
    transactional_ddl = False
    batch_separator = "/"
    command_terminator = ""
    type_synonyms = DefaultImpl.type_synonyms + (
        {"VARCHAR", "VARCHAR2"},
        {"BIGINT", "INTEGER", "SMALLINT", "DECIMAL", "NUMERIC", "NUMBER"},
        {"DOUBLE", "FLOAT", "DOUBLE_PRECISION"},
    )
    identity_attrs_ignore = ()
    def __init__(self, *arg, **kw) -> None:
        super().__init__(*arg, **kw)
        self.batch_separator = self.context_opts.get(
            "oracle_batch_separator", self.batch_separator
...(truncado)

===== ./venv/lib/python3.13/site-packages/alembic/ddl/base.py =====
from __future__ import annotations
import functools
from typing import Optional
from typing import TYPE_CHECKING
from typing import Union
from sqlalchemy import exc
from sqlalchemy import Integer
from sqlalchemy import types as sqltypes
from sqlalchemy.ext.compiler import compiles
from sqlalchemy.schema import Column
from sqlalchemy.schema import DDLElement
from sqlalchemy.sql.elements import quoted_name
from ..util.sqla_compat import _columns_for_constraint  # noqa
from ..util.sqla_compat import _find_columns  # noqa
from ..util.sqla_compat import _fk_spec  # noqa
from ..util.sqla_compat import _is_type_bound  # noqa
from ..util.sqla_compat import _table_for_constraint  # noqa
if TYPE_CHECKING:
    from typing import Any
    from sqlalchemy import Computed
    from sqlalchemy import Identity
    from sqlalchemy.sql.compiler import Compiled
    from sqlalchemy.sql.compiler import DDLCompiler
    from sqlalchemy.sql.elements import TextClause
    from sqlalchemy.sql.functions import Function
    from sqlalchemy.sql.schema import FetchedValue
    from sqlalchemy.sql.type_api import TypeEngine
    from .impl import DefaultImpl
_ServerDefault = Union["TextClause", "FetchedValue", "Function[Any]", str]
class AlterTable(DDLElement):
    """Represent an ALTER TABLE statement.
    Only the string name and optional schema name of the table
    is required, not a full Table object.
    """
    def __init__(
        self,
        table_name: str,
        schema: Optional[Union[quoted_name, str]] = None,
    ) -> None:
        self.table_name = table_name
...(truncado)

===== ./venv/lib/python3.13/site-packages/alembic/ddl/mysql.py =====
from __future__ import annotations
import re
from typing import Any
from typing import Optional
from typing import TYPE_CHECKING
from typing import Union
from sqlalchemy import schema
from sqlalchemy import types as sqltypes
from sqlalchemy.sql import elements
from sqlalchemy.sql import functions
from sqlalchemy.sql import operators
from .base import alter_table
from .base import AlterColumn
from .base import ColumnDefault
from .base import ColumnName
from .base import ColumnNullable
from .base import ColumnType
from .base import format_column_name
from .base import format_server_default
from .impl import DefaultImpl
from .. import util
from ..util import sqla_compat
from ..util.sqla_compat import _is_type_bound
from ..util.sqla_compat import compiles
if TYPE_CHECKING:
    from typing import Literal
    from sqlalchemy.dialects.mysql.base import MySQLDDLCompiler
    from sqlalchemy.sql.ddl import DropConstraint
    from sqlalchemy.sql.elements import ClauseElement
    from sqlalchemy.sql.schema import Constraint
    from sqlalchemy.sql.type_api import TypeEngine
    from .base import _ServerDefault
class MySQLImpl(DefaultImpl):
    __dialect__ = "mysql"
    transactional_ddl = False
    type_synonyms = DefaultImpl.type_synonyms + (
        {"BOOL", "TINYINT"},
        {"JSON", "LONGTEXT"},
    )
    type_arg_extract = [r"character set ([\w\-_]+)", r"collate ([\w\-_]+)"]
...(truncado)

===== ./venv/lib/python3.13/site-packages/alembic/runtime/__init__.py =====
...(truncado)

===== ./venv/lib/python3.13/site-packages/alembic/runtime/environment.py =====
from __future__ import annotations
from typing import Any
from typing import Callable
from typing import Collection
from typing import Dict
from typing import List
from typing import Mapping
from typing import MutableMapping
from typing import Optional
from typing import overload
from typing import Sequence
from typing import TextIO
from typing import Tuple
from typing import TYPE_CHECKING
from typing import Union
from sqlalchemy.sql.schema import Column
from sqlalchemy.sql.schema import FetchedValue
from typing_extensions import ContextManager
from typing_extensions import Literal
from .migration import _ProxyTransaction
from .migration import MigrationContext
from .. import util
from ..operations import Operations
from ..script.revision import _GetRevArg
if TYPE_CHECKING:
    from sqlalchemy.engine import URL
    from sqlalchemy.engine.base import Connection
    from sqlalchemy.sql import Executable
    from sqlalchemy.sql.schema import MetaData
    from sqlalchemy.sql.schema import SchemaItem
    from sqlalchemy.sql.type_api import TypeEngine
    from .migration import MigrationInfo
    from ..autogenerate.api import AutogenContext
    from ..config import Config
    from ..ddl import DefaultImpl
    from ..operations.ops import MigrationScript
    from ..script.base import ScriptDirectory
_RevNumber = Optional[Union[str, Tuple[str, ...]]]
ProcessRevisionDirectiveFn = Callable[
    [MigrationContext, _GetRevArg, List["MigrationScript"]], None
...(truncado)

===== ./venv/lib/python3.13/site-packages/alembic/runtime/migration.py =====
from __future__ import annotations
from contextlib import contextmanager
from contextlib import nullcontext
import logging
import sys
from typing import Any
from typing import Callable
from typing import cast
from typing import Collection
from typing import Dict
from typing import Iterable
from typing import Iterator
from typing import List
from typing import Optional
from typing import Set
from typing import Tuple
from typing import TYPE_CHECKING
from typing import Union
from sqlalchemy import Column
from sqlalchemy import literal_column
from sqlalchemy import select
from sqlalchemy.engine import Engine
from sqlalchemy.engine import url as sqla_url
from sqlalchemy.engine.strategies import MockEngineStrategy
from typing_extensions import ContextManager
from .. import ddl
from .. import util
from ..util import sqla_compat
from ..util.compat import EncodedIO
if TYPE_CHECKING:
    from sqlalchemy.engine import Dialect
    from sqlalchemy.engine import URL
    from sqlalchemy.engine.base import Connection
    from sqlalchemy.engine.base import Transaction
    from sqlalchemy.engine.mock import MockConnection
    from sqlalchemy.sql import Executable
    from .environment import EnvironmentContext
    from ..config import Config
    from ..script.base import Script
    from ..script.base import ScriptDirectory
...(truncado)

===== ./venv/lib/python3.13/site-packages/alembic/__init__.py =====
from . import context
from . import op
__version__ = "1.16.5"
...(truncado)

===== ./venv/lib/python3.13/site-packages/alembic/operations/schemaobj.py =====
from __future__ import annotations
from typing import Any
from typing import Dict
from typing import List
from typing import Optional
from typing import Sequence
from typing import Tuple
from typing import TYPE_CHECKING
from typing import Union
from sqlalchemy import schema as sa_schema
from sqlalchemy.sql.schema import Column
from sqlalchemy.sql.schema import Constraint
from sqlalchemy.sql.schema import Index
from sqlalchemy.types import Integer
from sqlalchemy.types import NULLTYPE
from .. import util
from ..util import sqla_compat
if TYPE_CHECKING:
    from sqlalchemy.sql.elements import ColumnElement
    from sqlalchemy.sql.elements import TextClause
    from sqlalchemy.sql.schema import CheckConstraint
    from sqlalchemy.sql.schema import ForeignKey
    from sqlalchemy.sql.schema import ForeignKeyConstraint
    from sqlalchemy.sql.schema import MetaData
    from sqlalchemy.sql.schema import PrimaryKeyConstraint
    from sqlalchemy.sql.schema import Table
    from sqlalchemy.sql.schema import UniqueConstraint
    from sqlalchemy.sql.type_api import TypeEngine
    from ..runtime.migration import MigrationContext
class SchemaObjects:
    def __init__(
        self, migration_context: Optional[MigrationContext] = None
    ) -> None:
        self.migration_context = migration_context
    def primary_key_constraint(
        self,
        name: Optional[sqla_compat._ConstraintNameDefined],
        table_name: str,
        cols: Sequence[str],
        schema: Optional[str] = None,
...(truncado)

===== ./venv/lib/python3.13/site-packages/alembic/operations/batch.py =====
from __future__ import annotations
from typing import Any
from typing import Dict
from typing import List
from typing import Optional
from typing import Tuple
from typing import TYPE_CHECKING
from typing import Union
from sqlalchemy import CheckConstraint
from sqlalchemy import Column
from sqlalchemy import ForeignKeyConstraint
from sqlalchemy import Index
from sqlalchemy import MetaData
from sqlalchemy import PrimaryKeyConstraint
from sqlalchemy import schema as sql_schema
from sqlalchemy import select
from sqlalchemy import Table
from sqlalchemy import types as sqltypes
from sqlalchemy.sql.schema import SchemaEventTarget
from sqlalchemy.util import OrderedDict
from sqlalchemy.util import topological
from ..util import exc
from ..util.sqla_compat import _columns_for_constraint
from ..util.sqla_compat import _copy
from ..util.sqla_compat import _copy_expression
from ..util.sqla_compat import _ensure_scope_for_ddl
from ..util.sqla_compat import _fk_is_self_referential
from ..util.sqla_compat import _idx_table_bound_expressions
from ..util.sqla_compat import _is_type_bound
from ..util.sqla_compat import _remove_column_from_collection
from ..util.sqla_compat import _resolve_for_variant
from ..util.sqla_compat import constraint_name_defined
from ..util.sqla_compat import constraint_name_string
if TYPE_CHECKING:
    from typing import Literal
    from sqlalchemy.engine import Dialect
    from sqlalchemy.sql.elements import ColumnClause
    from sqlalchemy.sql.elements import quoted_name
    from sqlalchemy.sql.functions import Function
    from sqlalchemy.sql.schema import Constraint
...(truncado)

===== ./venv/lib/python3.13/site-packages/alembic/operations/__init__.py =====
from . import toimpl
from .base import AbstractOperations
from .base import BatchOperations
from .base import Operations
from .ops import MigrateOperation
from .ops import MigrationScript
__all__ = [
    "AbstractOperations",
    "Operations",
    "BatchOperations",
    "MigrateOperation",
    "MigrationScript",
]
...(truncado)

===== ./venv/lib/python3.13/site-packages/alembic/operations/ops.py =====
from __future__ import annotations
from abc import abstractmethod
import os
import pathlib
import re
from typing import Any
from typing import Callable
from typing import cast
from typing import Dict
from typing import FrozenSet
from typing import Iterator
from typing import List
from typing import MutableMapping
from typing import Optional
from typing import Sequence
from typing import Set
from typing import Tuple
from typing import Type
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union
from sqlalchemy.types import NULLTYPE
from . import schemaobj
from .base import BatchOperations
from .base import Operations
from .. import util
from ..util import sqla_compat
if TYPE_CHECKING:
    from typing import Literal
    from sqlalchemy.sql import Executable
    from sqlalchemy.sql.elements import ColumnElement
    from sqlalchemy.sql.elements import conv
    from sqlalchemy.sql.elements import quoted_name
    from sqlalchemy.sql.elements import TextClause
    from sqlalchemy.sql.schema import CheckConstraint
    from sqlalchemy.sql.schema import Column
    from sqlalchemy.sql.schema import Computed
    from sqlalchemy.sql.schema import Constraint
    from sqlalchemy.sql.schema import ForeignKeyConstraint
    from sqlalchemy.sql.schema import Identity
...(truncado)

===== ./venv/lib/python3.13/site-packages/alembic/operations/toimpl.py =====
from typing import TYPE_CHECKING
from sqlalchemy import schema as sa_schema
from . import ops
from .base import Operations
from ..util.sqla_compat import _copy
from ..util.sqla_compat import sqla_2
if TYPE_CHECKING:
    from sqlalchemy.sql.schema import Table
@Operations.implementation_for(ops.AlterColumnOp)
def alter_column(
    operations: "Operations", operation: "ops.AlterColumnOp"
) -> None:
    compiler = operations.impl.dialect.statement_compiler(
        operations.impl.dialect, None
    )
    existing_type = operation.existing_type
    existing_nullable = operation.existing_nullable
    existing_server_default = operation.existing_server_default
    type_ = operation.modify_type
    column_name = operation.column_name
    table_name = operation.table_name
    schema = operation.schema
    server_default = operation.modify_server_default
    new_column_name = operation.modify_name
    nullable = operation.modify_nullable
    comment = operation.modify_comment
    existing_comment = operation.existing_comment
    def _count_constraint(constraint):
        return not isinstance(constraint, sa_schema.PrimaryKeyConstraint) and (
            not constraint._create_rule or constraint._create_rule(compiler)
        )
    if existing_type and type_:
        t = operations.schema_obj.table(
            table_name,
            sa_schema.Column(column_name, existing_type),
            schema=schema,
        )
        for constraint in t.constraints:
            if _count_constraint(constraint):
                operations.impl.drop_constraint(constraint)
...(truncado)

===== ./venv/lib/python3.13/site-packages/alembic/operations/base.py =====
from __future__ import annotations
from contextlib import contextmanager
import re
import textwrap
from typing import Any
from typing import Awaitable
from typing import Callable
from typing import Dict
from typing import Iterator
from typing import List  # noqa
from typing import Mapping
from typing import NoReturn
from typing import Optional
from typing import overload
from typing import Sequence  # noqa
from typing import Tuple
from typing import Type  # noqa
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union
from sqlalchemy.sql.elements import conv
from . import batch
from . import schemaobj
from .. import util
from ..util import sqla_compat
from ..util.compat import formatannotation_fwdref
from ..util.compat import inspect_formatargspec
from ..util.compat import inspect_getfullargspec
from ..util.sqla_compat import _literal_bindparam
if TYPE_CHECKING:
    from typing import Literal
    from sqlalchemy import Table
    from sqlalchemy.engine import Connection
    from sqlalchemy.sql import Executable
    from sqlalchemy.sql.expression import ColumnElement
    from sqlalchemy.sql.expression import TableClause
    from sqlalchemy.sql.expression import TextClause
    from sqlalchemy.sql.schema import Column
    from sqlalchemy.sql.schema import Computed
    from sqlalchemy.sql.schema import Identity
...(truncado)

===== ./venv/lib/python3.13/site-packages/alembic/script/__init__.py =====
from .base import Script
from .base import ScriptDirectory
__all__ = ["ScriptDirectory", "Script"]
...(truncado)

===== ./venv/lib/python3.13/site-packages/alembic/script/write_hooks.py =====
from __future__ import annotations
import importlib.util
import os
import shlex
import subprocess
import sys
from typing import Any
from typing import Callable
from typing import Dict
from typing import List
from typing import Optional
from typing import TYPE_CHECKING
from typing import Union
from .. import util
from ..util import compat
from ..util.pyfiles import _preserving_path_as_str
if TYPE_CHECKING:
    from ..config import PostWriteHookConfig
REVISION_SCRIPT_TOKEN = "REVISION_SCRIPT_FILENAME"
_registry: dict = {}
def register(name: str) -> Callable:
    """A function decorator that will register that function as a write hook.
    See the documentation linked below for an example.
    .. seealso::
        :ref:`post_write_hooks_custom`
    """
    def decorate(fn):
        _registry[name] = fn
        return fn
    return decorate
def _invoke(
    name: str,
    revision_path: Union[str, os.PathLike[str]],
    options: PostWriteHookConfig,
) -> Any:
    """Invokes the formatter registered for the given name.
    :param name: The name of a formatter in the registry
    :param revision: string path to the revision file
    :param options: A dict containing kwargs passed to the
        specified formatter.
...(truncado)

===== ./venv/lib/python3.13/site-packages/alembic/script/revision.py =====
from __future__ import annotations
import collections
import re
from typing import Any
from typing import Callable
from typing import cast
from typing import Collection
from typing import Deque
from typing import Dict
from typing import FrozenSet
from typing import Iterable
from typing import Iterator
from typing import List
from typing import Optional
from typing import overload
from typing import Protocol
from typing import Sequence
from typing import Set
from typing import Tuple
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union
from sqlalchemy import util as sqlautil
from .. import util
from ..util import not_none
if TYPE_CHECKING:
    from typing import Literal
_RevIdType = Union[str, List[str], Tuple[str, ...]]
_GetRevArg = Union[
    str,
    Iterable[Optional[str]],
    Iterable[str],
]
_RevisionIdentifierType = Union[str, Tuple[str, ...], None]
_RevisionOrStr = Union["Revision", str]
_RevisionOrBase = Union["Revision", "Literal['base']"]
_InterimRevisionMapType = Dict[str, "Revision"]
_RevisionMapType = Dict[Union[None, str, Tuple[()]], Optional["Revision"]]
_T = TypeVar("_T")
_TR = TypeVar("_TR", bound=Optional[_RevisionOrStr])
...(truncado)

===== ./venv/lib/python3.13/site-packages/alembic/script/base.py =====
from __future__ import annotations
from contextlib import contextmanager
import datetime
import os
from pathlib import Path
import re
import shutil
import sys
from types import ModuleType
from typing import Any
from typing import cast
from typing import Iterator
from typing import List
from typing import Optional
from typing import Sequence
from typing import Set
from typing import Tuple
from typing import TYPE_CHECKING
from typing import Union
from . import revision
from . import write_hooks
from .. import util
from ..runtime import migration
from ..util import compat
from ..util import not_none
from ..util.pyfiles import _preserving_path_as_str
if TYPE_CHECKING:
    from .revision import _GetRevArg
    from .revision import _RevIdType
    from .revision import Revision
    from ..config import Config
    from ..config import MessagingOptions
    from ..config import PostWriteHookConfig
    from ..runtime.migration import RevisionStep
    from ..runtime.migration import StampStep
try:
    if compat.py39:
        from zoneinfo import ZoneInfo
        from zoneinfo import ZoneInfoNotFoundError
    else:
...(truncado)

===== ./venv/lib/python3.13/site-packages/alembic/op.py =====
from .operations.base import Operations
Operations.create_module_class_proxy(globals(), locals())
...(truncado)

===== ./venv/lib/python3.13/site-packages/alembic/testing/env.py =====
import importlib.machinery
import os
from pathlib import Path
import shutil
import textwrap
from sqlalchemy.testing import config
from sqlalchemy.testing import provision
from . import util as testing_util
from .. import command
from .. import script
from .. import util
from ..script import Script
from ..script import ScriptDirectory
def _get_staging_directory():
    if provision.FOLLOWER_IDENT:
        return f"scratch_{provision.FOLLOWER_IDENT}"
    else:
        return "scratch"
def staging_env(create=True, template="generic", sourceless=False):
    cfg = _testing_config()
    if create:
        path = _join_path(_get_staging_directory(), "scripts")
        assert not os.path.exists(path), (
            "staging directory %s already exists; poor cleanup?" % path
        )
        command.init(cfg, path, template=template)
        if sourceless:
            try:
                # do an import so that a .pyc/.pyo is generated.
                util.load_python_file(path, "env.py")
            except AttributeError:
                # we don't have the migration context set up yet
                # so running the .env py throws this exception.
                # theoretically we could be using py_compiler here to
                # generate .pyc/.pyo without importing but not really
                # worth it.
                pass
            assert sourceless in (
                "pep3147_envonly",
                "simple",
...(truncado)

===== ./venv/lib/python3.13/site-packages/alembic/testing/util.py =====
from __future__ import annotations
import types
from typing import Union
from sqlalchemy.util import inspect_getfullargspec
from ..util import sqla_2
def flag_combinations(*combinations):
    """A facade around @testing.combinations() oriented towards boolean
    keyword-based arguments.
    Basically generates a nice looking identifier based on the keywords
    and also sets up the argument names.
    E.g.::
        @testing.flag_combinations(
            dict(lazy=False, passive=False),
            dict(lazy=True, passive=False),
            dict(lazy=False, passive=True),
            dict(lazy=False, passive=True, raiseload=True),
        )
    would result in::
        @testing.combinations(
            ('', False, False, False),
            ('lazy', True, False, False),
            ('lazy_passive', True, True, False),
            ('lazy_passive', True, True, True),
            id_='iaaa',
            argnames='lazy,passive,raiseload'
        )
    """
    from sqlalchemy.testing import config
    keys = set()
    for d in combinations:
        keys.update(d)
    keys = sorted(keys)
    return config.combinations(
        *[
            ("_".join(k for k in keys if d.get(k, False)),)
            + tuple(d.get(k, False) for k in keys)
            for d in combinations
        ],
        id_="i" + ("a" * len(keys)),
        argnames=",".join(keys),
...(truncado)

===== ./venv/lib/python3.13/site-packages/alembic/testing/schemacompare.py =====
from itertools import zip_longest
from sqlalchemy import schema
from sqlalchemy.sql.elements import ClauseList
class CompareTable:
    def __init__(self, table):
        self.table = table
    def __eq__(self, other):
        if self.table.name != other.name or self.table.schema != other.schema:
            return False
        for c1, c2 in zip_longest(self.table.c, other.c):
            if (c1 is None and c2 is not None) or (
                c2 is None and c1 is not None
            ):
                return False
            if CompareColumn(c1) != c2:
                return False
        return True
        # TODO: compare constraints, indexes
    def __ne__(self, other):
        return not self.__eq__(other)
class CompareColumn:
    def __init__(self, column):
        self.column = column
    def __eq__(self, other):
        return (
            self.column.name == other.name
            and self.column.nullable == other.nullable
        )
        # TODO: datatypes etc
    def __ne__(self, other):
        return not self.__eq__(other)
class CompareIndex:
    def __init__(self, index, name_only=False):
        self.index = index
        self.name_only = name_only
    def __eq__(self, other):
        if self.name_only:
            return self.index.name == other.name
        else:
            return (
...(truncado)

===== ./venv/lib/python3.13/site-packages/alembic/testing/warnings.py =====
import warnings
from sqlalchemy import exc as sa_exc
def setup_filters():
    """Set global warning behavior for the test suite."""
    warnings.resetwarnings()
    warnings.filterwarnings("error", category=sa_exc.SADeprecationWarning)
    warnings.filterwarnings("error", category=sa_exc.SAWarning)
    # some selected deprecations...
    warnings.filterwarnings("error", category=DeprecationWarning)
    try:
        import pytest
    except ImportError:
        pass
    else:
        warnings.filterwarnings(
            "once", category=pytest.PytestDeprecationWarning
        )
...(truncado)

===== ./venv/lib/python3.13/site-packages/alembic/testing/plugin/bootstrap.py =====
"""
Bootstrapper for test framework plugins.
"""
...(truncado)

===== ./venv/lib/python3.13/site-packages/alembic/testing/plugin/__init__.py =====
...(truncado)

===== ./venv/lib/python3.13/site-packages/alembic/testing/__init__.py =====
from sqlalchemy.testing import config
from sqlalchemy.testing import emits_warning
from sqlalchemy.testing import engines
from sqlalchemy.testing import exclusions
from sqlalchemy.testing import mock
from sqlalchemy.testing import provide_metadata
from sqlalchemy.testing import skip_if
from sqlalchemy.testing import uses_deprecated
from sqlalchemy.testing.config import combinations
from sqlalchemy.testing.config import fixture
from sqlalchemy.testing.config import requirements as requires
from sqlalchemy.testing.config import Variation
from sqlalchemy.testing.config import variation
from .assertions import assert_raises
from .assertions import assert_raises_message
from .assertions import emits_python_deprecation_warning
from .assertions import eq_
from .assertions import eq_ignore_whitespace
from .assertions import expect_deprecated
from .assertions import expect_raises
from .assertions import expect_raises_message
from .assertions import expect_sqlalchemy_deprecated
from .assertions import expect_sqlalchemy_deprecated_20
from .assertions import expect_warnings
from .assertions import is_
from .assertions import is_false
from .assertions import is_not_
from .assertions import is_true
from .assertions import ne_
from .fixtures import TestBase
from .util import resolve_lambda
...(truncado)

===== ./venv/lib/python3.13/site-packages/alembic/testing/assertions.py =====
from __future__ import annotations
import contextlib
import re
import sys
from typing import Any
from typing import Dict
from sqlalchemy import exc as sa_exc
from sqlalchemy.engine import default
from sqlalchemy.engine import URL
from sqlalchemy.testing.assertions import _expect_warnings
from sqlalchemy.testing.assertions import eq_  # noqa
from sqlalchemy.testing.assertions import is_  # noqa
from sqlalchemy.testing.assertions import is_false  # noqa
from sqlalchemy.testing.assertions import is_not_  # noqa
from sqlalchemy.testing.assertions import is_true  # noqa
from sqlalchemy.testing.assertions import ne_  # noqa
from sqlalchemy.util import decorator
def _assert_proper_exception_context(exception):
    """assert that any exception we're catching does not have a __context__
    without a __cause__, and that __suppress_context__ is never set.
    Python 3 will report nested as exceptions as "during the handling of
    error X, error Y occurred". That's not what we want to do.  we want
    these exceptions in a cause chain.
    """
    if (
        exception.__context__ is not exception.__cause__
        and not exception.__suppress_context__
    ):
        assert False, (
            "Exception %r was correctly raised but did not set a cause, "
            "within context %r as its cause."
            % (exception, exception.__context__)
        )
def assert_raises(except_cls, callable_, *args, **kw):
    return _assert_raises(except_cls, callable_, args, kw, check_context=True)
def assert_raises_context_ok(except_cls, callable_, *args, **kw):
    return _assert_raises(except_cls, callable_, args, kw)
def assert_raises_message(except_cls, msg, callable_, *args, **kwargs):
    return _assert_raises(
        except_cls, callable_, args, kwargs, msg=msg, check_context=True
...(truncado)

===== ./venv/lib/python3.13/site-packages/alembic/testing/requirements.py =====
from sqlalchemy.testing.requirements import Requirements
from alembic import util
from ..testing import exclusions
class SuiteRequirements(Requirements):
    @property
    def schemas(self):
        """Target database must support external schemas, and have one
        named 'test_schema'."""
        return exclusions.open()
    @property
    def autocommit_isolation(self):
        """target database should support 'AUTOCOMMIT' isolation level"""
        return exclusions.closed()
    @property
    def materialized_views(self):
        """needed for sqlalchemy compat"""
        return exclusions.closed()
    @property
    def unique_constraint_reflection(self):
        def doesnt_have_check_uq_constraints(config):
            from sqlalchemy import inspect
            insp = inspect(config.db)
            try:
                insp.get_unique_constraints("x")
            except NotImplementedError:
                return True
            except TypeError:
                return True
            except Exception:
                pass
            return False
        return exclusions.skip_if(doesnt_have_check_uq_constraints)
    @property
    def sequences(self):
        """Target database must support SEQUENCEs."""
        return exclusions.only_if(
            [lambda config: config.db.dialect.supports_sequences],
            "no sequence support",
        )
    @property
...(truncado)

===== ./venv/lib/python3.13/site-packages/alembic/testing/suite/test_autogen_fks.py =====
from sqlalchemy import Column
from sqlalchemy import ForeignKeyConstraint
from sqlalchemy import Integer
from sqlalchemy import MetaData
from sqlalchemy import String
from sqlalchemy import Table
from ._autogen_fixtures import AutogenFixtureTest
from ...testing import combinations
from ...testing import config
from ...testing import eq_
from ...testing import mock
from ...testing import TestBase
class AutogenerateForeignKeysTest(AutogenFixtureTest, TestBase):
    __backend__ = True
    __requires__ = ("foreign_key_constraint_reflection",)
    def test_remove_fk(self):
        m1 = MetaData()
        m2 = MetaData()
        Table(
            "some_table",
            m1,
            Column("test", String(10), primary_key=True),
        )
        Table(
            "user",
            m1,
            Column("id", Integer, primary_key=True),
            Column("name", String(50), nullable=False),
            Column("a1", String(10), server_default="x"),
            Column("test2", String(10)),
            ForeignKeyConstraint(["test2"], ["some_table.test"]),
        )
        Table(
            "some_table",
            m2,
            Column("test", String(10), primary_key=True),
        )
        Table(
            "user",
            m2,
...(truncado)

===== ./venv/lib/python3.13/site-packages/alembic/testing/suite/_autogen_fixtures.py =====
from __future__ import annotations
from typing import Any
from typing import Dict
from typing import Set
from sqlalchemy import CHAR
from sqlalchemy import CheckConstraint
from sqlalchemy import Column
from sqlalchemy import event
from sqlalchemy import ForeignKey
from sqlalchemy import Index
from sqlalchemy import inspect
from sqlalchemy import Integer
from sqlalchemy import MetaData
from sqlalchemy import Numeric
from sqlalchemy import PrimaryKeyConstraint
from sqlalchemy import String
from sqlalchemy import Table
from sqlalchemy import Text
from sqlalchemy import text
from sqlalchemy import UniqueConstraint
from ... import autogenerate
from ... import util
from ...autogenerate import api
from ...ddl.base import _fk_spec
from ...migration import MigrationContext
from ...operations import ops
from ...testing import config
from ...testing import eq_
from ...testing.env import clear_staging_env
from ...testing.env import staging_env
names_in_this_test: Set[Any] = set()
@event.listens_for(Table, "after_parent_attach")
def new_table(table, parent):
    names_in_this_test.add(table.name)
def _default_include_object(obj, name, type_, reflected, compare_to):
    if type_ == "table":
        return name in names_in_this_test
    else:
        return True
_default_object_filters: Any = _default_include_object
...(truncado)

===== ./venv/lib/python3.13/site-packages/alembic/testing/suite/test_autogen_computed.py =====
import sqlalchemy as sa
from sqlalchemy import Column
from sqlalchemy import Integer
from sqlalchemy import MetaData
from sqlalchemy import Table
from ._autogen_fixtures import AutogenFixtureTest
from ... import testing
from ...testing import eq_
from ...testing import is_
from ...testing import is_true
from ...testing import mock
from ...testing import TestBase
class AutogenerateComputedTest(AutogenFixtureTest, TestBase):
    __requires__ = ("computed_columns",)
    __backend__ = True
    def test_add_computed_column(self):
        m1 = MetaData()
        m2 = MetaData()
        Table("user", m1, Column("id", Integer, primary_key=True))
        Table(
            "user",
            m2,
            Column("id", Integer, primary_key=True),
            Column("foo", Integer, sa.Computed("5")),
        )
        diffs = self._fixture(m1, m2)
        eq_(diffs[0][0], "add_column")
        eq_(diffs[0][2], "user")
        eq_(diffs[0][3].name, "foo")
        c = diffs[0][3].computed
        is_true(isinstance(c, sa.Computed))
        is_(c.persisted, None)
        eq_(str(c.sqltext), "5")
    def test_remove_computed_column(self):
        m1 = MetaData()
        m2 = MetaData()
        Table(
            "user",
            m1,
            Column("id", Integer, primary_key=True),
...(truncado)

===== ./venv/lib/python3.13/site-packages/alembic/testing/suite/test_autogen_diffs.py =====
from sqlalchemy import BigInteger
from sqlalchemy import Column
from sqlalchemy import Integer
from sqlalchemy import MetaData
from sqlalchemy import Table
from sqlalchemy.testing import in_
from ._autogen_fixtures import AutogenFixtureTest
from ... import testing
from ...testing import config
from ...testing import eq_
from ...testing import is_
from ...testing import TestBase
class AlterColumnTest(AutogenFixtureTest, TestBase):
    __backend__ = True
    @testing.combinations((True,), (False,))
    @config.requirements.comments
    def test_all_existings_filled(self, pk):
        m1 = MetaData()
        m2 = MetaData()
        Table("a", m1, Column("x", Integer, primary_key=pk))
        Table("a", m2, Column("x", Integer, comment="x", primary_key=pk))
        alter_col = self._assert_alter_col(m1, m2, pk)
        eq_(alter_col.modify_comment, "x")
    @testing.combinations((True,), (False,))
    @config.requirements.comments
    def test_all_existings_filled_in_notnull(self, pk):
        m1 = MetaData()
        m2 = MetaData()
        Table("a", m1, Column("x", Integer, nullable=False, primary_key=pk))
        Table(
            "a",
            m2,
            Column("x", Integer, nullable=False, comment="x", primary_key=pk),
        )
        self._assert_alter_col(m1, m2, pk, nullable=False)
    @testing.combinations((True,), (False,))
    @config.requirements.comments
    def test_all_existings_filled_in_comment(self, pk):
        m1 = MetaData()
        m2 = MetaData()
...(truncado)

===== ./venv/lib/python3.13/site-packages/alembic/testing/suite/__init__.py =====
from .test_autogen_comments import *  # noqa
from .test_autogen_computed import *  # noqa
from .test_autogen_diffs import *  # noqa
from .test_autogen_fks import *  # noqa
from .test_autogen_identity import *  # noqa
from .test_environment import *  # noqa
from .test_op import *  # noqa
...(truncado)

===== ./venv/lib/python3.13/site-packages/alembic/testing/suite/test_autogen_identity.py =====
import sqlalchemy as sa
from sqlalchemy import Column
from sqlalchemy import Integer
from sqlalchemy import MetaData
from sqlalchemy import Table
from alembic.util import sqla_compat
from ._autogen_fixtures import AutogenFixtureTest
from ... import testing
from ...testing import config
from ...testing import eq_
from ...testing import is_true
from ...testing import TestBase
class AutogenerateIdentityTest(AutogenFixtureTest, TestBase):
    __requires__ = ("identity_columns",)
    __backend__ = True
    def test_add_identity_column(self):
        m1 = MetaData()
        m2 = MetaData()
        Table("user", m1, Column("other", sa.Text))
        Table(
            "user",
            m2,
            Column("other", sa.Text),
            Column(
                "id",
                Integer,
                sa.Identity(start=5, increment=7),
                primary_key=True,
            ),
        )
        diffs = self._fixture(m1, m2)
        eq_(diffs[0][0], "add_column")
        eq_(diffs[0][2], "user")
        eq_(diffs[0][3].name, "id")
        i = diffs[0][3].identity
        is_true(isinstance(i, sa.Identity))
        eq_(i.start, 5)
        eq_(i.increment, 7)
    def test_remove_identity_column(self):
        m1 = MetaData()
...(truncado)

===== ./venv/lib/python3.13/site-packages/alembic/testing/suite/test_autogen_comments.py =====
from sqlalchemy import Column
from sqlalchemy import Float
from sqlalchemy import MetaData
from sqlalchemy import String
from sqlalchemy import Table
from ._autogen_fixtures import AutogenFixtureTest
from ...testing import eq_
from ...testing import mock
from ...testing import TestBase
class AutogenerateCommentsTest(AutogenFixtureTest, TestBase):
    __backend__ = True
    __requires__ = ("comments",)
    def test_existing_table_comment_no_change(self):
        m1 = MetaData()
        m2 = MetaData()
        Table(
            "some_table",
            m1,
            Column("test", String(10), primary_key=True),
            comment="this is some table",
        )
        Table(
            "some_table",
            m2,
            Column("test", String(10), primary_key=True),
            comment="this is some table",
        )
        diffs = self._fixture(m1, m2)
        eq_(diffs, [])
    def test_add_table_comment(self):
        m1 = MetaData()
        m2 = MetaData()
        Table("some_table", m1, Column("test", String(10), primary_key=True))
        Table(
            "some_table",
            m2,
            Column("test", String(10), primary_key=True),
            comment="this is some table",
        )
        diffs = self._fixture(m1, m2)
...(truncado)

===== ./venv/lib/python3.13/site-packages/alembic/testing/suite/test_op.py =====
"""Test against the builders in the op.* module."""
from sqlalchemy import Column
from sqlalchemy import event
from sqlalchemy import Integer
from sqlalchemy import String
from sqlalchemy import Table
from sqlalchemy.sql import text
from ...testing.fixtures import AlterColRoundTripFixture
from ...testing.fixtures import TestBase
@event.listens_for(Table, "after_parent_attach")
def _add_cols(table, metadata):
    if table.name == "tbl_with_auto_appended_column":
        table.append_column(Column("bat", Integer))
class BackendAlterColumnTest(AlterColRoundTripFixture, TestBase):
    __backend__ = True
    def test_rename_column(self):
        self._run_alter_col({}, {"name": "newname"})
    def test_modify_type_int_str(self):
        self._run_alter_col({"type": Integer()}, {"type": String(50)})
    def test_add_server_default_int(self):
        self._run_alter_col({"type": Integer}, {"server_default": text("5")})
    def test_modify_server_default_int(self):
        self._run_alter_col(
            {"type": Integer, "server_default": text("2")},
            {"server_default": text("5")},
        )
    def test_modify_nullable_to_non(self):
        self._run_alter_col({}, {"nullable": False})
    def test_modify_non_nullable_to_nullable(self):
        self._run_alter_col({"nullable": False}, {"nullable": True})
...(truncado)

===== ./venv/lib/python3.13/site-packages/alembic/testing/suite/test_environment.py =====
import io
from ...migration import MigrationContext
from ...testing import assert_raises
from ...testing import config
from ...testing import eq_
from ...testing import is_
from ...testing import is_false
from ...testing import is_not_
from ...testing import is_true
from ...testing import ne_
from ...testing.fixtures import TestBase
class MigrationTransactionTest(TestBase):
    __backend__ = True
    conn = None
    def _fixture(self, opts):
        self.conn = conn = config.db.connect()
        if opts.get("as_sql", False):
            self.context = MigrationContext.configure(
                dialect=conn.dialect, opts=opts
            )
            self.context.output_buffer = self.context.impl.output_buffer = (
                io.StringIO()
            )
        else:
            self.context = MigrationContext.configure(
                connection=conn, opts=opts
            )
        return self.context
    def teardown_method(self):
        if self.conn:
            self.conn.close()
    def test_proxy_transaction_rollback(self):
        context = self._fixture(
            {"transaction_per_migration": True, "transactional_ddl": True}
        )
        is_false(self.conn.in_transaction())
        proxy = context.begin_transaction(_per_migration=True)
        is_true(self.conn.in_transaction())
        proxy.rollback()
        is_false(self.conn.in_transaction())
...(truncado)

===== ./venv/lib/python3.13/site-packages/alembic/testing/fixtures.py =====
from __future__ import annotations
import configparser
from contextlib import contextmanager
import io
import os
import re
import shutil
from typing import Any
from typing import Dict
from sqlalchemy import Column
from sqlalchemy import create_mock_engine
from sqlalchemy import inspect
from sqlalchemy import MetaData
from sqlalchemy import String
from sqlalchemy import Table
from sqlalchemy import testing
from sqlalchemy import text
from sqlalchemy.testing import config
from sqlalchemy.testing import mock
from sqlalchemy.testing.assertions import eq_
from sqlalchemy.testing.fixtures import FutureEngineMixin
from sqlalchemy.testing.fixtures import TablesTest as SQLAlchemyTablesTest
from sqlalchemy.testing.fixtures import TestBase as SQLAlchemyTestBase
import alembic
from .assertions import _get_dialect
from .env import _get_staging_directory
from ..environment import EnvironmentContext
from ..migration import MigrationContext
from ..operations import Operations
from ..util import sqla_compat
from ..util.sqla_compat import sqla_2
testing_config = configparser.ConfigParser()
testing_config.read(["test.cfg"])
class TestBase(SQLAlchemyTestBase):
    is_sqlalchemy_future = sqla_2
    @testing.fixture()
    def clear_staging_dir(self):
        yield
        location = _get_staging_directory()
        for filename in os.listdir(location):
...(truncado)

===== ./venv/lib/python3.13/site-packages/alembic/context.py =====
from .runtime.environment import EnvironmentContext
EnvironmentContext.create_module_class_proxy(globals(), locals())
...(truncado)

===== ./venv/lib/python3.13/site-packages/alembic/autogenerate/render.py =====
from __future__ import annotations
from io import StringIO
import re
from typing import Any
from typing import cast
from typing import Dict
from typing import List
from typing import Optional
from typing import Tuple
from typing import TYPE_CHECKING
from typing import Union
from mako.pygen import PythonPrinter
from sqlalchemy import schema as sa_schema
from sqlalchemy import sql
from sqlalchemy import types as sqltypes
from sqlalchemy.sql.base import _DialectArgView
from sqlalchemy.sql.elements import conv
from sqlalchemy.sql.elements import Label
from sqlalchemy.sql.elements import quoted_name
from .. import util
from ..operations import ops
from ..util import sqla_compat
if TYPE_CHECKING:
    from typing import Literal
    from sqlalchemy import Computed
    from sqlalchemy import Identity
    from sqlalchemy.sql.elements import ColumnElement
    from sqlalchemy.sql.elements import TextClause
    from sqlalchemy.sql.schema import CheckConstraint
    from sqlalchemy.sql.schema import Column
    from sqlalchemy.sql.schema import Constraint
    from sqlalchemy.sql.schema import FetchedValue
    from sqlalchemy.sql.schema import ForeignKey
    from sqlalchemy.sql.schema import ForeignKeyConstraint
    from sqlalchemy.sql.schema import Index
    from sqlalchemy.sql.schema import MetaData
    from sqlalchemy.sql.schema import PrimaryKeyConstraint
    from sqlalchemy.sql.schema import UniqueConstraint
    from sqlalchemy.sql.sqltypes import ARRAY
    from sqlalchemy.sql.type_api import TypeEngine
...(truncado)

===== ./venv/lib/python3.13/site-packages/alembic/autogenerate/rewriter.py =====
from __future__ import annotations
from typing import Any
from typing import Callable
from typing import Iterator
from typing import List
from typing import Tuple
from typing import Type
from typing import TYPE_CHECKING
from typing import Union
from .. import util
from ..operations import ops
if TYPE_CHECKING:
    from ..operations.ops import AddColumnOp
    from ..operations.ops import AlterColumnOp
    from ..operations.ops import CreateTableOp
    from ..operations.ops import DowngradeOps
    from ..operations.ops import MigrateOperation
    from ..operations.ops import MigrationScript
    from ..operations.ops import ModifyTableOps
    from ..operations.ops import OpContainer
    from ..operations.ops import UpgradeOps
    from ..runtime.migration import MigrationContext
    from ..script.revision import _GetRevArg
ProcessRevisionDirectiveFn = Callable[
    ["MigrationContext", "_GetRevArg", List["MigrationScript"]], None
]
class Rewriter:
    """A helper object that allows easy 'rewriting' of ops streams.
    The :class:`.Rewriter` object is intended to be passed along
    to the
    :paramref:`.EnvironmentContext.configure.process_revision_directives`
    parameter in an ``env.py`` script.    Once constructed, any number
    of "rewrites" functions can be associated with it, which will be given
    the opportunity to modify the structure without having to have explicit
    knowledge of the overall structure.
    The function is passed the :class:`.MigrationContext` object and
    ``revision`` tuple that are passed to the  :paramref:`.Environment
    Context.configure.process_revision_directives` function normally,
    and the third argument is an individual directive of the type
    noted in the decorator.  The function has the choice of  returning
...(truncado)

===== ./venv/lib/python3.13/site-packages/alembic/autogenerate/__init__.py =====
from .api import _render_migration_diffs as _render_migration_diffs
from .api import compare_metadata as compare_metadata
from .api import produce_migrations as produce_migrations
from .api import render_python_code as render_python_code
from .api import RevisionContext as RevisionContext
from .compare import _produce_net_changes as _produce_net_changes
from .compare import comparators as comparators
from .render import render_op_text as render_op_text
from .render import renderers as renderers
from .rewriter import Rewriter as Rewriter
...(truncado)

===== ./venv/lib/python3.13/site-packages/alembic/autogenerate/api.py =====
from __future__ import annotations
import contextlib
from typing import Any
from typing import Dict
from typing import Iterator
from typing import List
from typing import Optional
from typing import Sequence
from typing import Set
from typing import TYPE_CHECKING
from typing import Union
from sqlalchemy import inspect
from . import compare
from . import render
from .. import util
from ..operations import ops
from ..util import sqla_compat
"""Provide the 'autogenerate' feature which can produce migration operations
automatically."""
if TYPE_CHECKING:
    from sqlalchemy.engine import Connection
    from sqlalchemy.engine import Dialect
    from sqlalchemy.engine import Inspector
    from sqlalchemy.sql.schema import MetaData
    from sqlalchemy.sql.schema import SchemaItem
    from sqlalchemy.sql.schema import Table
    from ..config import Config
    from ..operations.ops import DowngradeOps
    from ..operations.ops import MigrationScript
    from ..operations.ops import UpgradeOps
    from ..runtime.environment import NameFilterParentNames
    from ..runtime.environment import NameFilterType
    from ..runtime.environment import ProcessRevisionDirectiveFn
    from ..runtime.environment import RenderItemFn
    from ..runtime.migration import MigrationContext
    from ..script.base import Script
    from ..script.base import ScriptDirectory
    from ..script.revision import _GetRevArg
def compare_metadata(context: MigrationContext, metadata: MetaData) -> Any:
    """Compare a database schema to that given in a
...(truncado)

===== ./venv/lib/python3.13/site-packages/alembic/autogenerate/compare.py =====
from __future__ import annotations
import contextlib
import logging
import re
from typing import Any
from typing import cast
from typing import Dict
from typing import Iterator
from typing import Mapping
from typing import Optional
from typing import Set
from typing import Tuple
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union
from sqlalchemy import event
from sqlalchemy import inspect
from sqlalchemy import schema as sa_schema
from sqlalchemy import text
from sqlalchemy import types as sqltypes
from sqlalchemy.sql import expression
from sqlalchemy.sql.elements import conv
from sqlalchemy.sql.schema import ForeignKeyConstraint
from sqlalchemy.sql.schema import Index
from sqlalchemy.sql.schema import UniqueConstraint
from sqlalchemy.util import OrderedSet
from .. import util
from ..ddl._autogen import is_index_sig
from ..ddl._autogen import is_uq_sig
from ..operations import ops
from ..util import sqla_compat
if TYPE_CHECKING:
    from typing import Literal
    from sqlalchemy.engine.reflection import Inspector
    from sqlalchemy.sql.elements import quoted_name
    from sqlalchemy.sql.elements import TextClause
    from sqlalchemy.sql.schema import Column
    from sqlalchemy.sql.schema import Table
    from alembic.autogenerate.api import AutogenContext
    from alembic.ddl.impl import DefaultImpl
...(truncado)

===== ./venv/lib/python3.13/site-packages/alembic/environment.py =====
from .runtime.environment import *  # noqa
...(truncado)

===== ./venv/lib/python3.13/site-packages/alembic/templates/pyproject_async/env.py =====
import asyncio
from logging.config import fileConfig
from sqlalchemy import pool
from sqlalchemy.engine import Connection
from sqlalchemy.ext.asyncio import async_engine_from_config
from alembic import context
config = context.config
if config.config_file_name is not None:
    fileConfig(config.config_file_name)
target_metadata = None
def run_migrations_offline() -> None:
    """Run migrations in 'offline' mode.
    This configures the context with just a URL
    and not an Engine, though an Engine is acceptable
    here as well.  By skipping the Engine creation
    we don't even need a DBAPI to be available.
    Calls to context.execute() here emit the given string to the
    script output.
    """
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
    )
    with context.begin_transaction():
        context.run_migrations()
def do_run_migrations(connection: Connection) -> None:
    context.configure(connection=connection, target_metadata=target_metadata)
    with context.begin_transaction():
        context.run_migrations()
async def run_async_migrations() -> None:
    """In this scenario we need to create an Engine
    and associate a connection with the context.
    """
    connectable = async_engine_from_config(
        config.get_section(config.config_ini_section, {}),
        prefix="sqlalchemy.",
        poolclass=pool.NullPool,
...(truncado)

===== ./venv/lib/python3.13/site-packages/alembic/templates/async/env.py =====
import asyncio
from logging.config import fileConfig
from sqlalchemy import pool
from sqlalchemy.engine import Connection
from sqlalchemy.ext.asyncio import async_engine_from_config
from alembic import context
config = context.config
if config.config_file_name is not None:
    fileConfig(config.config_file_name)
target_metadata = None
def run_migrations_offline() -> None:
    """Run migrations in 'offline' mode.
    This configures the context with just a URL
    and not an Engine, though an Engine is acceptable
    here as well.  By skipping the Engine creation
    we don't even need a DBAPI to be available.
    Calls to context.execute() here emit the given string to the
    script output.
    """
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
    )
    with context.begin_transaction():
        context.run_migrations()
def do_run_migrations(connection: Connection) -> None:
    context.configure(connection=connection, target_metadata=target_metadata)
    with context.begin_transaction():
        context.run_migrations()
async def run_async_migrations() -> None:
    """In this scenario we need to create an Engine
    and associate a connection with the context.
    """
    connectable = async_engine_from_config(
        config.get_section(config.config_ini_section, {}),
        prefix="sqlalchemy.",
        poolclass=pool.NullPool,
...(truncado)

===== ./venv/lib/python3.13/site-packages/alembic/templates/multidb/env.py =====
import logging
from logging.config import fileConfig
import re
from sqlalchemy import engine_from_config
from sqlalchemy import pool
from alembic import context
USE_TWOPHASE = False
config = context.config
if config.config_file_name is not None:
    fileConfig(config.config_file_name)
logger = logging.getLogger("alembic.env")
db_names = config.get_main_option("databases", "")
target_metadata = {}
def run_migrations_offline() -> None:
    """Run migrations in 'offline' mode.
    This configures the context with just a URL
    and not an Engine, though an Engine is acceptable
    here as well.  By skipping the Engine creation
    we don't even need a DBAPI to be available.
    Calls to context.execute() here emit the given string to the
    script output.
    """
    # for the --sql use case, run migrations for each URL into
    # individual files.
    engines = {}
    for name in re.split(r",\s*", db_names):
        engines[name] = rec = {}
        rec["url"] = context.config.get_section_option(name, "sqlalchemy.url")
    for name, rec in engines.items():
        logger.info("Migrating database %s" % name)
        file_ = "%s.sql" % name
        logger.info("Writing output to %s" % file_)
        with open(file_, "w") as buffer:
            context.configure(
                url=rec["url"],
                output_buffer=buffer,
                target_metadata=target_metadata.get(name),
                literal_binds=True,
                dialect_opts={"paramstyle": "named"},
            )
...(truncado)

===== ./venv/lib/python3.13/site-packages/alembic/templates/pyproject/env.py =====
from logging.config import fileConfig
from sqlalchemy import engine_from_config
from sqlalchemy import pool
from alembic import context
config = context.config
if config.config_file_name is not None:
    fileConfig(config.config_file_name)
target_metadata = None
def run_migrations_offline() -> None:
    """Run migrations in 'offline' mode.
    This configures the context with just a URL
    and not an Engine, though an Engine is acceptable
    here as well.  By skipping the Engine creation
    we don't even need a DBAPI to be available.
    Calls to context.execute() here emit the given string to the
    script output.
    """
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
    )
    with context.begin_transaction():
        context.run_migrations()
def run_migrations_online() -> None:
    """Run migrations in 'online' mode.
    In this scenario we need to create an Engine
    and associate a connection with the context.
    """
    connectable = engine_from_config(
        config.get_section(config.config_ini_section, {}),
        prefix="sqlalchemy.",
        poolclass=pool.NullPool,
    )
    with connectable.connect() as connection:
        context.configure(
            connection=connection, target_metadata=target_metadata
        )
...(truncado)

===== ./venv/lib/python3.13/site-packages/alembic/templates/generic/env.py =====
from logging.config import fileConfig
from sqlalchemy import engine_from_config
from sqlalchemy import pool
from alembic import context
config = context.config
if config.config_file_name is not None:
    fileConfig(config.config_file_name)
target_metadata = None
def run_migrations_offline() -> None:
    """Run migrations in 'offline' mode.
    This configures the context with just a URL
    and not an Engine, though an Engine is acceptable
    here as well.  By skipping the Engine creation
    we don't even need a DBAPI to be available.
    Calls to context.execute() here emit the given string to the
    script output.
    """
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
    )
    with context.begin_transaction():
        context.run_migrations()
def run_migrations_online() -> None:
    """Run migrations in 'online' mode.
    In this scenario we need to create an Engine
    and associate a connection with the context.
    """
    connectable = engine_from_config(
        config.get_section(config.config_ini_section, {}),
        prefix="sqlalchemy.",
        poolclass=pool.NullPool,
    )
    with connectable.connect() as connection:
        context.configure(
            connection=connection, target_metadata=target_metadata
        )
...(truncado)

===== ./venv/lib/python3.13/site-packages/alembic/migration.py =====
from .runtime.migration import *  # noqa
...(truncado)

===== ./venv/lib/python3.13/site-packages/alembic/__main__.py =====
from .config import main
if __name__ == "__main__":
    main(prog="alembic")
...(truncado)

===== ./venv/lib/python3.13/site-packages/blinker/__init__.py =====
from __future__ import annotations
from .base import ANY
from .base import default_namespace
from .base import NamedSignal
from .base import Namespace
from .base import Signal
from .base import signal
__all__ = [
    "ANY",
    "default_namespace",
    "NamedSignal",
    "Namespace",
    "Signal",
    "signal",
]
...(truncado)

===== ./venv/lib/python3.13/site-packages/blinker/_utilities.py =====
from __future__ import annotations
import collections.abc as c
import inspect
import typing as t
from weakref import ref
from weakref import WeakMethod
T = t.TypeVar("T")
class Symbol:
    """A constant symbol, nicer than ``object()``. Repeated calls return the
    same instance.
    >>> Symbol('foo') is Symbol('foo')
    True
    >>> Symbol('foo')
    foo
    """
    symbols: t.ClassVar[dict[str, Symbol]] = {}
    def __new__(cls, name: str) -> Symbol:
        if name in cls.symbols:
            return cls.symbols[name]
        obj = super().__new__(cls)
        cls.symbols[name] = obj
        return obj
    def __init__(self, name: str) -> None:
        self.name = name
    def __repr__(self) -> str:
        return self.name
    def __getnewargs__(self) -> tuple[t.Any, ...]:
        return (self.name,)
def make_id(obj: object) -> c.Hashable:
    """Get a stable identifier for a receiver or sender, to be used as a dict
    key or in a set.
    """
    if inspect.ismethod(obj):
        # The id of a bound method is not stable, but the id of the unbound
        # function and instance are.
        return id(obj.__func__), id(obj.__self__)
    if isinstance(obj, (str, int)):
        # Instances with the same value always compare equal and have the same
        # hash, even if the id may change.
        return obj
...(truncado)

===== ./venv/lib/python3.13/site-packages/blinker/base.py =====
from __future__ import annotations
import collections.abc as c
import sys
import typing as t
import weakref
from collections import defaultdict
from contextlib import contextmanager
from functools import cached_property
from inspect import iscoroutinefunction
from ._utilities import make_id
from ._utilities import make_ref
from ._utilities import Symbol
F = t.TypeVar("F", bound=c.Callable[..., t.Any])
ANY = Symbol("ANY")
"""Symbol for "any sender"."""
ANY_ID = 0
class Signal:
    """A notification emitter.
    :param doc: The docstring for the signal.
    """
    ANY = ANY
    """An alias for the :data:`~blinker.ANY` sender symbol."""
    set_class: type[set[t.Any]] = set
    """The set class to use for tracking connected receivers and senders.
    Python's ``set`` is unordered. If receivers must be dispatched in the order
    they were connected, an ordered set implementation can be used.
    .. versionadded:: 1.7
    """
    @cached_property
    def receiver_connected(self) -> Signal:
        """Emitted at the end of each :meth:`connect` call.
        The signal sender is the signal instance, and the :meth:`connect`
        arguments are passed through: ``receiver``, ``sender``, and ``weak``.
        .. versionadded:: 1.2
        """
        return Signal(doc="Emitted after a receiver connects.")
    @cached_property
    def receiver_disconnected(self) -> Signal:
        """Emitted at the end of each :meth:`disconnect` call.
        The sender is the signal instance, and the :meth:`disconnect` arguments
...(truncado)

===== ./venv/lib/python3.13/site-packages/wtforms/validators.py =====
import ipaddress
import math
import re
import uuid
__all__ = (
    "DataRequired",
    "data_required",
    "Email",
    "email",
    "EqualTo",
    "equal_to",
    "IPAddress",
    "ip_address",
    "InputRequired",
    "input_required",
    "Length",
    "length",
    "NumberRange",
    "number_range",
    "Optional",
    "optional",
    "Regexp",
    "regexp",
    "URL",
    "url",
    "AnyOf",
    "any_of",
    "NoneOf",
    "none_of",
    "MacAddress",
    "mac_address",
    "UUID",
    "ValidationError",
    "StopValidation",
    "readonly",
    "ReadOnly",
    "disabled",
    "Disabled",
)
class ValidationError(ValueError):
...(truncado)

===== ./venv/lib/python3.13/site-packages/wtforms/__init__.py =====
from wtforms import validators
from wtforms import widgets
from wtforms.fields.choices import RadioField
from wtforms.fields.choices import SelectField
from wtforms.fields.choices import SelectFieldBase
from wtforms.fields.choices import SelectMultipleField
from wtforms.fields.core import Field
from wtforms.fields.core import Flags
from wtforms.fields.core import Label
from wtforms.fields.datetime import DateField
from wtforms.fields.datetime import DateTimeField
from wtforms.fields.datetime import DateTimeLocalField
from wtforms.fields.datetime import MonthField
from wtforms.fields.datetime import TimeField
from wtforms.fields.datetime import WeekField
from wtforms.fields.form import FormField
from wtforms.fields.list import FieldList
from wtforms.fields.numeric import DecimalField
from wtforms.fields.numeric import DecimalRangeField
from wtforms.fields.numeric import FloatField
from wtforms.fields.numeric import IntegerField
from wtforms.fields.numeric import IntegerRangeField
from wtforms.fields.simple import BooleanField
from wtforms.fields.simple import ColorField
from wtforms.fields.simple import EmailField
from wtforms.fields.simple import FileField
from wtforms.fields.simple import HiddenField
from wtforms.fields.simple import MultipleFileField
from wtforms.fields.simple import PasswordField
from wtforms.fields.simple import SearchField
from wtforms.fields.simple import StringField
from wtforms.fields.simple import SubmitField
from wtforms.fields.simple import TelField
from wtforms.fields.simple import TextAreaField
from wtforms.fields.simple import URLField
from wtforms.form import Form
from wtforms.validators import ValidationError
__version__ = "3.2.1"
__all__ = [
    "validators",
...(truncado)

===== ./venv/lib/python3.13/site-packages/wtforms/csrf/session.py =====
"""
A provided CSRF implementation which puts CSRF data in a session.
This can be used fairly comfortably with many `request.session` type
objects, including the Werkzeug/Flask session store, Django sessions, and
potentially other similar objects which use a dict-like API for storing
session keys.
The basic concept is a randomly generated value is stored in the user's
session, and an hmac-sha1 of it (along with an optional expiration time,
for extra security) is used as the value of the csrf_token. If this token
validates with the hmac of the random value + expiration time, and the
expiration time is not passed, the CSRF validation will pass.
"""
import hmac
import os
from datetime import datetime
from datetime import timedelta
from hashlib import sha1
from ..validators import ValidationError
from .core import CSRF
__all__ = ("SessionCSRF",)
class SessionCSRF(CSRF):
    TIME_FORMAT = "%Y%m%d%H%M%S"
    def setup_form(self, form):
        self.form_meta = form.meta
        return super().setup_form(form)
    def generate_csrf_token(self, csrf_token_field):
        meta = self.form_meta
        if meta.csrf_secret is None:
            raise Exception(
                "must set `csrf_secret` on class Meta for SessionCSRF to work"
            )
        if meta.csrf_context is None:
            raise TypeError("Must provide a session-like object as csrf context")
        session = self.session
        if "csrf" not in session:
            session["csrf"] = sha1(os.urandom(64)).hexdigest()
        if self.time_limit:
            expires = (self.now() + self.time_limit).strftime(self.TIME_FORMAT)
            csrf_build = "{}{}".format(session["csrf"], expires)
        else:
...(truncado)

===== ./venv/lib/python3.13/site-packages/wtforms/csrf/__init__.py =====
...(truncado)

===== ./venv/lib/python3.13/site-packages/wtforms/csrf/core.py =====
from wtforms.fields import HiddenField
from wtforms.validators import ValidationError
__all__ = ("CSRFTokenField", "CSRF")
class CSRFTokenField(HiddenField):
    """
    A subclass of HiddenField designed for sending the CSRF token that is used
    for most CSRF protection schemes.
    Notably different from a normal field, this field always renders the
    current token regardless of the submitted value, and also will not be
    populated over to object data via populate_obj
    """
    current_token = None
    def __init__(self, *args, **kw):
        self.csrf_impl = kw.pop("csrf_impl")
        super().__init__(*args, **kw)
    def _value(self):
        """
        We want to always return the current token on render, regardless of
        whether a good or bad token was passed.
        """
        return self.current_token
    def populate_obj(self, *args):
        """
        Don't populate objects with the CSRF token
        """
        pass
    def pre_validate(self, form):
        """
        Handle validation of this token field.
        """
        self.csrf_impl.validate_csrf_token(form, self)
    def process(self, *args, **kwargs):
        super().process(*args, **kwargs)
        self.current_token = self.csrf_impl.generate_csrf_token(self)
class CSRF:
    field_class = CSRFTokenField
    def setup_form(self, form):
        """
        Receive the form we're attached to and set up fields.
        The default implementation creates a single field of
...(truncado)

===== ./venv/lib/python3.13/site-packages/wtforms/form.py =====
import itertools
from collections import OrderedDict
from wtforms.meta import DefaultMeta
from wtforms.utils import unset_value
__all__ = ("BaseForm", "Form")
_default_meta = DefaultMeta()
class BaseForm:
    """
    Base Form Class.  Provides core behaviour like field construction,
    validation, and data and error proxying.
    """
    def __init__(self, fields, prefix="", meta=_default_meta):
        """
        :param fields:
            A dict or sequence of 2-tuples of partially-constructed fields.
        :param prefix:
            If provided, all fields will have their name prefixed with the
            value.
        :param meta:
            A meta instance which is used for configuration and customization
            of WTForms behaviors.
        """
        if prefix and prefix[-1] not in "-_;:/.":
            prefix += "-"
        self.meta = meta
        self._form_error_key = ""
        self._prefix = prefix
        self._fields = OrderedDict()
        if hasattr(fields, "items"):
            fields = fields.items()
        translations = self.meta.get_translations(self)
        extra_fields = []
        if meta.csrf:
            self._csrf = meta.build_csrf(self)
            extra_fields.extend(self._csrf.setup_form(self))
        for name, unbound_field in itertools.chain(fields, extra_fields):
            field_name = unbound_field.name or name
            options = dict(name=field_name, prefix=prefix, translations=translations)
            field = meta.bind_field(self, unbound_field, options)
            self._fields[name] = field
...(truncado)

===== ./venv/lib/python3.13/site-packages/wtforms/utils.py =====
import os
import re
_LEADING_SYMBOL = "#" if os.name == "nt" else "-"
_DATETIME_STRIP_ZERO_PADDING_FORMATS_RE = re.compile(
    f"%{_LEADING_SYMBOL}["
    "d"  # day of month
    "m"  # month
    "H"  # hour (24-hour)
    "I"  # hour (12-hour)
    "M"  # minutes
    "S"  # seconds
    "U"  # week of year (Sunday first day of week)
    "W"  # week of year (Monday first day of week)
    "V"  # week of year (ISO 8601)
    "]",
    re.MULTILINE,
)
def clean_datetime_format_for_strptime(formats):
    """
    Remove dashes used to disable zero-padding with strftime formats (for
    compatibility with strptime).
    """
    return [
        re.sub(
            _DATETIME_STRIP_ZERO_PADDING_FORMATS_RE,
            lambda m: m[0].replace(_LEADING_SYMBOL, ""),
            format,
        )
        for format in formats
    ]
class UnsetValue:
    """
    An unset value.
    This is used in situations where a blank value like `None` is acceptable
    usually as the default value of a class variable or function parameter
    (iow, usually when `None` is a valid value.)
    """
    def __str__(self):
        return "<unset value>"
    def __repr__(self):
...(truncado)

===== ./venv/lib/python3.13/site-packages/wtforms/i18n.py =====
import os
def messages_path():
    """
    Determine the path to the 'messages' directory as best possible.
    """
    module_path = os.path.abspath(__file__)
    locale_path = os.path.join(os.path.dirname(module_path), "locale")
    if not os.path.exists(locale_path):  # pragma: no cover
        locale_path = "/usr/share/locale"
    return locale_path
def get_builtin_gnu_translations(languages=None):
    """
    Get a gettext.GNUTranslations object pointing at the
    included translation files.
    :param languages:
        A list of languages to try, in order. If omitted or None, then
        gettext will try to use locale information from the environment.
    """
    import gettext
    return gettext.translation("wtforms", messages_path(), languages)
def get_translations(languages=None, getter=get_builtin_gnu_translations):
    """
    Get a WTForms translation object which wraps a low-level translations object.
    :param languages:
        A sequence of languages to try, in order.
    :param getter:
        A single-argument callable which returns a low-level translations object.
    """
    return getter(languages)
class DefaultTranslations:
    """
    A WTForms translations object to wrap translations objects which use
    ugettext/ungettext.
    """
    def __init__(self, translations):
        self.translations = translations
    def gettext(self, string):
        return self.translations.ugettext(string)
    def ngettext(self, singular, plural, n):
        return self.translations.ungettext(singular, plural, n)
...(truncado)

===== ./venv/lib/python3.13/site-packages/wtforms/fields/list.py =====
import itertools
from wtforms.utils import unset_value
from .. import widgets
from .core import Field
from .core import UnboundField
__all__ = ("FieldList",)
class FieldList(Field):
    """
    Encapsulate an ordered list of multiple instances of the same field type,
    keeping data as a list.
    >>> authors = FieldList(StringField('Name', [validators.DataRequired()]))
    :param unbound_field:
        A partially-instantiated field definition, just like that would be
        defined on a form directly.
    :param min_entries:
        if provided, always have at least this many entries on the field,
        creating blank ones if the provided input does not specify a sufficient
        amount.
    :param max_entries:
        accept no more than this many entries as input, even if more exist in
        formdata.
    :param separator:
        A string which will be suffixed to this field's name to create the
        prefix to enclosed list entries. The default is fine for most uses.
    """
    widget = widgets.ListWidget()
    def __init__(
        self,
        unbound_field,
        label=None,
        validators=None,
        min_entries=0,
        max_entries=None,
        separator="-",
        default=(),
        **kwargs,
    ):
        super().__init__(label, validators, default=default, **kwargs)
        if self.filters:
            raise TypeError(
...(truncado)

===== ./venv/lib/python3.13/site-packages/wtforms/fields/__init__.py =====
from wtforms.fields.choices import RadioField
from wtforms.fields.choices import SelectField
from wtforms.fields.choices import SelectFieldBase
from wtforms.fields.choices import SelectMultipleField
from wtforms.fields.core import Field
from wtforms.fields.core import Flags
from wtforms.fields.core import Label
from wtforms.fields.datetime import DateField
from wtforms.fields.datetime import DateTimeField
from wtforms.fields.datetime import DateTimeLocalField
from wtforms.fields.datetime import MonthField
from wtforms.fields.datetime import TimeField
from wtforms.fields.datetime import WeekField
from wtforms.fields.form import FormField
from wtforms.fields.list import FieldList
from wtforms.fields.numeric import DecimalField
from wtforms.fields.numeric import DecimalRangeField
from wtforms.fields.numeric import FloatField
from wtforms.fields.numeric import IntegerField
from wtforms.fields.numeric import IntegerRangeField
from wtforms.fields.simple import BooleanField
from wtforms.fields.simple import ColorField
from wtforms.fields.simple import EmailField
from wtforms.fields.simple import FileField
from wtforms.fields.simple import HiddenField
from wtforms.fields.simple import MultipleFileField
from wtforms.fields.simple import PasswordField
from wtforms.fields.simple import SearchField
from wtforms.fields.simple import StringField
from wtforms.fields.simple import SubmitField
from wtforms.fields.simple import TelField
from wtforms.fields.simple import TextAreaField
from wtforms.fields.simple import URLField
from wtforms.utils import unset_value as _unset_value
__all__ = [
    "Field",
    "Flags",
    "Label",
    "SelectField",
    "SelectMultipleField",
...(truncado)

===== ./venv/lib/python3.13/site-packages/wtforms/fields/core.py =====
import inspect
import itertools
from markupsafe import escape
from markupsafe import Markup
from wtforms import widgets
from wtforms.i18n import DummyTranslations
from wtforms.utils import unset_value
from wtforms.validators import StopValidation
from wtforms.validators import ValidationError
class Field:
    """
    Field base class
    """
    errors = tuple()
    process_errors = tuple()
    raw_data = None
    validators = tuple()
    widget = None
    _formfield = True
    _translations = DummyTranslations()
    do_not_call_in_templates = True  # Allow Django 1.4 traversal
    def __new__(cls, *args, **kwargs):
        if "_form" in kwargs:
            return super().__new__(cls)
        else:
            return UnboundField(cls, *args, **kwargs)
    def __init__(
        self,
        label=None,
        validators=None,
        filters=(),
        description="",
        id=None,
        default=None,
        widget=None,
        render_kw=None,
        name=None,
        _form=None,
        _prefix="",
        _translations=None,
...(truncado)

===== ./venv/lib/python3.13/site-packages/wtforms/fields/form.py =====
from wtforms.utils import unset_value
from .. import widgets
from .core import Field
__all__ = ("FormField",)
class FormField(Field):
    """
    Encapsulate a form as a field in another form.
    :param form_class:
        A subclass of Form that will be encapsulated.
    :param separator:
        A string which will be suffixed to this field's name to create the
        prefix to enclosed fields. The default is fine for most uses.
    """
    widget = widgets.TableWidget()
    def __init__(
        self, form_class, label=None, validators=None, separator="-", **kwargs
    ):
        super().__init__(label, validators, **kwargs)
        self.form_class = form_class
        self.separator = separator
        self._obj = None
        if self.filters:
            raise TypeError(
                "FormField cannot take filters, as the encapsulated"
                " data is not mutable."
            )
        if validators:
            raise TypeError(
                "FormField does not accept any validators. Instead,"
                " define them on the enclosed form."
            )
    def process(self, formdata, data=unset_value, extra_filters=None):
        if extra_filters:
            raise TypeError(
                "FormField cannot take filters, as the encapsulated"
                "data is not mutable."
            )
        if data is unset_value:
            try:
                data = self.default()
...(truncado)

===== ./venv/lib/python3.13/site-packages/wtforms/fields/numeric.py =====
import decimal
from wtforms import widgets
from wtforms.fields.core import Field
from wtforms.utils import unset_value
__all__ = (
    "IntegerField",
    "DecimalField",
    "FloatField",
    "IntegerRangeField",
    "DecimalRangeField",
)
class LocaleAwareNumberField(Field):
    """
    Base class for implementing locale-aware number parsing.
    Locale-aware numbers require the 'babel' package to be present.
    """
    def __init__(
        self,
        label=None,
        validators=None,
        use_locale=False,
        number_format=None,
        **kwargs,
    ):
        super().__init__(label, validators, **kwargs)
        self.use_locale = use_locale
        if use_locale:
            self.number_format = number_format
            self.locale = kwargs["_form"].meta.locales[0]
            self._init_babel()
    def _init_babel(self):
        try:
            from babel import numbers
            self.babel_numbers = numbers
        except ImportError as exc:
            raise ImportError(
                "Using locale-aware decimals requires the babel library."
            ) from exc
    def _parse_decimal(self, value):
        return self.babel_numbers.parse_decimal(value, self.locale)
...(truncado)

===== ./venv/lib/python3.13/site-packages/wtforms/fields/choices.py =====
import itertools
from wtforms import widgets
from wtforms.fields.core import Field
from wtforms.validators import ValidationError
__all__ = (
    "SelectField",
    "SelectMultipleField",
    "RadioField",
)
class SelectFieldBase(Field):
    option_widget = widgets.Option()
    """
    Base class for fields which can be iterated to produce options.
    This isn't a field, but an abstract base class for fields which want to
    provide this functionality.
    """
    def __init__(self, label=None, validators=None, option_widget=None, **kwargs):
        super().__init__(label, validators, **kwargs)
        if option_widget is not None:
            self.option_widget = option_widget
    def iter_choices(self):
        """
        Provides data for choice widget rendering. Must return a sequence or
        iterable of (value, label, selected, render_kw) tuples.
        """
        raise NotImplementedError()
    def has_groups(self):
        return False
    def iter_groups(self):
        raise NotImplementedError()
    def __iter__(self):
        opts = dict(
            widget=self.option_widget,
            validators=self.validators,
            name=self.name,
            render_kw=self.render_kw,
            _form=None,
            _meta=self.meta,
        )
        for i, choice in enumerate(self.iter_choices()):
...(truncado)

===== ./venv/lib/python3.13/site-packages/wtforms/fields/datetime.py =====
import datetime
from wtforms import widgets
from wtforms.fields.core import Field
from wtforms.utils import clean_datetime_format_for_strptime
__all__ = (
    "DateTimeField",
    "DateField",
    "TimeField",
    "MonthField",
    "DateTimeLocalField",
    "WeekField",
)
class DateTimeField(Field):
    """
    A text field which stores a :class:`datetime.datetime` matching one or
    several formats. If ``format`` is a list, any input value matching any
    format will be accepted, and the first format in the list will be used
    to produce HTML values.
    """
    widget = widgets.DateTimeInput()
    def __init__(
        self, label=None, validators=None, format="%Y-%m-%d %H:%M:%S", **kwargs
    ):
        super().__init__(label, validators, **kwargs)
        self.format = format if isinstance(format, list) else [format]
        self.strptime_format = clean_datetime_format_for_strptime(self.format)
    def _value(self):
        if self.raw_data:
            return " ".join(self.raw_data)
        format = self.format[0]
        return self.data and self.data.strftime(format) or ""
    def process_formdata(self, valuelist):
        if not valuelist:
            return
        date_str = " ".join(valuelist)
        for format in self.strptime_format:
            try:
                self.data = datetime.datetime.strptime(date_str, format)
                return
            except ValueError:
...(truncado)

===== ./venv/lib/python3.13/site-packages/wtforms/fields/simple.py =====
from .. import widgets
from .core import Field
__all__ = (
    "BooleanField",
    "TextAreaField",
    "PasswordField",
    "FileField",
    "MultipleFileField",
    "HiddenField",
    "SearchField",
    "SubmitField",
    "StringField",
    "TelField",
    "URLField",
    "EmailField",
    "ColorField",
)
class BooleanField(Field):
    """
    Represents an ``<input type="checkbox">``. Set the ``checked``-status by using the
    ``default``-option. Any value for ``default``, e.g. ``default="checked"`` puts
    ``checked`` into the html-element and sets the ``data`` to ``True``
    :param false_values:
        If provided, a sequence of strings each of which is an exact match
        string of what is considered a "false" value. Defaults to the tuple
        ``(False, "false", "")``
    """
    widget = widgets.CheckboxInput()
    false_values = (False, "false", "")
    def __init__(self, label=None, validators=None, false_values=None, **kwargs):
        super().__init__(label, validators, **kwargs)
        if false_values is not None:
            self.false_values = false_values
    def process_data(self, value):
        self.data = bool(value)
    def process_formdata(self, valuelist):
        if not valuelist or valuelist[0] in self.false_values:
            self.data = False
        else:
            self.data = True
...(truncado)

===== ./venv/lib/python3.13/site-packages/wtforms/widgets/__init__.py =====
from wtforms.widgets.core import CheckboxInput
from wtforms.widgets.core import ColorInput
from wtforms.widgets.core import DateInput
from wtforms.widgets.core import DateTimeInput
from wtforms.widgets.core import DateTimeLocalInput
from wtforms.widgets.core import EmailInput
from wtforms.widgets.core import FileInput
from wtforms.widgets.core import HiddenInput
from wtforms.widgets.core import html_params
from wtforms.widgets.core import Input
from wtforms.widgets.core import ListWidget
from wtforms.widgets.core import MonthInput
from wtforms.widgets.core import NumberInput
from wtforms.widgets.core import Option
from wtforms.widgets.core import PasswordInput
from wtforms.widgets.core import RadioInput
from wtforms.widgets.core import RangeInput
from wtforms.widgets.core import SearchInput
from wtforms.widgets.core import Select
from wtforms.widgets.core import SubmitInput
from wtforms.widgets.core import TableWidget
from wtforms.widgets.core import TelInput
from wtforms.widgets.core import TextArea
from wtforms.widgets.core import TextInput
from wtforms.widgets.core import TimeInput
from wtforms.widgets.core import URLInput
from wtforms.widgets.core import WeekInput
__all__ = [
    "CheckboxInput",
    "ColorInput",
    "DateInput",
    "DateTimeInput",
    "DateTimeLocalInput",
    "EmailInput",
    "FileInput",
    "HiddenInput",
    "ListWidget",
    "MonthInput",
    "NumberInput",
    "Option",
...(truncado)

===== ./venv/lib/python3.13/site-packages/wtforms/widgets/core.py =====
from markupsafe import escape
from markupsafe import Markup
__all__ = (
    "CheckboxInput",
    "ColorInput",
    "DateInput",
    "DateTimeInput",
    "DateTimeLocalInput",
    "EmailInput",
    "FileInput",
    "HiddenInput",
    "ListWidget",
    "MonthInput",
    "NumberInput",
    "Option",
    "PasswordInput",
    "RadioInput",
    "RangeInput",
    "SearchInput",
    "Select",
    "SubmitInput",
    "TableWidget",
    "TextArea",
    "TextInput",
    "TelInput",
    "TimeInput",
    "URLInput",
    "WeekInput",
)
def clean_key(key):
    key = key.rstrip("_")
    if key.startswith("data_") or key.startswith("aria_"):
        key = key.replace("_", "-")
    return key
def html_params(**kwargs):
    """
    Generate HTML attribute syntax from inputted keyword arguments.
    The output value is sorted by the passed keys, to provide consistent output
    each time this function is called with the same parameters. Because of the
    frequent use of the normally reserved keywords `class` and `for`, suffixing
...(truncado)

===== ./venv/lib/python3.13/site-packages/wtforms/meta.py =====
from wtforms import i18n
from wtforms.utils import WebobInputWrapper
from wtforms.widgets.core import clean_key
class DefaultMeta:
    """
    This is the default Meta class which defines all the default values and
    therefore also the 'API' of the class Meta interface.
    """
    # -- Basic form primitives
    def bind_field(self, form, unbound_field, options):
        """
        bind_field allows potential customization of how fields are bound.
        The default implementation simply passes the options to
        :meth:`UnboundField.bind`.
        :param form: The form.
        :param unbound_field: The unbound field.
        :param options:
            A dictionary of options which are typically passed to the field.
        :return: A bound field
        """
        return unbound_field.bind(form=form, **options)
    def wrap_formdata(self, form, formdata):
        """
        wrap_formdata allows doing custom wrappers of WTForms formdata.
        The default implementation detects webob-style multidicts and wraps
        them, otherwise passes formdata back un-changed.
        :param form: The form.
        :param formdata: Form data.
        :return: A form-input wrapper compatible with WTForms.
        """
        if formdata is not None and not hasattr(formdata, "getlist"):
            if hasattr(formdata, "getall"):
                return WebobInputWrapper(formdata)
            else:
                raise TypeError(
                    "formdata should be a multidict-type wrapper that"
                    " supports the 'getlist' method"
                )
        return formdata
    def render_field(self, field, render_kw):
...(truncado)

===== ./venv/lib/python3.13/site-packages/psycopg2/_json.py =====
"""Implementation of the JSON adaptation objects
This module exists to avoid a circular import problem: pyscopg2.extras depends
on psycopg2.extension, so I can't create the default JSON typecasters in
extensions importing register_json from extras.
"""
import json
from psycopg2._psycopg import ISQLQuote, QuotedString
from psycopg2._psycopg import new_type, new_array_type, register_type
JSON_OID = 114
JSONARRAY_OID = 199
JSONB_OID = 3802
JSONBARRAY_OID = 3807
class Json:
    """
    An `~psycopg2.extensions.ISQLQuote` wrapper to adapt a Python object to
    :sql:`json` data type.
    `!Json` can be used to wrap any object supported by the provided *dumps*
    function. If none is provided, the standard :py:func:`json.dumps()` is
    used.
    """
    def __init__(self, adapted, dumps=None):
        self.adapted = adapted
        self._conn = None
        self._dumps = dumps or json.dumps
    def __conform__(self, proto):
        if proto is ISQLQuote:
            return self
    def dumps(self, obj):
        """Serialize *obj* in JSON format.
        The default is to call `!json.dumps()` or the *dumps* function
        provided in the constructor. You can override this method to create a
        customized JSON wrapper.
        """
        return self._dumps(obj)
    def prepare(self, conn):
        self._conn = conn
    def getquoted(self):
        s = self.dumps(self.adapted)
        qs = QuotedString(s)
        if self._conn is not None:
...(truncado)

===== ./venv/lib/python3.13/site-packages/psycopg2/extras.py =====
"""Miscellaneous goodies for psycopg2
This module is a generic place used to hold little helper functions
and classes until a better place in the distribution is found.
"""
import os as _os
import time as _time
import re as _re
from collections import namedtuple, OrderedDict
import logging as _logging
import psycopg2
from psycopg2 import extensions as _ext
from .extensions import cursor as _cursor
from .extensions import connection as _connection
from .extensions import adapt as _A, quote_ident
from functools import lru_cache
from psycopg2._psycopg import (                             # noqa
    REPLICATION_PHYSICAL, REPLICATION_LOGICAL,
    ReplicationConnection as _replicationConnection,
    ReplicationCursor as _replicationCursor,
    ReplicationMessage)
from psycopg2._json import (                                # noqa
    json, Json, register_json, register_default_json, register_default_jsonb)
from psycopg2._range import (                               # noqa
    Range, NumericRange, DateRange, DateTimeRange, DateTimeTZRange,
    register_range, RangeAdapter, RangeCaster)
from psycopg2._ipaddress import register_ipaddress          # noqa
class DictCursorBase(_cursor):
    """Base class for all dict-like cursors."""
    def __init__(self, *args, **kwargs):
        if 'row_factory' in kwargs:
            row_factory = kwargs['row_factory']
            del kwargs['row_factory']
        else:
            raise NotImplementedError(
                "DictCursorBase can't be instantiated without a row factory.")
        super().__init__(*args, **kwargs)
        self._query_executed = False
        self._prefetch = False
        self.row_factory = row_factory
    def fetchone(self):
...(truncado)

===== ./venv/lib/python3.13/site-packages/psycopg2/errorcodes.py =====
"""Error codes for PostgreSQL
This module contains symbolic names for all PostgreSQL error codes.
"""
def lookup(code, _cache={}):
    """Lookup an error code or class code and return its symbolic name.
    Raise `KeyError` if the code is not found.
    """
    if _cache:
        return _cache[code]
    # Generate the lookup map at first usage.
    tmp = {}
    for k, v in globals().items():
        if isinstance(v, str) and len(v) in (2, 5):
            # Strip trailing underscore used to disambiguate duplicate values
            tmp[v] = k.rstrip("_")
    assert tmp
    # Atomic update, to avoid race condition on import (bug #382)
    _cache.update(tmp)
    return _cache[code]
CLASS_SUCCESSFUL_COMPLETION = '00'
CLASS_WARNING = '01'
CLASS_NO_DATA = '02'
CLASS_SQL_STATEMENT_NOT_YET_COMPLETE = '03'
CLASS_CONNECTION_EXCEPTION = '08'
CLASS_TRIGGERED_ACTION_EXCEPTION = '09'
CLASS_FEATURE_NOT_SUPPORTED = '0A'
CLASS_INVALID_TRANSACTION_INITIATION = '0B'
CLASS_LOCATOR_EXCEPTION = '0F'
CLASS_INVALID_GRANTOR = '0L'
CLASS_INVALID_ROLE_SPECIFICATION = '0P'
CLASS_DIAGNOSTICS_EXCEPTION = '0Z'
CLASS_CASE_NOT_FOUND = '20'
CLASS_CARDINALITY_VIOLATION = '21'
CLASS_DATA_EXCEPTION = '22'
CLASS_INTEGRITY_CONSTRAINT_VIOLATION = '23'
CLASS_INVALID_CURSOR_STATE = '24'
CLASS_INVALID_TRANSACTION_STATE = '25'
CLASS_INVALID_SQL_STATEMENT_NAME = '26'
CLASS_TRIGGERED_DATA_CHANGE_VIOLATION = '27'
CLASS_INVALID_AUTHORIZATION_SPECIFICATION = '28'
...(truncado)

===== ./venv/lib/python3.13/site-packages/psycopg2/tz.py =====
"""tzinfo implementations for psycopg2
This module holds two different tzinfo implementations that can be used as
the 'tzinfo' argument to datetime constructors, directly passed to psycopg
functions or used to set the .tzinfo_factory attribute in cursors.
"""
import datetime
import time
ZERO = datetime.timedelta(0)
class FixedOffsetTimezone(datetime.tzinfo):
    """Fixed offset in minutes east from UTC.
    This is exactly the implementation__ found in Python 2.3.x documentation,
    with a small change to the `!__init__()` method to allow for pickling
    and a default name in the form ``sHH:MM`` (``s`` is the sign.).
    The implementation also caches instances. During creation, if a
    FixedOffsetTimezone instance has previously been created with the same
    offset and name that instance will be returned. This saves memory and
    improves comparability.
    .. versionchanged:: 2.9
        The constructor can take either a timedelta or a number of minutes of
        offset. Previously only minutes were supported.
    .. __: https://docs.python.org/library/datetime.html
    """
    _name = None
    _offset = ZERO
    _cache = {}
    def __init__(self, offset=None, name=None):
        if offset is not None:
            if not isinstance(offset, datetime.timedelta):
                offset = datetime.timedelta(minutes=offset)
            self._offset = offset
        if name is not None:
            self._name = name
    def __new__(cls, offset=None, name=None):
        """Return a suitable instance created earlier if it exists
        """
        key = (offset, name)
        try:
            return cls._cache[key]
        except KeyError:
            tz = super().__new__(cls, offset, name)
...(truncado)

===== ./venv/lib/python3.13/site-packages/psycopg2/_range.py =====
"""Implementation of the Range type and adaptation
"""
import re
from psycopg2._psycopg import ProgrammingError, InterfaceError
from psycopg2.extensions import ISQLQuote, adapt, register_adapter
from psycopg2.extensions import new_type, new_array_type, register_type
class Range:
    """Python representation for a PostgreSQL |range|_ type.
    :param lower: lower bound for the range. `!None` means unbound
    :param upper: upper bound for the range. `!None` means unbound
    :param bounds: one of the literal strings ``()``, ``[)``, ``(]``, ``[]``,
        representing whether the lower or upper bounds are included
    :param empty: if `!True`, the range is empty
    """
    __slots__ = ('_lower', '_upper', '_bounds')
    def __init__(self, lower=None, upper=None, bounds='[)', empty=False):
        if not empty:
            if bounds not in ('[)', '(]', '()', '[]'):
                raise ValueError(f"bound flags not valid: {bounds!r}")
            self._lower = lower
            self._upper = upper
            self._bounds = bounds
        else:
            self._lower = self._upper = self._bounds = None
    def __repr__(self):
        if self._bounds is None:
            return f"{self.__class__.__name__}(empty=True)"
        else:
            return "{}({!r}, {!r}, {!r})".format(self.__class__.__name__,
                self._lower, self._upper, self._bounds)
    def __str__(self):
        if self._bounds is None:
            return 'empty'
        items = [
            self._bounds[0],
            str(self._lower),
            ', ',
            str(self._upper),
            self._bounds[1]
        ]
...(truncado)

===== ./venv/lib/python3.13/site-packages/psycopg2/_ipaddress.py =====
"""Implementation of the ipaddres-based network types adaptation
"""
from psycopg2.extensions import (
    new_type, new_array_type, register_type, register_adapter, QuotedString)
ipaddress = None
_casters = None
def register_ipaddress(conn_or_curs=None):
    """
    Register conversion support between `ipaddress` objects and `network types`__.
    :param conn_or_curs: the scope where to register the type casters.
        If `!None` register them globally.
    After the function is called, PostgreSQL :sql:`inet` values will be
    converted into `~ipaddress.IPv4Interface` or `~ipaddress.IPv6Interface`
    objects, :sql:`cidr` values into into `~ipaddress.IPv4Network` or
    `~ipaddress.IPv6Network`.
    .. __: https://www.postgresql.org/docs/current/static/datatype-net-types.html
    """
    global ipaddress
    import ipaddress
    global _casters
    if _casters is None:
        _casters = _make_casters()
    for c in _casters:
        register_type(c, conn_or_curs)
    for t in [ipaddress.IPv4Interface, ipaddress.IPv6Interface,
              ipaddress.IPv4Network, ipaddress.IPv6Network]:
        register_adapter(t, adapt_ipaddress)
def _make_casters():
    inet = new_type((869,), 'INET', cast_interface)
    ainet = new_array_type((1041,), 'INET[]', inet)
    cidr = new_type((650,), 'CIDR', cast_network)
    acidr = new_array_type((651,), 'CIDR[]', cidr)
    return [inet, ainet, cidr, acidr]
def cast_interface(s, cur=None):
    if s is None:
        return None
    # Py2 version force the use of unicode. meh.
    return ipaddress.ip_interface(str(s))
def cast_network(s, cur=None):
    if s is None:
...(truncado)

===== ./venv/lib/python3.13/site-packages/psycopg2/__init__.py =====
"""A Python driver for PostgreSQL
psycopg is a PostgreSQL_ database adapter for the Python_ programming
language. This is version 2, a complete rewrite of the original code to
provide new-style classes for connection and cursor objects and other sweet
candies. Like the original, psycopg 2 was written with the aim of being very
small and fast, and stable as a rock.
Homepage: https://psycopg.org/
.. _PostgreSQL: https://www.postgresql.org/
.. _Python: https://www.python.org/
:Groups:
  * `Connections creation`: connect
  * `Value objects constructors`: Binary, Date, DateFromTicks, Time,
    TimeFromTicks, Timestamp, TimestampFromTicks
"""
from psycopg2._psycopg import (                     # noqa
    BINARY, NUMBER, STRING, DATETIME, ROWID,
    Binary, Date, Time, Timestamp,
    DateFromTicks, TimeFromTicks, TimestampFromTicks,
    Error, Warning, DataError, DatabaseError, ProgrammingError, IntegrityError,
    InterfaceError, InternalError, NotSupportedError, OperationalError,
    _connect, apilevel, threadsafety, paramstyle,
    __version__, __libpq_version__,
)
from psycopg2 import extensions as _ext
_ext.register_adapter(tuple, _ext.SQL_IN)
_ext.register_adapter(type(None), _ext.NoneAdapter)
from decimal import Decimal                         # noqa
from psycopg2._psycopg import Decimal as Adapter    # noqa
_ext.register_adapter(Decimal, Adapter)
del Decimal, Adapter
def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
    """
    Create a new database connection.
    The connection parameters can be specified as a string:
        conn = psycopg2.connect("dbname=test user=postgres password=secret")
    or using a set of keyword arguments:
        conn = psycopg2.connect(database="test", user="postgres", password="secret")
    Or as a mix of both. The basic connection parameters are:
    - *dbname*: the database name
    - *database*: the database name (only as keyword argument)
...(truncado)

===== ./venv/lib/python3.13/site-packages/psycopg2/extensions.py =====
"""psycopg extensions to the DBAPI-2.0
This module holds all the extensions to the DBAPI-2.0 provided by psycopg.
- `connection` -- the new-type inheritable connection class
- `cursor` -- the new-type inheritable cursor class
- `lobject` -- the new-type inheritable large object class
- `adapt()` -- exposes the PEP-246_ compatible adapting mechanism used
  by psycopg to adapt Python types to PostgreSQL ones
.. _PEP-246: https://www.python.org/dev/peps/pep-0246/
"""
import re as _re
from psycopg2._psycopg import (                             # noqa
    BINARYARRAY, BOOLEAN, BOOLEANARRAY, BYTES, BYTESARRAY, DATE, DATEARRAY,
    DATETIMEARRAY, DECIMAL, DECIMALARRAY, FLOAT, FLOATARRAY, INTEGER,
    INTEGERARRAY, INTERVAL, INTERVALARRAY, LONGINTEGER, LONGINTEGERARRAY,
    ROWIDARRAY, STRINGARRAY, TIME, TIMEARRAY, UNICODE, UNICODEARRAY,
    AsIs, Binary, Boolean, Float, Int, QuotedString, )
from psycopg2._psycopg import (                         # noqa
    PYDATE, PYDATETIME, PYDATETIMETZ, PYINTERVAL, PYTIME, PYDATEARRAY,
    PYDATETIMEARRAY, PYDATETIMETZARRAY, PYINTERVALARRAY, PYTIMEARRAY,
    DateFromPy, TimeFromPy, TimestampFromPy, IntervalFromPy, )
from psycopg2._psycopg import (                             # noqa
    adapt, adapters, encodings, connection, cursor,
    lobject, Xid, libpq_version, parse_dsn, quote_ident,
    string_types, binary_types, new_type, new_array_type, register_type,
    ISQLQuote, Notify, Diagnostics, Column, ConnectionInfo,
    QueryCanceledError, TransactionRollbackError,
    set_wait_callback, get_wait_callback, encrypt_password, )
"""Isolation level values."""
ISOLATION_LEVEL_AUTOCOMMIT = 0
ISOLATION_LEVEL_READ_UNCOMMITTED = 4
ISOLATION_LEVEL_READ_COMMITTED = 1
ISOLATION_LEVEL_REPEATABLE_READ = 2
ISOLATION_LEVEL_SERIALIZABLE = 3
ISOLATION_LEVEL_DEFAULT = None
"""psycopg connection status values."""
STATUS_SETUP = 0
STATUS_READY = 1
STATUS_BEGIN = 2
STATUS_SYNC = 3  # currently unused
STATUS_ASYNC = 4  # currently unused
...(truncado)

===== ./venv/lib/python3.13/site-packages/psycopg2/errors.py =====
"""Error classes for PostgreSQL error codes
"""
def lookup(code):
    """Lookup an error code and return its exception class.
    Raise `!KeyError` if the code is not found.
    """
    from psycopg2._psycopg import sqlstate_errors   # avoid circular import
    return sqlstate_errors[code]
...(truncado)

===== ./venv/lib/python3.13/site-packages/psycopg2/sql.py =====
"""SQL composition utility module
"""
import string
from psycopg2 import extensions as ext
_formatter = string.Formatter()
class Composable:
    """
    Abstract base class for objects that can be used to compose an SQL string.
    `!Composable` objects can be passed directly to `~cursor.execute()`,
    `~cursor.executemany()`, `~cursor.copy_expert()` in place of the query
    string.
    `!Composable` objects can be joined using the ``+`` operator: the result
    will be a `Composed` instance containing the objects joined. The operator
    ``*`` is also supported with an integer argument: the result is a
    `!Composed` instance containing the left argument repeated as many times as
    requested.
    """
    def __init__(self, wrapped):
        self._wrapped = wrapped
    def __repr__(self):
        return f"{self.__class__.__name__}({self._wrapped!r})"
    def as_string(self, context):
        """
        Return the string value of the object.
        :param context: the context to evaluate the string into.
        :type context: `connection` or `cursor`
        The method is automatically invoked by `~cursor.execute()`,
        `~cursor.executemany()`, `~cursor.copy_expert()` if a `!Composable` is
        passed instead of the query string.
        """
        raise NotImplementedError
    def __add__(self, other):
        if isinstance(other, Composed):
            return Composed([self]) + other
        if isinstance(other, Composable):
            return Composed([self]) + Composed([other])
        else:
            return NotImplemented
    def __mul__(self, n):
        return Composed([self] * n)
...(truncado)

===== ./venv/lib/python3.13/site-packages/psycopg2/pool.py =====
"""Connection pooling for psycopg2
This module implements thread-safe (and not) connection pools.
"""
import psycopg2
from psycopg2 import extensions as _ext
class PoolError(psycopg2.Error):
    pass
class AbstractConnectionPool:
    """Generic key-based pooling code."""
    def __init__(self, minconn, maxconn, *args, **kwargs):
        """Initialize the connection pool.
        New 'minconn' connections are created immediately calling 'connfunc'
        with given parameters. The connection pool will support a maximum of
        about 'maxconn' connections.
        """
        self.minconn = int(minconn)
        self.maxconn = int(maxconn)
        self.closed = False
        self._args = args
        self._kwargs = kwargs
        self._pool = []
        self._used = {}
        self._rused = {}    # id(conn) -> key map
        self._keys = 0
        for i in range(self.minconn):
            self._connect()
    def _connect(self, key=None):
        """Create a new connection and assign it to 'key' if not None."""
        conn = psycopg2.connect(*self._args, **self._kwargs)
        if key is not None:
            self._used[key] = conn
            self._rused[id(conn)] = key
        else:
            self._pool.append(conn)
        return conn
    def _getkey(self):
        """Return a new unique key."""
        self._keys += 1
        return self._keys
    def _getconn(self, key=None):
...(truncado)

===== ./venv/lib/python3.13/site-packages/itsdangerous/_json.py =====
from __future__ import annotations
import json as _json
import typing as t
class _CompactJSON:
    """Wrapper around json module that strips whitespace."""
    @staticmethod
    def loads(payload: str | bytes) -> t.Any:
        return _json.loads(payload)
    @staticmethod
    def dumps(obj: t.Any, **kwargs: t.Any) -> str:
        kwargs.setdefault("ensure_ascii", False)
        kwargs.setdefault("separators", (",", ":"))
        return _json.dumps(obj, **kwargs)
...(truncado)

===== ./venv/lib/python3.13/site-packages/itsdangerous/timed.py =====
from __future__ import annotations
import collections.abc as cabc
import time
import typing as t
from datetime import datetime
from datetime import timezone
from .encoding import base64_decode
from .encoding import base64_encode
from .encoding import bytes_to_int
from .encoding import int_to_bytes
from .encoding import want_bytes
from .exc import BadSignature
from .exc import BadTimeSignature
from .exc import SignatureExpired
from .serializer import _TSerialized
from .serializer import Serializer
from .signer import Signer
class TimestampSigner(Signer):
    """Works like the regular :class:`.Signer` but also records the time
    of the signing and can be used to expire signatures. The
    :meth:`unsign` method can raise :exc:`.SignatureExpired` if the
    unsigning failed because the signature is expired.
    """
    def get_timestamp(self) -> int:
        """Returns the current timestamp. The function must return an
        integer.
        """
        return int(time.time())
    def timestamp_to_datetime(self, ts: int) -> datetime:
        """Convert the timestamp from :meth:`get_timestamp` into an
        aware :class`datetime.datetime` in UTC.
        .. versionchanged:: 2.0
            The timestamp is returned as a timezone-aware ``datetime``
            in UTC rather than a naive ``datetime`` assumed to be UTC.
        """
        return datetime.fromtimestamp(ts, tz=timezone.utc)
    def sign(self, value: str | bytes) -> bytes:
        """Signs the given string and also attaches time information."""
        value = want_bytes(value)
        timestamp = base64_encode(int_to_bytes(self.get_timestamp()))
...(truncado)

===== ./venv/lib/python3.13/site-packages/itsdangerous/encoding.py =====
from __future__ import annotations
import base64
import string
import struct
import typing as t
from .exc import BadData
def want_bytes(
    s: str | bytes, encoding: str = "utf-8", errors: str = "strict"
) -> bytes:
    if isinstance(s, str):
        s = s.encode(encoding, errors)
    return s
def base64_encode(string: str | bytes) -> bytes:
    """Base64 encode a string of bytes or text. The resulting bytes are
    safe to use in URLs.
    """
    string = want_bytes(string)
    return base64.urlsafe_b64encode(string).rstrip(b"=")
def base64_decode(string: str | bytes) -> bytes:
    """Base64 decode a URL-safe string of bytes or text. The result is
    bytes.
    """
    string = want_bytes(string, encoding="ascii", errors="ignore")
    string += b"=" * (-len(string) % 4)
    try:
        return base64.urlsafe_b64decode(string)
    except (TypeError, ValueError) as e:
        raise BadData("Invalid base64-encoded data") from e
_base64_alphabet = f"{string.ascii_letters}{string.digits}-_=".encode("ascii")
_int64_struct = struct.Struct(">Q")
_int_to_bytes = _int64_struct.pack
_bytes_to_int = t.cast("t.Callable[[bytes], tuple[int]]", _int64_struct.unpack)
def int_to_bytes(num: int) -> bytes:
    return _int_to_bytes(num).lstrip(b"\x00")
def bytes_to_int(bytestr: bytes) -> int:
    return _bytes_to_int(bytestr.rjust(8, b"\x00"))[0]
...(truncado)

===== ./venv/lib/python3.13/site-packages/itsdangerous/__init__.py =====
from __future__ import annotations
import typing as t
from .encoding import base64_decode as base64_decode
from .encoding import base64_encode as base64_encode
from .encoding import want_bytes as want_bytes
from .exc import BadData as BadData
from .exc import BadHeader as BadHeader
from .exc import BadPayload as BadPayload
from .exc import BadSignature as BadSignature
from .exc import BadTimeSignature as BadTimeSignature
from .exc import SignatureExpired as SignatureExpired
from .serializer import Serializer as Serializer
from .signer import HMACAlgorithm as HMACAlgorithm
from .signer import NoneAlgorithm as NoneAlgorithm
from .signer import Signer as Signer
from .timed import TimedSerializer as TimedSerializer
from .timed import TimestampSigner as TimestampSigner
from .url_safe import URLSafeSerializer as URLSafeSerializer
from .url_safe import URLSafeTimedSerializer as URLSafeTimedSerializer
def __getattr__(name: str) -> t.Any:
    if name == "__version__":
        import importlib.metadata
        import warnings
        warnings.warn(
            "The '__version__' attribute is deprecated and will be removed in"
            " ItsDangerous 2.3. Use feature detection or"
            " 'importlib.metadata.version(\"itsdangerous\")' instead.",
            DeprecationWarning,
            stacklevel=2,
        )
        return importlib.metadata.version("itsdangerous")
    raise AttributeError(name)
...(truncado)

===== ./venv/lib/python3.13/site-packages/itsdangerous/url_safe.py =====
from __future__ import annotations
import typing as t
import zlib
from ._json import _CompactJSON
from .encoding import base64_decode
from .encoding import base64_encode
from .exc import BadPayload
from .serializer import _PDataSerializer
from .serializer import Serializer
from .timed import TimedSerializer
class URLSafeSerializerMixin(Serializer[str]):
    """Mixed in with a regular serializer it will attempt to zlib
    compress the string to make it shorter if necessary. It will also
    base64 encode the string so that it can safely be placed in a URL.
    """
    default_serializer: _PDataSerializer[str] = _CompactJSON
    def load_payload(
        self,
        payload: bytes,
        *args: t.Any,
        serializer: t.Any | None = None,
        **kwargs: t.Any,
    ) -> t.Any:
        decompress = False
        if payload.startswith(b"."):
            payload = payload[1:]
            decompress = True
        try:
            json = base64_decode(payload)
        except Exception as e:
            raise BadPayload(
                "Could not base64 decode the payload because of an exception",
                original_error=e,
            ) from e
        if decompress:
            try:
                json = zlib.decompress(json)
            except Exception as e:
                raise BadPayload(
                    "Could not zlib decompress the payload before decoding the payload",
...(truncado)

===== ./venv/lib/python3.13/site-packages/itsdangerous/exc.py =====
from __future__ import annotations
import typing as t
from datetime import datetime
class BadData(Exception):
    """Raised if bad data of any sort was encountered. This is the base
    for all exceptions that ItsDangerous defines.
    .. versionadded:: 0.15
    """
    def __init__(self, message: str):
        super().__init__(message)
        self.message = message
    def __str__(self) -> str:
        return self.message
class BadSignature(BadData):
    """Raised if a signature does not match."""
    def __init__(self, message: str, payload: t.Any | None = None):
        super().__init__(message)
        #: The payload that failed the signature test. In some
        #: situations you might still want to inspect this, even if
        #: you know it was tampered with.
        #:
        #: .. versionadded:: 0.14
        self.payload: t.Any | None = payload
class BadTimeSignature(BadSignature):
    """Raised if a time-based signature is invalid. This is a subclass
    of :class:`BadSignature`.
    """
    def __init__(
        self,
        message: str,
        payload: t.Any | None = None,
        date_signed: datetime | None = None,
    ):
        super().__init__(message, payload)
        #: If the signature expired this exposes the date of when the
        #: signature was created. This can be helpful in order to
        #: tell the user how long a link has been gone stale.
        #:
        #: .. versionchanged:: 2.0
        #:     The datetime value is timezone-aware rather than naive.
...(truncado)

===== ./venv/lib/python3.13/site-packages/itsdangerous/serializer.py =====
from __future__ import annotations
import collections.abc as cabc
import json
import typing as t
from .encoding import want_bytes
from .exc import BadPayload
from .exc import BadSignature
from .signer import _make_keys_list
from .signer import Signer
if t.TYPE_CHECKING:
    import typing_extensions as te
    # This should be either be str or bytes. To avoid having to specify the
    # bound type, it falls back to a union if structural matching fails.
    _TSerialized = te.TypeVar(
        "_TSerialized", bound=t.Union[str, bytes], default=t.Union[str, bytes]
    )
else:
    # Still available at runtime on Python < 3.13, but without the default.
    _TSerialized = t.TypeVar("_TSerialized", bound=t.Union[str, bytes])
class _PDataSerializer(t.Protocol[_TSerialized]):
    def loads(self, payload: _TSerialized, /) -> t.Any: ...
    # A signature with additional arguments is not handled correctly by type
    # checkers right now, so an overload is used below for serializers that
    # don't match this strict protocol.
    def dumps(self, obj: t.Any, /) -> _TSerialized: ...
def is_text_serializer(
    serializer: _PDataSerializer[t.Any],
) -> te.TypeGuard[_PDataSerializer[str]]:
    """Checks whether a serializer generates text or binary."""
    return isinstance(serializer.dumps({}), str)
class Serializer(t.Generic[_TSerialized]):
    """A serializer wraps a :class:`~itsdangerous.signer.Signer` to
    enable serializing and securely signing data other than bytes. It
    can unsign to verify that the data hasn't been changed.
    The serializer provides :meth:`dumps` and :meth:`loads`, similar to
    :mod:`json`, and by default uses :mod:`json` internally to serialize
    the data to bytes.
    The secret key should be a random string of ``bytes`` and should not
    be saved to code or version control. Different salts should be used
    to distinguish signing in different contexts. See :doc:`/concepts`
...(truncado)

===== ./venv/lib/python3.13/site-packages/itsdangerous/signer.py =====
from __future__ import annotations
import collections.abc as cabc
import hashlib
import hmac
import typing as t
from .encoding import _base64_alphabet
from .encoding import base64_decode
from .encoding import base64_encode
from .encoding import want_bytes
from .exc import BadSignature
class SigningAlgorithm:
    """Subclasses must implement :meth:`get_signature` to provide
    signature generation functionality.
    """
    def get_signature(self, key: bytes, value: bytes) -> bytes:
        """Returns the signature for the given key and value."""
        raise NotImplementedError()
    def verify_signature(self, key: bytes, value: bytes, sig: bytes) -> bool:
        """Verifies the given signature matches the expected
        signature.
        """
        return hmac.compare_digest(sig, self.get_signature(key, value))
class NoneAlgorithm(SigningAlgorithm):
    """Provides an algorithm that does not perform any signing and
    returns an empty signature.
    """
    def get_signature(self, key: bytes, value: bytes) -> bytes:
        return b""
def _lazy_sha1(string: bytes = b"") -> t.Any:
    """Don't access ``hashlib.sha1`` until runtime. FIPS builds may not include
    SHA-1, in which case the import and use as a default would fail before the
    developer can configure something else.
    """
    return hashlib.sha1(string)
class HMACAlgorithm(SigningAlgorithm):
    """Provides signature generation using HMACs."""
    #: The digest method to use with the MAC algorithm. This defaults to
    #: SHA1, but can be changed to any other function in the hashlib
    #: module.
    default_digest_method: t.Any = staticmethod(_lazy_sha1)
...(truncado)

===== ./venv/lib/python3.13/site-packages/typing_extensions.py =====
import abc
import builtins
import collections
import collections.abc
import contextlib
import enum
import functools
import inspect
import io
import keyword
import operator
import sys
import types as _types
import typing
import warnings
if sys.version_info >= (3, 14):
    import annotationlib
__all__ = [
    # Super-special typing primitives.
    'Any',
    'ClassVar',
    'Concatenate',
    'Final',
    'LiteralString',
    'ParamSpec',
    'ParamSpecArgs',
    'ParamSpecKwargs',
    'Self',
    'Type',
    'TypeVar',
    'TypeVarTuple',
    'Unpack',
    # ABCs (from collections.abc).
    'Awaitable',
    'AsyncIterator',
    'AsyncIterable',
    'Coroutine',
    'AsyncGenerator',
    'AsyncContextManager',
    'Buffer',
...(truncado)
