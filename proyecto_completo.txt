### ESTRUCTURA DE CARPETAS ###
.
‚îú‚îÄ‚îÄ .env
‚îú‚îÄ‚îÄ .gitignore
‚îú‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ app
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ __init__.py
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ api
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ __init__.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ contracts.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ search.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ stats.py
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ app.py
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ models
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ __init__.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ contrato.py
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ routes.py
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ services
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ __init__.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ aggregation_service.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ filter_service.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ search_service.py
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ static
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ css
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ style.css
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ img
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ js
‚îÇ¬†¬† ‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ app.js
‚îÇ¬†¬† ‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ modules
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ templates
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ index.html
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ utils
‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ __init__.py
‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ activity_tracker.py
‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ decorators.py
‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ logging_config.py
‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ metrics.py
‚îú‚îÄ‚îÄ config
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ __init__.py
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ config.py
‚îú‚îÄ‚îÄ fix_sql.txt
‚îú‚îÄ‚îÄ logs
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ access.log
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ error.log
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ search.log
‚îú‚îÄ‚îÄ migrations
‚îú‚îÄ‚îÄ proyecto_completo.txt
‚îú‚îÄ‚îÄ requirements
‚îú‚îÄ‚îÄ requirements.txt
‚îú‚îÄ‚îÄ run.py
‚îú‚îÄ‚îÄ scripts
‚îú‚îÄ‚îÄ test_connection.py
‚îú‚îÄ‚îÄ test_connection_do.py
‚îú‚îÄ‚îÄ test_new_structure.py
‚îú‚îÄ‚îÄ utils
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ tests
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ .gitkeep
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ __init__.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ fixtures
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ integration
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ __init__.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ unit
‚îÇ¬†¬† ‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ __init__.py
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ validators.py
‚îî‚îÄ‚îÄ view_metrics.py

22 directories, 42 files


### CONTENIDO DE ARCHIVOS ###

===============================
üìÅ Archivo: ./run.py
===============================
# run.py (en la ra√≠z del proyecto, NO dentro de app/)

import os
from dotenv import load_dotenv

# Cargar variables de entorno ANTES de importar la app
load_dotenv()

from app import create_app, db
from app.models import Contrato
from sqlalchemy import text, func

# Obtener configuraci√≥n del entorno
config_name = os.environ.get('FLASK_ENV', 'development')
app = create_app(config_name)

def create_indexes():
    """Crea los √≠ndices necesarios para optimizar las b√∫squedas"""
    indices_sql = """
    -- √çndices para mejorar performance
    CREATE INDEX IF NOT EXISTS idx_contratos_importe 
        ON contratos.contratos(importe DESC NULLS LAST);
    
    CREATE INDEX IF NOT EXISTS idx_contratos_proveedor 
        ON contratos.contratos(proveedor_contratista);
    
    CREATE INDEX IF NOT EXISTS idx_contratos_rfc 
        ON contratos.contratos(rfc);
    
    CREATE INDEX IF NOT EXISTS idx_contratos_siglas_inst 
        ON contratos.contratos(siglas_institucion);
    
    CREATE INDEX IF NOT EXISTS idx_contratos_anio 
        ON contratos.contratos(anio_fuente);
    
    CREATE INDEX IF NOT EXISTS idx_contratos_tipo_contratacion
        ON contratos.contratos(tipo_contratacion);
    
    CREATE INDEX IF NOT EXISTS idx_contratos_tipo_procedimiento
        ON contratos.contratos(tipo_procedimiento);
    
    -- √çndices para b√∫squeda de texto
    CREATE INDEX IF NOT EXISTS idx_contratos_titulo_gin
        ON contratos.contratos USING gin(to_tsvector('spanish', titulo_contrato));
    
    CREATE INDEX IF NOT EXISTS idx_contratos_descripcion_gin
        ON contratos.contratos USING gin(to_tsvector('spanish', descripcion_contrato));
    """
    
    try:
        db.session.execute(text(indices_sql))
        db.session.commit()
        print("‚úÖ √çndices verificados/creados")
        return True
    except Exception as e:
        print(f"‚ö†Ô∏è No se pudieron crear algunos √≠ndices: {e}")
        db.session.rollback()
        return False

if __name__ == '__main__':
    with app.app_context():
        # Verificar conexi√≥n a la base de datos
        try:
            db.session.execute(text('SELECT 1'))
            print("‚úÖ Conexi√≥n a la base de datos exitosa")
            
            # Contar registros
            count = db.session.query(func.count(Contrato.codigo_contrato)).scalar()
            print(f"üìä Total de contratos en la BD: {count:,}")
            
            
        except Exception as e:
            print(f"‚ùå Error de conexi√≥n a la BD: {e}")
            exit(1)
    
    # Ejecutar aplicaci√≥n
    port = int(os.environ.get('PORT', 5000))
    debug = config_name == 'development'
    
    app.run(
        debug=debug,
        host='0.0.0.0',
        port=port
    )


===============================
üìÅ Archivo: ./app/__init__.py
===============================
# app/__init__.py
import os
import logging
from pathlib import Path
from flask import Flask, g, request
from flask_sqlalchemy import SQLAlchemy
from flask_migrate import Migrate
from config import config
import time
import json
from datetime import datetime
import hashlib

# Inicializar extensiones
db = SQLAlchemy()
migrate = Migrate()

def setup_logging(app):
    """Configurar el sistema de logging"""
    
    # Crear directorio de logs si no existe
    log_dir = Path('logs')
    log_dir.mkdir(exist_ok=True)
    
    # Configuraci√≥n del formato de logs
    class JSONFormatter(logging.Formatter):
        def format(self, record):
            log_obj = {
                'timestamp': datetime.utcnow().isoformat(),
                'level': record.levelname,
                'message': record.getMessage(),
                'module': record.module,
                'function': record.funcName
            }
            if hasattr(record, 'extra_fields'):
                log_obj.update(record.extra_fields)
            return json.dumps(log_obj)
    
    # Configurar handlers para diferentes tipos de logs
    from logging.handlers import RotatingFileHandler
    
    # Handler para logs generales
    if not app.debug:
        file_handler = RotatingFileHandler(
            'logs/app.log',
            maxBytes=10240000,  # 10MB
            backupCount=10
        )
        file_handler.setFormatter(JSONFormatter())
        file_handler.setLevel(logging.INFO)
        app.logger.addHandler(file_handler)
        app.logger.setLevel(logging.INFO)
        app.logger.info('Aplicaci√≥n iniciada')
    
    # Logger para accesos
    access_logger = logging.getLogger('access')
    access_handler = RotatingFileHandler(
        'logs/access.log',
        maxBytes=10240000,
        backupCount=10
    )
    access_handler.setFormatter(JSONFormatter())
    access_logger.addHandler(access_handler)
    access_logger.setLevel(logging.INFO)
    
    # Logger para b√∫squedas
    search_logger = logging.getLogger('search')
    search_handler = RotatingFileHandler(
        'logs/search.log',
        maxBytes=10240000,
        backupCount=10
    )
    search_handler.setFormatter(JSONFormatter())
    search_logger.addHandler(search_handler)
    search_logger.setLevel(logging.INFO)
    
    # Logger para errores
    error_logger = logging.getLogger('error')
    error_handler = RotatingFileHandler(
        'logs/error.log',
        maxBytes=10240000,
        backupCount=10
    )
    error_handler.setFormatter(JSONFormatter())
    error_handler.setLevel(logging.ERROR)
    error_logger.addHandler(error_handler)
    
    return app

def log_request():
    """Log cada request"""
    g.start_time = time.time()
    
    # Crear fingerprint an√≥nimo del usuario
    user_agent = request.headers.get('User-Agent', '')
    ip = request.remote_addr
    user_fingerprint = hashlib.md5(f"{ip}{user_agent}".encode()).hexdigest()
    
    access_logger = logging.getLogger('access')
    
    # Informaci√≥n del request
    log_data = {
        'event': 'request_start',
        'method': request.method,
        'path': request.path,
        'endpoint': request.endpoint,
        'ip_hash': hashlib.md5(ip.encode()).hexdigest()[:8],
        'user_fingerprint': user_fingerprint,
        'user_agent': user_agent[:100]  # Limitar longitud
    }
    
    access_logger.info(
        f"Request: {request.method} {request.path}",
        extra={'extra_fields': log_data}
    )

def log_response(response):
    """Log cada response"""
    if hasattr(g, 'start_time'):
        elapsed = time.time() - g.start_time
        
        access_logger = logging.getLogger('access')
        
        log_data = {
            'event': 'request_complete',
            'method': request.method,
            'path': request.path,
            'status_code': response.status_code,
            'response_time': round(elapsed * 1000, 2)  # en ms
        }
        
        access_logger.info(
            f"Response: {response.status_code} in {elapsed:.3f}s",
            extra={'extra_fields': log_data}
        )
    
    return response

def log_search(search_params, results_count):
    """Log b√∫squedas realizadas"""
    search_logger = logging.getLogger('search')
    
    # Sanitizar par√°metros
    safe_params = {k: v for k, v in search_params.items() if v}
    
    log_data = {
        'event': 'search',
        'search_params': safe_params,
        'results_count': results_count,
        'has_filters': bool(any(k != 'q' for k in safe_params.keys()))
    }
    
    search_logger.info(
        f"Search: {safe_params.get('q', 'No query')} - {results_count} results",
        extra={'extra_fields': log_data}
    )

def create_app(config_name=None):
    """Factory para crear la aplicaci√≥n"""
    
    if config_name is None:
        config_name = os.environ.get('FLASK_ENV', 'development')
    
    app = Flask(__name__)
    
    # Cargar configuraci√≥n
    app.config.from_object(config[config_name])
    
    # Inicializar extensiones
    db.init_app(app)
    migrate.init_app(app, db)
    
    # Configurar logging
    setup_logging(app)
    
    # Registrar hooks para logging
    app.before_request(log_request)
    app.after_request(log_response)
    
    # ========== REGISTRAR BLUEPRINTS ==========
    
    # Blueprint principal (rutas de p√°ginas)
    from app.routes import main_bp
    app.register_blueprint(main_bp)
    
    # Blueprint de API de b√∫squeda - IMPORTANTE: con prefijo /api
    from app.api.search import search_bp
    app.register_blueprint(search_bp, url_prefix='/api')
    
    # ========== MANEJADORES DE ERRORES ==========
    
    @app.errorhandler(404)
    def not_found_error(error):
        error_logger = logging.getLogger('error')
        error_logger.error(f"404 Error: {request.url}")
        return {'error': 'Not found'}, 404
    
    @app.errorhandler(500)
    def internal_error(error):
        error_logger = logging.getLogger('error')
        error_logger.error(f"500 Error: {str(error)}", exc_info=True)
        db.session.rollback()
        return {'error': 'Internal server error'}, 500
    
    @app.errorhandler(400)
    def bad_request_error(error):
        error_logger = logging.getLogger('error')
        error_logger.error(f"400 Error: {request.url} - {str(error)}")
        return {'error': 'Bad request'}, 400
    
    # ========== VERIFICACI√ìN DE RUTAS (OPCIONAL - REMOVER EN PRODUCCI√ìN) ==========
    
    # Imprimir rutas registradas para debugging
    if app.config.get('DEBUG'):
        print("\n" + "="*50)
        print("üìç RUTAS REGISTRADAS:")
        print("="*50)
        for rule in app.url_map.iter_rules():
            methods = ','.join(sorted(rule.methods - {'OPTIONS', 'HEAD'}))
            if methods:  # Solo mostrar rutas con m√©todos
                print(f"  {methods:8s} {rule.rule:30s} -> {rule.endpoint}")
        print("="*50 + "\n")
    
    # ========== LOGS DE INICIO ==========
    
    app.logger.info(f'Aplicaci√≥n iniciada en modo {config_name}')
    
    # Mensaje de confirmaci√≥n en consola
    print(f"‚úÖ Aplicaci√≥n Flask iniciada")
    print(f"üìÅ Modo: {config_name}")
    print(f"üìÇ Logs guard√°ndose en: logs/")
    print(f"üîç Para ver m√©tricas ejecuta: python view_metrics.py")
    print(f"üåê API disponible en: /api/search (POST) y /api/aggregates (POST)")
    
    return app

# Funci√≥n helper para usar en routes
def track_search(func):
    """Decorador para rastrear b√∫squedas"""
    from functools import wraps
    
    @wraps(func)
    def decorated_function(*args, **kwargs):
        start_time = time.time()
        
        # Ejecutar la funci√≥n
        result = func(*args, **kwargs)
        
        # Log de la b√∫squeda
        execution_time = time.time() - start_time
        
        # Extraer par√°metros
        search_params = dict(request.args)
        
        # Contar resultados (ajusta seg√∫n tu implementaci√≥n)
        if hasattr(result, '__len__'):
            results_count = len(result)
        elif hasattr(result, 'total'):
            results_count = result.total
        else:
            results_count = 0
        
        # Log con tiempo de ejecuci√≥n
        search_params['execution_time_ms'] = round(execution_time * 1000, 2)
        log_search(search_params, results_count)
        
        return result
    
    return decorated_function


===============================
üìÅ Archivo: ./app/utils/metrics.py
===============================
# app/utils/metrics.py
from datetime import datetime, timedelta
from collections import Counter, defaultdict
import json
from pathlib import Path
import pandas as pd

class PlatformMetrics:
    """Analiza m√©tricas de uso de la plataforma"""
    
    @staticmethod
    def parse_logs(log_file, start_date=None, end_date=None):
        """Parsea archivo de logs y filtra por fecha"""
        logs = []
        
        with open(log_file, 'r') as f:
            for line in f:
                try:
                    log_entry = json.loads(line)
                    log_time = datetime.fromisoformat(log_entry['timestamp'])
                    
                    if start_date and log_time < start_date:
                        continue
                    if end_date and log_time > end_date:
                        continue
                        
                    logs.append(log_entry)
                except:
                    continue
                    
        return logs
    
    @staticmethod
    def get_usage_metrics(days=7):
        """Obtiene m√©tricas de uso de los √∫ltimos N d√≠as"""
        end_date = datetime.utcnow()
        start_date = end_date - timedelta(days=days)
        
        # Parsear logs de acceso
        access_logs = PlatformMetrics.parse_logs(
            'logs/access.log',
            start_date,
            end_date
        )
        
        # Parsear logs de b√∫squeda
        search_logs = PlatformMetrics.parse_logs(
            'logs/search.log',
            start_date,
            end_date
        )
        
        metrics = {
            'period': f'{days} d√≠as',
            'start_date': start_date.isoformat(),
            'end_date': end_date.isoformat(),
            'general': PlatformMetrics._calculate_general_metrics(access_logs),
            'searches': PlatformMetrics._calculate_search_metrics(search_logs),
            'performance': PlatformMetrics._calculate_performance_metrics(access_logs),
            'users': PlatformMetrics._calculate_user_metrics(access_logs),
            'content': PlatformMetrics._calculate_content_metrics(access_logs)
        }
        
        return metrics
    
    @staticmethod
    def _calculate_general_metrics(logs):
        """Calcula m√©tricas generales"""
        total_requests = len(logs)
        unique_users = len(set(l.get('user_fingerprint') for l in logs if l.get('user_fingerprint')))
        
        # Contador de endpoints m√°s visitados
        endpoints = Counter(l.get('endpoint') for l in logs if l.get('endpoint'))
        
        # An√°lisis por dispositivo
        devices = Counter(l.get('is_mobile') for l in logs)
        
        return {
            'total_requests': total_requests,
            'unique_users': unique_users,
            'avg_requests_per_user': round(total_requests / unique_users, 2) if unique_users > 0 else 0,
            'top_endpoints': dict(endpoints.most_common(10)),
            'mobile_percentage': round((devices.get(True, 0) / total_requests * 100), 2) if total_requests > 0 else 0
        }
    
    @staticmethod
    def _calculate_search_metrics(logs):
        """Calcula m√©tricas de b√∫squedas"""
        total_searches = len(logs)
        
        # B√∫squedas con filtros vs sin filtros
        filtered_searches = sum(1 for l in logs if l.get('has_filters'))
        
        # Promedio de resultados
        results_counts = [l.get('results_count', 0) for l in logs]
        avg_results = sum(results_counts) / len(results_counts) if results_counts else 0
        
        # B√∫squedas sin resultados
        no_results = sum(1 for count in results_counts if count == 0)
        
        # T√©rminos m√°s buscados (si hay campo 'q' en search_params)
        search_terms = []
        for log in logs:
            params = log.get('search_params', {})
            if params.get('q'):
                search_terms.append(params['q'].lower())
        
        top_terms = Counter(search_terms).most_common(20)
        
        return {
            'total_searches': total_searches,
            'filtered_searches': filtered_searches,
            'filter_usage_rate': round((filtered_searches / total_searches * 100), 2) if total_searches > 0 else 0,
            'avg_results_per_search': round(avg_results, 2),
            'no_results_searches': no_results,
            'no_results_rate': round((no_results / total_searches * 100), 2) if total_searches > 0 else 0,
            'top_search_terms': dict(top_terms)
        }
    
    @staticmethod
    def _calculate_performance_metrics(logs):
        """Calcula m√©tricas de rendimiento"""
        response_times = [l.get('response_time', 0) for l in logs if l.get('response_time')]
        
        if not response_times:
            return {}
            
        return {
            'avg_response_time_ms': round(sum(response_times) / len(response_times), 2),
            'median_response_time_ms': round(sorted(response_times)[len(response_times)//2], 2),
            'p95_response_time_ms': round(sorted(response_times)[int(len(response_times) * 0.95)], 2),
            'p99_response_time_ms': round(sorted(response_times)[int(len(response_times) * 0.99)], 2),
            'slow_requests_count': sum(1 for t in response_times if t > 1000),  # >1 segundo
        }
    
    @staticmethod
    def _calculate_user_metrics(logs):
        """Calcula m√©tricas de usuarios"""
        # Agrupar por usuario
        user_activity = defaultdict(list)
        for log in logs:
            if log.get('user_fingerprint'):
                user_activity[log['user_fingerprint']].append(log)
        
        # Calcular sesiones por usuario
        sessions_per_user = []
        for user_logs in user_activity.values():
            # Agrupar por sesi√≥n (requests con < 30 min de diferencia)
            sessions = 1
            user_logs.sort(key=lambda x: x['timestamp'])
            
            for i in range(1, len(user_logs)):
                time_diff = (datetime.fromisoformat(user_logs[i]['timestamp']) - 
                           datetime.fromisoformat(user_logs[i-1]['timestamp']))
                if time_diff.seconds > 1800:  # 30 minutos
                    sessions += 1
            
            sessions_per_user.append(sessions)
        
        # Navegadores y SO m√°s comunes
        browsers = Counter(l.get('browser') for l in logs if l.get('browser'))
        os_systems = Counter(l.get('os') for l in logs if l.get('os'))
        
        return {
            'total_unique_users': len(user_activity),
            'avg_sessions_per_user': round(sum(sessions_per_user) / len(sessions_per_user), 2) if sessions_per_user else 0,
            'returning_users': sum(1 for s in sessions_per_user if s > 1),
            'top_browsers': dict(browsers.most_common(5)),
            'top_os': dict(os_systems.most_common(5))
        }
    
    @staticmethod
    def _calculate_content_metrics(logs):
        """Calcula m√©tricas de contenido"""
        # Filtrar solo eventos de visualizaci√≥n de contratos
        contract_views = [l for l in logs if l.get('event') == 'contract_view']
        
        # Instituciones m√°s consultadas
        instituciones = Counter(l.get('institucion') for l in contract_views if l.get('institucion'))
        
        # Tipos de procedimiento m√°s vistos
        tipos = Counter(l.get('tipo_procedimiento') for l in contract_views if l.get('tipo_procedimiento'))
        
        return {
            'total_contract_views': len(contract_views),
            'unique_contracts_viewed': len(set(l.get('contract_id') for l in contract_views)),
            'top_instituciones': dict(instituciones.most_common(10)),
            'top_tipos_procedimiento': dict(tipos.most_common(5))
        }
    
    @staticmethod
    def generate_report(days=7, output_format='json'):
        """Genera reporte de m√©tricas"""
        metrics = PlatformMetrics.get_usage_metrics(days)
        
        if output_format == 'json':
            return json.dumps(metrics, indent=2, ensure_ascii=False)
        elif output_format == 'html':
            return PlatformMetrics._generate_html_report(metrics)
        else:
            return metrics



===============================
üìÅ Archivo: ./app/utils/logging_config.py
===============================
# app/utils/logging_config.py
import logging
import logging.handlers
import json
from datetime import datetime
from flask import request, g
from functools import wraps
import os
from pathlib import Path

class StructuredFormatter(logging.Formatter):
    """Formateador para logs estructurados en JSON"""
    def format(self, record):
        log_obj = {
            'timestamp': datetime.utcnow().isoformat(),
            'level': record.levelname,
            'logger': record.name,
            'message': record.getMessage(),
            'module': record.module,
            'function': record.funcName,
            'line': record.lineno
        }
        
        # Agregar campos extra si existen
        if hasattr(record, 'extra_fields'):
            log_obj.update(record.extra_fields)
            
        return json.dumps(log_obj, ensure_ascii=False)

def setup_logging(app):
    """Configurar el sistema de logging para la aplicaci√≥n"""
    
    # Crear directorio de logs si no existe
    log_dir = Path('logs')
    log_dir.mkdir(exist_ok=True)
    
    # Configurar logger principal
    app.logger.setLevel(logging.INFO)
    
    # Handler para archivo de logs general
    file_handler = logging.handlers.RotatingFileHandler(
        'logs/app.log',
        maxBytes=10485760,  # 10MB
        backupCount=10
    )
    file_handler.setFormatter(StructuredFormatter())
    app.logger.addHandler(file_handler)
    
    # Handler separado para logs de acceso/uso
    access_logger = logging.getLogger('access')
    access_handler = logging.handlers.RotatingFileHandler(
        'logs/access.log',
        maxBytes=10485760,
        backupCount=30  # Mantener m√°s hist√≥rico de acceso
    )
    access_handler.setFormatter(StructuredFormatter())
    access_logger.addHandler(access_handler)
    access_logger.setLevel(logging.INFO)
    
    # Handler para logs de b√∫squedas
    search_logger = logging.getLogger('search')
    search_handler = logging.handlers.RotatingFileHandler(
        'logs/search.log',
        maxBytes=10485760,
        backupCount=20
    )
    search_handler.setFormatter(StructuredFormatter())
    search_logger.addHandler(search_handler)
    search_logger.setLevel(logging.INFO)
    
    # Handler para logs de errores
    error_handler = logging.handlers.RotatingFileHandler(
        'logs/error.log',
        maxBytes=10485760,
        backupCount=10
    )
    error_handler.setLevel(logging.ERROR)
    error_handler.setFormatter(StructuredFormatter())
    app.logger.addHandler(error_handler)
    
    return app



===============================
üìÅ Archivo: ./app/utils/activity_tracker.py
===============================
# app/utils/activity_tracker.py
from flask import request, g, session
from datetime import datetime
import logging
import hashlib
from user_agents import parse
from functools import wraps
import time

access_logger = logging.getLogger('access')
search_logger = logging.getLogger('search')

class ActivityTracker:
    """Rastrea actividad de usuarios en la plataforma"""
    
    @staticmethod
    def get_user_fingerprint():
        """Genera un fingerprint √∫nico para el usuario (an√≥nimo)"""
        user_agent = request.headers.get('User-Agent', '')
        ip = request.remote_addr
        # Hash para anonimizar
        fingerprint = hashlib.md5(f"{ip}{user_agent}".encode()).hexdigest()
        return fingerprint
    
    @staticmethod
    def get_request_context():
        """Obtiene contexto de la petici√≥n actual"""
        user_agent = parse(request.headers.get('User-Agent', ''))
        
        return {
            'ip_hash': hashlib.md5(request.remote_addr.encode()).hexdigest()[:8],
            'method': request.method,
            'path': request.path,
            'endpoint': request.endpoint,
            'referrer': request.referrer,
            'browser': user_agent.browser.family,
            'browser_version': user_agent.browser.version_string,
            'os': user_agent.os.family,
            'device': user_agent.device.family,
            'is_mobile': user_agent.is_mobile,
            'is_bot': user_agent.is_bot,
            'session_id': session.get('session_id'),
            'user_fingerprint': ActivityTracker.get_user_fingerprint()
        }
    
    @staticmethod
    def log_request():
        """Log de cada request HTTP"""
        g.start_time = time.time()
        
        context = ActivityTracker.get_request_context()
        
        access_logger.info(
            f"Request iniciado",
            extra={'extra_fields': {
                'event': 'request_start',
                **context
            }}
        )
    
    @staticmethod
    def log_response(response):
        """Log de cada response HTTP"""
        if hasattr(g, 'start_time'):
            elapsed = time.time() - g.start_time
        else:
            elapsed = 0
            
        context = ActivityTracker.get_request_context()
        
        access_logger.info(
            f"Request completado",
            extra={'extra_fields': {
                'event': 'request_complete',
                'status_code': response.status_code,
                'response_time': round(elapsed * 1000, 2),  # en ms
                **context
            }}
        )
        
        return response
    
    @staticmethod
    def log_search(search_params, results_count, execution_time):
        """Log de b√∫squedas realizadas"""
        context = ActivityTracker.get_request_context()
        
        # Sanitizar par√°metros sensibles si los hay
        safe_params = {
            k: v for k, v in search_params.items() 
            if k not in ['password', 'token', 'api_key']
        }
        
        search_logger.info(
            f"B√∫squeda realizada",
            extra={'extra_fields': {
                'event': 'search',
                'search_params': safe_params,
                'results_count': results_count,
                'execution_time_ms': round(execution_time * 1000, 2),
                'has_filters': bool(any(v for k, v in safe_params.items() if k != 'q')),
                **context
            }}
        )
    
    @staticmethod
    def log_contract_view(contract_id, contract_data=None):
        """Log cuando se visualiza un contrato espec√≠fico"""
        context = ActivityTracker.get_request_context()
        
        log_data = {
            'event': 'contract_view',
            'contract_id': contract_id,
            **context
        }
        
        if contract_data:
            log_data.update({
                'institucion': contract_data.get('siglas_institucion'),
                'tipo_procedimiento': contract_data.get('tipo_procedimiento'),
                'importe': contract_data.get('importe'),
                'anio': contract_data.get('anio_fuente')
            })
        
        access_logger.info(
            f"Contrato visualizado",
            extra={'extra_fields': log_data}
        )
    
    @staticmethod
    def log_export(format_type, filters, count):
        """Log de exportaciones de datos"""
        context = ActivityTracker.get_request_context()
        
        access_logger.info(
            f"Datos exportados",
            extra={'extra_fields': {
                'event': 'export',
                'format': format_type,
                'filters': filters,
                'records_count': count,
                **context
            }}
        )
    
    @staticmethod
    def log_error(error, error_type='general'):
        """Log de errores con contexto"""
        context = ActivityTracker.get_request_context()
        
        logging.getLogger('app').error(
            f"Error: {str(error)}",
            extra={'extra_fields': {
                'event': 'error',
                'error_type': error_type,
                'error_message': str(error),
                'error_class': error.__class__.__name__,
                **context
            }},
            exc_info=True
        )



===============================
üìÅ Archivo: ./app/utils/__init__.py
===============================



===============================
üìÅ Archivo: ./app/utils/decorators.py
===============================
# app/decorators.py
from functools import wraps
from flask import g
import time
from app.utils.activity_tracker import ActivityTracker

def track_activity(func):
    """Decorador para rastrear actividad en endpoints espec√≠ficos"""
    @wraps(func)
    def decorated_function(*args, **kwargs):
        g.start_time = time.time()
        
        try:
            result = func(*args, **kwargs)
            
            # Log espec√≠fico seg√∫n el endpoint
            if 'contract' in func.__name__:
                contract_id = kwargs.get('id')
                if contract_id:
                    ActivityTracker.log_contract_view(contract_id)
                    
            return result
            
        except Exception as e:
            ActivityTracker.log_error(e, error_type='endpoint_error')
            raise
            
    return decorated_function

def track_search(func):
    """Decorador espec√≠fico para rastrear b√∫squedas"""
    @wraps(func)
    def decorated_function(*args, **kwargs):
        start_time = time.time()
        
        result = func(*args, **kwargs)
        
        execution_time = time.time() - start_time
        
        # Extraer par√°metros de b√∫squeda del request
        from flask import request
        search_params = dict(request.args)
        
        # Asumir que result tiene info sobre cantidad de resultados
        results_count = len(result) if hasattr(result, '__len__') else 0
        
        ActivityTracker.log_search(search_params, results_count, execution_time)
        
        return result
        
    return decorated_function


===============================
üìÅ Archivo: ./app/models/contrato.py
===============================
# app/models/contrato.py

from app import db
from datetime import datetime

class Contrato(db.Model):
    """Modelo de Contrato"""
    __tablename__ = 'contratos'
    __table_args__ = {'schema': 'contratos'}
    
    codigo_contrato = db.Column(db.String, primary_key=True)
    codigo_expediente = db.Column(db.String)
    titulo_contrato = db.Column(db.Text)
    titulo_expediente = db.Column(db.Text)
    descripcion_contrato = db.Column(db.Text)
    tipo_contratacion = db.Column(db.String)
    tipo_procedimiento = db.Column(db.String)
    proveedor_contratista = db.Column(db.String)
    rfc = db.Column(db.String)
    institucion = db.Column(db.String)
    siglas_institucion = db.Column(db.String)
    importe = db.Column(db.Numeric)
    importe_contrato = db.Column(db.String)
    moneda = db.Column(db.String)
    fecha_inicio_contrato = db.Column(db.Date)
    fecha_fin_contrato = db.Column(db.Date)
    estatus_contrato = db.Column(db.String)
    direccion_anuncio = db.Column(db.Text)
    anio_fuente = db.Column(db.Integer)
    
    def get_importe_numerico(self):
        """Obtiene el importe como n√∫mero flotante"""
        if self.importe:
            return float(self.importe)
        elif self.importe_contrato:
            try:
                importe_str = str(self.importe_contrato).replace(',', '').strip()
                return float(importe_str)
            except:
                return 0.0
        return 0.0
    
    def to_dict(self):
        """Convierte el objeto a diccionario para JSON"""
        return {
            'codigo_contrato': self.codigo_contrato,
            'codigo_expediente': self.codigo_expediente,
            'titulo': self.titulo_contrato,
            'descripcion': self.descripcion_contrato,
            'tipo_contratacion': self.tipo_contratacion,
            'tipo_procedimiento': self.tipo_procedimiento,
            'proveedor': self.proveedor_contratista,
            'rfc': self.rfc,
            'institucion': self.institucion,
            'siglas_institucion': self.siglas_institucion,
            'importe': self.get_importe_numerico(),
            'moneda': self.moneda,
            'fecha_inicio': self.fecha_inicio_contrato.isoformat() if self.fecha_inicio_contrato else None,
            'fecha_fin': self.fecha_fin_contrato.isoformat() if self.fecha_fin_contrato else None,
            'estatus': self.estatus_contrato,
            'url_compranet': self.direccion_anuncio,
            'anio': self.anio_fuente
        }
    
    def __repr__(self):
        return f'<Contrato {self.codigo_contrato}>'


===============================
üìÅ Archivo: ./app/models/__init__.py
===============================
# app/models/__init__.py

from .contrato import Contrato

__all__ = ['Contrato']


===============================
üìÅ Archivo: ./app/static/css/style.css
===============================
/* Minimal Liquid Glass Design - Elegant & Functional */

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

:root {
    /* Primary Colors */
    --primary: #007AFF;
    --primary-dark: #0051D5;
    --success: #34C759;
    --danger: #FF3B30;
    --warning: #FF9500;
    
    /* Neutral Palette */
    --bg-primary: #000000;
    --bg-secondary: #1C1C1E;
    --bg-tertiary: #2C2C2E;
    --surface: #1C1C1E;
    --surface-elevated: #2C2C2E;
    
    /* Text Colors */
    --text-primary: rgba(255, 255, 255, 1);
    --text-secondary: rgba(255, 255, 255, 0.85);
    --text-tertiary: rgba(255, 255, 255, 0.6);
    --text-quaternary: rgba(255, 255, 255, 0.4);
    
    /* Glass Effects - Subtle */
    --glass: rgba(255, 255, 255, 0.05);
    --glass-hover: rgba(255, 255, 255, 0.08);
    --glass-border: rgba(255, 255, 255, 0.1);
    
    /* Shadows */
    --shadow-sm: 0 2px 8px rgba(0, 0, 0, 0.2);
    --shadow-md: 0 4px 20px rgba(0, 0, 0, 0.25);
    --shadow-lg: 0 8px 40px rgba(0, 0, 0, 0.3);
    
    /* Animation */
    --ease: cubic-bezier(0.4, 0, 0.2, 1);
    --ease-spring: cubic-bezier(0.34, 1.56, 0.64, 1);
}

/* Base Styles */
body {
    font-family: -apple-system, BlinkMacSystemFont, 'Inter', sans-serif;
    background: var(--bg-primary);
    color: var(--text-secondary);
    line-height: 1.6;
    min-height: 100vh;
    position: relative;
}

/* Subtle gradient background */
body::before {
    content: '';
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: radial-gradient(
        circle at 50% 0%,
        rgba(0, 122, 255, 0.05) 0%,
        transparent 50%
    );
    pointer-events: none;
    z-index: 0;
}

.container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 24px;
    position: relative;
    z-index: 1;
}

/* Header - Clean & Minimal */
header {
    text-align: center;
    margin-bottom: 48px;
    padding: 48px 0;
    position: relative;
}

header h1 {
    font-size: 3.5rem;
    font-weight: 700;
    letter-spacing: -0.03em;
    margin-bottom: 12px;
    color: var(--text-primary);
    background: linear-gradient(
        180deg,
        var(--text-primary) 0%,
        var(--text-secondary) 100%
    );
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
}

.subtitle {
    color: var(--text-tertiary);
    font-size: 1.125rem;
    font-weight: 400;
    letter-spacing: 0.01em;
}

/* Search Container - Clean Card */
.search-container {
    background: var(--surface);
    border: 1px solid var(--glass-border);
    padding: 32px;
    border-radius: 16px;
    margin-bottom: 32px;
    transition: all 0.3s var(--ease);
}

.search-container:hover {
    border-color: rgba(255, 255, 255, 0.15);
    box-shadow: var(--shadow-md);
}

.search-box {
    display: flex;
    gap: 12px;
    margin-bottom: 24px;
}

/* Input Field - Minimal Glass */
#searchInput {
    flex: 1;
    padding: 16px 20px;
    font-size: 16px;
    border-radius: 12px;
    border: 1px solid var(--glass-border);
    outline: none;
    background: var(--glass);
    color: var(--text-primary);
    transition: all 0.2s var(--ease);
}

#searchInput::placeholder {
    color: var(--text-quaternary);
}

#searchInput:hover {
    background: var(--glass-hover);
    border-color: rgba(255, 255, 255, 0.15);
}

#searchInput:focus {
    background: rgba(255, 255, 255, 0.1);
    border-color: var(--primary);
    box-shadow: 0 0 0 3px rgba(0, 122, 255, 0.2);
}

/* Button - Solid & Clear */
#searchBtn {
    padding: 16px 32px;
    background: var(--primary);
    color: white;
    border: none;
    border-radius: 12px;
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s var(--ease);
    position: relative;
    overflow: hidden;
}

#searchBtn:hover {
    background: var(--primary-dark);
    transform: translateY(-1px);
    box-shadow: var(--shadow-md);
}

#searchBtn:active {
    transform: translateY(0);
    box-shadow: var(--shadow-sm);
}

/* Search Options - Radio Group */
.search-options {
    display: flex;
    gap: 16px;
    flex-wrap: wrap;
    justify-content: center;
}

.search-options label {
    cursor: pointer;
    padding: 8px 16px;
    border-radius: 8px;
    transition: all 0.2s var(--ease);
    color: var(--text-secondary);
    background: var(--glass);
    border: 1px solid transparent;
}

.search-options label:hover {
    background: var(--glass-hover);
    border-color: var(--glass-border);
}

.search-options input[type="radio"]:checked + label,
.search-options label:has(input:checked) {
    background: rgba(0, 122, 255, 0.1);
    border-color: var(--primary);
    color: var(--primary);
}

.search-options input[type="radio"] {
    margin-right: 6px;
    accent-color: var(--primary);
}

/* Loading State - Simple Spinner */
.loading {
    text-align: center;
    padding: 60px;
    background: var(--surface);
    border: 1px solid var(--glass-border);
    border-radius: 16px;
    margin-bottom: 32px;
}

.spinner {
    width: 48px;
    height: 48px;
    margin: 0 auto 20px;
    border: 3px solid var(--glass-border);
    border-top-color: var(--primary);
    border-radius: 50%;
    animation: spin 1s linear infinite;
}

@keyframes spin {
    to { transform: rotate(360deg); }
}

/* Results Summary - Info Bar */
.results-summary {
    background: var(--surface-elevated);
    color: var(--text-secondary);
    padding: 20px 24px;
    border-radius: 12px;
    margin-bottom: 24px;
    font-size: 1rem;
    border: 1px solid var(--glass-border);
    display: flex;
    align-items: center;
    justify-content: space-between;
}

.results-summary strong {
    color: var(--primary);
    font-weight: 600;
}

/* Filters Bar - Clean Toolbar */
.filters-bar {
    background: var(--surface);
    border: 1px solid var(--glass-border);
    padding: 24px;
    border-radius: 12px;
    margin-bottom: 24px;
}

.filter-label {
    font-weight: 600;
    margin-bottom: 16px;
    font-size: 0.875rem;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    color: var(--text-tertiary);
}

.filter-buttons {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
    margin-bottom: 16px;
}

/* Filter Buttons - Pill Style */
.filter-btn {
    padding: 8px 16px;
    background: var(--glass);
    border: 1px solid var(--glass-border);
    border-radius: 20px;
    cursor: pointer;
    color: var(--text-secondary);
    font-size: 14px;
    font-weight: 500;
    transition: all 0.2s var(--ease);
}

.filter-btn:hover {
    background: var(--glass-hover);
    border-color: rgba(255, 255, 255, 0.2);
    color: var(--text-primary);
    transform: translateY(-1px);
}

.filter-btn.active {
    background: rgba(0, 122, 255, 0.15);
    border-color: var(--primary);
    color: var(--primary);
}

/* Active Filters - Tags */
.active-filters {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
}

.filter-chip {
    background: rgba(0, 122, 255, 0.15);
    color: var(--primary);
    padding: 6px 12px 6px 16px;
    border-radius: 20px;
    font-size: 13px;
    display: inline-flex;
    align-items: center;
    gap: 8px;
    border: 1px solid rgba(0, 122, 255, 0.3);
}

.filter-chip .remove {
    cursor: pointer;
    font-weight: bold;
    font-size: 16px;
    line-height: 1;
    opacity: 0.7;
    transition: opacity 0.2s var(--ease);
}

.filter-chip .remove:hover {
    opacity: 1;
}

/* Results Section - Content Cards */
.results-section {
    background: var(--surface);
    border: 1px solid var(--glass-border);
    padding: 32px;
    border-radius: 16px;
    margin-bottom: 24px;
    transition: all 0.3s var(--ease);
}

.results-section h2 {
    font-size: 1.5rem;
    font-weight: 600;
    letter-spacing: -0.01em;
    margin-bottom: 24px;
    padding-bottom: 16px;
    color: var(--text-primary);
    border-bottom: 1px solid var(--glass-border);
}

/* List Items - Clean & Readable */
.grouped-list {
    display: flex;
    flex-direction: column;
    gap: 12px;
}

.group-item {
    padding: 20px;
    border-radius: 12px;
    cursor: pointer;
    transition: all 0.2s var(--ease);
    display: flex;
    justify-content: space-between;
    align-items: center;
    background: var(--glass);
    border: 1px solid transparent;
}

.group-item:hover {
    background: var(--glass-hover);
    border-color: var(--glass-border);
    transform: translateX(4px);
}

.group-info {
    flex: 1;
}

.group-name {
    font-weight: 600;
    font-size: 1.125rem;
    color: var(--text-primary);
    margin-bottom: 4px;
}

.group-details {
    font-size: 0.875rem;
    color: var(--text-tertiary);
}

.group-amount {
    text-align: right;
    font-size: 1.375rem;
    font-weight: 700;
    color: var(--success);
}

/* Contract Items */
.contract-item {
    padding: 20px;
    border-radius: 12px;
    margin-bottom: 12px;
    transition: all 0.2s var(--ease);
    background: var(--glass);
    border: 1px solid transparent;
    border-left: 3px solid transparent;
}

.contract-item:hover {
    background: var(--glass-hover);
    border-color: var(--glass-border);
    border-left-color: var(--primary);
    transform: translateX(4px);
}

.contract-header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    margin-bottom: 12px;
}

.contract-amount {
    font-size: 1.375rem;
    font-weight: 700;
    color: var(--success);
}

.contract-title {
    color: var(--text-primary);
    font-weight: 600;
    margin-bottom: 8px;
    font-size: 1.125rem;
}

.contract-details {
    font-size: 0.875rem;
    color: var(--text-tertiary);
    line-height: 1.6;
}

/* Modal - Clean Overlay */
.modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.75);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
    opacity: 0;
    visibility: hidden;
    transition: all 0.3s var(--ease);
}

.modal.active {
    opacity: 1;
    visibility: visible;
}

.modal-content {
    background: var(--surface-elevated);
    padding: 32px;
    border-radius: 16px;
    max-width: 500px;
    width: 90%;
    max-height: 70vh;
    overflow-y: auto;
    border: 1px solid var(--glass-border);
    box-shadow: var(--shadow-lg);
    transform: scale(0.9) translateY(20px);
    transition: all 0.3s var(--ease-spring);
}

.modal.active .modal-content {
    transform: scale(1) translateY(0);
}

.modal-content h3 {
    margin-bottom: 24px;
    font-size: 1.5rem;
    font-weight: 600;
    color: var(--text-primary);
}

.close {
    float: right;
    font-size: 24px;
    font-weight: 400;
    cursor: pointer;
    color: var(--text-tertiary);
    width: 32px;
    height: 32px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 8px;
    transition: all 0.2s var(--ease);
}

.close:hover {
    color: var(--text-primary);
    background: var(--glass-hover);
}

/* Filter Options in Modal */
.filter-option {
    padding: 12px;
    margin-bottom: 4px;
    cursor: pointer;
    transition: all 0.2s var(--ease);
    border-radius: 8px;
    display: flex;
    align-items: center;
    justify-content: space-between;
}

.filter-option:hover {
    background: var(--glass-hover);
}

.filter-option input[type="checkbox"] {
    margin-right: 12px;
    accent-color: var(--primary);
    width: 18px;
    height: 18px;
}

.filter-count {
    color: var(--text-tertiary);
    font-size: 0.875rem;
}

/* Apply Button */
.apply-btn {
    width: 100%;
    padding: 14px;
    background: var(--primary);
    color: white;
    border: none;
    border-radius: 12px;
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
    margin-top: 24px;
    transition: all 0.2s var(--ease);
}

.apply-btn:hover {
    background: var(--primary-dark);
    transform: translateY(-1px);
    box-shadow: var(--shadow-md);
}

.apply-btn:active {
    transform: translateY(0);
}

/* Utility Classes */
.hidden {
    display: none !important;
}

/* Error Message */
.error-message {
    background: rgba(255, 59, 48, 0.1);
    color: var(--danger);
    padding: 20px;
    border-radius: 12px;
    text-align: center;
    margin: 24px 0;
    border: 1px solid rgba(255, 59, 48, 0.3);
}

/* Custom Scrollbar */
::-webkit-scrollbar {
    width: 10px;
}

::-webkit-scrollbar-track {
    background: var(--bg-secondary);
    border-radius: 10px;
}

::-webkit-scrollbar-thumb {
    background: var(--glass-border);
    border-radius: 10px;
}

::-webkit-scrollbar-thumb:hover {
    background: rgba(255, 255, 255, 0.2);
}

/* Responsive Design */
@media (max-width: 768px) {
    .container {
        padding: 16px;
    }
    
    header h1 {
        font-size: 2.5rem;
    }
    
    .search-box {
        flex-direction: column;
    }
    
    #searchBtn {
        width: 100%;
    }
    
    .search-options {
        gap: 12px;
    }
    
    .group-item {
        flex-direction: column;
        align-items: flex-start;
        gap: 12px;
    }
    
    .group-amount {
        text-align: left;
    }
    
    .modal-content {
        width: 95%;
        padding: 24px;
    }
    
    .results-section {
        padding: 24px;
    }
}

/* Light Mode Support */
@media (prefers-color-scheme: light) {
    :root {
        --bg-primary: #FFFFFF;
        --bg-secondary: #F2F2F7;
        --bg-tertiary: #FFFFFF;
        --surface: #FFFFFF;
        --surface-elevated: #F2F2F7;
        
        --text-primary: rgba(0, 0, 0, 0.85);
        --text-secondary: rgba(0, 0, 0, 0.7);
        --text-tertiary: rgba(0, 0, 0, 0.5);
        --text-quaternary: rgba(0, 0, 0, 0.35);
        
        --glass: rgba(0, 0, 0, 0.02);
        --glass-hover: rgba(0, 0, 0, 0.04);
        --glass-border: rgba(0, 0, 0, 0.08);
        
        --shadow-sm: 0 2px 8px rgba(0, 0, 0, 0.08);
        --shadow-md: 0 4px 20px rgba(0, 0, 0, 0.1);
        --shadow-lg: 0 8px 40px rgba(0, 0, 0, 0.12);
    }
    
    body::before {
        background: radial-gradient(
            circle at 50% 0%,
            rgba(0, 122, 255, 0.03) 0%,
            transparent 50%
        );
    }
}

/* Accessibility - Reduced Motion */
@media (prefers-reduced-motion: reduce) {
    *,
    *::before,
    *::after {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
    }
}

/* High Contrast Mode */
@media (prefers-contrast: high) {
    :root {
        --glass-border: rgba(255, 255, 255, 0.3);
    }
    
    .search-container,
    .results-section,
    .filters-bar {
        border-width: 2px;
    }
    
    #searchInput:focus {
        outline: 2px solid var(--primary);
        outline-offset: 2px;
    }
}


===============================
üìÅ Archivo: ./app/static/js/app.js
===============================
// ===========================
// VARIABLES GLOBALES
// ===========================
let currentPage = 1;
let totalPages = 1;
let totalCount = 0;
let currentContracts = null;
let isLoadingMore = false;
let lastQuery = '';
let lastSearchType = 'descripcion';
let activeFilters = {};
const perPage = 20;

// ===========================
// Inicializaci√≥n
// ===========================
document.addEventListener('DOMContentLoaded', function() {
    // Event listener para buscar con Enter
    document.getElementById('searchInput').addEventListener('keypress', function(e) {
        if (e.key === 'Enter') {
            buscar();
        }
    });

    // Observer para scroll infinito
    const sentinel = document.getElementById('scrollSentinel');
    if (sentinel) {
        const observer = new IntersectionObserver((entries) => {
            if (entries[0].isIntersecting && !isLoadingMore && currentPage < totalPages) {
                cargarContratos(currentPage + 1, true);
            }
        });
        observer.observe(sentinel);
    }
});

// ===========================
// Funci√≥n principal de b√∫squeda
// ===========================
async function buscar(resetFilters = true) {
    const query = document.getElementById('searchInput').value.trim();
    if (!query) {
        mostrarError('Por favor ingresa un t√©rmino de b√∫squeda');
        return;
    }

    // Obtener tipo de b√∫squeda seleccionado
    const searchType = document.querySelector('input[name="searchType"]:checked').value;

    // Guardar para uso posterior
    lastQuery = query;
    lastSearchType = searchType;
    
    // Solo resetear filtros si es una b√∫squeda nueva
    if (resetFilters) {
        activeFilters = {};
    }
    
    currentPage = 1;

    // Mostrar loading
    document.getElementById('loading').classList.remove('hidden');
    document.getElementById('resultsArea').classList.add('hidden');
    document.getElementById('errorMessage').classList.add('hidden');

    try {
        const response = await fetch('/api/search', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                query: query,
                search_type: searchType,
                filters: activeFilters
            })
        });

        // Ocultar loading
        document.getElementById('loading').classList.add('hidden');

        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.error || `Error HTTP: ${response.status}`);
        }

        const data = await response.json();
        
        // Debug log para verificar la estructura
        console.log('Datos recibidos:', data);
        console.log('Filtros activos:', activeFilters);

        // Verificar si hay resultados
        if (!data || data.total === 0) {
            mostrarError('No se encontraron resultados para tu b√∫squeda');
            return;
        }

        // Mostrar resultados
        document.getElementById('resultsArea').classList.remove('hidden');
        
        // Renderizar el resumen de resultados con las propiedades correctas
        renderResultsSummary(data);
        
        // Renderizar los agregados (proveedores e instituciones)
        renderAggregates(data);
        
        // Renderizar contratos
        if (data.contratos && data.contratos.length > 0) {
            renderContratos(data.contratos, false);
            document.getElementById('contratosSection').classList.remove('hidden');
        }
        
        // Renderizar filtros si est√°n disponibles
        if (data.filtros_disponibles) {
            renderFilters(data.filtros_disponibles);
        }

    } catch (error) {
        console.error('Error en b√∫squeda:', error);
        document.getElementById('loading').classList.add('hidden');
        mostrarError(error.message || 'Error al realizar la b√∫squeda. Por favor intenta de nuevo.');
    }
}

// ===========================
// Render del resumen de resultados
// ===========================
function renderResultsSummary(data) {
    const summaryHtml = `
        <strong>Resultados para:</strong> "${data.query}" | 
        <strong>Tipo de b√∫squeda:</strong> ${data.search_type} | 
        <strong>Total:</strong> ${data.total.toLocaleString()} contratos | 
        <strong>Monto total:</strong> ${formatMoney(data.monto_total)}
    `;
    document.getElementById('resultsSummary').innerHTML = summaryHtml;
}

// ===========================
// Render de agregados
// ===========================
function renderAggregates(data) {
    // Mostrar proveedores
    if (data.proveedores && data.proveedores.length > 0) {
        mostrarProveedores(data.proveedores);
        document.getElementById('empresasSection').classList.remove('hidden');
    } else {
        document.getElementById('empresasSection').classList.add('hidden');
    }

    // Mostrar instituciones
    if (data.instituciones && data.instituciones.length > 0) {
        mostrarInstituciones(data.instituciones);
        document.getElementById('institucionesSection').classList.remove('hidden');
    } else {
        document.getElementById('institucionesSection').classList.add('hidden');
    }
}

// ===========================
// Render de contratos
// ===========================
function renderContratos(contratos, append = false) {
    let html = '';

    contratos.forEach(contrato => {
        const titulo = contrato.titulo || contrato.descripcion || 'Sin t√≠tulo';
        const tituloCorto = titulo.length > 100 ? titulo.substring(0, 100) + '...' : titulo;

        const botonCompranet = contrato.url_compranet && contrato.url_compranet.startsWith('http') 
            ? `<a href="${contrato.url_compranet}" target="_blank" class="btn-compranet" title="Ver en CompraNet">üîó CompraNet</a>` 
            : '';

        html += `
            <div class="contract-item">
                <div class="contract-header">
                    <div style="flex: 1;">
                        <div class="contract-title">${tituloCorto}</div>
                        <div class="contract-details">
                            <strong>${contrato.institucion || contrato.siglas_institucion || ''}</strong> | 
                            ${contrato.proveedor || 'Sin proveedor'}<br>
                            C√≥digo: ${contrato.codigo_contrato || 'N/A'} | 
                            ${contrato.tipo_procedimiento || ''} | 
                            ${contrato.anio || ''}
                        </div>
                        ${botonCompranet}
                    </div>
                    <div class="contract-amount">${formatMoney(contrato.importe)}</div>
                </div>
            </div>
        `;
    });

    if (append) {
        document.getElementById('contratosList').insertAdjacentHTML('beforeend', html);
    } else {
        document.getElementById('contratosList').innerHTML = html;
    }
}

// ===========================
// Mostrar proveedores
// ===========================
function mostrarProveedores(proveedores) {
    let html = '';
    proveedores.forEach(proveedor => {
        const rfc = proveedor.rfc && proveedor.rfc !== 'RFC Gen√©rico' 
            ? proveedor.rfc 
            : 'Sin RFC';
        
        html += `
            <div class="group-item">
                <div class="group-info">
                    <div class="group-name">${proveedor.nombre || 'Sin nombre'}</div>
                    <div class="group-details">
                        RFC: ${rfc} | ${proveedor.num_contratos} contratos
                    </div>
                </div>
                <div class="group-amount">${formatMoney(proveedor.monto_total)}</div>
            </div>
        `;
    });
    document.getElementById('empresasList').innerHTML = html;
}

// ===========================
// Mostrar instituciones
// ===========================
function mostrarInstituciones(instituciones) {
    let html = '';
    instituciones.forEach(inst => {
        html += `
            <div class="group-item">
                <div class="group-info">
                    <div class="group-name">${inst.nombre || inst.siglas}</div>
                    <div class="group-details">
                        ${inst.siglas} | ${inst.num_contratos} contratos
                    </div>
                </div>
                <div class="group-amount">${formatMoney(inst.monto_total)}</div>
            </div>
        `;
    });
    document.getElementById('institucionesList').innerHTML = html;
}

// ===========================
// Render de filtros
// ===========================
function renderFilters(filtros) {
    if (!filtros || Object.keys(filtros).length === 0) {
        document.getElementById('filtersBar').classList.add('hidden');
        return;
    }

    let buttonsHtml = '';
    
    // Instituciones
    if (filtros.instituciones && Object.keys(filtros.instituciones).length > 0) {
        buttonsHtml += `<button class="filter-btn" onclick="openFilterModal('instituciones', ${JSON.stringify(filtros.instituciones).replace(/"/g, '&quot;')})">
            Instituci√≥n (${Object.keys(filtros.instituciones).length})
        </button>`;
    }
    
    // Tipos de contrataci√≥n
    if (filtros.tipos && Object.keys(filtros.tipos).length > 0) {
        buttonsHtml += `<button class="filter-btn" onclick="openFilterModal('tipos', ${JSON.stringify(filtros.tipos).replace(/"/g, '&quot;')})">
            Tipo (${Object.keys(filtros.tipos).length})
        </button>`;
    }
    
    // Procedimientos
    if (filtros.procedimientos && Object.keys(filtros.procedimientos).length > 0) {
        buttonsHtml += `<button class="filter-btn" onclick="openFilterModal('procedimientos', ${JSON.stringify(filtros.procedimientos).replace(/"/g, '&quot;')})">
            Procedimiento (${Object.keys(filtros.procedimientos).length})
        </button>`;
    }
    
    // A√±os
    if (filtros.anios && Object.keys(filtros.anios).length > 0) {
        buttonsHtml += `<button class="filter-btn" onclick="openFilterModal('anios', ${JSON.stringify(filtros.anios).replace(/"/g, '&quot;')})">
            A√±o (${Object.keys(filtros.anios).length})
        </button>`;
    }
    
    // Estatus
    if (filtros.estatus && Object.keys(filtros.estatus).length > 0) {
        buttonsHtml += `<button class="filter-btn" onclick="openFilterModal('estatus', ${JSON.stringify(filtros.estatus).replace(/"/g, '&quot;')})">
            Estatus (${Object.keys(filtros.estatus).length})
        </button>`;
    }

    document.getElementById('filterButtons').innerHTML = buttonsHtml;
    document.getElementById('filtersBar').classList.remove('hidden');
}

// ===========================
// Modal de filtros
// ===========================
let currentFilterType = '';
let currentFilterOptions = {};

function openFilterModal(type, options) {
    currentFilterType = type;
    currentFilterOptions = options;
    
    const modal = document.getElementById('filterModal');
    const modalTitle = document.getElementById('filterModalTitle');
    const modalBody = document.getElementById('filterModalBody');
    
    // Configurar t√≠tulo
    const titles = {
        'instituciones': 'Filtrar por Instituci√≥n',
        'tipos': 'Filtrar por Tipo de Contrataci√≥n',
        'procedimientos': 'Filtrar por Tipo de Procedimiento',
        'anios': 'Filtrar por A√±o',
        'estatus': 'Filtrar por Estatus'
    };
    modalTitle.textContent = titles[type] || 'Filtrar';
    
    // Generar checkboxes
    let bodyHtml = '<div class="filter-options">';
    for (const [key, count] of Object.entries(options)) {
        const isChecked = activeFilters[type] && activeFilters[type].includes(key) ? 'checked' : '';
        bodyHtml += `
            <label class="filter-option">
                <input type="checkbox" value="${key}" ${isChecked}>
                <span>${key} (${count})</span>
            </label>
        `;
    }
    bodyHtml += '</div>';
    modalBody.innerHTML = bodyHtml;
    
    modal.classList.remove('hidden');
}

function closeFilterModal() {
    document.getElementById('filterModal').classList.add('hidden');
}

function applyFilters() {
    const checkboxes = document.querySelectorAll('#filterModalBody input[type="checkbox"]:checked');
    const selectedValues = Array.from(checkboxes).map(cb => cb.value);
    
    if (selectedValues.length > 0) {
        activeFilters[currentFilterType] = selectedValues;
    } else {
        delete activeFilters[currentFilterType];
    }
    
    closeFilterModal();
    updateActiveFiltersDisplay();
    buscar(false); // No resetear filtros
}

function updateActiveFiltersDisplay() {
    const container = document.getElementById('activeFilters');
    if (Object.keys(activeFilters).length === 0) {
        container.innerHTML = '';
        return;
    }
    
    let html = '<span>Filtros activos: </span>';
    for (const [type, values] of Object.entries(activeFilters)) {
        values.forEach(value => {
            html += `<span class="active-filter-tag">${value} 
                <button onclick="removeFilter('${type}', '${value}')">&times;</button>
            </span>`;
        });
    }
    html += `<button class="clear-filters-btn" onclick="clearAllFilters()">Limpiar todos</button>`;
    container.innerHTML = html;
}

function removeFilter(type, value) {
    if (activeFilters[type]) {
        activeFilters[type] = activeFilters[type].filter(v => v !== value);
        if (activeFilters[type].length === 0) {
            delete activeFilters[type];
        }
    }
    updateActiveFiltersDisplay();
    buscar(false); // No resetear filtros
}

function clearAllFilters() {
    activeFilters = {};
    updateActiveFiltersDisplay();
    buscar(false); // Ya limpiamos los filtros manualmente
}

// ===========================
// Funciones auxiliares
// ===========================
function formatMoney(amount) {
    if (amount === null || amount === undefined || isNaN(amount)) return '$0.00';
    return '$' + Number(amount).toLocaleString('es-MX', {
        minimumFractionDigits: 2,
        maximumFractionDigits: 2
    });
}

function mostrarError(mensaje) {
    const errorDiv = document.getElementById('errorMessage');
    errorDiv.textContent = mensaje;
    errorDiv.classList.remove('hidden');
    document.getElementById('resultsArea').classList.add('hidden');
}

// ===========================
// Cargar contratos adicionales (scroll infinito)
// ===========================
async function cargarContratos(page, append = false) {
    if (isLoadingMore) return;
    
    try {
        isLoadingMore = true;
        
        const response = await fetch('/api/contracts/page', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                query: lastQuery,
                search_type: lastSearchType,
                filters: activeFilters,
                page: page,
                per_page: perPage
            })
        });

        if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
        }
        
        const data = await response.json();
        
        if (data.contratos && data.contratos.length > 0) {
            renderContratos(data.contratos, append);
            currentPage = page;
        }
        
        isLoadingMore = false;
        
    } catch (error) {
        console.error('Error cargando m√°s contratos:', error);
        isLoadingMore = false;
    }
}

// Cerrar modal al hacer clic fuera
window.onclick = function(event) {
    const modal = document.getElementById('filterModal');
    if (event.target == modal) {
        closeFilterModal();
    }
}


===============================
üìÅ Archivo: ./app/app.py
===============================
# ===========================
# IMPORTS
# ===========================
import os
import re
from datetime import datetime
from flask import Flask, render_template, request, jsonify
from flask_sqlalchemy import SQLAlchemy
from sqlalchemy import func, or_, text, and_
from sqlalchemy.orm import Query
import logging

# ===========================
# CONFIGURACI√ìN
# ===========================
app = Flask(__name__)

# Configuraci√≥n de la base de datos
DB_USER = os.getenv('DB_USER', 'postgres')
DB_PASSWORD = os.getenv('DB_PASSWORD', 'password')
DB_HOST = os.getenv('DB_HOST', 'localhost')
DB_PORT = os.getenv('DB_PORT', '5432')
DB_NAME = os.getenv('DB_NAME', 'contratos_db')

app.config['SQLALCHEMY_DATABASE_URI'] = f'postgresql://{DB_USER}:{DB_PASSWORD}@{DB_HOST}:{DB_PORT}/{DB_NAME}'
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
app.config['JSON_AS_ASCII'] = False

db = SQLAlchemy(app)

# Configurar logging
logging.basicConfig(level=logging.INFO)

# ===========================
# MODELOS
# ===========================
class Contrato(db.Model):
    __tablename__ = 'contratos'
    __table_args__ = {'schema': 'contratos'}
    
    codigo_contrato = db.Column(db.String, primary_key=True)
    codigo_expediente = db.Column(db.String)
    titulo_contrato = db.Column(db.Text)
    titulo_expediente = db.Column(db.Text)
    descripcion_contrato = db.Column(db.Text)
    tipo_contratacion = db.Column(db.String)
    tipo_procedimiento = db.Column(db.String)
    proveedor_contratista = db.Column(db.String)
    rfc = db.Column(db.String)
    institucion = db.Column(db.String)
    siglas_institucion = db.Column(db.String)
    importe = db.Column(db.Numeric)
    importe_contrato = db.Column(db.String)
    moneda = db.Column(db.String)
    fecha_inicio_contrato = db.Column(db.Date)
    fecha_fin_contrato = db.Column(db.Date)
    estatus_contrato = db.Column(db.String)
    direccion_anuncio = db.Column(db.Text)
    anio_fuente = db.Column(db.Integer)
    
    def get_importe_numerico(self):
        """Obtiene el importe como n√∫mero flotante"""
        if self.importe:
            return float(self.importe)
        elif self.importe_contrato:
            try:
                # Limpiar string: quitar comas y espacios
                importe_str = str(self.importe_contrato).replace(',', '').strip()
                return float(importe_str)
            except:
                return 0.0
        return 0.0
    
    def to_dict(self):
        """Convierte el objeto a diccionario para JSON"""
        return {
            'codigo_contrato': self.codigo_contrato,
            'codigo_expediente': self.codigo_expediente,
            'titulo': self.titulo_contrato,
            'descripcion': self.descripcion_contrato,
            'tipo_contratacion': self.tipo_contratacion,
            'tipo_procedimiento': self.tipo_procedimiento,
            'proveedor': self.proveedor_contratista,
            'rfc': self.rfc,
            'institucion': self.institucion,
            'siglas_institucion': self.siglas_institucion,
            'importe': self.get_importe_numerico(),
            'moneda': self.moneda,
            'fecha_inicio': self.fecha_inicio_contrato.isoformat() if self.fecha_inicio_contrato else None,
            'fecha_fin': self.fecha_fin_contrato.isoformat() if self.fecha_fin_contrato else None,
            'estatus': self.estatus_contrato,
            'url_compranet': self.direccion_anuncio,
            'anio': self.anio_fuente
        }

# ===========================
# RUTAS PRINCIPALES
# ===========================
@app.route('/')
def index():
    """P√°gina principal"""
    return render_template('index.html')

@app.route('/api/search', methods=['POST'])
def search():
    """B√∫squeda inicial - retorna agregados y primeros contratos"""
    try:
        data = request.get_json()
        
        # Validar y sanitizar entrada
        query_text = data.get('query', '').strip()
        
        # Limitar longitud de b√∫squeda
        if len(query_text) > 200:
            return jsonify({'error': 'T√©rmino de b√∫squeda demasiado largo'}), 400
            
        # Remover caracteres potencialmente peligrosos pero mantener acentos y caracteres v√°lidos
        query_text = re.sub(r'[^\w\s\-.,√°√©√≠√≥√∫√±√Å√â√ç√ì√ö√ë]', '', query_text)
        
        # Validar tipo de b√∫squeda
        search_type = data.get('search_type', 'todo')
        valid_types = ['descripcion', 'titulo', 'empresa', 'rfc', 'institucion', 'todo']
        if search_type not in valid_types:
            search_type = 'todo'
        
        filters = data.get('filters', {})
        
        if not query_text:
            return jsonify({'error': 'Por favor ingresa un t√©rmino de b√∫squeda'}), 400
        
        # Si es b√∫squeda por RFC, validar formato
        if search_type == 'rfc':
            rfc_pattern = r'^[A-Z√ë&]{3,4}\d{6}[A-Z0-9]{3}$'
            if not re.match(rfc_pattern, query_text.upper()):
                return jsonify({'error': 'Formato de RFC inv√°lido'}), 400
        
        # Construir la consulta base seg√∫n el tipo
        base_query = build_search_query(query_text, search_type)
        
        # Aplicar filtros si existen
        if filters:
            base_query = apply_filters(base_query, filters)
        
        # Guardar los par√°metros de b√∫squeda en la sesi√≥n para paginaci√≥n posterior
        app.logger.info(f"B√∫squeda: {query_text}, tipo: {search_type}")
        
        # 1. Obtener agregados de forma eficiente
        agregados = obtener_agregados_optimizado(base_query)
        
        # 2. Obtener solo los primeros 50 contratos ordenados por importe
        contratos = base_query.order_by(Contrato.importe.desc().nullslast()).limit(50).all()
        
        # 3. Obtener filtros disponibles (solo de los resultados totales)
        filtros_disponibles = obtener_filtros_disponibles(base_query)
        
        resultado = {
            'query': query_text,
            'search_type': search_type,
            'total': agregados['total_contratos'],
            'monto_total': agregados['monto_total'],
            'proveedores': agregados['top_proveedores'],
            'instituciones': agregados['top_instituciones'],
            'contratos': [c.to_dict() for c in contratos],
            'filtros_disponibles': filtros_disponibles,
            'page': 1,
            'has_more': agregados['total_contratos'] > 50
        }
        
        return jsonify(resultado)
        
    except Exception as e:
        app.logger.error(f"Error en b√∫squeda: {str(e)}")
        return jsonify({'error': 'Error al procesar la b√∫squeda'}), 500

@app.route('/api/contracts/page', methods=['POST'])
def get_contracts_page():
    """Obtiene una p√°gina espec√≠fica de contratos (para scroll infinito)"""
    try:
        data = request.get_json()
        
        query_text = data.get('query', '').strip()
        search_type = data.get('search_type', 'todo')
        filters = data.get('filters', {})
        page = data.get('page', 1)
        per_page = min(data.get('per_page', 50), 100)  # M√°ximo 100 por p√°gina
        
        # Validaci√≥n b√°sica
        if not query_text:
            return jsonify({'error': 'Query requerido'}), 400
        
        if page < 1:
            page = 1
            
        # Construir la consulta
        query = build_search_query(query_text, search_type)
        
        # Aplicar filtros
        if filters:
            query = apply_filters(query, filters)
        
        # Calcular offset
        offset = (page - 1) * per_page
        
        # Obtener contratos paginados ordenados por importe
        contratos = query.order_by(Contrato.importe.desc().nullslast()).offset(offset).limit(per_page).all()
        
        # Verificar si hay m√°s p√°ginas
        total_contratos = query.count()
        has_more = (offset + per_page) < total_contratos
        
        return jsonify({
            'contratos': [c.to_dict() for c in contratos],
            'page': page,
            'per_page': per_page,
            'has_more': has_more,
            'total': total_contratos
        })
        
    except Exception as e:
        app.logger.error(f"Error obteniendo p√°gina de contratos: {str(e)}")
        return jsonify({'error': 'Error al obtener contratos'}), 500

@app.route('/api/aggregates', methods=['POST'])
def get_aggregates_only():
    """Obtiene solo los agregados (√∫til para actualizaci√≥n r√°pida)"""
    try:
        data = request.get_json()
        
        query_text = data.get('query', '').strip()
        search_type = data.get('search_type', 'todo')
        filters = data.get('filters', {})
        
        if not query_text:
            return jsonify({'error': 'Query requerido'}), 400
        
        # Construir consulta base
        base_query = build_search_query(query_text, search_type)
        
        # Aplicar filtros
        if filters:
            base_query = apply_filters(base_query, filters)
        
        # Obtener agregados optimizados
        agregados = obtener_agregados_optimizado(base_query)
        
        return jsonify(agregados)
        
    except Exception as e:
        app.logger.error(f"Error obteniendo agregados: {str(e)}")
        return jsonify({'error': 'Error al obtener agregados'}), 500

# ===========================
# FUNCIONES AUXILIARES OPTIMIZADAS
# ===========================

def obtener_agregados_optimizado(base_query):
    """
    Obtiene agregados usando consultas SQL optimizadas
    """
    try:
        # 1. Total de contratos y monto total en una sola consulta
        totales = db.session.query(
            func.count(Contrato.codigo_contrato).label('total'),
            func.sum(Contrato.importe).label('monto_total')
        ).select_from(base_query.subquery()).first()
        
        total_contratos = totales.total or 0
        monto_total = float(totales.monto_total or 0)
        
        # 2. Top 20 proveedores agrupados por RFC (optimizado con SQL)
        subquery = base_query.subquery()
        
        # Consulta para proveedores agrupados
        proveedores_query = db.session.query(
            Contrato.proveedor_contratista.label('nombre'),
            Contrato.rfc.label('rfc'),
            func.count(Contrato.codigo_contrato).label('num_contratos'),
            func.sum(Contrato.importe).label('monto_total')
        ).select_from(subquery).filter(
            Contrato.proveedor_contratista.isnot(None)
        ).group_by(
            Contrato.proveedor_contratista,
            Contrato.rfc
        ).order_by(
            func.sum(Contrato.importe).desc().nullslast()
        ).limit(20)
        
        proveedores = []
        for p in proveedores_query:
            proveedores.append({
                'nombre': p.nombre,
                'rfc': p.rfc if p.rfc and p.rfc != 'XAXX010101000' else 'RFC Gen√©rico',
                'num_contratos': p.num_contratos,
                'monto_total': float(p.monto_total or 0)
            })
        
        # 3. Top 20 instituciones agrupadas
        instituciones_query = db.session.query(
            Contrato.institucion.label('nombre'),
            Contrato.siglas_institucion.label('siglas'),
            func.count(Contrato.codigo_contrato).label('num_contratos'),
            func.sum(Contrato.importe).label('monto_total')
        ).select_from(subquery).filter(
            Contrato.siglas_institucion.isnot(None)
        ).group_by(
            Contrato.institucion,
            Contrato.siglas_institucion
        ).order_by(
            func.sum(Contrato.importe).desc().nullslast()
        ).limit(20)
        
        instituciones = []
        for i in instituciones_query:
            instituciones.append({
                'nombre': i.nombre,
                'siglas': i.siglas,
                'num_contratos': i.num_contratos,
                'monto_total': float(i.monto_total or 0)
            })
        
        return {
            'total_contratos': total_contratos,
            'monto_total': monto_total,
            'top_proveedores': proveedores,
            'top_instituciones': instituciones
        }
        
    except Exception as e:
        app.logger.error(f"Error en agregados optimizados: {str(e)}")
        return {
            'total_contratos': 0,
            'monto_total': 0,
            'top_proveedores': [],
            'top_instituciones': []
        }

def obtener_filtros_disponibles(base_query):
    """
    Obtiene los valores √∫nicos para filtros usando consultas optimizadas
    """
    try:
        filtros = {}
        
        # Usar subconsultas para mejorar performance
        subquery = base_query.subquery()
        
        # Top 10 instituciones m√°s frecuentes
        inst_query = db.session.query(
            Contrato.siglas_institucion,
            func.count(Contrato.codigo_contrato).label('count')
        ).select_from(subquery).filter(
            Contrato.siglas_institucion.isnot(None)
        ).group_by(
            Contrato.siglas_institucion
        ).order_by(
            func.count(Contrato.codigo_contrato).desc()
        ).limit(10)
        
        filtros['instituciones'] = {i.siglas_institucion: i.count for i in inst_query}
        
        # Top 10 tipos de contrataci√≥n
        tipos_query = db.session.query(
            Contrato.tipo_contratacion,
            func.count(Contrato.codigo_contrato).label('count')
        ).select_from(subquery).filter(
            Contrato.tipo_contratacion.isnot(None)
        ).group_by(
            Contrato.tipo_contratacion
        ).order_by(
            func.count(Contrato.codigo_contrato).desc()
        ).limit(10)
        
        filtros['tipos'] = {t.tipo_contratacion: t.count for t in tipos_query}
        
        # Top 10 tipos de procedimiento
        proc_query = db.session.query(
            Contrato.tipo_procedimiento,
            func.count(Contrato.codigo_contrato).label('count')
        ).select_from(subquery).filter(
            Contrato.tipo_procedimiento.isnot(None)
        ).group_by(
            Contrato.tipo_procedimiento
        ).order_by(
            func.count(Contrato.codigo_contrato).desc()
        ).limit(10)
        
        filtros['procedimientos'] = {p.tipo_procedimiento: p.count for p in proc_query}
        
        # Top 10 a√±os
        anios_query = db.session.query(
            Contrato.anio_fuente,
            func.count(Contrato.codigo_contrato).label('count')
        ).select_from(subquery).filter(
            Contrato.anio_fuente.isnot(None)
        ).group_by(
            Contrato.anio_fuente
        ).order_by(
            Contrato.anio_fuente.desc()
        ).limit(10)
        
        filtros['anios'] = {str(a.anio_fuente): a.count for a in anios_query}
        
        # Top 5 estatus
        estatus_query = db.session.query(
            Contrato.estatus_contrato,
            func.count(Contrato.codigo_contrato).label('count')
        ).select_from(subquery).filter(
            Contrato.estatus_contrato.isnot(None)
        ).group_by(
            Contrato.estatus_contrato
        ).order_by(
            func.count(Contrato.codigo_contrato).desc()
        ).limit(5)
        
        filtros['estatus'] = {e.estatus_contrato: e.count for e in estatus_query}
        
        return filtros
        
    except Exception as e:
        app.logger.error(f"Error obteniendo filtros: {str(e)}")
        return {}

def build_search_query(query_text, search_type):
    """Construye la consulta de b√∫squeda seg√∫n el tipo"""
    query = Contrato.query
    
    if search_type == 'descripcion':
        query = query.filter(Contrato.descripcion_contrato.ilike(f'%{query_text}%'))
        
    elif search_type == 'titulo':
        query = query.filter(or_(
            Contrato.titulo_contrato.ilike(f'%{query_text}%'),
            Contrato.titulo_expediente.ilike(f'%{query_text}%')
        ))
        
    elif search_type == 'empresa':
        query = query.filter(Contrato.proveedor_contratista.ilike(f'%{query_text}%'))
        
    elif search_type == 'rfc':
        # RFC debe ser exacto y en may√∫sculas
        query = query.filter(Contrato.rfc == query_text.upper())
        
    elif search_type == 'institucion':
        query = query.filter(or_(
            Contrato.institucion.ilike(f'%{query_text}%'),
            Contrato.siglas_institucion.ilike(f'%{query_text}%')
        ))
        
    else:  # todo
        query = query.filter(or_(
            Contrato.descripcion_contrato.ilike(f'%{query_text}%'),
            Contrato.titulo_contrato.ilike(f'%{query_text}%'),
            Contrato.titulo_expediente.ilike(f'%{query_text}%'),
            Contrato.proveedor_contratista.ilike(f'%{query_text}%'),
            Contrato.institucion.ilike(f'%{query_text}%'),
            Contrato.siglas_institucion.ilike(f'%{query_text}%')
        ))
    
    return query

def apply_filters(query, filters):
    """Aplica filtros adicionales a la consulta"""
    if filters.get('institucion'):
        query = query.filter(Contrato.siglas_institucion.in_(filters['institucion']))
    
    if filters.get('tipo'):
        query = query.filter(Contrato.tipo_contratacion.in_(filters['tipo']))
    
    if filters.get('procedimiento'):
        query = query.filter(Contrato.tipo_procedimiento.in_(filters['procedimiento']))
    
    if filters.get('anio'):
        # Convertir a√±os a enteros, manejando posibles errores
        try:
            anos = [int(a) for a in filters['anio']]
            query = query.filter(Contrato.anio_fuente.in_(anos))
        except ValueError:
            # Si hay un error de conversi√≥n, ignorar el filtro
            pass
    
    if filters.get('estatus'):
        query = query.filter(Contrato.estatus_contrato.in_(filters['estatus']))
    
    return query

@app.route('/api/stats')
def get_stats():
    """Obtiene estad√≠sticas generales de la base de datos"""
    try:
        total_contratos = db.session.query(func.count(Contrato.codigo_contrato)).scalar()
        total_instituciones = db.session.query(func.count(func.distinct(Contrato.siglas_institucion))).scalar()
        total_empresas = db.session.query(func.count(func.distinct(Contrato.rfc))).scalar()
        
        return jsonify({
            'total_contratos': total_contratos,
            'total_instituciones': total_instituciones,
            'total_empresas': total_empresas
        })
        
    except Exception as e:
        app.logger.error(f"Error obteniendo estad√≠sticas: {str(e)}")
        return jsonify({'error': 'Error al obtener estad√≠sticas'}), 500

# ===========================
# INICIALIZACI√ìN
# ===========================
if __name__ == '__main__':
    with app.app_context():
        # Verificar conexi√≥n a la base de datos
        try:
            from sqlalchemy import text
            db.session.execute(text('SELECT 1'))
            print("‚úÖ Conexi√≥n a la base de datos exitosa")
            
            # Contar registros
            count = db.session.query(func.count(Contrato.codigo_contrato)).scalar()
            print(f"üìä Total de contratos en la BD: {count:,}")
            
            # Crear √≠ndices si no existen (importante para performance)
            indices_sql = """
            -- √çndices para mejorar performance
            CREATE INDEX IF NOT EXISTS idx_contratos_importe 
                ON contratos.contratos(importe DESC NULLS LAST);
            
            CREATE INDEX IF NOT EXISTS idx_contratos_proveedor 
                ON contratos.contratos(proveedor_contratista);
            
            CREATE INDEX IF NOT EXISTS idx_contratos_rfc 
                ON contratos.contratos(rfc);
            
            CREATE INDEX IF NOT EXISTS idx_contratos_siglas_inst 
                ON contratos.contratos(siglas_institucion);
            
            CREATE INDEX IF NOT EXISTS idx_contratos_anio 
                ON contratos.contratos(anio_fuente);
            
            -- √çndices para b√∫squeda de texto
            CREATE INDEX IF NOT EXISTS idx_contratos_titulo_contrato 
                ON contratos.contratos USING gin(to_tsvector('spanish', titulo_contrato));
            
            CREATE INDEX IF NOT EXISTS idx_contratos_descripcion 
                ON contratos.contratos USING gin(to_tsvector('spanish', descripcion_contrato));
            """
            
            try:
                db.session.execute(text(indices_sql))
                db.session.commit()
                print("‚úÖ √çndices verificados/creados")
            except Exception as e:
                print(f"‚ö†Ô∏è No se pudieron crear algunos √≠ndices: {e}")
                db.session.rollback()
            
        except Exception as e:
            print(f"‚ùå Error de conexi√≥n a la BD: {e}")
            exit(1)
    
    # Ejecutar aplicaci√≥n
    app.run(debug=True, host='0.0.0.0', port=5000)


===============================
üìÅ Archivo: ./app/api/__init__.py
===============================
# app/api/__init__.py

from .search import search_bp
from .contracts import contracts_bp
from .stats import stats_bp

__all__ = ['search_bp', 'contracts_bp', 'stats_bp']


===============================
üìÅ Archivo: ./app/api/stats.py
===============================
# app/api/stats.py

from flask import Blueprint, jsonify
from app.services.aggregation_service import AggregationService
import logging

stats_bp = Blueprint('stats', __name__)
logger = logging.getLogger(__name__)

@stats_bp.route('/stats', methods=['GET'])
def get_stats():
    """Obtiene estad√≠sticas generales de la base de datos"""
    try:
        aggregation_service = AggregationService()
        stats = aggregation_service.get_stats()
        return jsonify(stats)
        
    except Exception as e:
        logger.error(f"Error obteniendo estad√≠sticas: {str(e)}")
        return jsonify({'error': 'Error al obtener estad√≠sticas'}), 500


===============================
üìÅ Archivo: ./app/api/contracts.py
===============================
# app/api/contracts.py

from flask import Blueprint, request, jsonify
from app.models import Contrato
from app.services.search_service import SearchService
import logging

contracts_bp = Blueprint('contracts', __name__)
logger = logging.getLogger(__name__)

@contracts_bp.route('/contracts/page', methods=['POST'])
def get_contracts_page():
    """Obtiene una p√°gina espec√≠fica de contratos (para scroll infinito)"""
    try:
        data = request.get_json()
        
        query_text = data.get('query', '').strip()
        search_type = data.get('search_type', 'todo')
        filters = data.get('filters', {})
        page = data.get('page', 1)
        per_page = min(data.get('per_page', 50), 100)  # M√°ximo 100 por p√°gina
        
        # Validaci√≥n b√°sica
        if not query_text:
            return jsonify({'error': 'Query requerido'}), 400
        
        if page < 1:
            page = 1
        
        # Usar el servicio para construir la consulta
        search_service = SearchService()
        query = search_service.build_search_query(query_text, search_type)
        
        # Aplicar filtros
        if filters:
            query = search_service.apply_filters(query, filters)
        
        # Calcular offset
        offset = (page - 1) * per_page
        
        # Obtener contratos paginados ordenados por importe
        contratos = query.order_by(
            Contrato.importe.desc().nullslast()
        ).offset(offset).limit(per_page).all()
        
        # Verificar si hay m√°s p√°ginas
        total_contratos = query.count()
        has_more = (offset + per_page) < total_contratos
        
        return jsonify({
            'contratos': [c.to_dict() for c in contratos],
            'page': page,
            'per_page': per_page,
            'has_more': has_more,
            'total': total_contratos
        })
        
    except Exception as e:
        logger.error(f"Error obteniendo p√°gina de contratos: {str(e)}")
        return jsonify({'error': 'Error al obtener contratos'}), 500


===============================
üìÅ Archivo: ./app/api/search.py
===============================
# app/api/search.py (versi√≥n con manejo de errores mejorado)

from flask import Blueprint, request, jsonify
from app.models import Contrato
from app.services.search_service import SearchService
from app.services.aggregation_service import AggregationService
from app.services.filter_service import FilterService
from app import db
from sqlalchemy import func
import logging
import time

search_bp = Blueprint('search', __name__)
logger = logging.getLogger(__name__)

@search_bp.route('/search', methods=['POST'])
def search():
    """B√∫squeda inicial - retorna agregados COMPLETOS y primeros 50 contratos"""
    try:
        start_time = time.time()
        data = request.get_json()
        
        # Validar entrada
        search_service = SearchService()
        query_text, search_type = search_service.validate_search_input(
            data.get('query', ''),
            data.get('search_type', 'todo')
        )
        
        filters = data.get('filters', {})
        
        if not query_text:
            return jsonify({'error': 'Por favor ingresa un t√©rmino de b√∫squeda'}), 400
        
        # Construir la consulta base
        base_query = search_service.build_search_query(query_text, search_type)
        
        # Aplicar filtros
        if filters:
            base_query = search_service.apply_filters(base_query, filters)
        
        logger.info(f"B√∫squeda: {query_text}, tipo: {search_type}, filtros: {filters}")
        
        # 1. Obtener agregados COMPLETOS de TODOS los resultados
        aggregation_service = AggregationService()
        agregados = aggregation_service.obtener_agregados_optimizado(base_query)
        
        # 2. Obtener solo los primeros 50 contratos para mostrar
        contratos = base_query.order_by(
            Contrato.importe.desc().nullslast()
        ).limit(50).all()
        
        # 3. Obtener filtros disponibles
        filter_service = FilterService() 
        filtros_disponibles = filter_service.obtener_filtros_disponibles(base_query)
        
        elapsed_time = time.time() - start_time
        logger.info(f"B√∫squeda completada en {elapsed_time:.2f} segundos")
        
        resultado = {
            'query': query_text,
            'search_type': search_type,
            'total': agregados['total_contratos'],
            'monto_total': agregados['monto_total'],
            'proveedores': agregados['top_proveedores'],
            'instituciones': agregados['top_instituciones'],
            'contratos': [c.to_dict() for c in contratos],
            'filtros_disponibles': filtros_disponibles,
            'page': 1,
            'has_more': agregados['total_contratos'] > 50,
            'tiempo_busqueda': f"{elapsed_time:.2f}s"
        }
        
        return jsonify(resultado)
        
    except ValueError as ve:
        db.session.rollback()  # Rollback en caso de error
        return jsonify({'error': str(ve)}), 400
    except Exception as e:
        db.session.rollback()  # Rollback en caso de error
        logger.error(f"Error en b√∫squeda: {str(e)}")
        return jsonify({'error': 'Error al procesar la b√∫squeda'}), 500
    finally:
        db.session.close()  # Siempre cerrar la sesi√≥n

@search_bp.route('/aggregates', methods=['POST'])
def get_aggregates_only():
    """Obtiene solo los agregados de TODOS los resultados"""
    try:
        data = request.get_json()
        
        search_service = SearchService()
        query_text, search_type = search_service.validate_search_input(
            data.get('query', ''),
            data.get('search_type', 'todo')
        )
        
        filters = data.get('filters', {})
        
        if not query_text:
            return jsonify({'error': 'Query requerido'}), 400
        
        base_query = search_service.build_search_query(query_text, search_type)
        
        if filters:
            base_query = search_service.apply_filters(base_query, filters)
        
        # Obtener agregados completos
        aggregation_service = AggregationService()
        agregados = aggregation_service.obtener_agregados_optimizado(base_query)
        
        return jsonify(agregados)
        
    except Exception as e:
        db.session.rollback()
        logger.error(f"Error obteniendo agregados: {str(e)}")
        return jsonify({'error': 'Error al obtener agregados'}), 500
    finally:
        db.session.close()


===============================
üìÅ Archivo: ./app/templates/index.html
===============================
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LaLupa üîç - Buscador de Contratos Gubernamentales</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
</head>
<body>
    <div class="container">
        <!-- Header -->
        <header>
            <h1>LaLupa üîç</h1>
            <p class="subtitle">Buscador de Contratos Gubernamentales de M√©xico</p>
        </header>

        <!-- Barra de b√∫squeda -->
        <div class="search-container">
            <div class="search-box">
                <input type="text" id="searchInput" placeholder="Buscar contratos..." autofocus>
                <button id="searchBtn" type="button" onclick="buscar()">Buscar</button>
            </div>
            <div class="search-options">
                <label><input type="radio" name="searchType" value="descripcion" checked> Descripci√≥n</label>
                <label><input type="radio" name="searchType" value="titulo"> T√≠tulo</label>
                <label><input type="radio" name="searchType" value="empresa"> Proveedor</label>
                <label><input type="radio" name="searchType" value="rfc"> RFC</label>
                <label><input type="radio" name="searchType" value="institucion"> Instituci√≥n</label>
                <label><input type="radio" name="searchType" value="todo"> Todo</label>
            </div>
        </div>

        <!-- Loading global -->
        <div id="loading" class="loading hidden">
            <div class="spinner"></div>
            <p>Buscando contratos...</p>
        </div>

        <!-- √Årea de resultados -->
        <div id="resultsArea" class="hidden">
            
            <!-- Resumen de resultados -->
            <div id="resultsSummary" class="results-summary"></div>
            
            <!-- Barra de filtros -->
            <div id="filtersBar" class="filters-bar hidden">
                <div class="filter-label">REFINAR B√öSQUEDA:</div>
                <div class="filter-buttons" id="filterButtons"></div>
                <div id="activeFilters" class="active-filters"></div>
            </div>

            <!-- Secci√≥n de empresas -->
            <div id="empresasSection" class="results-section">
                <h2>üè¢ PROVEEDORES</h2>
                <div id="empresasList" class="grouped-list"></div>
            </div>

            <!-- Secci√≥n de instituciones -->
            <div id="institucionesSection" class="results-section">
                <h2>üèõÔ∏è INSTITUCIONES</h2>
                <div id="institucionesList" class="grouped-list"></div>
            </div>

            <!-- Secci√≥n de contratos -->
            <div id="contratosSection" class="results-section">
                <h2>üìÑ CONTRATOS</h2>
                <div id="contratosList" class="contracts-list"></div>
                <!-- Sentinel para scroll infinito -->
                <div id="scrollSentinel"></div>
            </div>
        </div>

        <!-- Mensaje de error -->
        <div id="errorMessage" class="error-message hidden"></div>
    </div>

    <!-- Modal para filtros -->
    <div id="filterModal" class="modal hidden">
        <div class="modal-content">
            <span class="close" onclick="closeFilterModal()">&times;</span>
            <h3 id="filterModalTitle">Filtrar por</h3>
            <div id="filterModalBody"></div>
            <button type="button" onclick="applyFilters()" class="apply-btn">Aplicar filtros</button>
        </div>
    </div>

    <script src="{{ url_for('static', filename='js/app.js') }}"></script>
</body>
</html>



===============================
üìÅ Archivo: ./app/services/filter_service.py
===============================
# app/services/filter_service.py

"""Servicio de filtros"""
from sqlalchemy import func
from app import db
import logging

logger = logging.getLogger(__name__)

class FilterService:
    """Servicio para manejar filtros"""
    
    def obtener_filtros_disponibles(self, base_query):
        """Obtiene los valores √∫nicos para filtros usando consultas optimizadas"""
        try:
            from app.models import Contrato
            filtros = {}
            
            # Crear alias para la subquery
            subquery = base_query.subquery()
            
            # Top 10 instituciones m√°s frecuentes
            inst_query = db.session.query(
                subquery.c.siglas_institucion,
                func.count('*').label('count')
            ).group_by(
                subquery.c.siglas_institucion
            ).filter(
                subquery.c.siglas_institucion.isnot(None)
            ).order_by(
                func.count('*').desc()
            ).limit(10)
            
            filtros['instituciones'] = {
                i.siglas_institucion: i.count for i in inst_query
            }
            
            # Top 10 tipos de contrataci√≥n
            tipos_query = db.session.query(
                subquery.c.tipo_contratacion,
                func.count('*').label('count')
            ).group_by(
                subquery.c.tipo_contratacion
            ).filter(
                subquery.c.tipo_contratacion.isnot(None)
            ).order_by(
                func.count('*').desc()
            ).limit(10)
            
            filtros['tipos'] = {
                t.tipo_contratacion: t.count for t in tipos_query
            }
            
            # Top 10 tipos de procedimiento
            proc_query = db.session.query(
                subquery.c.tipo_procedimiento,
                func.count('*').label('count')
            ).group_by(
                subquery.c.tipo_procedimiento
            ).filter(
                subquery.c.tipo_procedimiento.isnot(None)
            ).order_by(
                func.count('*').desc()
            ).limit(10)
            
            filtros['procedimientos'] = {
                p.tipo_procedimiento: p.count for p in proc_query
            }
            
            # Top 10 a√±os
            anios_query = db.session.query(
                subquery.c.anio_fuente,
                func.count('*').label('count')
            ).group_by(
                subquery.c.anio_fuente
            ).filter(
                subquery.c.anio_fuente.isnot(None)
            ).order_by(
                subquery.c.anio_fuente.desc()
            ).limit(10)
            
            filtros['anios'] = {
                str(a.anio_fuente): a.count for a in anios_query
            }
            
            # Top 5 estatus
            estatus_query = db.session.query(
                subquery.c.estatus_contrato,
                func.count('*').label('count')
            ).group_by(
                subquery.c.estatus_contrato
            ).filter(
                subquery.c.estatus_contrato.isnot(None)
            ).order_by(
                func.count('*').desc()
            ).limit(5)
            
            filtros['estatus'] = {
                e.estatus_contrato: e.count for e in estatus_query
            }
            
            return filtros
            
        except Exception as e:
            logger.error(f"Error obteniendo filtros: {str(e)}")
            return {}


===============================
üìÅ Archivo: ./app/services/__init__.py
===============================
# app/services/__init__.py

from .search_service import SearchService
from .aggregation_service import AggregationService
from .filter_service import FilterService

__all__ = ['SearchService', 'AggregationService', 'FilterService']


===============================
üìÅ Archivo: ./app/services/search_service.py
===============================
# app/services/search_service.py

"""Servicio de b√∫squeda de contratos"""
import re
from sqlalchemy import or_

class SearchService:
    """Servicio para b√∫squedas de contratos"""
    
    def validate_search_input(self, query_text, search_type):
        """Valida y sanitiza la entrada de b√∫squeda"""
        query_text = query_text.strip()
        
        if len(query_text) > 200:
            raise ValueError('T√©rmino de b√∫squeda demasiado largo')
        
        # Remover caracteres peligrosos pero mantener acentos
        query_text = re.sub(r'[^\w\s\-.,√°√©√≠√≥√∫√±√Å√â√ç√ì√ö√ë]', '', query_text)
        
        # Validar tipo de b√∫squeda
        valid_types = ['descripcion', 'titulo', 'empresa', 'rfc', 'institucion', 'todo']
        if search_type not in valid_types:
            search_type = 'todo'
        
        # Validaci√≥n especial para RFC
        if search_type == 'rfc':
            rfc_pattern = r'^[A-Z√ë&]{3,4}\d{6}[A-Z0-9]{3}$'
            if not re.match(rfc_pattern, query_text.upper()):
                raise ValueError('Formato de RFC inv√°lido')
        
        return query_text, search_type
    
    def build_search_query(self, query_text, search_type):
        """Construye la consulta seg√∫n el tipo de b√∫squeda"""
        # Importar aqu√≠ para evitar import circular
        from app.models import Contrato
        
        query = Contrato.query
        
        if search_type == 'descripcion':
            query = query.filter(
                Contrato.descripcion_contrato.ilike(f'%{query_text}%')
            )
        elif search_type == 'titulo':
            query = query.filter(or_(
                Contrato.titulo_contrato.ilike(f'%{query_text}%'),
                Contrato.titulo_expediente.ilike(f'%{query_text}%')
            ))
        elif search_type == 'empresa':
            query = query.filter(
                Contrato.proveedor_contratista.ilike(f'%{query_text}%')
            )
        elif search_type == 'rfc':
            query = query.filter(Contrato.rfc == query_text.upper())
        elif search_type == 'institucion':
            query = query.filter(or_(
                Contrato.institucion.ilike(f'%{query_text}%'),
                Contrato.siglas_institucion.ilike(f'%{query_text}%')
            ))
        else:  # todo
            query = query.filter(or_(
                Contrato.descripcion_contrato.ilike(f'%{query_text}%'),
                Contrato.titulo_contrato.ilike(f'%{query_text}%'),
                Contrato.titulo_expediente.ilike(f'%{query_text}%'),
                Contrato.proveedor_contratista.ilike(f'%{query_text}%'),
                Contrato.institucion.ilike(f'%{query_text}%'),
                Contrato.siglas_institucion.ilike(f'%{query_text}%')
            ))
        
        return query
    
    def apply_filters(self, query, filters):
        """Aplica filtros adicionales a la consulta"""
        from app.models import Contrato
        
        if not filters:
            return query
        
        # Los nombres deben coincidir con lo que env√≠a el frontend
        if filters.get('instituciones'):  # Plural
            query = query.filter(
                Contrato.siglas_institucion.in_(filters['instituciones'])
            )
        
        if filters.get('tipos'):  # Plural
            query = query.filter(
                Contrato.tipo_contratacion.in_(filters['tipos'])
            )
        
        if filters.get('procedimientos'):  # Plural
            query = query.filter(
                Contrato.tipo_procedimiento.in_(filters['procedimientos'])
            )
        if filters.get('anios'):  # Plural
            try:
                # Como anio_fuente es VARCHAR, convertir los a√±os a strings
                anos_str = [str(a) for a in filters['anios']]
                query = query.filter(Contrato.anio_fuente.in_(anos_str))
            except (ValueError, TypeError):
                pass
    
        
        if filters.get('estatus'):  # Singular
            query = query.filter(
                Contrato.estatus_contrato.in_(filters['estatus'])
            )
        
        return query


===============================
üìÅ Archivo: ./app/services/aggregation_service.py
===============================
# app/services/aggregation_service.py

"""Servicio de agregaci√≥n de datos"""
from sqlalchemy import func
from app import db
import logging

logger = logging.getLogger(__name__)

class AggregationService:
    """Servicio para agregaciones y estad√≠sticas"""
    
    def obtener_agregados_optimizado(self, base_query):
        """Obtiene agregados usando consultas SQL optimizadas"""
        try:
            from app.models import Contrato
            
            # Total de contratos y monto total
            subquery = base_query.subquery()
            totales = db.session.query(
                func.count('*').label('total'),
                func.sum(subquery.c.importe).label('monto_total')
            ).select_from(subquery).first()
            
            total_contratos = totales.total or 0
            monto_total = float(totales.monto_total or 0)
            
            # Top 20 proveedores
            proveedores_query = db.session.query(
                subquery.c.proveedor_contratista.label('nombre'),
                subquery.c.rfc.label('rfc'),
                func.count('*').label('num_contratos'),
                func.sum(subquery.c.importe).label('monto_total')
            ).filter(
                subquery.c.proveedor_contratista.isnot(None)
            ).group_by(
                subquery.c.proveedor_contratista,
                subquery.c.rfc
            ).order_by(
                func.sum(subquery.c.importe).desc().nullslast()
            ).limit(20)
            
            proveedores = []
            for p in proveedores_query:
                proveedores.append({
                    'nombre': p.nombre,
                    'rfc': p.rfc if p.rfc and p.rfc != 'XAXX010101000' else 'RFC Gen√©rico',
                    'num_contratos': p.num_contratos,
                    'monto_total': float(p.monto_total or 0)
                })
            
            # Top 20 instituciones
            instituciones_query = db.session.query(
                subquery.c.institucion.label('nombre'),
                subquery.c.siglas_institucion.label('siglas'),
                func.count('*').label('num_contratos'),
                func.sum(subquery.c.importe).label('monto_total')
            ).filter(
                subquery.c.siglas_institucion.isnot(None)
            ).group_by(
                subquery.c.institucion,
                subquery.c.siglas_institucion
            ).order_by(
                func.sum(subquery.c.importe).desc().nullslast()
            ).limit(20)
            
            instituciones = []
            for i in instituciones_query:
                instituciones.append({
                    'nombre': i.nombre,
                    'siglas': i.siglas,
                    'num_contratos': i.num_contratos,
                    'monto_total': float(i.monto_total or 0)
                })
            
            return {
                'total_contratos': total_contratos,
                'monto_total': monto_total,
                'top_proveedores': proveedores,
                'top_instituciones': instituciones
            }
            
        except Exception as e:
            logger.error(f"Error en agregados: {str(e)}")
            return {
                'total_contratos': 0,
                'monto_total': 0,
                'top_proveedores': [],
                'top_instituciones': []
            }
    
    def get_stats(self):
        """Obtiene estad√≠sticas generales de la base de datos"""
        try:
            from app.models import Contrato
            
            total_contratos = db.session.query(
                func.count(Contrato.codigo_contrato)
            ).scalar()
            
            total_instituciones = db.session.query(
                func.count(func.distinct(Contrato.siglas_institucion))
            ).scalar()
            
            total_empresas = db.session.query(
                func.count(func.distinct(Contrato.rfc))
            ).scalar()
            
            return {
                'total_contratos': total_contratos,
                'total_instituciones': total_instituciones,
                'total_empresas': total_empresas
            }
        except Exception as e:
            logger.error(f"Error obteniendo estad√≠sticas: {str(e)}")
            return {
                'total_contratos': 0,
                'total_instituciones': 0,
                'total_empresas': 0
            }


===============================
üìÅ Archivo: ./app/routes.py
===============================
# app/routes.py
from flask import Blueprint, render_template, request, jsonify
from app import db
from sqlalchemy import func, text

main_bp = Blueprint('main', __name__)

@main_bp.route('/')
def index():
    """P√°gina principal"""
    return render_template('index.html')

@main_bp.route('/api/filters', methods=['GET'])
def get_filters():
    """
    Obtener opciones disponibles para filtros
    """
    try:
        from app.models.contrato import Contrato
        
        # Obtener instituciones √∫nicas con conteo
        instituciones = db.session.query(
            Contrato.siglas_institucion,
            Contrato.institucion,
            func.count(Contrato.codigo_contrato).label('total')
        ).filter(
            Contrato.siglas_institucion != None
        ).group_by(
            Contrato.siglas_institucion,
            Contrato.institucion
        ).having(
            func.count(Contrato.codigo_contrato) > 10
        ).order_by(
            text('total DESC')
        ).limit(100).all()
        
        # A√±os disponibles
        anios = db.session.query(
            Contrato.anio_fuente
        ).distinct().filter(
            Contrato.anio_fuente != None
        ).order_by(
            Contrato.anio_fuente.desc()
        ).all()
        
        # Tipos de contrataci√≥n
        tipos_contratacion = db.session.query(
            Contrato.tipo_contratacion
        ).distinct().filter(
            Contrato.tipo_contratacion != None
        ).all()
        
        # Tipos de procedimiento
        tipos_procedimiento = db.session.query(
            Contrato.tipo_procedimiento
        ).distinct().filter(
            Contrato.tipo_procedimiento != None
        ).all()
        
        return jsonify({
            'instituciones': [
                {
                    'siglas': inst[0],
                    'nombre': inst[1] or inst[0],
                    'total': inst[2]
                }
                for inst in instituciones
            ],
            'anios': [a[0] for a in anios if a[0]],
            'tipos_contratacion': [t[0] for t in tipos_contratacion if t[0]],
            'tipos_procedimiento': [t[0] for t in tipos_procedimiento if t[0]]
        })
        
    except Exception as e:
        print(f"Error obteniendo filtros: {str(e)}")
        return jsonify({'error': 'Error al obtener filtros'}), 500

@main_bp.route('/api/stats', methods=['GET'])
def api_stats():
    """
    Estad√≠sticas generales de la plataforma
    """
    try:
        from app.models.contrato import Contrato
        
        stats = {
            'total_contratos': db.session.query(func.count(Contrato.codigo_contrato)).scalar() or 0,
            'total_importe': float(db.session.query(func.sum(Contrato.importe)).scalar() or 0),
            'proveedores_unicos': db.session.query(func.count(func.distinct(Contrato.proveedor_contratista))).scalar() or 0,
            'instituciones_unicas': db.session.query(func.count(func.distinct(Contrato.siglas_institucion))).scalar() or 0
        }
        
        return jsonify(stats)
        
    except Exception as e:
        print(f"Error en stats: {str(e)}")
        return jsonify({'error': 'Error al obtener estad√≠sticas'}), 500

@main_bp.route('/health')
def health():
    """Health check endpoint"""
    return jsonify({'status': 'healthy'}), 200


===============================
üìÅ Archivo: ./config/config.py
===============================
import os
from dotenv import load_dotenv

load_dotenv()

class Config:
    SECRET_KEY = os.environ.get('SECRET_KEY') or 'dev-secret-key'
    SQLALCHEMY_DATABASE_URI = os.environ.get('DATABASE_URL')
    SQLALCHEMY_TRACK_MODIFICATIONS = False
    SQLALCHEMY_ENGINE_OPTIONS = {
        'pool_size': 10,
        'pool_recycle': 3600,
        'pool_pre_ping': True
    }




===============================
üìÅ Archivo: ./config/__init__.py
===============================
# app/config.py
import os
from datetime import timedelta

class Config:
    """Configuraci√≥n base"""
    SECRET_KEY = os.environ.get('SECRET_KEY') or 'dev-secret-key-change-in-production'
    
    # Database
    SQLALCHEMY_TRACK_MODIFICATIONS = False
    SQLALCHEMY_RECORD_QUERIES = True
    
    # JSON
    JSON_AS_ASCII = False
    JSON_SORT_KEYS = False
    
    # Pagination
    CONTRACTS_PER_PAGE = 50
    MAX_CONTRACTS_PER_PAGE = 100
    
    # Cache
    CACHE_TYPE = 'simple'
    CACHE_DEFAULT_TIMEOUT = 300
    
    # ===== CONFIGURACI√ìN DE LOGGING =====
    # Directorio de logs
    LOG_DIR = 'logs'
    LOG_TO_STDOUT = os.environ.get('LOG_TO_STDOUT', 'false').lower() == 'true'
    
    # Niveles de logging
    LOG_LEVEL = os.environ.get('LOG_LEVEL', 'INFO')
    
    # Configuraci√≥n de archivos de log
    LOG_FILE_MAX_BYTES = 10485760  # 10MB
    LOG_FILE_BACKUP_COUNT = 10
    
    # Tipos de logs a mantener
    LOG_TYPES = {
        'app': {
            'filename': 'app.log',
            'level': 'INFO',
            'backup_count': 10
        },
        'access': {
            'filename': 'access.log',
            'level': 'INFO',
            'backup_count': 30  # M√°s hist√≥rico para an√°lisis de uso
        },
        'search': {
            'filename': 'search.log',
            'level': 'INFO',
            'backup_count': 20
        },
        'error': {
            'filename': 'error.log',
            'level': 'ERROR',
            'backup_count': 10
        },
        'performance': {
            'filename': 'performance.log',
            'level': 'INFO',
            'backup_count': 15
        }
    }
    
    # Configuraci√≥n de m√©tricas
    METRICS_ENABLED = True
    METRICS_TRACK_UNIQUE_USERS = True
    METRICS_ANONYMIZE_IPS = True  # Hash IPs for privacy
    METRICS_SESSION_TIMEOUT = timedelta(minutes=30)  # Para calcular sesiones
    
    # Configuraci√≥n de tracking
    TRACK_USER_AGENTS = True
    TRACK_SEARCH_TERMS = True
    TRACK_RESPONSE_TIME = True
    TRACK_DATABASE_QUERIES = False  # Activar solo en desarrollo
    
    # Alertas y monitoreo
    ALERT_ON_SLOW_REQUESTS = True
    SLOW_REQUEST_THRESHOLD_MS = 1000  # 1 segundo
    ALERT_ON_HIGH_ERROR_RATE = True
    ERROR_RATE_THRESHOLD = 0.05  # 5% de errores
    
    # Privacidad y seguridad en logs
    LOG_SANITIZE_FIELDS = ['password', 'token', 'api_key', 'secret', 'rfc']
    LOG_EXCLUDE_PATHS = ['/health', '/metrics', '/static']  # No loggear estos paths
    
    # Retenci√≥n de logs
    LOG_RETENTION_DAYS = 90  # D√≠as a mantener logs antes de archivar
    LOG_ARCHIVE_ENABLED = False  # Activar en producci√≥n si se necesita

class DevelopmentConfig(Config):
    """Configuraci√≥n de desarrollo"""
    DEBUG = True
    TESTING = False
    
    # Database - Usando tu conexi√≥n de DigitalOcean
    DB_USER = os.getenv('DB_USER', 'lalupa')
    DB_PASSWORD = os.getenv('DB_PASSWORD', 'Kx9mP!7Nq3Lw5Rv_')
    DB_HOST = os.getenv('DB_HOST', 'db-postgresql-nyc1-16758-do-user-15464590-0.k.db.ondigitalocean.com')
    DB_PORT = os.getenv('DB_PORT', '25060')
    DB_NAME = os.getenv('DB_NAME', 'defaultdb')
    
    # Importante: sslmode=require para DigitalOcean
    SQLALCHEMY_DATABASE_URI = f'postgresql://{DB_USER}:{DB_PASSWORD}@{DB_HOST}:{DB_PORT}/{DB_NAME}?sslmode=require'
    
    # Development specific
    SQLALCHEMY_ECHO = False  # Set to True to see SQL queries
    
    # ===== LOGGING EN DESARROLLO =====
    LOG_LEVEL = 'DEBUG'
    TRACK_DATABASE_QUERIES = True  # Ver queries SQL en logs
    LOG_TO_STDOUT = True  # Tambi√©n mostrar logs en consola
    
    # M√°s verbose en desarrollo
    LOG_FORMAT = '%(asctime)s - %(name)s - %(levelname)s - %(filename)s:%(lineno)d - %(message)s'
    
    # M√©tricas m√°s detalladas en desarrollo
    METRICS_INCLUDE_DEBUG = True
    METRICS_SAMPLE_RATE = 1.0  # Loggear todo (100%)

class ProductionConfig(Config):
    """Configuraci√≥n de producci√≥n"""
    DEBUG = False
    TESTING = False
    
    # Database from environment variable
    SQLALCHEMY_DATABASE_URI = os.environ.get('DATABASE_URL')
    
    # Security
    SESSION_COOKIE_SECURE = True
    SESSION_COOKIE_HTTPONLY = True
    SESSION_COOKIE_SAMESITE = 'Lax'
    
    # Performance - Importante para DigitalOcean
    SQLALCHEMY_POOL_SIZE = 10
    SQLALCHEMY_POOL_RECYCLE = 3600
    SQLALCHEMY_POOL_TIMEOUT = 30
    SQLALCHEMY_ENGINE_OPTIONS = {
        'pool_pre_ping': True,
        'pool_recycle': 3600,
        'connect_args': {
            'connect_timeout': 10,
            'options': '-c statement_timeout=30000'  # 30 segundos timeout
        }
    }
    
    # ===== LOGGING EN PRODUCCI√ìN =====
    LOG_LEVEL = os.environ.get('LOG_LEVEL', 'WARNING')
    TRACK_DATABASE_QUERIES = False  # No loggear queries en producci√≥n
    
    # Logs m√°s compactos en producci√≥n
    LOG_FORMAT = 'json'  # Usar formato JSON estructurado
    
    # Configuraci√≥n de m√©tricas para producci√≥n
    METRICS_SAMPLE_RATE = 0.1  # Samplear 10% de requests para reducir volumen
    METRICS_INCLUDE_DEBUG = False
    
    # Alertas activas en producci√≥n
    ALERT_EMAIL_ENABLED = True
    ALERT_EMAIL_TO = os.environ.get('ALERT_EMAIL', 'admin@example.com')
    ALERT_EMAIL_FROM = 'noreply@contratos.gob.mx'
    
    # Integraci√≥n con servicios externos (opcional)
    SENTRY_DSN = os.environ.get('SENTRY_DSN')  # Para error tracking
    DATADOG_API_KEY = os.environ.get('DATADOG_API_KEY')  # Para m√©tricas
    
    # Archivado de logs antiguos
    LOG_ARCHIVE_ENABLED = True
    LOG_ARCHIVE_COMPRESSION = 'gzip'
    LOG_ARCHIVE_PATH = '/var/log/contratos/archive'
    
    # Rate limiting para logs (evitar flood)
    LOG_RATE_LIMIT_ENABLED = True
    LOG_RATE_LIMIT_PER_MINUTE = 1000

class TestingConfig(Config):
    """Configuraci√≥n para tests"""
    TESTING = True
    DEBUG = True
    SQLALCHEMY_DATABASE_URI = 'sqlite:///:memory:'
    WTF_CSRF_ENABLED = False
    
    # ===== LOGGING EN TESTS =====
    LOG_LEVEL = 'ERROR'  # Solo errores en tests
    LOG_TO_STDOUT = False  # No mostrar logs en tests
    METRICS_ENABLED = False  # Desactivar m√©tricas en tests
    
    # Configuraci√≥n espec√≠fica para tests
    LOG_DIR = 'test_logs'
    LOG_FILE_MAX_BYTES = 1048576  # 1MB para tests

# Diccionario de configuraciones
config = {
    'development': DevelopmentConfig,
    'production': ProductionConfig,
    'testing': TestingConfig,
    'default': DevelopmentConfig
}

# Funci√≥n helper para obtener configuraci√≥n actual
def get_config():
    """Obtiene la configuraci√≥n basada en la variable de entorno FLASK_ENV"""
    env = os.environ.get('FLASK_ENV', 'development')
    return config.get(env, config['default'])


===============================
üìÅ Archivo: ./view_metrics.py
===============================
#!/usr/bin/env python3
# view_metrics.py - Script para ver m√©tricas del sistema de logging

import json
import os
from datetime import datetime, timedelta
from collections import Counter
from pathlib import Path

def parse_json_logs(log_file):
    """Parse JSON logs from file"""
    logs = []
    if not os.path.exists(log_file):
        return logs
        
    with open(log_file, 'r') as f:
        for line in f:
            try:
                logs.append(json.loads(line.strip()))
            except:
                continue
    return logs

def show_recent_activity():
    """Muestra actividad reciente"""
    print("\n" + "="*60)
    print("üìä ACTIVIDAD RECIENTE (√öltimos 30 minutos)")
    print("="*60)
    
    # Leer logs de acceso
    access_logs = parse_json_logs('logs/access.log')
    
    # Filtrar √∫ltimos 30 minutos
    thirty_min_ago = datetime.utcnow() - timedelta(minutes=30)
    recent_logs = [
        log for log in access_logs 
        if datetime.fromisoformat(log.get('timestamp', '')) > thirty_min_ago
    ]
    
    if recent_logs:
        print(f"\n‚úÖ Total de requests: {len(recent_logs)}")
        
        # Endpoints m√°s visitados
        endpoints = Counter(log.get('endpoint') for log in recent_logs if log.get('endpoint'))
        print("\nüéØ Top Endpoints visitados:")
        for endpoint, count in endpoints.most_common(5):
            print(f"   - {endpoint}: {count} visitas")
        
        # Usuarios √∫nicos
        unique_users = set(log.get('user_fingerprint') for log in recent_logs if log.get('user_fingerprint'))
        print(f"\nüë• Usuarios √∫nicos: {len(unique_users)}")
        
        # Dispositivos
        mobile = sum(1 for log in recent_logs if log.get('is_mobile'))
        desktop = len(recent_logs) - mobile
        print(f"\nüì± Dispositivos:")
        print(f"   - Desktop: {desktop} ({desktop*100//len(recent_logs)}%)")
        print(f"   - Mobile: {mobile} ({mobile*100//len(recent_logs)}%)")
    else:
        print("‚ùå No hay actividad en los √∫ltimos 30 minutos")

def show_searches():
    """Muestra b√∫squedas realizadas"""
    print("\n" + "="*60)
    print("üîç B√öSQUEDAS REALIZADAS")
    print("="*60)
    
    search_logs = parse_json_logs('logs/search.log')
    
    if search_logs:
        # √öltimas 10 b√∫squedas
        print("\nüìù √öltimas 10 b√∫squedas:")
        for log in search_logs[-10:]:
            params = log.get('search_params', {})
            results = log.get('results_count', 0)
            time = log.get('execution_time_ms', 0)
            timestamp = log.get('timestamp', '')[:19]
            
            query = params.get('q', 'Sin t√©rmino')
            print(f"\n   [{timestamp}]")
            print(f"   B√∫squeda: '{query}'")
            print(f"   Resultados: {results} | Tiempo: {time}ms")
            
            # Mostrar filtros si los hay
            filters = {k: v for k, v in params.items() if k != 'q' and v}
            if filters:
                print(f"   Filtros: {filters}")
        
        # T√©rminos m√°s buscados
        all_terms = []
        for log in search_logs:
            term = log.get('search_params', {}).get('q')
            if term:
                all_terms.append(term.lower())
        
        if all_terms:
            top_terms = Counter(all_terms).most_common(10)
            print("\nüèÜ Top 10 t√©rminos m√°s buscados:")
            for term, count in top_terms:
                print(f"   - '{term}': {count} veces")
        
        # Estad√≠sticas
        total_searches = len(search_logs)
        with_filters = sum(1 for log in search_logs if log.get('has_filters'))
        no_results = sum(1 for log in search_logs if log.get('results_count', 0) == 0)
        
        print(f"\nüìà Estad√≠sticas totales:")
        print(f"   - Total de b√∫squedas: {total_searches}")
        print(f"   - Con filtros: {with_filters} ({with_filters*100//total_searches if total_searches else 0}%)")
        print(f"   - Sin resultados: {no_results} ({no_results*100//total_searches if total_searches else 0}%)")
    else:
        print("‚ùå No hay b√∫squedas registradas a√∫n")

def show_errors():
    """Muestra errores recientes"""
    print("\n" + "="*60)
    print("‚ùå ERRORES RECIENTES")
    print("="*60)
    
    error_logs = parse_json_logs('logs/error.log')
    
    if error_logs:
        print(f"\nTotal de errores: {len(error_logs)}")
        
        # √öltimos 5 errores
        print("\nüî¥ √öltimos 5 errores:")
        for log in error_logs[-5:]:
            timestamp = log.get('timestamp', '')[:19]
            error_type = log.get('error_type', 'Unknown')
            message = log.get('error_message', 'Sin mensaje')
            path = log.get('path', 'Unknown')
            
            print(f"\n   [{timestamp}]")
            print(f"   Tipo: {error_type}")
            print(f"   Path: {path}")
            print(f"   Mensaje: {message[:100]}...")
        
        # Tipos de error m√°s comunes
        error_types = Counter(log.get('error_type') for log in error_logs)
        print("\nüìä Tipos de error m√°s comunes:")
        for error_type, count in error_types.most_common(5):
            print(f"   - {error_type}: {count} veces")
    else:
        print("‚úÖ No hay errores registrados (¬°Excelente!)")

def show_performance():
    """Muestra m√©tricas de performance"""
    print("\n" + "="*60)
    print("‚ö° M√âTRICAS DE PERFORMANCE")
    print("="*60)
    
    access_logs = parse_json_logs('logs/access.log')
    
    # Filtrar logs con response_time
    perf_logs = [log for log in access_logs if log.get('response_time')]
    
    if perf_logs:
        response_times = [log['response_time'] for log in perf_logs]
        response_times.sort()
        
        avg_time = sum(response_times) / len(response_times)
        median_time = response_times[len(response_times)//2]
        p95_time = response_times[int(len(response_times) * 0.95)] if len(response_times) > 20 else max(response_times)
        slow_requests = sum(1 for t in response_times if t > 1000)
        
        print(f"\nüìä Tiempos de respuesta (√∫ltimas {len(response_times)} peticiones):")
        print(f"   - Promedio: {avg_time:.2f}ms")
        print(f"   - Mediana: {median_time:.2f}ms")
        print(f"   - P95: {p95_time:.2f}ms")
        print(f"   - M√°s r√°pido: {min(response_times):.2f}ms")
        print(f"   - M√°s lento: {max(response_times):.2f}ms")
        print(f"   - Requests lentos (>1s): {slow_requests}")
        
        # Endpoints m√°s lentos
        endpoint_times = {}
        for log in perf_logs:
            endpoint = log.get('endpoint', 'unknown')
            time = log.get('response_time', 0)
            if endpoint not in endpoint_times:
                endpoint_times[endpoint] = []
            endpoint_times[endpoint].append(time)
        
        # Calcular promedio por endpoint
        endpoint_avg = {
            endpoint: sum(times)/len(times) 
            for endpoint, times in endpoint_times.items()
        }
        
        print("\nüêå Endpoints m√°s lentos (promedio):")
        for endpoint, avg in sorted(endpoint_avg.items(), key=lambda x: x[1], reverse=True)[:5]:
            print(f"   - {endpoint}: {avg:.2f}ms")
    else:
        print("‚ùå No hay m√©tricas de performance a√∫n")

def show_live_tail():
    """Muestra logs en tiempo real"""
    print("\n" + "="*60)
    print("üëÅÔ∏è  LOGS EN TIEMPO REAL")
    print("="*60)
    print("\nPara ver logs en tiempo real, ejecuta estos comandos en tu terminal:\n")
    
    commands = [
        ("Ver todo el tr√°fico", "tail -f logs/access.log | python -m json.tool"),
        ("Ver b√∫squedas en vivo", "tail -f logs/search.log | python -m json.tool"),
        ("Ver errores", "tail -f logs/error.log"),
        ("Ver todos a la vez", "tail -f logs/*.log"),
        ("Filtrar por t√©rmino", "tail -f logs/access.log | grep 'contract'"),
    ]
    
    for desc, cmd in commands:
        print(f"üìå {desc}:")
        print(f"   $ {cmd}\n")

def check_log_files():
    """Verifica que existan los archivos de log"""
    print("\n" + "="*60)
    print("üìÅ ESTADO DE ARCHIVOS DE LOG")
    print("="*60)
    
    log_dir = Path('logs')
    if not log_dir.exists():
        print("‚ùå El directorio 'logs/' no existe. Aseg√∫rate de que la app est√© corriendo.")
        return False
    
    log_files = ['app.log', 'access.log', 'search.log', 'error.log', 'performance.log']
    
    print("\nArchivos de log:")
    for log_file in log_files:
        file_path = log_dir / log_file
        if file_path.exists():
            size = file_path.stat().st_size
            if size > 1024*1024:  # M√°s de 1MB
                size_str = f"{size / (1024*1024):.2f} MB"
            elif size > 1024:  # M√°s de 1KB
                size_str = f"{size / 1024:.2f} KB"
            else:
                size_str = f"{size} bytes"
            
            # Contar l√≠neas
            with open(file_path, 'r') as f:
                lines = sum(1 for _ in f)
            
            print(f"   ‚úÖ {log_file}: {size_str} ({lines} l√≠neas)")
        else:
            print(f"   ‚ö†Ô∏è  {log_file}: No existe a√∫n")
    
    return True

def main():
    """Funci√≥n principal"""
    print("\n" + "="*70)
    print(" üîç SISTEMA DE M√âTRICAS Y LOGGING - CONTRATOS GUBERNAMENTALES")
    print("="*70)
    
    # Verificar archivos
    if not check_log_files():
        return
    
    # Mostrar todas las m√©tricas
    show_recent_activity()
    show_searches()
    show_performance()
    show_errors()
    show_live_tail()
    
    print("\n" + "="*70)
    print(" üí° TIP: Ejecuta este script regularmente para monitorear tu app")
    print("="*70)
    print()

if __name__ == "__main__":
    main()


===============================
üìÅ Archivo: ./test_connection.py
===============================
# test_connection.py
# Prueba de conexi√≥n usando SOLO el archivo .env

import os
from dotenv import load_dotenv
import psycopg2
from urllib.parse import urlparse

# Cargar variables desde .env
load_dotenv()

print("üîç PRUEBA DE CONEXI√ìN DESDE .env")
print("=" * 60)

# Obtener DATABASE_URL del .env
DATABASE_URL = os.getenv('DATABASE_URL')

if not DATABASE_URL:
    print("‚ùå Error: No se encontr√≥ DATABASE_URL en el archivo .env")
    print("Verifica que el archivo .env existe y contiene DATABASE_URL")
    exit(1)

print("‚úÖ DATABASE_URL encontrada en .env")
print(f"üìù URL: {DATABASE_URL[:50]}...")  # Mostrar solo el inicio por seguridad
print()

# Parsear la DATABASE_URL
result = urlparse(DATABASE_URL)

print("üìã Configuraci√≥n parseada:")
print(f"   Host: {result.hostname}")
print(f"   Puerto: {result.port}")
print(f"   Base de datos: {result.path[1:]}")
print(f"   Usuario: {result.username}")
print(f"   SSL: sslmode=require")
print()

print("üîå Intentando conectar...")
print("-" * 60)

try:
    # Conectar usando psycopg2 directamente
    conn = psycopg2.connect(DATABASE_URL)
    
    print("‚úÖ ¬°CONEXI√ìN EXITOSA!")
    print()
    
    cur = conn.cursor()
    
    # Prueba 1: Contar registros
    cur.execute("SELECT COUNT(*) FROM contratos.contratos")
    count = cur.fetchone()[0]
    print(f"üìä Total de contratos en la BD: {count:,}")
    
    # Prueba 2: Obtener muestra de datos
    print("\nüìù Muestra de datos (primeros 3 contratos):")
    print("-" * 60)
    
    cur.execute("""
        SELECT 
            codigo_contrato,
            proveedor_contratista,
            institucion,
            importe,
            titulo_contrato
        FROM contratos.contratos 
        LIMIT 3
    """)
    
    for i, row in enumerate(cur.fetchall(), 1):
        print(f"\nContrato {i}:")
        print(f"  C√≥digo: {row[0]}")
        print(f"  Proveedor: {row[1] if row[1] else 'N/A'}")
        print(f"  Instituci√≥n: {row[2][:50] if row[2] else 'N/A'}...")
        print(f"  Importe: ${float(row[3]):,.2f}" if row[3] else "  Importe: N/A")
        print(f"  T√≠tulo: {row[4][:60] if row[4] else 'N/A'}...")
    
    # Prueba 3: B√∫squeda simple
    print("\nüîç Prueba de b√∫squeda (contratos con 'medicamento'):")
    print("-" * 60)
    
    cur.execute("""
        SELECT COUNT(*) 
        FROM contratos.contratos 
        WHERE descripcion_contrato ILIKE '%medicamento%'
    """)
    
    medicamentos_count = cur.fetchone()[0]
    print(f"Contratos relacionados con medicamentos: {medicamentos_count:,}")
    
    # Prueba 4: Verificar columnas
    print("\nüìã Columnas disponibles en la tabla:")
    print("-" * 60)
    
    cur.execute("""
        SELECT column_name, data_type 
        FROM information_schema.columns 
        WHERE table_schema = 'contratos' 
        AND table_name = 'contratos'
        LIMIT 10
    """)
    
    for col in cur.fetchall():
        print(f"  ‚Ä¢ {col[0]:<30} ({col[1]})")
    
    print("\n" + "=" * 60)
    print("‚ú® ¬°TODO FUNCIONANDO CORRECTAMENTE!")
    print("=" * 60)
    print("\nüöÄ Ya puedes ejecutar la aplicaci√≥n:")
    print("   python app_simple.py")
    print("\nüìå Luego abre en tu navegador:")
    print("   http://localhost:5000")
    
    cur.close()
    conn.close()
    
except psycopg2.OperationalError as e:
    print(f"‚ùå Error de conexi√≥n: {e}")
    print()
    print("üîß Posibles soluciones:")
    print("1. Verifica que el archivo .env tenga la DATABASE_URL correcta")
    print("2. Si el error es 'permission denied for schema contratos',")
    print("   ejecuta estos comandos SQL como administrador:")
    print()
    print("   GRANT USAGE ON SCHEMA contratos TO lalupa;")
    print("   GRANT SELECT ON ALL TABLES IN SCHEMA contratos TO lalupa;")
    print()
    print("3. Si el error es de autenticaci√≥n, verifica la contrase√±a")
    
except Exception as e:
    print(f"‚ùå Error: {e}")
    print()
    print("Verifica tu archivo .env y la conexi√≥n a internet")


===============================
üìÅ Archivo: ./utils/validators.py
===============================
# utils/validators.py
import re
from typing import Optional

def sanitize_search_input(text: str, max_length: int = 200) -> Optional[str]:
    """
    Sanitiza la entrada de b√∫squeda
    """
    if not text:
        return None
    
    # Eliminar espacios al inicio y final
    text = text.strip()
    
    # Limitar longitud
    if len(text) > max_length:
        text = text[:max_length]
    
    # Remover caracteres peligrosos pero permitir b√∫squedas normales
    # Permitimos letras, n√∫meros, espacios, guiones, puntos, comas, acentos
    text = re.sub(r'[^\w\s\-.,√°√©√≠√≥√∫√±√Å√â√ç√ì√ö√ë]', '', text)
    
    # Evitar m√∫ltiples espacios
    text = ' '.join(text.split())
    
    return text if text else None

def validate_rfc(rfc: str) -> bool:
    """
    Valida formato de RFC mexicano
    """
    # RFC persona moral: 3 letras, 6 n√∫meros, 3 caracteres
    # RFC persona f√≠sica: 4 letras, 6 n√∫meros, 3 caracteres
    pattern = r'^[A-Z√ë&]{3,4}\d{6}[A-Z0-9]{3}$'
    return bool(re.match(pattern, rfc.upper()))

def validate_year(year: str) -> Optional[int]:
    """
    Valida que el a√±o est√© en un rango razonable
    """
    try:
        year_int = int(year)
        # Rango razonable de a√±os para contratos
        if 2000 <= year_int <= 2030:
            return year_int
    except (ValueError, TypeError):
        pass
    return None

def validate_search_type(search_type: str) -> str:
    """
    Valida que el tipo de b√∫squeda sea v√°lido
    """
    valid_types = ['descripcion', 'titulo', 'empresa', 'rfc', 'institucion', 'todo']
    return search_type if search_type in valid_types else 'todo'


===============================
üìÅ Archivo: ./utils/tests/unit/__init__.py
===============================



===============================
üìÅ Archivo: ./utils/tests/integration/__init__.py
===============================



===============================
üìÅ Archivo: ./utils/tests/__init__.py
===============================



===============================
üìÅ Archivo: ./test_connection_do.py
===============================
# test_new_structure.py (versi√≥n corregida al final)

"""Script para probar que la nueva estructura funciona correctamente"""
import os
import sys
from dotenv import load_dotenv

# Cargar variables de entorno
load_dotenv()

# Configurar el entorno antes de importar la app
os.environ['FLASK_ENV'] = 'development'

# Importar y crear la app
from app import create_app, db
from app.models import Contrato
from app.services import SearchService, AggregationService, FilterService
from sqlalchemy import func

def test_database_connection():
    """Prueba la conexi√≥n a la base de datos"""
    print("\n1. Probando conexi√≥n a la base de datos...")
    try:
        app = create_app('development')
        with app.app_context():
            # Test b√°sico de conexi√≥n
            result = db.session.execute(db.text('SELECT 1')).scalar()
            assert result == 1
            
            # Contar contratos
            count = db.session.query(func.count(Contrato.codigo_contrato)).scalar()
            print(f"   ‚úÖ Conexi√≥n exitosa. Contratos en BD: {count:,}")
            return True
    except Exception as e:
        print(f"   ‚ùå Error: {e}")
        return False

def test_services():
    """Prueba los servicios"""
    print("\n2. Probando servicios...")
    try:
        app = create_app('development')
        with app.app_context():
            # Probar SearchService
            search_service = SearchService()
            query_text, search_type = search_service.validate_search_input(
                "construcci√≥n", "todo"
            )
            print(f"   ‚úÖ SearchService funciona")
            
            # Probar AggregationService
            aggregation_service = AggregationService()
            stats = aggregation_service.get_stats()
            print(f"   ‚úÖ AggregationService funciona")
            print(f"      - Total contratos: {stats['total_contratos']:,}")
            print(f"      - Total instituciones: {stats['total_instituciones']:,}")
            print(f"      - Total empresas: {stats['total_empresas']:,}")
            
            # Probar FilterService (con l√≠mite peque√±o para evitar demoras)
            filter_service = FilterService()
            base_query = Contrato.query.limit(100)
            filtros = filter_service.obtener_filtros_disponibles(base_query)
            print(f"   ‚úÖ FilterService funciona")
            print(f"      - Tipos de filtros disponibles: {list(filtros.keys())}")
            
            return True
    except Exception as e:
        print(f"   ‚ùå Error: {e}")
        import traceback
        traceback.print_exc()
        return False

def test_endpoints():
    """Prueba los endpoints"""
    print("\n3. Probando endpoints...")
    try:
        app = create_app('development')
        
        # Usar test client sin ejecutar el servidor
        with app.test_client() as client:
            # Probar /api/stats
            response = client.get('/api/stats')
            assert response.status_code == 200
            print(f"   ‚úÖ GET /api/stats funciona")
            
            # Probar /api/search con un t√©rmino simple
            response = client.post('/api/search', 
                json={'query': 'construcci√≥n', 'search_type': 'titulo'})
            
            if response.status_code == 200:
                data = response.get_json()
                print(f"   ‚úÖ POST /api/search funciona")
                if data.get('total', 0) > 0:
                    print(f"      - Resultados encontrados: {data.get('total', 0):,}")
            else:
                print(f"   ‚ö†Ô∏è POST /api/search respondi√≥ con c√≥digo: {response.status_code}")
            
            # Probar p√°gina principal
            response = client.get('/')
            assert response.status_code == 200
            print(f"   ‚úÖ GET / (p√°gina principal) funciona")
            
            return True
            
    except Exception as e:
        print(f"   ‚ùå Error: {e}")
        import traceback
        traceback.print_exc()
        return False

def main():
    """Ejecuta todas las pruebas"""
    print("=" * 50)
    print("PRUEBAS DE LA NUEVA ESTRUCTURA")
    print("=" * 50)
    
    all_tests_passed = True
    
    # Ejecutar pruebas
    all_tests_passed &= test_database_connection()
    all_tests_passed &= test_services()
    all_tests_passed &= test_endpoints()
    
    print("\n" + "=" * 50)
    if all_tests_passed:
        print("‚úÖ TODAS LAS PRUEBAS PASARON")
        print("\nPuedes ejecutar la aplicaci√≥n con:")
        print("  python run.py")
    else:
        print("‚ùå ALGUNAS PRUEBAS FALLARON")
        print("Revisa los errores arriba")
    print("=" * 50)
    
    # Asegurar que el script termine
    sys.exit(0 if all_tests_passed else 1)

if __name__ == "__main__":
    main()


===============================
üìÅ Archivo: ./test_new_structure.py
===============================
# test_new_structure.py

"""Script para probar que la nueva estructura funciona correctamente"""
import os
import sys
from dotenv import load_dotenv

# Cargar variables de entorno
load_dotenv()

# Configurar el entorno antes de importar la app
os.environ['FLASK_ENV'] = 'development'

# Importar y crear la app
from app import create_app, db
from app.models import Contrato
from app.services import SearchService, AggregationService, FilterService
from sqlalchemy import func

def test_database_connection():
    """Prueba la conexi√≥n a la base de datos"""
    print("\n1. Probando conexi√≥n a la base de datos...")
    try:
        app = create_app('development')
        with app.app_context():
            # Test b√°sico de conexi√≥n
            result = db.session.execute(db.text('SELECT 1')).scalar()
            assert result == 1
            
            # Contar contratos
            count = db.session.query(func.count(Contrato.codigo_contrato)).scalar()
            print(f"   ‚úÖ Conexi√≥n exitosa. Contratos en BD: {count:,}")
            return True
    except Exception as e:
        print(f"   ‚ùå Error: {e}")
        return False

def test_services():
    """Prueba los servicios"""
    print("\n2. Probando servicios...")
    try:
        app = create_app('development')
        with app.app_context():
            # Probar SearchService
            search_service = SearchService()
            query_text, search_type = search_service.validate_search_input(
                "construcci√≥n", "todo"
            )
            print(f"   ‚úÖ SearchService funciona")
            
            # Probar AggregationService
            aggregation_service = AggregationService()
            stats = aggregation_service.get_stats()
            print(f"   ‚úÖ AggregationService funciona")
            print(f"      - Total contratos: {stats['total_contratos']:,}")
            print(f"      - Total instituciones: {stats['total_instituciones']:,}")
            print(f"      - Total empresas: {stats['total_empresas']:,}")
            
            # Probar FilterService
            filter_service = FilterService()
            base_query = Contrato.query.limit(100)
            filtros = filter_service.obtener_filtros_disponibles(base_query)
            print(f"   ‚úÖ FilterService funciona")
            print(f"      - Tipos de filtros disponibles: {list(filtros.keys())}")
            
            return True
    except Exception as e:
        print(f"   ‚ùå Error: {e}")
        return False

def test_endpoints():
    """Prueba los endpoints"""
    print("\n3. Probando endpoints...")
    try:
        app = create_app('development')
        client = app.test_client()
        
        # Probar /api/stats
        response = client.get('/api/stats')
        assert response.status_code == 200
        print(f"   ‚úÖ GET /api/stats funciona")
        
        # Probar /api/search
        response = client.post('/api/search', 
            json={'query': 'construcci√≥n', 'search_type': 'todo'})
        assert response.status_code == 200
        data = response.get_json()
        print(f"   ‚úÖ POST /api/search funciona")
        print(f"      - Resultados encontrados: {data.get('total', 0):,}")
        
        # Probar p√°gina principal
        response = client.get('/')
        assert response.status_code == 200
        print(f"   ‚úÖ GET / (p√°gina principal) funciona")
        
        return True
    except Exception as e:
        print(f"   ‚ùå Error: {e}")
        return False

def main():
    """Ejecuta todas las pruebas"""
    print("=" * 50)
    print("PRUEBAS DE LA NUEVA ESTRUCTURA")
    print("=" * 50)
    
    all_tests_passed = True
    
    # Ejecutar pruebas
    all_tests_passed &= test_database_connection()
    all_tests_passed &= test_services()
    all_tests_passed &= test_endpoints()
    
    print("\n" + "=" * 50)
    if all_tests_passed:
        print("‚úÖ TODAS LAS PRUEBAS PASARON")
        print("\nPuedes ejecutar la aplicaci√≥n con:")
        print("  python run.py")
    else:
        print("‚ùå ALGUNAS PRUEBAS FALLARON")
        print("Revisa los errores arriba")
    print("=" * 50)

if __name__ == "__main__":
    main()


